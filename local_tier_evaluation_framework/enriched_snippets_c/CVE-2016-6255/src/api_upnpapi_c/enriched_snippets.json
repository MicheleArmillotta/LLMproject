[
  {
    "function_name": "UpnpSetMaxContentLength",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4410-4423",
    "snippet": "int UpnpSetMaxContentLength(size_t contentLength)\n{\n\tint errCode = UPNP_E_SUCCESS;\n\n\tdo {\n\t\tif (UpnpSdkInit != 1) {\n\t\t\terrCode = UPNP_E_FINISH;\n\t\t\tbreak;\n\t\t}\n\t\tg_maxContentLength = contentLength;\n\t} while(0);\n\n\treturn errCode;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "size_t g_maxContentLength = DEFAULT_SOAP_CONTENT_LENGTH;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nsize_t g_maxContentLength = DEFAULT_SOAP_CONTENT_LENGTH;\nint UpnpSdkInit = 0;\n\nint UpnpSetMaxContentLength(size_t contentLength)\n{\n\tint errCode = UPNP_E_SUCCESS;\n\n\tdo {\n\t\tif (UpnpSdkInit != 1) {\n\t\t\terrCode = UPNP_E_FINISH;\n\t\t\tbreak;\n\t\t}\n\t\tg_maxContentLength = contentLength;\n\t} while(0);\n\n\treturn errCode;\n}"
  },
  {
    "function_name": "UpnpSetContentLength",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4379-4408",
    "snippet": "int UpnpSetContentLength(UpnpClient_Handle Hnd, size_t contentLength)\n{\n\tint errCode = UPNP_E_SUCCESS;\n\tstruct Handle_Info *HInfo = NULL;\n\n\tdo {\n\t\tif (UpnpSdkInit != 1) {\n\t\t\terrCode = UPNP_E_FINISH;\n\t\t\tbreak;\n\t\t}\n\n\t\tHandleLock();\n\n\t\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tHandleUnlock();\n\t\t        return UPNP_E_INVALID_HANDLE;\n\t\t}\n\t\tif (contentLength > MAX_SOAP_CONTENT_LENGTH) {\n\t\t\terrCode = UPNP_E_OUTOF_BOUNDS;\n\t\t\tbreak;\n\t\t}\n\t\tg_maxContentLength = contentLength;\n\t} while (0);\n\n\tHandleUnlock();\n\treturn errCode;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "size_t g_maxContentLength = DEFAULT_SOAP_CONTENT_LENGTH;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 4406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 4396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&HInfo"
          ],
          "line": 4392
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nsize_t g_maxContentLength = DEFAULT_SOAP_CONTENT_LENGTH;\nint UpnpSdkInit = 0;\n\nint UpnpSetContentLength(UpnpClient_Handle Hnd, size_t contentLength)\n{\n\tint errCode = UPNP_E_SUCCESS;\n\tstruct Handle_Info *HInfo = NULL;\n\n\tdo {\n\t\tif (UpnpSdkInit != 1) {\n\t\t\terrCode = UPNP_E_FINISH;\n\t\t\tbreak;\n\t\t}\n\n\t\tHandleLock();\n\n\t\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tHandleUnlock();\n\t\t        return UPNP_E_INVALID_HANDLE;\n\t\t}\n\t\tif (contentLength > MAX_SOAP_CONTENT_LENGTH) {\n\t\t\terrCode = UPNP_E_OUTOF_BOUNDS;\n\t\t\tbreak;\n\t\t}\n\t\tg_maxContentLength = contentLength;\n\t} while (0);\n\n\tHandleUnlock();\n\treturn errCode;\n}"
  },
  {
    "function_name": "UpnpVirtualDir_set_CloseCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4367-4377",
    "snippet": "int UpnpVirtualDir_set_CloseCallback(VDCallback_Close callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.close = callback;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct VirtualDirCallbacks virtualDirCallback;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstruct VirtualDirCallbacks virtualDirCallback;\n\nint UpnpVirtualDir_set_CloseCallback(VDCallback_Close callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.close = callback;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "UpnpVirtualDir_set_SeekCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4354-4364",
    "snippet": "int UpnpVirtualDir_set_SeekCallback(VDCallback_Seek callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.seek = callback;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct VirtualDirCallbacks virtualDirCallback;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstruct VirtualDirCallbacks virtualDirCallback;\n\nint UpnpVirtualDir_set_SeekCallback(VDCallback_Seek callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.seek = callback;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "UpnpVirtualDir_set_WriteCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4341-4351",
    "snippet": "int UpnpVirtualDir_set_WriteCallback(VDCallback_Write callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.write = callback;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct VirtualDirCallbacks virtualDirCallback;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstruct VirtualDirCallbacks virtualDirCallback;\n\nint UpnpVirtualDir_set_WriteCallback(VDCallback_Write callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.write = callback;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "UpnpVirtualDir_set_ReadCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4328-4338",
    "snippet": "int UpnpVirtualDir_set_ReadCallback(VDCallback_Read callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.read = callback;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct VirtualDirCallbacks virtualDirCallback;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstruct VirtualDirCallbacks virtualDirCallback;\n\nint UpnpVirtualDir_set_ReadCallback(VDCallback_Read callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.read = callback;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "UpnpVirtualDir_set_OpenCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4315-4325",
    "snippet": "int UpnpVirtualDir_set_OpenCallback(VDCallback_Open callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.open = callback;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct VirtualDirCallbacks virtualDirCallback;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstruct VirtualDirCallbacks virtualDirCallback;\n\nint UpnpVirtualDir_set_OpenCallback(VDCallback_Open callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.open = callback;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "UpnpVirtualDir_set_GetInfoCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4302-4312",
    "snippet": "int UpnpVirtualDir_set_GetInfoCallback(VDCallback_GetInfo callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.get_info = callback;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct VirtualDirCallbacks virtualDirCallback;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstruct VirtualDirCallbacks virtualDirCallback;\n\nint UpnpVirtualDir_set_GetInfoCallback(VDCallback_GetInfo callback)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tif (!callback) {\n\t        ret = UPNP_E_INVALID_PARAM;\n\t} else {\n\t\tvirtualDirCallback.get_info = callback;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "UpnpIsWebserverEnabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4292-4299",
    "snippet": "int UpnpIsWebserverEnabled(void)\n{\n\tif (UpnpSdkInit != 1) {\n\t\treturn 0;\n\t}\n\n\treturn bWebServerState == (WebServerState)WEB_SERVER_ENABLED;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "WebServerState bWebServerState = WEB_SERVER_DISABLED;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nWebServerState bWebServerState = WEB_SERVER_DISABLED;\nint UpnpSdkInit = 0;\n\nint UpnpIsWebserverEnabled(void)\n{\n\tif (UpnpSdkInit != 1) {\n\t\treturn 0;\n\t}\n\n\treturn bWebServerState == (WebServerState)WEB_SERVER_ENABLED;\n}"
  },
  {
    "function_name": "UpnpEnableWebserver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4255-4284",
    "snippet": "int UpnpEnableWebserver(int enable)\n{\n    int retVal = UPNP_E_SUCCESS;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    switch ( enable ) {\n#ifdef INTERNAL_WEB_SERVER\n        case TRUE:\n            if( ( retVal = web_server_init() ) != UPNP_E_SUCCESS ) {\n                return retVal;\n            }\n            bWebServerState = WEB_SERVER_ENABLED;\n            SetHTTPGetCallback( web_server_callback );\n            break;\n\n        case FALSE:\n            web_server_destroy();\n            bWebServerState = WEB_SERVER_DISABLED;\n            SetHTTPGetCallback( NULL );\n            break;\n#endif /* INTERNAL_WEB_SERVER */\n        default:\n            retVal = UPNP_E_INVALID_PARAM;\n    }\n\n    return retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "WebServerState bWebServerState = WEB_SERVER_DISABLED;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetHTTPGetCallback",
          "args": [
            "NULL"
          ],
          "line": 4276
        },
        "resolved": true,
        "details": {
          "function_name": "SetHTTPGetCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "100-103",
          "snippet": "void SetHTTPGetCallback(MiniServerCallback callback)\n{\n\tgGetCallback = callback;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nvoid SetHTTPGetCallback(MiniServerCallback callback)\n{\n\tgGetCallback = callback;\n}"
        }
      },
      {
        "call_info": {
          "callee": "web_server_destroy",
          "args": [],
          "line": 4274
        },
        "resolved": true,
        "details": {
          "function_name": "web_server_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "495-508",
          "snippet": "void web_server_destroy(void)\n{\n\tif (bWebServerState == WEB_SERVER_ENABLED) {\n\t\tmembuffer_destroy(&gDocumentRootDir);\n\t\talias_release(&gAliasDoc);\n\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tmemset(&gAliasDoc, 0, sizeof(struct xml_alias_t));\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\tithread_mutex_destroy(&gWebMutex);\n\t\tbWebServerState = WEB_SERVER_DISABLED;\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nvoid web_server_destroy(void)\n{\n\tif (bWebServerState == WEB_SERVER_ENABLED) {\n\t\tmembuffer_destroy(&gDocumentRootDir);\n\t\talias_release(&gAliasDoc);\n\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tmemset(&gAliasDoc, 0, sizeof(struct xml_alias_t));\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\tithread_mutex_destroy(&gWebMutex);\n\t\tbWebServerState = WEB_SERVER_DISABLED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "web_server_init",
          "args": [],
          "line": 4266
        },
        "resolved": true,
        "details": {
          "function_name": "web_server_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "467-493",
          "snippet": "int web_server_init()\n{\n\tint ret = 0;\n\n\tif (bWebServerState == WEB_SERVER_DISABLED) {\n\t\t/* decode media list */\n\t\tmedia_list_init();\n\t\tmembuffer_init(&gDocumentRootDir);\n\t\tglob_alias_init();\n\t\tpVirtualDirList = NULL;\n\n\t\t/* Initialize callbacks */\n\t\tvirtualDirCallback.get_info = NULL;\n\t\tvirtualDirCallback.open = NULL;\n\t\tvirtualDirCallback.read = NULL;\n\t\tvirtualDirCallback.write = NULL;\n\t\tvirtualDirCallback.seek = NULL;\n\t\tvirtualDirCallback.close = NULL;\n\n\t\tif (ithread_mutex_init(&gWebMutex, NULL) == -1)\n\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\telse\n\t\t\tbWebServerState = WEB_SERVER_ENABLED;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nint web_server_init()\n{\n\tint ret = 0;\n\n\tif (bWebServerState == WEB_SERVER_DISABLED) {\n\t\t/* decode media list */\n\t\tmedia_list_init();\n\t\tmembuffer_init(&gDocumentRootDir);\n\t\tglob_alias_init();\n\t\tpVirtualDirList = NULL;\n\n\t\t/* Initialize callbacks */\n\t\tvirtualDirCallback.get_info = NULL;\n\t\tvirtualDirCallback.open = NULL;\n\t\tvirtualDirCallback.read = NULL;\n\t\tvirtualDirCallback.write = NULL;\n\t\tvirtualDirCallback.seek = NULL;\n\t\tvirtualDirCallback.close = NULL;\n\n\t\tif (ithread_mutex_init(&gWebMutex, NULL) == -1)\n\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\telse\n\t\t\tbWebServerState = WEB_SERVER_ENABLED;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nWebServerState bWebServerState = WEB_SERVER_DISABLED;\nint UpnpSdkInit = 0;\n\nint UpnpEnableWebserver(int enable)\n{\n    int retVal = UPNP_E_SUCCESS;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    switch ( enable ) {\n#ifdef INTERNAL_WEB_SERVER\n        case TRUE:\n            if( ( retVal = web_server_init() ) != UPNP_E_SUCCESS ) {\n                return retVal;\n            }\n            bWebServerState = WEB_SERVER_ENABLED;\n            SetHTTPGetCallback( web_server_callback );\n            break;\n\n        case FALSE:\n            web_server_destroy();\n            bWebServerState = WEB_SERVER_DISABLED;\n            SetHTTPGetCallback( NULL );\n            break;\n#endif /* INTERNAL_WEB_SERVER */\n        default:\n            retVal = UPNP_E_INVALID_PARAM;\n    }\n\n    return retVal;\n}"
  },
  {
    "function_name": "UpnpRemoveAllVirtualDirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4233-4252",
    "snippet": "void UpnpRemoveAllVirtualDirs(void)\n{\n    virtualDirList *pCur;\n    virtualDirList *pNext;\n\n    if( UpnpSdkInit != 1 ) {\n        return;\n    }\n\n    pCur = pVirtualDirList;\n\n    while( pCur != NULL ) {\n        pNext = pCur->next;\n        free( pCur );\n\n        pCur = pNext;\n    }\n\n    pVirtualDirList = NULL;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "virtualDirList *pVirtualDirList;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pCur"
          ],
          "line": 4246
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nvirtualDirList *pVirtualDirList;\nint UpnpSdkInit = 0;\n\nvoid UpnpRemoveAllVirtualDirs(void)\n{\n    virtualDirList *pCur;\n    virtualDirList *pNext;\n\n    if( UpnpSdkInit != 1 ) {\n        return;\n    }\n\n    pCur = pVirtualDirList;\n\n    while( pCur != NULL ) {\n        pNext = pCur->next;\n        free( pCur );\n\n        pCur = pNext;\n    }\n\n    pVirtualDirList = NULL;\n}"
  },
  {
    "function_name": "UpnpRemoveVirtualDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4184-4230",
    "snippet": "int UpnpRemoveVirtualDir(const char *dirName)\n{\n    virtualDirList *pPrev;\n    virtualDirList *pCur;\n    int found = 0;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    if( dirName == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    if( pVirtualDirList == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    /* Handle the special case where the directory that we are */\n    /* removing is the first in the list. */\n    if (strcmp( pVirtualDirList->dirName, dirName ) == 0)\n    {\n        pPrev = pVirtualDirList;\n        pVirtualDirList = pVirtualDirList->next;\n        free( pPrev );\n        return UPNP_E_SUCCESS;\n    }\n\n    pCur = pVirtualDirList->next;\n    pPrev = pVirtualDirList;\n\n    while( pCur != NULL ) {\n        if( strcmp( pCur->dirName, dirName ) == 0 ) {\n            pPrev->next = pCur->next;\n            free( pCur );\n            found = 1;\n            break;\n        } else {\n            pPrev = pCur;\n            pCur = pCur->next;\n        }\n    }\n\n    if( found == 1 )\n        return UPNP_E_SUCCESS;\n    else\n        return UPNP_E_INVALID_PARAM;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "virtualDirList *pVirtualDirList;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pCur"
          ],
          "line": 4217
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pCur->dirName",
            "dirName"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pVirtualDirList->dirName",
            "dirName"
          ],
          "line": 4203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nvirtualDirList *pVirtualDirList;\nint UpnpSdkInit = 0;\n\nint UpnpRemoveVirtualDir(const char *dirName)\n{\n    virtualDirList *pPrev;\n    virtualDirList *pCur;\n    int found = 0;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    if( dirName == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    if( pVirtualDirList == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    /* Handle the special case where the directory that we are */\n    /* removing is the first in the list. */\n    if (strcmp( pVirtualDirList->dirName, dirName ) == 0)\n    {\n        pPrev = pVirtualDirList;\n        pVirtualDirList = pVirtualDirList->next;\n        free( pPrev );\n        return UPNP_E_SUCCESS;\n    }\n\n    pCur = pVirtualDirList->next;\n    pPrev = pVirtualDirList;\n\n    while( pCur != NULL ) {\n        if( strcmp( pCur->dirName, dirName ) == 0 ) {\n            pPrev->next = pCur->next;\n            free( pCur );\n            found = 1;\n            break;\n        } else {\n            pPrev = pCur;\n            pCur = pCur->next;\n        }\n    }\n\n    if( found == 1 )\n        return UPNP_E_SUCCESS;\n    else\n        return UPNP_E_INVALID_PARAM;\n}"
  },
  {
    "function_name": "UpnpAddVirtualDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4121-4181",
    "snippet": "int UpnpAddVirtualDir(const char *newDirName)\n{\n    virtualDirList *pNewVirtualDir;\n    virtualDirList *pLast;\n    virtualDirList *pCurVirtualDir;\n    char dirName[NAME_SIZE];\n\n    memset( dirName, 0, sizeof( dirName ) );\n    if( UpnpSdkInit != 1 ) {\n        /* SDK is not initialized */\n        return UPNP_E_FINISH;\n    }\n\n    if( ( newDirName == NULL ) || ( strlen( newDirName ) == ( size_t ) 0 ) ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    if( *newDirName != '/' ) {\n        if (strlen(newDirName) > sizeof(dirName) - 2)\n            return UPNP_E_INVALID_PARAM;\n        dirName[0] = '/';\n        strncpy( dirName + 1, newDirName, sizeof( dirName ) - 2 );\n    } else {\n        if (strlen(newDirName) > sizeof(dirName) - 1)\n            return UPNP_E_INVALID_PARAM;\n        strncpy( dirName, newDirName, sizeof( dirName ) - 1 );\n    }\n\n    pCurVirtualDir = pVirtualDirList;\n    while( pCurVirtualDir != NULL ) {\n        /* already has this entry */\n        if( strcmp( pCurVirtualDir->dirName, dirName ) == 0 ) {\n            return UPNP_E_SUCCESS;\n        }\n\n        pCurVirtualDir = pCurVirtualDir->next;\n    }\n\n    pNewVirtualDir =\n        ( virtualDirList * ) malloc( sizeof( virtualDirList ) );\n    if( pNewVirtualDir == NULL ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    pNewVirtualDir->next = NULL;\n    memset( pNewVirtualDir->dirName, 0, sizeof( pNewVirtualDir->dirName ) );\n    strncpy( pNewVirtualDir->dirName, dirName,\n\tsizeof( pNewVirtualDir->dirName ) - 1);\n    *( pNewVirtualDir->dirName + strlen( dirName ) ) = 0;\n\n    if( pVirtualDirList == NULL ) { /* first virtual dir */\n        pVirtualDirList = pNewVirtualDir;\n    } else {\n        pLast = pVirtualDirList;\n        while( pLast->next != NULL ) {\n            pLast = pLast->next;\n        }\n        pLast->next = pNewVirtualDir;\n    }\n\n    return UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "virtualDirList *pVirtualDirList;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dirName"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pNewVirtualDir->dirName",
            "dirName",
            "sizeof( pNewVirtualDir->dirName ) - 1"
          ],
          "line": 4166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pNewVirtualDir->dirName",
            "0",
            "sizeof( pNewVirtualDir->dirName )"
          ],
          "line": 4165
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof( virtualDirList )"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pCurVirtualDir->dirName",
            "dirName"
          ],
          "line": 4152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "dirName",
            "newDirName",
            "sizeof( dirName ) - 1"
          ],
          "line": 4146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "newDirName"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "dirName + 1",
            "newDirName",
            "sizeof( dirName ) - 2"
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "newDirName"
          ],
          "line": 4139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "newDirName"
          ],
          "line": 4134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nvirtualDirList *pVirtualDirList;\nint UpnpSdkInit = 0;\n\nint UpnpAddVirtualDir(const char *newDirName)\n{\n    virtualDirList *pNewVirtualDir;\n    virtualDirList *pLast;\n    virtualDirList *pCurVirtualDir;\n    char dirName[NAME_SIZE];\n\n    memset( dirName, 0, sizeof( dirName ) );\n    if( UpnpSdkInit != 1 ) {\n        /* SDK is not initialized */\n        return UPNP_E_FINISH;\n    }\n\n    if( ( newDirName == NULL ) || ( strlen( newDirName ) == ( size_t ) 0 ) ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    if( *newDirName != '/' ) {\n        if (strlen(newDirName) > sizeof(dirName) - 2)\n            return UPNP_E_INVALID_PARAM;\n        dirName[0] = '/';\n        strncpy( dirName + 1, newDirName, sizeof( dirName ) - 2 );\n    } else {\n        if (strlen(newDirName) > sizeof(dirName) - 1)\n            return UPNP_E_INVALID_PARAM;\n        strncpy( dirName, newDirName, sizeof( dirName ) - 1 );\n    }\n\n    pCurVirtualDir = pVirtualDirList;\n    while( pCurVirtualDir != NULL ) {\n        /* already has this entry */\n        if( strcmp( pCurVirtualDir->dirName, dirName ) == 0 ) {\n            return UPNP_E_SUCCESS;\n        }\n\n        pCurVirtualDir = pCurVirtualDir->next;\n    }\n\n    pNewVirtualDir =\n        ( virtualDirList * ) malloc( sizeof( virtualDirList ) );\n    if( pNewVirtualDir == NULL ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    pNewVirtualDir->next = NULL;\n    memset( pNewVirtualDir->dirName, 0, sizeof( pNewVirtualDir->dirName ) );\n    strncpy( pNewVirtualDir->dirName, dirName,\n\tsizeof( pNewVirtualDir->dirName ) - 1);\n    *( pNewVirtualDir->dirName + strlen( dirName ) ) = 0;\n\n    if( pVirtualDirList == NULL ) { /* first virtual dir */\n        pVirtualDirList = pNewVirtualDir;\n    } else {\n        pLast = pVirtualDirList;\n        while( pLast->next != NULL ) {\n            pLast = pLast->next;\n        }\n        pLast->next = pNewVirtualDir;\n    }\n\n    return UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpSetWebServerRootDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4106-4117",
    "snippet": "int UpnpSetWebServerRootDir(const char *rootDir)\n{\n    if( UpnpSdkInit == 0 )\n        return UPNP_E_FINISH;\n    if( ( rootDir == NULL ) || ( strlen( rootDir ) == 0 ) ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    membuffer_destroy( &gDocumentRootDir );\n\n    return web_server_set_root_dir(rootDir);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern membuffer gDocumentRootDir;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "web_server_set_root_dir",
          "args": [
            "rootDir"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "web_server_set_root_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "562-578",
          "snippet": "int web_server_set_root_dir(const char *root_dir)\n{\n\tsize_t index;\n\tint ret;\n\n\tret = membuffer_assign_str(&gDocumentRootDir, root_dir);\n\tif (ret != 0)\n\t\treturn ret;\n\t/* remove trailing '/', if any */\n\tif (gDocumentRootDir.length > 0) {\n\t\tindex = gDocumentRootDir.length - 1;\t/* last char */\n\t\tif (gDocumentRootDir.buf[index] == '/')\n\t\t\tmembuffer_delete(&gDocumentRootDir, index, 1);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nint web_server_set_root_dir(const char *root_dir)\n{\n\tsize_t index;\n\tint ret;\n\n\tret = membuffer_assign_str(&gDocumentRootDir, root_dir);\n\tif (ret != 0)\n\t\treturn ret;\n\t/* remove trailing '/', if any */\n\tif (gDocumentRootDir.length > 0) {\n\t\tindex = gDocumentRootDir.length - 1;\t/* last char */\n\t\tif (gDocumentRootDir.buf[index] == '/')\n\t\t\tmembuffer_delete(&gDocumentRootDir, index, 1);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&gDocumentRootDir"
          ],
          "line": 4114
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rootDir"
          ],
          "line": 4110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nextern membuffer gDocumentRootDir;\nint UpnpSdkInit = 0;\n\nint UpnpSetWebServerRootDir(const char *rootDir)\n{\n    if( UpnpSdkInit == 0 )\n        return UPNP_E_FINISH;\n    if( ( rootDir == NULL ) || ( strlen( rootDir ) == 0 ) ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    membuffer_destroy( &gDocumentRootDir );\n\n    return web_server_set_root_dir(rootDir);\n}"
  },
  {
    "function_name": "AutoAdvertise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "4094-4100",
    "snippet": "void AutoAdvertise(void *input)\n{\n\tupnp_timeout *event = (upnp_timeout *)input;\n\n\tUpnpSendAdvertisement(event->handle, *((int *)event->Event));\n\tfree_upnp_timeout(event);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_upnp_timeout",
          "args": [
            "event"
          ],
          "line": 4099
        },
        "resolved": true,
        "details": {
          "function_name": "free_upnp_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/upnp_timeout.c",
          "lines": "50-58",
          "snippet": "void free_upnp_timeout(upnp_timeout *event)\n{\n\tif (event) {\n\t\tif (event->Event) {\n\t\t\tfree(event->Event);\n\t\t}\n\t\tfree(event);\n\t}\n}",
          "includes": [
            "#include <stdlib.h> /* for free() */",
            "#include \"upnp_timeout.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for free() */\n#include \"upnp_timeout.h\"\n#include \"config.h\"\n\nvoid free_upnp_timeout(upnp_timeout *event)\n{\n\tif (event) {\n\t\tif (event->Event) {\n\t\t\tfree(event->Event);\n\t\t}\n\t\tfree(event);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpSendAdvertisement",
          "args": [
            "event->handle",
            "*((int *)event->Event)"
          ],
          "line": 4098
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpSendAdvertisement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "1706-1711",
          "snippet": "int UpnpSendAdvertisement(UpnpDevice_Handle Hnd, int Exp)\n{\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAdvertisement \\n\");\n    return UpnpSendAdvertisementLowPower (Hnd, Exp, -1, -1, -1);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSendAdvertisement(UpnpDevice_Handle Hnd, int Exp)\n{\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAdvertisement \\n\");\n    return UpnpSendAdvertisementLowPower (Hnd, Exp, -1, -1, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nvoid AutoAdvertise(void *input)\n{\n\tupnp_timeout *event = (upnp_timeout *)input;\n\n\tUpnpSendAdvertisement(event->handle, *((int *)event->Event));\n\tfree_upnp_timeout(event);\n}"
  },
  {
    "function_name": "getlocalhostname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3934-4089",
    "snippet": "int getlocalhostname(char *out, size_t out_len)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar tempstr[INET_ADDRSTRLEN];\n\tconst char *p = NULL;\n\n#ifdef WIN32\n\tstruct hostent *h = NULL;\n\tstruct sockaddr_in LocalAddr;\n\n\tmemset(&LocalAddr, 0, sizeof(LocalAddr));\n\n\tgethostname(out, out_len);\n\th = gethostbyname(out);\n\tif (h != NULL) {\n\t\tmemcpy(&LocalAddr.sin_addr, h->h_addr_list[0], 4);\n\t\tp = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));\n\t\tif (p) {\n\t\t\tstrncpy(out, p, out_len);\n\t\t} else {\n\t\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"getlocalhostname: inet_ntop returned error\\n\" );\n\t\t\tret = UPNP_E_INIT;\n\t\t}\n\t} else {\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"getlocalhostname: gethostbyname returned error\\n\" );\n\t\tret = UPNP_E_INIT;\n\t}\n\n#elif (defined(BSD) && BSD >= 199306) || defined(__FreeBSD_kernel__)\n\tstruct ifaddrs *ifap, *ifa;\n\n\tif (getifaddrs(&ifap) != 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"DiscoverInterfaces: getifaddrs() returned error\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\n\t/* cycle through available interfaces */\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t/* Skip loopback, point-to-point and down interfaces, \n\t\t * except don't skip down interfaces\n\t\t * if we're trying to get a list of configurable interfaces. */\n\t\tif ((ifa->ifa_flags & IFF_LOOPBACK) ||\n\t\t    (!( ifa->ifa_flags & IFF_UP))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\t/* We don't want the loopback interface. */\n\t\t\tif (((struct sockaddr_in *)(ifa->ifa_addr))->sin_addr.s_addr ==\n\t\t\t    htonl(INADDR_LOOPBACK)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp = inet_ntop(AF_INET,\n\t\t\t\t&((struct sockaddr_in *)(ifa->ifa_addr))->sin_addr,\n\t\t\t\ttempstr, sizeof(tempstr));\n\t\t\tif (p) {\n\t\t\t\tstrncpy(out, p, out_len);\n\t\t\t} else {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t\"getlocalhostname: inet_ntop returned error\\n\");\n\t\t\t\tret = UPNP_E_INIT;\n\t\t\t}\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"Inside getlocalhostname: after strncpy %s\\n\", out);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfreeifaddrs(ifap);\n\n\tret = ifa ? UPNP_E_SUCCESS : UPNP_E_INIT;\n#else\n\tchar szBuffer[MAX_INTERFACES * sizeof (struct ifreq)];\n\tstruct ifconf ifConf;\n\tstruct ifreq ifReq;\n\tint nResult;\n\tlong unsigned int i;\n\tint LocalSock;\n\tstruct sockaddr_in LocalAddr;\n\tint j = 0;\n\n\t/* purify */\n\tmemset(&ifConf,  0, sizeof(ifConf));\n\tmemset(&ifReq,   0, sizeof(ifReq));\n\tmemset(szBuffer, 0, sizeof(szBuffer));\n\tmemset(&LocalAddr, 0, sizeof(LocalAddr));\n\n\t/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on.  */\n\tLocalSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (LocalSock == INVALID_SOCKET) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Can't create addrlist socket\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Get the interface configuration information... */\n\tifConf.ifc_len = (int)sizeof szBuffer;\n\tifConf.ifc_ifcu.ifcu_buf = (caddr_t) szBuffer;\n\tnResult = ioctl(LocalSock, SIOCGIFCONF, &ifConf);\n\tif (nResult < 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"DiscoverInterfaces: SIOCGIFCONF returned error\\n\");\n\t\tclose(LocalSock);\n\t\treturn UPNP_E_INIT;\n\t}\n\n\t/* Cycle through the list of interfaces looking for IP addresses. */\n\tfor (i = 0lu; i < (long unsigned int)ifConf.ifc_len && j < DEFAULT_INTERFACE; ) {\n\t\tstruct ifreq *pifReq =\n\t\t\t(struct ifreq *)((caddr_t)ifConf.ifc_req + i);\n\t\ti += sizeof *pifReq;\n\t\t/* See if this is the sort of interface we want to deal with. */\n\t\tmemset(ifReq.ifr_name, 0, sizeof(ifReq.ifr_name));\n\t\tstrncpy(ifReq.ifr_name, pifReq->ifr_name,\n\t\t\tsizeof(ifReq.ifr_name) - 1);\n\t\tif (ioctl(LocalSock, SIOCGIFFLAGS, &ifReq) < 0) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"Can't get interface flags for %s:\\n\",\n\t\t\t\tifReq.ifr_name);\n\t\t}\n\t\t/* Skip loopback, point-to-point and down interfaces,\n\t\t * except don't skip down interfaces\n\t\t * if we're trying to get a list of configurable interfaces. */\n\t\tif ((ifReq.ifr_flags & IFF_LOOPBACK) ||\n\t\t    (!(ifReq.ifr_flags & IFF_UP))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pifReq->ifr_addr.sa_family == AF_INET) {\n\t\t\t/* Get a pointer to the address...*/\n\t\t\tmemcpy(&LocalAddr, &pifReq->ifr_addr,\n\t\t\t\tsizeof pifReq->ifr_addr);\n\t\t\t/* We don't want the loopback interface. */\n\t\t\tif (LocalAddr.sin_addr.s_addr ==\n\t\t\t    htonl(INADDR_LOOPBACK)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* increment j if we found an address which is not loopback\n\t\t * and is up */\n\t\tj++;\n\t}\n\tclose(LocalSock);\n\n\tp = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));\n\tif (p) {\n\t\tstrncpy(out, p, out_len);\n\t} else {\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"getlocalhostname: inet_ntop returned error\\n\" );\n\t\tret = UPNP_E_INIT;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside getlocalhostname: after strncpy %s\\n\", out);\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Inside getlocalhostname: after strncpy %s\\n\"",
            "out"
          ],
          "line": 4085
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "out",
            "p",
            "out_len"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "AF_INET",
            "&LocalAddr.sin_addr",
            "tempstr",
            "sizeof(tempstr)"
          ],
          "line": 4077
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "291-305",
          "snippet": "const char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nconst char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "LocalSock"
          ],
          "line": 4075
        },
        "resolved": true,
        "details": {
          "function_name": "sock_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/sock.h",
          "lines": "79-89",
          "snippet": "static UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */",
            "#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */",
            "#include \"upnpconfig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */\n#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */\n#include \"upnpconfig.h\"\n\nstatic UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&LocalAddr",
            "&pifReq->ifr_addr",
            "sizeof pifReq->ifr_addr"
          ],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "LocalSock",
            "SIOCGIFFLAGS",
            "&ifReq"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifReq.ifr_name",
            "pifReq->ifr_name",
            "sizeof(ifReq.ifr_name) - 1"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ifReq.ifr_name",
            "0",
            "sizeof(ifReq.ifr_name)"
          ],
          "line": 4046
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "LocalSock",
            "SIOCGIFCONF",
            "&ifConf"
          ],
          "line": 4032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "IPPROTO_UDP"
          ],
          "line": 4023
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "ifap"
          ],
          "line": 4003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "out",
            "p",
            "out_len"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&ifap"
          ],
          "line": 3967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "out",
            "p",
            "out_len"
          ],
          "line": 3952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostbyname",
          "args": [
            "out"
          ],
          "line": 3947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "out",
            "out_len"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint getlocalhostname(char *out, size_t out_len)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar tempstr[INET_ADDRSTRLEN];\n\tconst char *p = NULL;\n\n#ifdef WIN32\n\tstruct hostent *h = NULL;\n\tstruct sockaddr_in LocalAddr;\n\n\tmemset(&LocalAddr, 0, sizeof(LocalAddr));\n\n\tgethostname(out, out_len);\n\th = gethostbyname(out);\n\tif (h != NULL) {\n\t\tmemcpy(&LocalAddr.sin_addr, h->h_addr_list[0], 4);\n\t\tp = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));\n\t\tif (p) {\n\t\t\tstrncpy(out, p, out_len);\n\t\t} else {\n\t\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"getlocalhostname: inet_ntop returned error\\n\" );\n\t\t\tret = UPNP_E_INIT;\n\t\t}\n\t} else {\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"getlocalhostname: gethostbyname returned error\\n\" );\n\t\tret = UPNP_E_INIT;\n\t}\n\n#elif (defined(BSD) && BSD >= 199306) || defined(__FreeBSD_kernel__)\n\tstruct ifaddrs *ifap, *ifa;\n\n\tif (getifaddrs(&ifap) != 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"DiscoverInterfaces: getifaddrs() returned error\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\n\t/* cycle through available interfaces */\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t/* Skip loopback, point-to-point and down interfaces, \n\t\t * except don't skip down interfaces\n\t\t * if we're trying to get a list of configurable interfaces. */\n\t\tif ((ifa->ifa_flags & IFF_LOOPBACK) ||\n\t\t    (!( ifa->ifa_flags & IFF_UP))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\t/* We don't want the loopback interface. */\n\t\t\tif (((struct sockaddr_in *)(ifa->ifa_addr))->sin_addr.s_addr ==\n\t\t\t    htonl(INADDR_LOOPBACK)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp = inet_ntop(AF_INET,\n\t\t\t\t&((struct sockaddr_in *)(ifa->ifa_addr))->sin_addr,\n\t\t\t\ttempstr, sizeof(tempstr));\n\t\t\tif (p) {\n\t\t\t\tstrncpy(out, p, out_len);\n\t\t\t} else {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t\"getlocalhostname: inet_ntop returned error\\n\");\n\t\t\t\tret = UPNP_E_INIT;\n\t\t\t}\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"Inside getlocalhostname: after strncpy %s\\n\", out);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfreeifaddrs(ifap);\n\n\tret = ifa ? UPNP_E_SUCCESS : UPNP_E_INIT;\n#else\n\tchar szBuffer[MAX_INTERFACES * sizeof (struct ifreq)];\n\tstruct ifconf ifConf;\n\tstruct ifreq ifReq;\n\tint nResult;\n\tlong unsigned int i;\n\tint LocalSock;\n\tstruct sockaddr_in LocalAddr;\n\tint j = 0;\n\n\t/* purify */\n\tmemset(&ifConf,  0, sizeof(ifConf));\n\tmemset(&ifReq,   0, sizeof(ifReq));\n\tmemset(szBuffer, 0, sizeof(szBuffer));\n\tmemset(&LocalAddr, 0, sizeof(LocalAddr));\n\n\t/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on.  */\n\tLocalSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (LocalSock == INVALID_SOCKET) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Can't create addrlist socket\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Get the interface configuration information... */\n\tifConf.ifc_len = (int)sizeof szBuffer;\n\tifConf.ifc_ifcu.ifcu_buf = (caddr_t) szBuffer;\n\tnResult = ioctl(LocalSock, SIOCGIFCONF, &ifConf);\n\tif (nResult < 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"DiscoverInterfaces: SIOCGIFCONF returned error\\n\");\n\t\tclose(LocalSock);\n\t\treturn UPNP_E_INIT;\n\t}\n\n\t/* Cycle through the list of interfaces looking for IP addresses. */\n\tfor (i = 0lu; i < (long unsigned int)ifConf.ifc_len && j < DEFAULT_INTERFACE; ) {\n\t\tstruct ifreq *pifReq =\n\t\t\t(struct ifreq *)((caddr_t)ifConf.ifc_req + i);\n\t\ti += sizeof *pifReq;\n\t\t/* See if this is the sort of interface we want to deal with. */\n\t\tmemset(ifReq.ifr_name, 0, sizeof(ifReq.ifr_name));\n\t\tstrncpy(ifReq.ifr_name, pifReq->ifr_name,\n\t\t\tsizeof(ifReq.ifr_name) - 1);\n\t\tif (ioctl(LocalSock, SIOCGIFFLAGS, &ifReq) < 0) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"Can't get interface flags for %s:\\n\",\n\t\t\t\tifReq.ifr_name);\n\t\t}\n\t\t/* Skip loopback, point-to-point and down interfaces,\n\t\t * except don't skip down interfaces\n\t\t * if we're trying to get a list of configurable interfaces. */\n\t\tif ((ifReq.ifr_flags & IFF_LOOPBACK) ||\n\t\t    (!(ifReq.ifr_flags & IFF_UP))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pifReq->ifr_addr.sa_family == AF_INET) {\n\t\t\t/* Get a pointer to the address...*/\n\t\t\tmemcpy(&LocalAddr, &pifReq->ifr_addr,\n\t\t\t\tsizeof pifReq->ifr_addr);\n\t\t\t/* We don't want the loopback interface. */\n\t\t\tif (LocalAddr.sin_addr.s_addr ==\n\t\t\t    htonl(INADDR_LOOPBACK)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* increment j if we found an address which is not loopback\n\t\t * and is up */\n\t\tj++;\n\t}\n\tclose(LocalSock);\n\n\tp = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));\n\tif (p) {\n\t\tstrncpy(out, p, out_len);\n\t} else {\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"getlocalhostname: inet_ntop returned error\\n\" );\n\t\tret = UPNP_E_INIT;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside getlocalhostname: after strncpy %s\\n\", out);\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "PrintHandleInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3908-3931",
    "snippet": "int PrintHandleInfo(UpnpClient_Handle Hnd)\n{\n    struct Handle_Info * HndInfo;\n    if (HandleTable[Hnd] != NULL) {\n        HndInfo = HandleTable[Hnd];\n            UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n                \"Printing information for Handle_%d\\n\", Hnd);\n            UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n                \"HType_%d\\n\", HndInfo->HType);\n#ifdef INCLUDE_DEVICE_APIS\n                switch(HndInfo->HType) {\n                case HND_CLIENT:\n                    break;\n                default:\n                    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n                        \"DescURL_%s\\n\", HndInfo->DescURL);\n                }\n#endif /* INCLUDE_DEVICE_APIS */\n    } else {\n        return UPNP_E_INVALID_HANDLE;\n    }\n\n    return UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *HandleTable[NUM_HANDLE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"DescURL_%s\\n\"",
            "HndInfo->DescURL"
          ],
          "line": 3922
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic void *HandleTable[NUM_HANDLE];\n\nint PrintHandleInfo(UpnpClient_Handle Hnd)\n{\n    struct Handle_Info * HndInfo;\n    if (HandleTable[Hnd] != NULL) {\n        HndInfo = HandleTable[Hnd];\n            UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n                \"Printing information for Handle_%d\\n\", Hnd);\n            UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n                \"HType_%d\\n\", HndInfo->HType);\n#ifdef INCLUDE_DEVICE_APIS\n                switch(HndInfo->HType) {\n                case HND_CLIENT:\n                    break;\n                default:\n                    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n                        \"DescURL_%s\\n\", HndInfo->DescURL);\n                }\n#endif /* INCLUDE_DEVICE_APIS */\n    } else {\n        return UPNP_E_INVALID_HANDLE;\n    }\n\n    return UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "GetHandleInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3881-3905",
    "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_HANDLE 200"
    ],
    "globals_used": [
      "static void *HandleTable[NUM_HANDLE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"GetHandleInfo: exiting\\n\""
          ],
          "line": 3902
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "GetDeviceHandleInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3849-3878",
    "snippet": "Upnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_HANDLE 200"
    ],
    "globals_used": [
      "int UpnpSdkDeviceRegisteredV4 = 0;",
      "int UpnpSdkDeviceregisteredV6 = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "*device_handle_out",
            "HndInfo"
          ],
          "line": 3864
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nint UpnpSdkDeviceRegisteredV4 = 0;\nint UpnpSdkDeviceregisteredV6 = 0;\n\nUpnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}"
  },
  {
    "function_name": "GetClientHandleInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3822-3846",
    "snippet": "Upnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "2",
            "HndInfo"
          ],
          "line": 3834
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nUpnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}"
  },
  {
    "function_name": "GetCallBackFn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3815-3818",
    "snippet": "Upnp_FunPtr GetCallBackFn(UpnpClient_Handle Hnd)\n{\n\treturn ((struct Handle_Info *)HandleTable[Hnd])->Callback;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *HandleTable[NUM_HANDLE];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_FunPtr GetCallBackFn(UpnpClient_Handle Hnd)\n{\n\treturn ((struct Handle_Info *)HandleTable[Hnd])->Callback;\n}"
  },
  {
    "function_name": "UpnpThreadDistribution",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3708-3806",
    "snippet": "void UpnpThreadDistribution(struct UpnpNonblockParam *Param)\n{\n\tint errCode = 0;\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpThreadDistribution \\n\");\n\n\tswitch (Param->FunName) {\n#if EXCLUDE_GENA == 0\n\tcase SUBSCRIBE: {\n\t\tUpnpEventSubscribe *evt = UpnpEventSubscribe_new();\n\t\tUpnpString *Sid = UpnpString_new();\n\n\t\tUpnpEventSubscribe_strcpy_PublisherUrl(evt, Param->Url);\n\t\terrCode = genaSubscribe(\n\t\t\tParam->Handle,\n\t\t\tUpnpEventSubscribe_get_PublisherUrl(evt),\n\t\t\t(int *)&Param->TimeOut,\n\t\t\tSid);\n\t\tUpnpEventSubscribe_set_ErrCode(evt, errCode);\n\t\tUpnpEventSubscribe_set_TimeOut(evt, Param->TimeOut);\n\t\tUpnpEventSubscribe_set_SID(evt, Sid);\n\t\tParam->Fun(UPNP_EVENT_SUBSCRIBE_COMPLETE, evt, Param->Cookie);\n \t\tUpnpString_delete(Sid);\n\t    \tUpnpEventSubscribe_delete(evt);\n\t\tfree(Param);\n\t\tbreak;\n\t}\n\tcase UNSUBSCRIBE: {\n\t\tUpnpEventSubscribe *evt = UpnpEventSubscribe_new();\n\t\tUpnpEventSubscribe_strcpy_SID(evt, Param->SubsId);\n\t\terrCode = genaUnSubscribe(\n\t\t\tParam->Handle,\n\t\t\tUpnpEventSubscribe_get_SID(evt));\n\t\tUpnpEventSubscribe_set_ErrCode(evt, errCode);\n\t\tUpnpEventSubscribe_strcpy_PublisherUrl(evt, \"\");\n\t\tUpnpEventSubscribe_set_TimeOut(evt, 0);\n\t\tParam->Fun(UPNP_EVENT_UNSUBSCRIBE_COMPLETE, evt, Param->Cookie);\n\t\tUpnpEventSubscribe_delete(evt);\n\t\tfree(Param);\n\t\tbreak;\n\t}\n\tcase RENEW: {\n\t\tUpnpEventSubscribe *evt = UpnpEventSubscribe_new();\n\t\tUpnpEventSubscribe_strcpy_SID(evt, Param->SubsId);\n\t\terrCode = genaRenewSubscription(\n\t\t\tParam->Handle,\n\t\t\tUpnpEventSubscribe_get_SID(evt),\n\t\t\t&Param->TimeOut);\n\t\tUpnpEventSubscribe_set_ErrCode(evt, errCode);\n\t\tUpnpEventSubscribe_set_TimeOut(evt, Param->TimeOut);\n\t\tParam->Fun(UPNP_EVENT_RENEWAL_COMPLETE, evt, Param->Cookie);\n\t\tUpnpEventSubscribe_delete(evt);\n\t\tfree(Param);\n\t\tbreak;\n\t}\n#endif /* EXCLUDE_GENA == 0 */\n#if EXCLUDE_SOAP == 0\n\tcase ACTION: {\n\t\tUpnpActionComplete *Evt = UpnpActionComplete_new();\n\t\tIXML_Document *actionResult = NULL;\n\t\tint errCode = SoapSendAction(\n\t\t\tParam->Url,\n\t\t\tParam->ServiceType,\n\t\t\tParam->Act,\n\t\t\t&actionResult);\n\t\tUpnpActionComplete_set_ErrCode(Evt, errCode);\n\t\tUpnpActionComplete_set_ActionRequest(Evt, Param->Act);\n\t\tUpnpActionComplete_set_ActionResult(Evt, actionResult);\n\t\tUpnpActionComplete_strcpy_CtrlUrl(Evt, Param->Url);\n\t\tParam->Fun(UPNP_CONTROL_ACTION_COMPLETE, Evt, Param->Cookie);\n\t\tfree(Param);\n\t\tUpnpActionComplete_delete(Evt);\n\t\tbreak;\n\t}\n\tcase STATUS: {\n\t\tUpnpStateVarComplete *Evt = UpnpStateVarComplete_new();\n\t\tDOMString currentVal = NULL;\n\t\tint errCode = SoapGetServiceVarStatus(\n\t\t\tParam->Url,\n\t\t\tParam->VarName,\n\t\t\t&currentVal);\n\t\tUpnpStateVarComplete_set_ErrCode(Evt, errCode);\n\t\tUpnpStateVarComplete_strcpy_CtrlUrl(Evt, Param->Url);\n\t\tUpnpStateVarComplete_strcpy_StateVarName(Evt, Param->VarName);\n\t\tUpnpStateVarComplete_set_CurrentVal(Evt, currentVal);\n\t\tParam->Fun(UPNP_CONTROL_GET_VAR_COMPLETE, Evt, Param->Cookie);\n\t\tfree(Param);\n\t\tUpnpStateVarComplete_delete(Evt);\n\t\tbreak;\n\t}\n#endif /* EXCLUDE_SOAP == 0 */\n\tdefault:\n\t\tbreak;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpThreadDistribution\\n\");\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpThreadDistribution\\n\""
          ],
          "line": 3804
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpStateVarComplete_delete",
          "args": [
            "Evt"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "Param"
          ],
          "line": 3795
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Param->Fun",
          "args": [
            "UPNP_CONTROL_GET_VAR_COMPLETE",
            "Evt",
            "Param->Cookie"
          ],
          "line": 3794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarComplete_set_CurrentVal",
          "args": [
            "Evt",
            "currentVal"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarComplete_strcpy_StateVarName",
          "args": [
            "Evt",
            "Param->VarName"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarComplete_strcpy_CtrlUrl",
          "args": [
            "Evt",
            "Param->Url"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarComplete_set_ErrCode",
          "args": [
            "Evt",
            "errCode"
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SoapGetServiceVarStatus",
          "args": [
            "Param->Url",
            "Param->VarName",
            "&currentVal"
          ],
          "line": 3786
        },
        "resolved": true,
        "details": {
          "function_name": "SoapGetServiceVarStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "821-885",
          "snippet": "int\nSoapGetServiceVarStatus( IN char *action_url,\n                         IN char *var_name,\n                         OUT char **var_value )\n{\n    const memptr host;                /* value for HOST header */\n    const memptr path;                /* ctrl path in first line in msg */\n    uri_type url;\n    membuffer request;\n    int ret_code;\n    http_parser_t response;\n    int upnp_error_code;\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\\r\\n\"\n        \"<u:QueryStateVariable xmlns:u=\\\"urn:schemas-upnp-org:control-1-0\\\">\\r\\n\"\n        \"<u:varName>\";\n    const char *xml_end =\n        \"</u:varName>\\r\\n\"\n        \"</u:QueryStateVariable>\\r\\n\"\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\";\n\n    *var_value = NULL;          /* return NULL in case of an error */\n    membuffer_init( &request );\n    /* get host hdr and url path */\n    if( get_host_and_path( action_url, &host, &path, &url ) == -1 ) {\n        return UPNP_E_INVALID_URL;\n    }\n    /* make headers */\n    request.size_inc = 50;\n    content_length = (off_t)(strlen(xml_start) + strlen(var_name) +\n\tstrlen(xml_end));\n    if (http_MakeMessage(\n\t&request, 1, 1,\n\t\"Q\" \"sbc\" \"N\" \"s\" \"sc\" \"Ucc\" \"sss\",\n\tSOAPMETHOD_POST, path.buf, path.length,\n\t\"HOST: \", host.buf, host.length,\n\tcontent_length,\n\tContentTypeHeader,\n\t\"SOAPACTION: \\\"urn:schemas-upnp-org:control-1-0#QueryStateVariable\\\"\",\n\txml_start, var_name, xml_end ) != 0 ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    /* send msg and get reply */\n    ret_code = soap_request_and_response( &request, &url, &response );\n    membuffer_destroy( &request );\n    if( ret_code != UPNP_E_SUCCESS ) {\n        return ret_code;\n    }\n    /* get variable value from the response */\n    ret_code = get_response_value( &response.msg, SOAP_VAR_RESP, NULL,\n                                   &upnp_error_code, NULL, var_value );\n    httpmsg_destroy( &response.msg );\n    if( ret_code == SOAP_VAR_RESP ) {\n        return UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_VAR_RESP_ERROR ) {\n        return upnp_error_code;\n    } else {\n        return ret_code;\n    }\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_VAR_RESP_ERROR\t4",
            "#define SOAP_VAR_RESP\t\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_VAR_RESP_ERROR\t4\n#define SOAP_VAR_RESP\t\t2\n\nint\nSoapGetServiceVarStatus( IN char *action_url,\n                         IN char *var_name,\n                         OUT char **var_value )\n{\n    const memptr host;                /* value for HOST header */\n    const memptr path;                /* ctrl path in first line in msg */\n    uri_type url;\n    membuffer request;\n    int ret_code;\n    http_parser_t response;\n    int upnp_error_code;\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\\r\\n\"\n        \"<u:QueryStateVariable xmlns:u=\\\"urn:schemas-upnp-org:control-1-0\\\">\\r\\n\"\n        \"<u:varName>\";\n    const char *xml_end =\n        \"</u:varName>\\r\\n\"\n        \"</u:QueryStateVariable>\\r\\n\"\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\";\n\n    *var_value = NULL;          /* return NULL in case of an error */\n    membuffer_init( &request );\n    /* get host hdr and url path */\n    if( get_host_and_path( action_url, &host, &path, &url ) == -1 ) {\n        return UPNP_E_INVALID_URL;\n    }\n    /* make headers */\n    request.size_inc = 50;\n    content_length = (off_t)(strlen(xml_start) + strlen(var_name) +\n\tstrlen(xml_end));\n    if (http_MakeMessage(\n\t&request, 1, 1,\n\t\"Q\" \"sbc\" \"N\" \"s\" \"sc\" \"Ucc\" \"sss\",\n\tSOAPMETHOD_POST, path.buf, path.length,\n\t\"HOST: \", host.buf, host.length,\n\tcontent_length,\n\tContentTypeHeader,\n\t\"SOAPACTION: \\\"urn:schemas-upnp-org:control-1-0#QueryStateVariable\\\"\",\n\txml_start, var_name, xml_end ) != 0 ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    /* send msg and get reply */\n    ret_code = soap_request_and_response( &request, &url, &response );\n    membuffer_destroy( &request );\n    if( ret_code != UPNP_E_SUCCESS ) {\n        return ret_code;\n    }\n    /* get variable value from the response */\n    ret_code = get_response_value( &response.msg, SOAP_VAR_RESP, NULL,\n                                   &upnp_error_code, NULL, var_value );\n    httpmsg_destroy( &response.msg );\n    if( ret_code == SOAP_VAR_RESP ) {\n        return UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_VAR_RESP_ERROR ) {\n        return upnp_error_code;\n    } else {\n        return ret_code;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpStateVarComplete_new",
          "args": [],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionComplete_delete",
          "args": [
            "Evt"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Param->Fun",
          "args": [
            "UPNP_CONTROL_ACTION_COMPLETE",
            "Evt",
            "Param->Cookie"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionComplete_strcpy_CtrlUrl",
          "args": [
            "Evt",
            "Param->Url"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionComplete_set_ActionResult",
          "args": [
            "Evt",
            "actionResult"
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionComplete_set_ActionRequest",
          "args": [
            "Evt",
            "Param->Act"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionComplete_set_ErrCode",
          "args": [
            "Evt",
            "errCode"
          ],
          "line": 3774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SoapSendAction",
          "args": [
            "Param->Url",
            "Param->ServiceType",
            "Param->Act",
            "&actionResult"
          ],
          "line": 3769
        },
        "resolved": true,
        "details": {
          "function_name": "SoapSendAction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "517-635",
          "snippet": "int\nSoapSendAction( IN char *action_url,\n                IN char *service_type,\n                IN IXML_Document * action_node,\n                OUT IXML_Document ** response_node )\n{\n    char *action_str = NULL;\n    memptr name;\n    membuffer request;\n    membuffer responsename;\n    int err_code;\n    int ret_code;\n    http_parser_t response;\n    uri_type url;\n    int upnp_error_code;\n    char *upnp_error_str;\n    int got_response = FALSE;\n\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\";\n    const char *xml_end =\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\\r\\n\";\n    size_t xml_start_len;\n    size_t xml_end_len;\n    size_t action_str_len;\n\n    *response_node = NULL;      /* init */\n\n    err_code = UPNP_E_OUTOF_MEMORY; /* default error */\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"Inside SoapSendAction():\" );\n    /* init */\n    membuffer_init( &request );\n    membuffer_init( &responsename );\n\n    /* print action */\n    action_str = ixmlPrintNode( ( IXML_Node * ) action_node );\n    if( action_str == NULL ) {\n        goto error_handler;\n    }\n    /* get action name */\n    if( get_action_name( action_str, &name ) != 0 ) {\n        err_code = UPNP_E_INVALID_ACTION;\n        goto error_handler;\n    }\n    /* parse url */\n    if( http_FixStrUrl( action_url, strlen( action_url ), &url ) != 0 ) {\n        err_code = UPNP_E_INVALID_URL;\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"path=%.*s, hostport=%.*s\\n\",\n        (int)url.pathquery.size,\n        url.pathquery.buff,\n        (int)url.hostport.text.size,\n        url.hostport.text.buff );\n\n    xml_start_len = strlen( xml_start );\n    xml_end_len = strlen( xml_end );\n    action_str_len = strlen( action_str );\n\n    /* make request msg */\n    request.size_inc = 50;\n    content_length = (off_t)(xml_start_len + action_str_len + xml_end_len);\n    if (http_MakeMessage(\n       \t&request, 1, 1,\n        \"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\",\n        SOAPMETHOD_POST, &url, \n        content_length,\n        ContentTypeHeader,\n        \"SOAPACTION: \\\"\", service_type, \"#\", name.buf, name.length, \"\\\"\",\n        xml_start, xml_start_len,\n        action_str, action_str_len,\n        xml_end, xml_end_len ) != 0 ) {\n        goto error_handler;\n    }\n\n    ret_code = soap_request_and_response( &request, &url, &response );\n    got_response = TRUE;\n    if( ret_code != UPNP_E_SUCCESS ) {\n        err_code = ret_code;\n        goto error_handler;\n    }\n\n    if( membuffer_append( &responsename, name.buf, name.length ) != 0 ||\n        membuffer_append_str( &responsename, \"Response\" ) != 0 ) {\n        goto error_handler;\n    }\n    /* get action node from the response */\n    ret_code = get_response_value( &response.msg, SOAP_ACTION_RESP,\n                                   responsename.buf, &upnp_error_code,\n                                   ( IXML_Node ** ) response_node,\n                                   &upnp_error_str );\n\n    if( ret_code == SOAP_ACTION_RESP ) {\n        err_code = UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_ACTION_RESP_ERROR ) {\n        err_code = upnp_error_code;\n    } else {\n        err_code = ret_code;\n    }\n\nerror_handler:\n    ixmlFreeDOMString( action_str );\n    membuffer_destroy( &request );\n    membuffer_destroy( &responsename );\n    if( got_response ) {\n        httpmsg_destroy( &response.msg );\n    }\n\n    return err_code;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_ACTION_RESP_ERROR  3",
            "#define SOAP_ACTION_RESP\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_ACTION_RESP_ERROR  3\n#define SOAP_ACTION_RESP\t1\n\nint\nSoapSendAction( IN char *action_url,\n                IN char *service_type,\n                IN IXML_Document * action_node,\n                OUT IXML_Document ** response_node )\n{\n    char *action_str = NULL;\n    memptr name;\n    membuffer request;\n    membuffer responsename;\n    int err_code;\n    int ret_code;\n    http_parser_t response;\n    uri_type url;\n    int upnp_error_code;\n    char *upnp_error_str;\n    int got_response = FALSE;\n\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\";\n    const char *xml_end =\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\\r\\n\";\n    size_t xml_start_len;\n    size_t xml_end_len;\n    size_t action_str_len;\n\n    *response_node = NULL;      /* init */\n\n    err_code = UPNP_E_OUTOF_MEMORY; /* default error */\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"Inside SoapSendAction():\" );\n    /* init */\n    membuffer_init( &request );\n    membuffer_init( &responsename );\n\n    /* print action */\n    action_str = ixmlPrintNode( ( IXML_Node * ) action_node );\n    if( action_str == NULL ) {\n        goto error_handler;\n    }\n    /* get action name */\n    if( get_action_name( action_str, &name ) != 0 ) {\n        err_code = UPNP_E_INVALID_ACTION;\n        goto error_handler;\n    }\n    /* parse url */\n    if( http_FixStrUrl( action_url, strlen( action_url ), &url ) != 0 ) {\n        err_code = UPNP_E_INVALID_URL;\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"path=%.*s, hostport=%.*s\\n\",\n        (int)url.pathquery.size,\n        url.pathquery.buff,\n        (int)url.hostport.text.size,\n        url.hostport.text.buff );\n\n    xml_start_len = strlen( xml_start );\n    xml_end_len = strlen( xml_end );\n    action_str_len = strlen( action_str );\n\n    /* make request msg */\n    request.size_inc = 50;\n    content_length = (off_t)(xml_start_len + action_str_len + xml_end_len);\n    if (http_MakeMessage(\n       \t&request, 1, 1,\n        \"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\",\n        SOAPMETHOD_POST, &url, \n        content_length,\n        ContentTypeHeader,\n        \"SOAPACTION: \\\"\", service_type, \"#\", name.buf, name.length, \"\\\"\",\n        xml_start, xml_start_len,\n        action_str, action_str_len,\n        xml_end, xml_end_len ) != 0 ) {\n        goto error_handler;\n    }\n\n    ret_code = soap_request_and_response( &request, &url, &response );\n    got_response = TRUE;\n    if( ret_code != UPNP_E_SUCCESS ) {\n        err_code = ret_code;\n        goto error_handler;\n    }\n\n    if( membuffer_append( &responsename, name.buf, name.length ) != 0 ||\n        membuffer_append_str( &responsename, \"Response\" ) != 0 ) {\n        goto error_handler;\n    }\n    /* get action node from the response */\n    ret_code = get_response_value( &response.msg, SOAP_ACTION_RESP,\n                                   responsename.buf, &upnp_error_code,\n                                   ( IXML_Node ** ) response_node,\n                                   &upnp_error_str );\n\n    if( ret_code == SOAP_ACTION_RESP ) {\n        err_code = UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_ACTION_RESP_ERROR ) {\n        err_code = upnp_error_code;\n    } else {\n        err_code = ret_code;\n    }\n\nerror_handler:\n    ixmlFreeDOMString( action_str );\n    membuffer_destroy( &request );\n    membuffer_destroy( &responsename );\n    if( got_response ) {\n        httpmsg_destroy( &response.msg );\n    }\n\n    return err_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpActionComplete_new",
          "args": [],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_delete",
          "args": [
            "evt"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Param->Fun",
          "args": [
            "UPNP_EVENT_RENEWAL_COMPLETE",
            "evt",
            "Param->Cookie"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_TimeOut",
          "args": [
            "evt",
            "Param->TimeOut"
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_ErrCode",
          "args": [
            "evt",
            "errCode"
          ],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genaRenewSubscription",
          "args": [
            "Param->Handle",
            "UpnpEventSubscribe_get_SID(evt)",
            "&Param->TimeOut"
          ],
          "line": 3753
        },
        "resolved": true,
        "details": {
          "function_name": "genaRenewSubscription",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "598-693",
          "snippet": "int genaRenewSubscription(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid,\n\tint *TimeOut)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *sub = NULL;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tstruct Handle_Info *handle_info;\n\tUpnpString *ActualSID = UpnpString_new();\n\tThreadPoolJob tempJob;\n\n\tHandleLock();\n\n\t/* validate handle and sid */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* remove old events */\n\tif (TimerThreadRemove(\n\t\t&gTimerThread,\n\t\tGenlibClientSubscription_get_RenewEventId(sub),\n\t\t&tempJob) == 0 ) {\n\t\tfree_upnp_timeout((upnp_timeout *)tempJob.arg);\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"REMOVED AUTO RENEW  EVENT\");\n\n\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\n\tHandleUnlock();\n\n\treturn_code = gena_subscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tTimeOut,\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\tActualSID);\n\n\tHandleLock();\n\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\t/* we just called GetHandleInfo, so we don't check for return value */\n\t/*GetHandleInfo(client_handle, &handle_info); */\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\t/* network failure (remove client sub) */\n\t\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription */\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* store actual sid */\n\tGenlibClientSubscription_set_ActualSID(sub, ActualSID);\n\n\t/* start renew subscription timer */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, sub);\n\tif (return_code != GENA_SUCCESS) {\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub));\n\t}\n\tfree_client_subscription(sub_copy);\n\tHandleUnlock();\n\nexit_function:\n\tUpnpString_delete(ActualSID);\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nint genaRenewSubscription(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid,\n\tint *TimeOut)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *sub = NULL;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tstruct Handle_Info *handle_info;\n\tUpnpString *ActualSID = UpnpString_new();\n\tThreadPoolJob tempJob;\n\n\tHandleLock();\n\n\t/* validate handle and sid */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* remove old events */\n\tif (TimerThreadRemove(\n\t\t&gTimerThread,\n\t\tGenlibClientSubscription_get_RenewEventId(sub),\n\t\t&tempJob) == 0 ) {\n\t\tfree_upnp_timeout((upnp_timeout *)tempJob.arg);\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"REMOVED AUTO RENEW  EVENT\");\n\n\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\n\tHandleUnlock();\n\n\treturn_code = gena_subscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tTimeOut,\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\tActualSID);\n\n\tHandleLock();\n\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\t/* we just called GetHandleInfo, so we don't check for return value */\n\t/*GetHandleInfo(client_handle, &handle_info); */\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\t/* network failure (remove client sub) */\n\t\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription */\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* store actual sid */\n\tGenlibClientSubscription_set_ActualSID(sub, ActualSID);\n\n\t/* start renew subscription timer */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, sub);\n\tif (return_code != GENA_SUCCESS) {\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub));\n\t}\n\tfree_client_subscription(sub_copy);\n\tHandleUnlock();\n\nexit_function:\n\tUpnpString_delete(ActualSID);\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_get_SID",
          "args": [
            "evt"
          ],
          "line": 3755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_strcpy_SID",
          "args": [
            "evt",
            "Param->SubsId"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_new",
          "args": [],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_delete",
          "args": [
            "evt"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Param->Fun",
          "args": [
            "UPNP_EVENT_UNSUBSCRIBE_COMPLETE",
            "evt",
            "Param->Cookie"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_TimeOut",
          "args": [
            "evt",
            "0"
          ],
          "line": 3744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_strcpy_PublisherUrl",
          "args": [
            "evt",
            "\"\""
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_ErrCode",
          "args": [
            "evt",
            "errCode"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genaUnSubscribe",
          "args": [
            "Param->Handle",
            "UpnpEventSubscribe_get_SID(evt)"
          ],
          "line": 3739
        },
        "resolved": true,
        "details": {
          "function_name": "genaUnSubscribe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "457-504",
          "snippet": "int genaUnSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid)\n{\n\tGenlibClientSubscription *sub = NULL;\n\tint return_code = GENA_SUCCESS;\n\tstruct Handle_Info *handle_info;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\thttp_parser_t response;\n\n\t/* validate handle and sid */\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\tHandleUnlock();\n\n\treturn_code = gena_unsubscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\t&response);\n\tif (return_code == 0) {\n\t\thttpmsg_destroy(&response.msg);\n\t}\n\tfree_client_subscription(sub_copy);\n\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\tHandleUnlock();\n\nexit_function:\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nint genaUnSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid)\n{\n\tGenlibClientSubscription *sub = NULL;\n\tint return_code = GENA_SUCCESS;\n\tstruct Handle_Info *handle_info;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\thttp_parser_t response;\n\n\t/* validate handle and sid */\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\tHandleUnlock();\n\n\treturn_code = gena_unsubscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\t&response);\n\tif (return_code == 0) {\n\t\thttpmsg_destroy(&response.msg);\n\t}\n\tfree_client_subscription(sub_copy);\n\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\tHandleUnlock();\n\nexit_function:\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_get_SID",
          "args": [
            "evt"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_strcpy_SID",
          "args": [
            "evt",
            "Param->SubsId"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_new",
          "args": [],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_delete",
          "args": [
            "evt"
          ],
          "line": 3732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_delete",
          "args": [
            "Sid"
          ],
          "line": 3731
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "99-111",
          "snippet": "void UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nvoid UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Param->Fun",
          "args": [
            "UPNP_EVENT_SUBSCRIBE_COMPLETE",
            "evt",
            "Param->Cookie"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_SID",
          "args": [
            "evt",
            "Sid"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_TimeOut",
          "args": [
            "evt",
            "Param->TimeOut"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_ErrCode",
          "args": [
            "evt",
            "errCode"
          ],
          "line": 3727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genaSubscribe",
          "args": [
            "Param->Handle",
            "UpnpEventSubscribe_get_PublisherUrl(evt)",
            "(int *)&Param->TimeOut",
            "Sid"
          ],
          "line": 3722
        },
        "resolved": true,
        "details": {
          "function_name": "genaSubscribe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "509-594",
          "snippet": "int genaSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *PublisherURL,\n\tint *TimeOut,\n\tUpnpString *out_sid)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *newSubscription = GenlibClientSubscription_new();\n\tuuid_upnp uid;\n\tUpnp_SID temp_sid;\n\tUpnp_SID temp_sid2;\n\tUpnpString *ActualSID = UpnpString_new();\n\tUpnpString *EventURL = UpnpString_new();\n\tstruct Handle_Info *handle_info;\n\tint rc = 0;\n\n\tmemset(temp_sid, 0, sizeof(temp_sid));\n\tmemset(temp_sid2, 0, sizeof(temp_sid2));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"GENA SUBSCRIBE BEGIN\");\n\n\tUpnpString_clear(out_sid);\n\n\tHandleReadLock();\n\t/* validate handle */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tSubscribeLock();\n\t\tgoto error_handler;\n\t}\n\tHandleUnlock();\n\n\t/* subscribe */\n\tSubscribeLock();\n\treturn_code = gena_subscribe(PublisherURL, TimeOut, NULL, ActualSID);\n\tHandleLock();\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf( UPNP_CRITICAL, GENA, __FILE__, __LINE__,\n\t\t\t\"SUBSCRIBE FAILED in transfer error code: %d returned\\n\",\n\t\t\treturn_code );\n\t\tgoto error_handler;\n\t}\n\n\tif(GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto error_handler;\n\t}\n\n\t/* generate client SID */\n\tuuid_create(&uid );\n\tuuid_unpack(&uid, temp_sid);\n\trc = snprintf(temp_sid2, sizeof(temp_sid2), \"uuid:%s\", temp_sid);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(temp_sid2)) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tUpnpString_set_String(out_sid, temp_sid2);\n\n\t/* create event url */\n\tUpnpString_assign(EventURL, PublisherURL);\n\n\t/* fill subscription */\n\tif (newSubscription == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tGenlibClientSubscription_set_RenewEventId(newSubscription, -1);\n\tGenlibClientSubscription_set_SID(newSubscription, out_sid);\n\tGenlibClientSubscription_set_ActualSID(newSubscription, ActualSID);\n\tGenlibClientSubscription_set_EventURL(newSubscription, EventURL);\n\tGenlibClientSubscription_set_Next(newSubscription, handle_info->ClientSubList);\n\thandle_info->ClientSubList = newSubscription;\n\n\t/* schedule expiration event */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, newSubscription);\n\nerror_handler:\n\tUpnpString_delete(ActualSID);\n\tUpnpString_delete(EventURL);\n\tif (return_code != UPNP_E_SUCCESS)\n\t\tGenlibClientSubscription_delete(newSubscription);\n\tHandleUnlock();\n\tSubscribeUnlock();\n\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint genaSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *PublisherURL,\n\tint *TimeOut,\n\tUpnpString *out_sid)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *newSubscription = GenlibClientSubscription_new();\n\tuuid_upnp uid;\n\tUpnp_SID temp_sid;\n\tUpnp_SID temp_sid2;\n\tUpnpString *ActualSID = UpnpString_new();\n\tUpnpString *EventURL = UpnpString_new();\n\tstruct Handle_Info *handle_info;\n\tint rc = 0;\n\n\tmemset(temp_sid, 0, sizeof(temp_sid));\n\tmemset(temp_sid2, 0, sizeof(temp_sid2));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"GENA SUBSCRIBE BEGIN\");\n\n\tUpnpString_clear(out_sid);\n\n\tHandleReadLock();\n\t/* validate handle */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tSubscribeLock();\n\t\tgoto error_handler;\n\t}\n\tHandleUnlock();\n\n\t/* subscribe */\n\tSubscribeLock();\n\treturn_code = gena_subscribe(PublisherURL, TimeOut, NULL, ActualSID);\n\tHandleLock();\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf( UPNP_CRITICAL, GENA, __FILE__, __LINE__,\n\t\t\t\"SUBSCRIBE FAILED in transfer error code: %d returned\\n\",\n\t\t\treturn_code );\n\t\tgoto error_handler;\n\t}\n\n\tif(GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto error_handler;\n\t}\n\n\t/* generate client SID */\n\tuuid_create(&uid );\n\tuuid_unpack(&uid, temp_sid);\n\trc = snprintf(temp_sid2, sizeof(temp_sid2), \"uuid:%s\", temp_sid);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(temp_sid2)) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tUpnpString_set_String(out_sid, temp_sid2);\n\n\t/* create event url */\n\tUpnpString_assign(EventURL, PublisherURL);\n\n\t/* fill subscription */\n\tif (newSubscription == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tGenlibClientSubscription_set_RenewEventId(newSubscription, -1);\n\tGenlibClientSubscription_set_SID(newSubscription, out_sid);\n\tGenlibClientSubscription_set_ActualSID(newSubscription, ActualSID);\n\tGenlibClientSubscription_set_EventURL(newSubscription, EventURL);\n\tGenlibClientSubscription_set_Next(newSubscription, handle_info->ClientSubList);\n\thandle_info->ClientSubList = newSubscription;\n\n\t/* schedule expiration event */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, newSubscription);\n\nerror_handler:\n\tUpnpString_delete(ActualSID);\n\tUpnpString_delete(EventURL);\n\tif (return_code != UPNP_E_SUCCESS)\n\t\tGenlibClientSubscription_delete(newSubscription);\n\tHandleUnlock();\n\tSubscribeUnlock();\n\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_get_PublisherUrl",
          "args": [
            "evt"
          ],
          "line": 3724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_strcpy_PublisherUrl",
          "args": [
            "evt",
            "Param->Url"
          ],
          "line": 3721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_new",
          "args": [],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "73-97",
          "snippet": "UpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nUpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_new",
          "args": [],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nvoid UpnpThreadDistribution(struct UpnpNonblockParam *Param)\n{\n\tint errCode = 0;\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpThreadDistribution \\n\");\n\n\tswitch (Param->FunName) {\n#if EXCLUDE_GENA == 0\n\tcase SUBSCRIBE: {\n\t\tUpnpEventSubscribe *evt = UpnpEventSubscribe_new();\n\t\tUpnpString *Sid = UpnpString_new();\n\n\t\tUpnpEventSubscribe_strcpy_PublisherUrl(evt, Param->Url);\n\t\terrCode = genaSubscribe(\n\t\t\tParam->Handle,\n\t\t\tUpnpEventSubscribe_get_PublisherUrl(evt),\n\t\t\t(int *)&Param->TimeOut,\n\t\t\tSid);\n\t\tUpnpEventSubscribe_set_ErrCode(evt, errCode);\n\t\tUpnpEventSubscribe_set_TimeOut(evt, Param->TimeOut);\n\t\tUpnpEventSubscribe_set_SID(evt, Sid);\n\t\tParam->Fun(UPNP_EVENT_SUBSCRIBE_COMPLETE, evt, Param->Cookie);\n \t\tUpnpString_delete(Sid);\n\t    \tUpnpEventSubscribe_delete(evt);\n\t\tfree(Param);\n\t\tbreak;\n\t}\n\tcase UNSUBSCRIBE: {\n\t\tUpnpEventSubscribe *evt = UpnpEventSubscribe_new();\n\t\tUpnpEventSubscribe_strcpy_SID(evt, Param->SubsId);\n\t\terrCode = genaUnSubscribe(\n\t\t\tParam->Handle,\n\t\t\tUpnpEventSubscribe_get_SID(evt));\n\t\tUpnpEventSubscribe_set_ErrCode(evt, errCode);\n\t\tUpnpEventSubscribe_strcpy_PublisherUrl(evt, \"\");\n\t\tUpnpEventSubscribe_set_TimeOut(evt, 0);\n\t\tParam->Fun(UPNP_EVENT_UNSUBSCRIBE_COMPLETE, evt, Param->Cookie);\n\t\tUpnpEventSubscribe_delete(evt);\n\t\tfree(Param);\n\t\tbreak;\n\t}\n\tcase RENEW: {\n\t\tUpnpEventSubscribe *evt = UpnpEventSubscribe_new();\n\t\tUpnpEventSubscribe_strcpy_SID(evt, Param->SubsId);\n\t\terrCode = genaRenewSubscription(\n\t\t\tParam->Handle,\n\t\t\tUpnpEventSubscribe_get_SID(evt),\n\t\t\t&Param->TimeOut);\n\t\tUpnpEventSubscribe_set_ErrCode(evt, errCode);\n\t\tUpnpEventSubscribe_set_TimeOut(evt, Param->TimeOut);\n\t\tParam->Fun(UPNP_EVENT_RENEWAL_COMPLETE, evt, Param->Cookie);\n\t\tUpnpEventSubscribe_delete(evt);\n\t\tfree(Param);\n\t\tbreak;\n\t}\n#endif /* EXCLUDE_GENA == 0 */\n#if EXCLUDE_SOAP == 0\n\tcase ACTION: {\n\t\tUpnpActionComplete *Evt = UpnpActionComplete_new();\n\t\tIXML_Document *actionResult = NULL;\n\t\tint errCode = SoapSendAction(\n\t\t\tParam->Url,\n\t\t\tParam->ServiceType,\n\t\t\tParam->Act,\n\t\t\t&actionResult);\n\t\tUpnpActionComplete_set_ErrCode(Evt, errCode);\n\t\tUpnpActionComplete_set_ActionRequest(Evt, Param->Act);\n\t\tUpnpActionComplete_set_ActionResult(Evt, actionResult);\n\t\tUpnpActionComplete_strcpy_CtrlUrl(Evt, Param->Url);\n\t\tParam->Fun(UPNP_CONTROL_ACTION_COMPLETE, Evt, Param->Cookie);\n\t\tfree(Param);\n\t\tUpnpActionComplete_delete(Evt);\n\t\tbreak;\n\t}\n\tcase STATUS: {\n\t\tUpnpStateVarComplete *Evt = UpnpStateVarComplete_new();\n\t\tDOMString currentVal = NULL;\n\t\tint errCode = SoapGetServiceVarStatus(\n\t\t\tParam->Url,\n\t\t\tParam->VarName,\n\t\t\t&currentVal);\n\t\tUpnpStateVarComplete_set_ErrCode(Evt, errCode);\n\t\tUpnpStateVarComplete_strcpy_CtrlUrl(Evt, Param->Url);\n\t\tUpnpStateVarComplete_strcpy_StateVarName(Evt, Param->VarName);\n\t\tUpnpStateVarComplete_set_CurrentVal(Evt, currentVal);\n\t\tParam->Fun(UPNP_CONTROL_GET_VAR_COMPLETE, Evt, Param->Cookie);\n\t\tfree(Param);\n\t\tUpnpStateVarComplete_delete(Evt);\n\t\tbreak;\n\t}\n#endif /* EXCLUDE_SOAP == 0 */\n\tdefault:\n\t\tbreak;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpThreadDistribution\\n\");\n}"
  },
  {
    "function_name": "UpnpGetIfInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3317-3701",
    "snippet": "int UpnpGetIfInfo(const char *IfName)\n{\n#ifdef WIN32\n\t/* ---------------------------------------------------- */\n\t/* WIN32 implementation will use the IpHlpAPI library. */\n\t/* ---------------------------------------------------- */\n\tPIP_ADAPTER_ADDRESSES adapts = NULL;\n\tPIP_ADAPTER_ADDRESSES adapts_item;\n\tPIP_ADAPTER_UNICAST_ADDRESS uni_addr;\n\tSOCKADDR *ip_addr;\n\tstruct in_addr v4_addr;\n\tstruct in6_addr v6_addr;\n\tULONG adapts_sz = 0;\n\tULONG ret;\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Get Adapters addresses required size. */\n\tret = GetAdaptersAddresses(AF_UNSPEC,\n\t\t\t\t   GAA_FLAG_SKIP_ANYCAST |\n\t\t\t\t   GAA_FLAG_SKIP_DNS_SERVER, NULL, adapts,\n\t\t\t\t   &adapts_sz);\n\tif (ret != ERROR_BUFFER_OVERFLOW) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"GetAdaptersAddresses failed to find list of adapters\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Allocate enough memory. */\n\tadapts = (PIP_ADAPTER_ADDRESSES) malloc(adapts_sz);\n\tif (adapts == NULL) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* Do the call that will actually return the info. */\n\tret = GetAdaptersAddresses(AF_UNSPEC,\n\t\t\t\t   GAA_FLAG_SKIP_ANYCAST |\n\t\t\t\t   GAA_FLAG_SKIP_DNS_SERVER, NULL, adapts,\n\t\t\t\t   &adapts_sz);\n\tif (ret != ERROR_SUCCESS) {\n\t\tfree(adapts);\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"GetAdaptersAddresses failed to find list of adapters\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\tadapts_item = adapts;\n\twhile (adapts_item != NULL) {\n\t\tif (adapts_item->Flags & IP_ADAPTER_NO_MULTICAST) {\n\t\t\tadapts_item = adapts_item->Next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n#ifdef UPNP_USE_MSVCPP\n\t\t\t/*\n\t\t\t * Partial fix for VC - friendly name is wchar string,\n\t\t\t * but currently gIF_NAME is char string. For now try\n\t\t\t * to convert it, which will work with many (but not\n\t\t\t * all) adapters. A full fix would require a lot of\n\t\t\t * big changes (gIF_NAME to wchar string?).\n\t\t\t */\n\t\t\twcstombs(gIF_NAME, adapts_item->FriendlyName,\n\t\t\t\tsizeof(gIF_NAME));\n#else\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, adapts_item->FriendlyName,\n\t\t\t\tsizeof(gIF_NAME) - 1);\n#endif\n\t\t\tifname_found = 1;\n\t\t} else {\n#ifdef UPNP_USE_MSVCPP\n\t\t\t/*\n\t\t\t * Partial fix for VC - friendly name is wchar string,\n\t\t\t * but currently gIF_NAME is char string. For now try\n\t\t\t * to convert it, which will work with many (but not\n\t\t\t * all) adapters. A full fix would require a lot of\n\t\t\t * big changes (gIF_NAME to wchar string?).\n\t\t\t */\n\t\t\tchar tmpIfName[LINE_SIZE] = { 0 };\n\t\t\twcstombs(tmpIfName, adapts_item->FriendlyName,\n\t\t\t\tsizeof(tmpIfName));\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, tmpIfName,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n#else\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, adapts_item->FriendlyName,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t}\n\t\t/* Loop thru this adapter's unicast IP addresses. */\n\t\tuni_addr = adapts_item->FirstUnicastAddress;\n\t\twhile (uni_addr) {\n\t\t\tip_addr = uni_addr->Address.lpSockaddr;\n\t\t\tswitch (ip_addr->sa_family) {\n\t\t\tcase AF_INET:\n\t\t\t\tmemcpy(&v4_addr,\n\t\t\t\t       &((struct sockaddr_in *)ip_addr)->\n\t\t\t\t       sin_addr, sizeof(v4_addr));\n\t\t\t\tvalid_addr_found = 1;\n\t\t\t\tbreak;\n\t\t\tcase AF_INET6:\n\t\t\t\t/* Only keep IPv6 link-local addresses. */\n\t\t\t\tif (IN6_IS_ADDR_LINKLOCAL\n\t\t\t\t    (&((struct sockaddr_in6 *)ip_addr)->\n\t\t\t\t     sin6_addr)) {\n\t\t\t\t\tmemcpy(&v6_addr,\n\t\t\t\t\t       &((struct sockaddr_in6 *)\n\t\t\t\t\t\t ip_addr)->sin6_addr,\n\t\t\t\t\t       sizeof(v6_addr));\n\t\t\t\t\tvalid_addr_found = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (valid_addr_found == 0) {\n\t\t\t\t\t/* Address is not IPv4 or IPv6 and no valid address has  */\n\t\t\t\t\t/* yet been found for this interface. Discard interface name. */\n\t\t\t\t\tifname_found = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Next address. */\n\t\t\tuni_addr = uni_addr->Next;\n\t\t}\n\t\tif (valid_addr_found == 1) {\n\t\t\tgIF_INDEX = adapts_item->IfIndex;\n\t\t\tbreak;\n\t\t}\n\t\t/* Next adapter. */\n\t\tadapts_item = adapts_item->Next;\n\t}\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\tinet_ntop(AF_INET, &v4_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\tinet_ntop(AF_INET6, &v6_addr, gIF_IPV6, sizeof(gIF_IPV6));\n#elif (defined(BSD) && BSD >= 199306) || defined(__FreeBSD_kernel__)\n\tstruct ifaddrs *ifap, *ifa;\n\tstruct in_addr v4_addr;\n\tstruct in6_addr v6_addr;\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\t/* Get system interface addresses. */\n\tif (getifaddrs(&ifap) != 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"getifaddrs failed to find list of addresses\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* cycle through available interfaces and their addresses. */\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t/* Skip LOOPBACK interfaces, DOWN interfaces and interfaces that  */\n\t\t/* don't support MULTICAST. */\n\t\tif ((ifa->ifa_flags & IFF_LOOPBACK)\n\t\t    || (!(ifa->ifa_flags & IFF_UP))\n\t\t    || (!(ifa->ifa_flags & IFF_MULTICAST))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, ifa->ifa_name, sizeof(gIF_NAME) - 1);\n\t\t\tifname_found = 1;\n\t\t} else {\n\t\t\tif (strncmp(gIF_NAME, ifa->ifa_name, sizeof(gIF_NAME))\n\t\t\t    != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* Keep interface addresses for later. */\n\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\tcase AF_INET:\n\t\t\tmemcpy(&v4_addr,\n\t\t\t       &((struct sockaddr_in *)(ifa->ifa_addr))->\n\t\t\t       sin_addr, sizeof(v4_addr));\n\t\t\tvalid_addr_found = 1;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t/* Only keep IPv6 link-local addresses. */\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL\n\t\t\t    (&((struct sockaddr_in6 *)(ifa->ifa_addr))->\n\t\t\t     sin6_addr)) {\n\t\t\t\tmemcpy(&v6_addr,\n\t\t\t\t       &((struct sockaddr_in6 *)(ifa->\n\t\t\t\t\t\t\t\t ifa_addr))->\n\t\t\t\t       sin6_addr, sizeof(v6_addr));\n\t\t\t\tvalid_addr_found = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (valid_addr_found == 0) {\n\t\t\t\t/* Address is not IPv4 or IPv6 and no valid address has  */\n\t\t\t\t/* yet been found for this interface. Discard interface name. */\n\t\t\t\tifname_found = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfreeifaddrs(ifap);\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\tinet_ntop(AF_INET, &v4_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\tinet_ntop(AF_INET6, &v6_addr, gIF_IPV6, sizeof(gIF_IPV6));\n\tgIF_INDEX = if_nametoindex(gIF_NAME);\n#else\n\tchar szBuffer[MAX_INTERFACES * sizeof(struct ifreq)];\n\tstruct ifconf ifConf;\n\tstruct ifreq ifReq;\n\tFILE *inet6_procfd;\n\tsize_t i;\n\tint LocalSock;\n\tstruct in6_addr v6_addr;\n\tunsigned if_idx;\n\tchar addr6[8][5];\n\tchar buf[INET6_ADDRSTRLEN];\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\t/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on.  */\n\tif ((LocalSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == INVALID_SOCKET) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t   \"Can't create addrlist socket\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Get the interface configuration information...  */\n\tifConf.ifc_len = (int)sizeof szBuffer;\n\tifConf.ifc_ifcu.ifcu_buf = (caddr_t) szBuffer;\n\n\tif (ioctl(LocalSock, SIOCGIFCONF, &ifConf) < 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t   \"DiscoverInterfaces: SIOCGIFCONF returned error\\n\");\n\t\tclose(LocalSock);\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Cycle through the list of interfaces looking for IP addresses.  */\n\tfor (i = (size_t)0; i < (size_t)ifConf.ifc_len;) {\n\t\tstruct ifreq *pifReq =\n\t\t    (struct ifreq *)((caddr_t) ifConf.ifc_req + i);\n\t\ti += sizeof *pifReq;\n\t\t/* See if this is the sort of interface we want to deal with. */\n\t\tmemset(ifReq.ifr_name, 0, sizeof(ifReq.ifr_name));\n\t\tstrncpy(ifReq.ifr_name, pifReq->ifr_name,\n\t\t\tsizeof(ifReq.ifr_name) - 1);\n\t\tif (ioctl(LocalSock, SIOCGIFFLAGS, &ifReq) < 0) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Can't get interface flags for %s:\\n\",\n\t\t\t\t   ifReq.ifr_name);\n\t\t}\n\t\t/* Skip LOOPBACK interfaces, DOWN interfaces and interfaces that  */\n\t\t/* don't support MULTICAST. */\n\t\tif ((ifReq.ifr_flags & IFF_LOOPBACK)\n\t\t    || (!(ifReq.ifr_flags & IFF_UP))\n\t\t    || (!(ifReq.ifr_flags & IFF_MULTICAST))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, pifReq->ifr_name, sizeof(gIF_NAME) - 1);\n\t\t\tifname_found = 1;\n\t\t} else {\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, pifReq->ifr_name,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* Check address family. */\n\t\tif (pifReq->ifr_addr.sa_family == AF_INET) {\n\t\t\t/* Copy interface name, IPv4 address and interface index. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, pifReq->ifr_name, sizeof(gIF_NAME) - 1);\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t  &((struct sockaddr_in *)&pifReq->ifr_addr)->\n\t\t\t\t  sin_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\t\t\tgIF_INDEX = if_nametoindex(gIF_NAME);\n\t\t\tvalid_addr_found = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Address is not IPv4 */\n\t\t\tifname_found = 0;\n\t\t}\n\t}\n\tclose(LocalSock);\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\t/* Try to get the IPv6 address for the same interface  */\n\t/* from \"/proc/net/if_inet6\", if possible. */\n\tinet6_procfd = fopen(\"/proc/net/if_inet6\", \"r\");\n\tif (inet6_procfd) {\n\t\twhile (fscanf(inet6_procfd,\n\t\t\t      \"%4s%4s%4s%4s%4s%4s%4s%4s %02x %*02x %*02x %*02x %*20s\\n\",\n\t\t\t      addr6[0], addr6[1], addr6[2], addr6[3],\n\t\t\t      addr6[4], addr6[5], addr6[6], addr6[7],\n\t\t\t      &if_idx) != EOF) {\n\t\t\t/* Get same interface as IPv4 address retrieved. */\n\t\t\tif (gIF_INDEX == if_idx) {\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"%s:%s:%s:%s:%s:%s:%s:%s\", addr6[0],\n\t\t\t\t\t addr6[1], addr6[2], addr6[3], addr6[4],\n\t\t\t\t\t addr6[5], addr6[6], addr6[7]);\n\t\t\t\t/* Validate formed address and check for link-local. */\n\t\t\t\tif (inet_pton(AF_INET6, buf, &v6_addr) > 0) {\n\t\t\t\t\tif (IN6_IS_ADDR_ULA(&v6_addr)) {\n\t\t\t\t\t\t/* Got valid IPv6 ula. */\n\t\t\t\t\t\tmemset(gIF_IPV6_ULA_GUA, 0,\n\t\t\t\t\t\t\tsizeof(gIF_IPV6_ULA_GUA));\n\t\t\t\t\t\tstrncpy(gIF_IPV6_ULA_GUA, buf,\n\t\t\t\t\t\t\tsizeof\n\t\t\t\t\t\t\t(gIF_IPV6_ULA_GUA) - 1);\n\t\t\t\t\t} else if (IN6_IS_ADDR_GLOBAL(&v6_addr)\n\t\t\t\t\t\t   && strlen(gIF_IPV6_ULA_GUA)\n\t\t\t\t\t\t   == (size_t)0) {\n\t\t\t\t\t\t/* got a GUA, should store it while no ULA is found */\n\t\t\t\t\t\tmemset(gIF_IPV6_ULA_GUA, 0,\n                                                        sizeof(gIF_IPV6_ULA_GUA));\n\t\t\t\t\t\tstrncpy(gIF_IPV6_ULA_GUA, buf,\n\t\t\t\t\t\t\tsizeof\n\t\t\t\t\t\t\t(gIF_IPV6_ULA_GUA) - 1);\n\t\t\t\t\t} else\n\t\t\t\t\t    if (IN6_IS_ADDR_LINKLOCAL(&v6_addr)\n\t\t\t\t\t\t&& strlen(gIF_IPV6) == (size_t)0) {\n\t\t\t\t\t\t/* got a Link local IPv6 address. */\n\t\t\t\t\t\tmemset(gIF_IPV6, 0,\n                                                        sizeof(gIF_IPV6));\n\t\t\t\t\t\tstrncpy(gIF_IPV6, buf,\n\t\t\t\t\t\t\tsizeof(gIF_IPV6) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfclose(inet6_procfd);\n\t}\n#endif\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Interface name=%s, index=%d, v4=%s, v6=%s, ULA or GUA v6=%s\\n\",\n\t\t   gIF_NAME, gIF_INDEX, gIF_IPV4, gIF_IPV6, gIF_IPV6_ULA_GUA);\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char gIF_NAME[LINE_SIZE] = { '\\0' };",
      "char gIF_IPV4[INET_ADDRSTRLEN] = { '\\0' };",
      "char gIF_IPV6[INET6_ADDRSTRLEN] = { '\\0' };",
      "char gIF_IPV6_ULA_GUA[INET6_ADDRSTRLEN] = { '\\0' };",
      "unsigned gIF_INDEX = (unsigned)-1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Interface name=%s, index=%d, v4=%s, v6=%s, ULA or GUA v6=%s\\n\"",
            "gIF_NAME",
            "gIF_INDEX",
            "gIF_IPV4",
            "gIF_IPV6",
            "gIF_IPV6_ULA_GUA"
          ],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "inet6_procfd"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "gIF_IPV6",
            "buf",
            "sizeof(gIF_IPV6) - 1"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "gIF_IPV6",
            "0",
            "sizeof(gIF_IPV6)"
          ],
          "line": 3685
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gIF_IPV6"
          ],
          "line": 3683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_LINKLOCAL",
          "args": [
            "&v6_addr"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "gIF_IPV6_ULA_GUA",
            "buf",
            "sizeof\n\t\t\t\t\t\t\t(gIF_IPV6_ULA_GUA) - 1"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gIF_IPV6_ULA_GUA"
          ],
          "line": 3673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_GLOBAL",
          "args": [
            "&v6_addr"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "gIF_IPV6_ULA_GUA",
            "buf",
            "sizeof\n\t\t\t\t\t\t\t(gIF_IPV6_ULA_GUA) - 1"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_ULA",
          "args": [
            "&v6_addr"
          ],
          "line": 3665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET6",
            "buf",
            "&v6_addr"
          ],
          "line": 3664
        },
        "resolved": true,
        "details": {
          "function_name": "inet_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "307-321",
          "snippet": "int inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nint inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%s:%s:%s:%s:%s:%s:%s:%s\"",
            "addr6[0]",
            "addr6[1]",
            "addr6[2]",
            "addr6[3]",
            "addr6[4]",
            "addr6[5]",
            "addr6[6]",
            "addr6[7]"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "inet6_procfd",
            "\"%4s%4s%4s%4s%4s%4s%4s%4s %02x %*02x %*02x %*02x %*20s\\n\"",
            "addr6[0]",
            "addr6[1]",
            "addr6[2]",
            "addr6[3]",
            "addr6[4]",
            "addr6[5]",
            "addr6[6]",
            "addr6[7]",
            "&if_idx"
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/net/if_inet6\"",
            "\"r\""
          ],
          "line": 3650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "LocalSock"
          ],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "sock_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/sock.h",
          "lines": "79-89",
          "snippet": "static UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */",
            "#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */",
            "#include \"upnpconfig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */\n#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */\n#include \"upnpconfig.h\"\n\nstatic UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "gIF_NAME"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "AF_INET",
            "&((struct sockaddr_in *)&pifReq->ifr_addr)->\n\t\t\t\t  sin_addr",
            "gIF_IPV4",
            "sizeof(gIF_IPV4)"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "291-305",
          "snippet": "const char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nconst char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "gIF_NAME",
            "pifReq->ifr_name",
            "sizeof(gIF_NAME) - 1"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "gIF_NAME",
            "pifReq->ifr_name",
            "sizeof(gIF_NAME)"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "gIF_NAME",
            "pifReq->ifr_name",
            "sizeof(gIF_NAME) - 1"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "LocalSock",
            "SIOCGIFFLAGS",
            "&ifReq"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifReq.ifr_name",
            "pifReq->ifr_name",
            "sizeof(ifReq.ifr_name) - 1"
          ],
          "line": 3597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "LocalSock",
            "SIOCGIFCONF",
            "&ifConf"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "IPPROTO_UDP"
          ],
          "line": 3575
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "gIF_NAME",
            "IfName",
            "sizeof(gIF_NAME) - 1"
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "IfName"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "gIF_NAME"
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "ifap"
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&v6_addr",
            "&((struct sockaddr_in6 *)(ifa->\n\t\t\t\t\t\t\t\t ifa_addr))->\n\t\t\t\t       sin6_addr",
            "sizeof(v6_addr)"
          ],
          "line": 3525
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_LINKLOCAL",
          "args": [
            "&((struct sockaddr_in6 *)(ifa->ifa_addr))->\n\t\t\t     sin6_addr"
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "gIF_NAME",
            "ifa->ifa_name",
            "sizeof(gIF_NAME)"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "gIF_NAME",
            "ifa->ifa_name",
            "sizeof(gIF_NAME) - 1"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&ifap"
          ],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "gIF_NAME",
            "IfName",
            "sizeof(gIF_NAME) - 1"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "IfName"
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_LINKLOCAL",
          "args": [
            "&((struct sockaddr_in6 *)ip_addr)->\n\t\t\t\t     sin6_addr"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "gIF_NAME",
            "adapts_item->FriendlyName",
            "sizeof(gIF_NAME)"
          ],
          "line": 3412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "gIF_NAME",
            "tmpIfName",
            "sizeof(gIF_NAME)"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcstombs",
          "args": [
            "tmpIfName",
            "adapts_item->FriendlyName",
            "sizeof(tmpIfName)"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "gIF_NAME",
            "adapts_item->FriendlyName",
            "sizeof(gIF_NAME) - 1"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcstombs",
          "args": [
            "gIF_NAME",
            "adapts_item->FriendlyName",
            "sizeof(gIF_NAME)"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "gIF_NAME",
            "IfName",
            "sizeof(gIF_NAME) - 1"
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "IfName"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "adapts"
          ],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAdaptersAddresses",
          "args": [
            "AF_UNSPEC",
            "GAA_FLAG_SKIP_ANYCAST |\n\t\t\t\t   GAA_FLAG_SKIP_DNS_SERVER",
            "NULL",
            "adapts",
            "&adapts_sz"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "adapts_sz"
          ],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAdaptersAddresses",
          "args": [
            "AF_UNSPEC",
            "GAA_FLAG_SKIP_ANYCAST |\n\t\t\t\t   GAA_FLAG_SKIP_DNS_SERVER",
            "NULL",
            "adapts",
            "&adapts_sz"
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nchar gIF_NAME[LINE_SIZE] = { '\\0' };\nchar gIF_IPV4[INET_ADDRSTRLEN] = { '\\0' };\nchar gIF_IPV6[INET6_ADDRSTRLEN] = { '\\0' };\nchar gIF_IPV6_ULA_GUA[INET6_ADDRSTRLEN] = { '\\0' };\nunsigned gIF_INDEX = (unsigned)-1;\n\nint UpnpGetIfInfo(const char *IfName)\n{\n#ifdef WIN32\n\t/* ---------------------------------------------------- */\n\t/* WIN32 implementation will use the IpHlpAPI library. */\n\t/* ---------------------------------------------------- */\n\tPIP_ADAPTER_ADDRESSES adapts = NULL;\n\tPIP_ADAPTER_ADDRESSES adapts_item;\n\tPIP_ADAPTER_UNICAST_ADDRESS uni_addr;\n\tSOCKADDR *ip_addr;\n\tstruct in_addr v4_addr;\n\tstruct in6_addr v6_addr;\n\tULONG adapts_sz = 0;\n\tULONG ret;\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Get Adapters addresses required size. */\n\tret = GetAdaptersAddresses(AF_UNSPEC,\n\t\t\t\t   GAA_FLAG_SKIP_ANYCAST |\n\t\t\t\t   GAA_FLAG_SKIP_DNS_SERVER, NULL, adapts,\n\t\t\t\t   &adapts_sz);\n\tif (ret != ERROR_BUFFER_OVERFLOW) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"GetAdaptersAddresses failed to find list of adapters\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Allocate enough memory. */\n\tadapts = (PIP_ADAPTER_ADDRESSES) malloc(adapts_sz);\n\tif (adapts == NULL) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* Do the call that will actually return the info. */\n\tret = GetAdaptersAddresses(AF_UNSPEC,\n\t\t\t\t   GAA_FLAG_SKIP_ANYCAST |\n\t\t\t\t   GAA_FLAG_SKIP_DNS_SERVER, NULL, adapts,\n\t\t\t\t   &adapts_sz);\n\tif (ret != ERROR_SUCCESS) {\n\t\tfree(adapts);\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"GetAdaptersAddresses failed to find list of adapters\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\tadapts_item = adapts;\n\twhile (adapts_item != NULL) {\n\t\tif (adapts_item->Flags & IP_ADAPTER_NO_MULTICAST) {\n\t\t\tadapts_item = adapts_item->Next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n#ifdef UPNP_USE_MSVCPP\n\t\t\t/*\n\t\t\t * Partial fix for VC - friendly name is wchar string,\n\t\t\t * but currently gIF_NAME is char string. For now try\n\t\t\t * to convert it, which will work with many (but not\n\t\t\t * all) adapters. A full fix would require a lot of\n\t\t\t * big changes (gIF_NAME to wchar string?).\n\t\t\t */\n\t\t\twcstombs(gIF_NAME, adapts_item->FriendlyName,\n\t\t\t\tsizeof(gIF_NAME));\n#else\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, adapts_item->FriendlyName,\n\t\t\t\tsizeof(gIF_NAME) - 1);\n#endif\n\t\t\tifname_found = 1;\n\t\t} else {\n#ifdef UPNP_USE_MSVCPP\n\t\t\t/*\n\t\t\t * Partial fix for VC - friendly name is wchar string,\n\t\t\t * but currently gIF_NAME is char string. For now try\n\t\t\t * to convert it, which will work with many (but not\n\t\t\t * all) adapters. A full fix would require a lot of\n\t\t\t * big changes (gIF_NAME to wchar string?).\n\t\t\t */\n\t\t\tchar tmpIfName[LINE_SIZE] = { 0 };\n\t\t\twcstombs(tmpIfName, adapts_item->FriendlyName,\n\t\t\t\tsizeof(tmpIfName));\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, tmpIfName,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n#else\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, adapts_item->FriendlyName,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t}\n\t\t/* Loop thru this adapter's unicast IP addresses. */\n\t\tuni_addr = adapts_item->FirstUnicastAddress;\n\t\twhile (uni_addr) {\n\t\t\tip_addr = uni_addr->Address.lpSockaddr;\n\t\t\tswitch (ip_addr->sa_family) {\n\t\t\tcase AF_INET:\n\t\t\t\tmemcpy(&v4_addr,\n\t\t\t\t       &((struct sockaddr_in *)ip_addr)->\n\t\t\t\t       sin_addr, sizeof(v4_addr));\n\t\t\t\tvalid_addr_found = 1;\n\t\t\t\tbreak;\n\t\t\tcase AF_INET6:\n\t\t\t\t/* Only keep IPv6 link-local addresses. */\n\t\t\t\tif (IN6_IS_ADDR_LINKLOCAL\n\t\t\t\t    (&((struct sockaddr_in6 *)ip_addr)->\n\t\t\t\t     sin6_addr)) {\n\t\t\t\t\tmemcpy(&v6_addr,\n\t\t\t\t\t       &((struct sockaddr_in6 *)\n\t\t\t\t\t\t ip_addr)->sin6_addr,\n\t\t\t\t\t       sizeof(v6_addr));\n\t\t\t\t\tvalid_addr_found = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (valid_addr_found == 0) {\n\t\t\t\t\t/* Address is not IPv4 or IPv6 and no valid address has  */\n\t\t\t\t\t/* yet been found for this interface. Discard interface name. */\n\t\t\t\t\tifname_found = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Next address. */\n\t\t\tuni_addr = uni_addr->Next;\n\t\t}\n\t\tif (valid_addr_found == 1) {\n\t\t\tgIF_INDEX = adapts_item->IfIndex;\n\t\t\tbreak;\n\t\t}\n\t\t/* Next adapter. */\n\t\tadapts_item = adapts_item->Next;\n\t}\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\tinet_ntop(AF_INET, &v4_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\tinet_ntop(AF_INET6, &v6_addr, gIF_IPV6, sizeof(gIF_IPV6));\n#elif (defined(BSD) && BSD >= 199306) || defined(__FreeBSD_kernel__)\n\tstruct ifaddrs *ifap, *ifa;\n\tstruct in_addr v4_addr;\n\tstruct in6_addr v6_addr;\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\t/* Get system interface addresses. */\n\tif (getifaddrs(&ifap) != 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"getifaddrs failed to find list of addresses\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* cycle through available interfaces and their addresses. */\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t/* Skip LOOPBACK interfaces, DOWN interfaces and interfaces that  */\n\t\t/* don't support MULTICAST. */\n\t\tif ((ifa->ifa_flags & IFF_LOOPBACK)\n\t\t    || (!(ifa->ifa_flags & IFF_UP))\n\t\t    || (!(ifa->ifa_flags & IFF_MULTICAST))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, ifa->ifa_name, sizeof(gIF_NAME) - 1);\n\t\t\tifname_found = 1;\n\t\t} else {\n\t\t\tif (strncmp(gIF_NAME, ifa->ifa_name, sizeof(gIF_NAME))\n\t\t\t    != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* Keep interface addresses for later. */\n\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\tcase AF_INET:\n\t\t\tmemcpy(&v4_addr,\n\t\t\t       &((struct sockaddr_in *)(ifa->ifa_addr))->\n\t\t\t       sin_addr, sizeof(v4_addr));\n\t\t\tvalid_addr_found = 1;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t/* Only keep IPv6 link-local addresses. */\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL\n\t\t\t    (&((struct sockaddr_in6 *)(ifa->ifa_addr))->\n\t\t\t     sin6_addr)) {\n\t\t\t\tmemcpy(&v6_addr,\n\t\t\t\t       &((struct sockaddr_in6 *)(ifa->\n\t\t\t\t\t\t\t\t ifa_addr))->\n\t\t\t\t       sin6_addr, sizeof(v6_addr));\n\t\t\t\tvalid_addr_found = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (valid_addr_found == 0) {\n\t\t\t\t/* Address is not IPv4 or IPv6 and no valid address has  */\n\t\t\t\t/* yet been found for this interface. Discard interface name. */\n\t\t\t\tifname_found = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfreeifaddrs(ifap);\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\tinet_ntop(AF_INET, &v4_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\tinet_ntop(AF_INET6, &v6_addr, gIF_IPV6, sizeof(gIF_IPV6));\n\tgIF_INDEX = if_nametoindex(gIF_NAME);\n#else\n\tchar szBuffer[MAX_INTERFACES * sizeof(struct ifreq)];\n\tstruct ifconf ifConf;\n\tstruct ifreq ifReq;\n\tFILE *inet6_procfd;\n\tsize_t i;\n\tint LocalSock;\n\tstruct in6_addr v6_addr;\n\tunsigned if_idx;\n\tchar addr6[8][5];\n\tchar buf[INET6_ADDRSTRLEN];\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\t/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on.  */\n\tif ((LocalSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == INVALID_SOCKET) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t   \"Can't create addrlist socket\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Get the interface configuration information...  */\n\tifConf.ifc_len = (int)sizeof szBuffer;\n\tifConf.ifc_ifcu.ifcu_buf = (caddr_t) szBuffer;\n\n\tif (ioctl(LocalSock, SIOCGIFCONF, &ifConf) < 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t   \"DiscoverInterfaces: SIOCGIFCONF returned error\\n\");\n\t\tclose(LocalSock);\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Cycle through the list of interfaces looking for IP addresses.  */\n\tfor (i = (size_t)0; i < (size_t)ifConf.ifc_len;) {\n\t\tstruct ifreq *pifReq =\n\t\t    (struct ifreq *)((caddr_t) ifConf.ifc_req + i);\n\t\ti += sizeof *pifReq;\n\t\t/* See if this is the sort of interface we want to deal with. */\n\t\tmemset(ifReq.ifr_name, 0, sizeof(ifReq.ifr_name));\n\t\tstrncpy(ifReq.ifr_name, pifReq->ifr_name,\n\t\t\tsizeof(ifReq.ifr_name) - 1);\n\t\tif (ioctl(LocalSock, SIOCGIFFLAGS, &ifReq) < 0) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Can't get interface flags for %s:\\n\",\n\t\t\t\t   ifReq.ifr_name);\n\t\t}\n\t\t/* Skip LOOPBACK interfaces, DOWN interfaces and interfaces that  */\n\t\t/* don't support MULTICAST. */\n\t\tif ((ifReq.ifr_flags & IFF_LOOPBACK)\n\t\t    || (!(ifReq.ifr_flags & IFF_UP))\n\t\t    || (!(ifReq.ifr_flags & IFF_MULTICAST))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, pifReq->ifr_name, sizeof(gIF_NAME) - 1);\n\t\t\tifname_found = 1;\n\t\t} else {\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, pifReq->ifr_name,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* Check address family. */\n\t\tif (pifReq->ifr_addr.sa_family == AF_INET) {\n\t\t\t/* Copy interface name, IPv4 address and interface index. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, pifReq->ifr_name, sizeof(gIF_NAME) - 1);\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t  &((struct sockaddr_in *)&pifReq->ifr_addr)->\n\t\t\t\t  sin_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\t\t\tgIF_INDEX = if_nametoindex(gIF_NAME);\n\t\t\tvalid_addr_found = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Address is not IPv4 */\n\t\t\tifname_found = 0;\n\t\t}\n\t}\n\tclose(LocalSock);\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\t/* Try to get the IPv6 address for the same interface  */\n\t/* from \"/proc/net/if_inet6\", if possible. */\n\tinet6_procfd = fopen(\"/proc/net/if_inet6\", \"r\");\n\tif (inet6_procfd) {\n\t\twhile (fscanf(inet6_procfd,\n\t\t\t      \"%4s%4s%4s%4s%4s%4s%4s%4s %02x %*02x %*02x %*02x %*20s\\n\",\n\t\t\t      addr6[0], addr6[1], addr6[2], addr6[3],\n\t\t\t      addr6[4], addr6[5], addr6[6], addr6[7],\n\t\t\t      &if_idx) != EOF) {\n\t\t\t/* Get same interface as IPv4 address retrieved. */\n\t\t\tif (gIF_INDEX == if_idx) {\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"%s:%s:%s:%s:%s:%s:%s:%s\", addr6[0],\n\t\t\t\t\t addr6[1], addr6[2], addr6[3], addr6[4],\n\t\t\t\t\t addr6[5], addr6[6], addr6[7]);\n\t\t\t\t/* Validate formed address and check for link-local. */\n\t\t\t\tif (inet_pton(AF_INET6, buf, &v6_addr) > 0) {\n\t\t\t\t\tif (IN6_IS_ADDR_ULA(&v6_addr)) {\n\t\t\t\t\t\t/* Got valid IPv6 ula. */\n\t\t\t\t\t\tmemset(gIF_IPV6_ULA_GUA, 0,\n\t\t\t\t\t\t\tsizeof(gIF_IPV6_ULA_GUA));\n\t\t\t\t\t\tstrncpy(gIF_IPV6_ULA_GUA, buf,\n\t\t\t\t\t\t\tsizeof\n\t\t\t\t\t\t\t(gIF_IPV6_ULA_GUA) - 1);\n\t\t\t\t\t} else if (IN6_IS_ADDR_GLOBAL(&v6_addr)\n\t\t\t\t\t\t   && strlen(gIF_IPV6_ULA_GUA)\n\t\t\t\t\t\t   == (size_t)0) {\n\t\t\t\t\t\t/* got a GUA, should store it while no ULA is found */\n\t\t\t\t\t\tmemset(gIF_IPV6_ULA_GUA, 0,\n                                                        sizeof(gIF_IPV6_ULA_GUA));\n\t\t\t\t\t\tstrncpy(gIF_IPV6_ULA_GUA, buf,\n\t\t\t\t\t\t\tsizeof\n\t\t\t\t\t\t\t(gIF_IPV6_ULA_GUA) - 1);\n\t\t\t\t\t} else\n\t\t\t\t\t    if (IN6_IS_ADDR_LINKLOCAL(&v6_addr)\n\t\t\t\t\t\t&& strlen(gIF_IPV6) == (size_t)0) {\n\t\t\t\t\t\t/* got a Link local IPv6 address. */\n\t\t\t\t\t\tmemset(gIF_IPV6, 0,\n                                                        sizeof(gIF_IPV6));\n\t\t\t\t\t\tstrncpy(gIF_IPV6, buf,\n\t\t\t\t\t\t\tsizeof(gIF_IPV6) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfclose(inet6_procfd);\n\t}\n#endif\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Interface name=%s, index=%d, v4=%s, v6=%s, ULA or GUA v6=%s\\n\",\n\t\t   gIF_NAME, gIF_INDEX, gIF_IPV4, gIF_IPV6, gIF_IPV6_ULA_GUA);\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpDownloadXmlDoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3256-3314",
    "snippet": "int UpnpDownloadXmlDoc(const char *url, IXML_Document **xmlDoc)\n{\n\tint ret_code;\n\tchar *xml_buf;\n\tchar content_type[LINE_SIZE];\n\n\tif (url == NULL || xmlDoc == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tret_code = UpnpDownloadUrlItem(url, &xml_buf, content_type);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Error downloading document, retCode: %d\\n\", ret_code);\n\t\treturn ret_code;\n\t}\n\n\tif (strncasecmp(content_type, \"text/xml\", strlen(\"text/xml\"))) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__, \"Not text/xml\\n\");\n\t\t/* Linksys WRT54G router returns\n\t\t * \"CONTENT-TYPE: application/octet-stream\".\n\t\t * Let's be nice to Linksys and try to parse document anyway.\n\t\t * If the data sended is not a xml file, ixmlParseBufferEx\n\t\t * will fail and the function will return UPNP_E_INVALID_DESC too. */\n#if 0\n\t\tfree(xml_buf);\n\t\treturn UPNP_E_INVALID_DESC;\n#endif\n\t}\n\n\tret_code = ixmlParseBufferEx(xml_buf, xmlDoc);\n\tfree(xml_buf);\n\tif (ret_code != IXML_SUCCESS) {\n\t\tif (ret_code == IXML_INSUFFICIENT_MEMORY) {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Out of memory, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t} else {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Invalid Description, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t}\n\t} else {\n#ifdef DEBUG\n\t\txml_buf = ixmlPrintNode((IXML_Node *)*xmlDoc);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Printing the Parsed xml document \\n %s\\n\", xml_buf);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"****************** END OF Parsed XML Doc *****************\\n\");\n\t\tixmlFreeDOMString(xml_buf);\n#endif\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Exiting UpnpDownloadXmlDoc\\n\");\n\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpDownloadXmlDoc\\n\""
          ],
          "line": 3309
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "xml_buf"
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "(IXML_Node *)*xmlDoc"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "xml_buf"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "xml_buf",
            "xmlDoc"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "content_type",
            "\"text/xml\"",
            "strlen(\"text/xml\")"
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"text/xml\""
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDownloadUrlItem",
          "args": [
            "url",
            "&xml_buf",
            "content_type"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpDownloadUrlItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3239-3253",
          "snippet": "int UpnpDownloadUrlItem(const char *url, char **outBuf, char *contentType)\n{\n\tint ret_code;\n\tsize_t dummy;\n\n\tif (url == NULL || outBuf == NULL || contentType == NULL)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tret_code = http_Download(url, HTTP_DEFAULT_TIMEOUT, outBuf, &dummy,\n\t\t\t\t contentType);\n\tif (ret_code > 0)\n\t\t/* error reply was received */\n\t\tret_code = UPNP_E_INVALID_URL;\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpDownloadUrlItem(const char *url, char **outBuf, char *contentType)\n{\n\tint ret_code;\n\tsize_t dummy;\n\n\tif (url == NULL || outBuf == NULL || contentType == NULL)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tret_code = http_Download(url, HTTP_DEFAULT_TIMEOUT, outBuf, &dummy,\n\t\t\t\t contentType);\n\tif (ret_code > 0)\n\t\t/* error reply was received */\n\t\tret_code = UPNP_E_INVALID_URL;\n\n\treturn ret_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpDownloadXmlDoc(const char *url, IXML_Document **xmlDoc)\n{\n\tint ret_code;\n\tchar *xml_buf;\n\tchar content_type[LINE_SIZE];\n\n\tif (url == NULL || xmlDoc == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tret_code = UpnpDownloadUrlItem(url, &xml_buf, content_type);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Error downloading document, retCode: %d\\n\", ret_code);\n\t\treturn ret_code;\n\t}\n\n\tif (strncasecmp(content_type, \"text/xml\", strlen(\"text/xml\"))) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__, \"Not text/xml\\n\");\n\t\t/* Linksys WRT54G router returns\n\t\t * \"CONTENT-TYPE: application/octet-stream\".\n\t\t * Let's be nice to Linksys and try to parse document anyway.\n\t\t * If the data sended is not a xml file, ixmlParseBufferEx\n\t\t * will fail and the function will return UPNP_E_INVALID_DESC too. */\n#if 0\n\t\tfree(xml_buf);\n\t\treturn UPNP_E_INVALID_DESC;\n#endif\n\t}\n\n\tret_code = ixmlParseBufferEx(xml_buf, xmlDoc);\n\tfree(xml_buf);\n\tif (ret_code != IXML_SUCCESS) {\n\t\tif (ret_code == IXML_INSUFFICIENT_MEMORY) {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Out of memory, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t} else {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Invalid Description, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t}\n\t} else {\n#ifdef DEBUG\n\t\txml_buf = ixmlPrintNode((IXML_Node *)*xmlDoc);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Printing the Parsed xml document \\n %s\\n\", xml_buf);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"****************** END OF Parsed XML Doc *****************\\n\");\n\t\tixmlFreeDOMString(xml_buf);\n#endif\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Exiting UpnpDownloadXmlDoc\\n\");\n\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}"
  },
  {
    "function_name": "UpnpDownloadUrlItem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3239-3253",
    "snippet": "int UpnpDownloadUrlItem(const char *url, char **outBuf, char *contentType)\n{\n\tint ret_code;\n\tsize_t dummy;\n\n\tif (url == NULL || outBuf == NULL || contentType == NULL)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tret_code = http_Download(url, HTTP_DEFAULT_TIMEOUT, outBuf, &dummy,\n\t\t\t\t contentType);\n\tif (ret_code > 0)\n\t\t/* error reply was received */\n\t\tret_code = UPNP_E_INVALID_URL;\n\n\treturn ret_code;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_Download",
          "args": [
            "url",
            "HTTP_DEFAULT_TIMEOUT",
            "outBuf",
            "&dummy",
            "contentType"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "http_Download",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "712-829",
          "snippet": "int http_Download( IN const char *url_str,\n               IN int timeout_secs,\n               OUT char **document,\n               OUT size_t *doc_length,\n               OUT char *content_type )\n{\n\tint ret_code;\n\turi_type url;\n\tchar *msg_start;\n\tchar *entity_start;\n\tchar *hoststr;\n\tchar *temp;\n\thttp_parser_t response;\n\tsize_t msg_length;\n\tsize_t hostlen;\n\tmemptr ctype;\n\tsize_t copy_len;\n\tmembuffer request;\n\tchar *urlPath = alloca(strlen(url_str) + (size_t)1);\n\n\t/*ret_code = parse_uri( (char*)url_str, strlen(url_str), &url ); */\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"DOWNLOAD URL : %s\\n\", url_str);\n\tret_code = http_FixStrUrl((char *)url_str, strlen(url_str), &url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* make msg */\n\tmembuffer_init(&request);\n\tmemset(urlPath, 0, strlen(url_str) + (size_t)1);\n\tstrncpy(urlPath, url_str, strlen(url_str));\n\thoststr = strstr(urlPath, \"//\");\n\tif (hoststr == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\thoststr += 2;\n\ttemp = strchr(hoststr, '/');\n\tif (temp) {\n\t\t*temp = '\\0';\n\t\thostlen = strlen(hoststr);\n\t\t*temp = '/';\n\t} else {\n\t\thostlen = strlen(hoststr);\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\", hoststr, hostlen);\n\tret_code = http_MakeMessage(&request, 1, 1,\n\t\t\t\t    \"Q\" \"s\" \"bcDCUc\",\n\t\t\t\t    HTTPMETHOD_GET, url.pathquery.buff,\n\t\t\t\t    url.pathquery.size, \"HOST: \", hoststr,\n\t\t\t\t    hostlen);\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\tmembuffer_destroy(&request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\", request.buf);\n\t/* get doc msg */\n\tret_code =\n\t    http_RequestAndResponse(&url, request.buf, request.length,\n\t\t\t\t    HTTPMETHOD_GET, timeout_secs, &response);\n\n\tif (ret_code != 0) {\n\t\thttpmsg_destroy(&response.msg);\n\t\tmembuffer_destroy(&request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__, \"Response\\n\");\n\tprint_http_headers(&response.msg);\n\t/* optional content-type */\n\tif (content_type) {\n\t\tif (httpmsg_find_hdr(&response.msg, HDR_CONTENT_TYPE, &ctype) ==\n\t\t    NULL) {\n\t\t\t*content_type = '\\0';\t/* no content-type */\n\t\t} else {\n\t\t\t/* safety */\n\t\t\tcopy_len = ctype.length < LINE_SIZE - (size_t)1 ?\n\t\t\t    ctype.length : LINE_SIZE - (size_t)1;\n\n\t\t\tmemcpy(content_type, ctype.buf, copy_len);\n\t\t\tcontent_type[copy_len] = '\\0';\n\t\t}\n\t}\n\t/* extract doc from msg */\n\tif ((*doc_length = response.msg.entity.length) == (size_t)0) {\n\t\t/* 0-length msg */\n\t\t*document = NULL;\n\t} else if (response.msg.status_code == HTTP_OK) {\n\t\t/*LEAK_FIX_MK */\n\t\t/* copy entity */\n\t\tentity_start = response.msg.entity.buf;\t/* what we want */\n\t\tmsg_length = response.msg.msg.length;\t/* save for posterity    */\n\t\tmsg_start = membuffer_detach(&response.msg.msg);\t/* whole msg */\n\t\t/* move entity to the start; copy null-terminator too */\n\t\tmemmove(msg_start, entity_start, *doc_length + (size_t)1);\n\t\t/* save mem for body only */\n\t\t*document = realloc(msg_start, *doc_length + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/* *document = Realloc( msg_start,msg_length, *doc_length + 1 ); LEAK_FIX_MK */\n\t\t/* shrink can't fail */\n\t\tassert(msg_length > *doc_length);\n\t\tassert(*document != NULL);\n\t\tif (msg_length <= *doc_length || *document == NULL)\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"msg_length(%\" PRIzu \") <= *doc_length(%\"\n\t\t\t\tPRIzu \") or document is NULL\",\n\t\t\t\tmsg_length, *doc_length);\n\t}\n\tif (response.msg.status_code == HTTP_OK) {\n\t\tret_code = 0;\t/* success */\n\t} else {\n\t\t/* server sent error msg (not requested doc) */\n\t\tret_code = response.msg.status_code;\n\t}\n\thttpmsg_destroy(&response.msg);\n\tmembuffer_destroy(&request);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_Download( IN const char *url_str,\n               IN int timeout_secs,\n               OUT char **document,\n               OUT size_t *doc_length,\n               OUT char *content_type )\n{\n\tint ret_code;\n\turi_type url;\n\tchar *msg_start;\n\tchar *entity_start;\n\tchar *hoststr;\n\tchar *temp;\n\thttp_parser_t response;\n\tsize_t msg_length;\n\tsize_t hostlen;\n\tmemptr ctype;\n\tsize_t copy_len;\n\tmembuffer request;\n\tchar *urlPath = alloca(strlen(url_str) + (size_t)1);\n\n\t/*ret_code = parse_uri( (char*)url_str, strlen(url_str), &url ); */\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"DOWNLOAD URL : %s\\n\", url_str);\n\tret_code = http_FixStrUrl((char *)url_str, strlen(url_str), &url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* make msg */\n\tmembuffer_init(&request);\n\tmemset(urlPath, 0, strlen(url_str) + (size_t)1);\n\tstrncpy(urlPath, url_str, strlen(url_str));\n\thoststr = strstr(urlPath, \"//\");\n\tif (hoststr == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\thoststr += 2;\n\ttemp = strchr(hoststr, '/');\n\tif (temp) {\n\t\t*temp = '\\0';\n\t\thostlen = strlen(hoststr);\n\t\t*temp = '/';\n\t} else {\n\t\thostlen = strlen(hoststr);\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\", hoststr, hostlen);\n\tret_code = http_MakeMessage(&request, 1, 1,\n\t\t\t\t    \"Q\" \"s\" \"bcDCUc\",\n\t\t\t\t    HTTPMETHOD_GET, url.pathquery.buff,\n\t\t\t\t    url.pathquery.size, \"HOST: \", hoststr,\n\t\t\t\t    hostlen);\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\tmembuffer_destroy(&request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\", request.buf);\n\t/* get doc msg */\n\tret_code =\n\t    http_RequestAndResponse(&url, request.buf, request.length,\n\t\t\t\t    HTTPMETHOD_GET, timeout_secs, &response);\n\n\tif (ret_code != 0) {\n\t\thttpmsg_destroy(&response.msg);\n\t\tmembuffer_destroy(&request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__, \"Response\\n\");\n\tprint_http_headers(&response.msg);\n\t/* optional content-type */\n\tif (content_type) {\n\t\tif (httpmsg_find_hdr(&response.msg, HDR_CONTENT_TYPE, &ctype) ==\n\t\t    NULL) {\n\t\t\t*content_type = '\\0';\t/* no content-type */\n\t\t} else {\n\t\t\t/* safety */\n\t\t\tcopy_len = ctype.length < LINE_SIZE - (size_t)1 ?\n\t\t\t    ctype.length : LINE_SIZE - (size_t)1;\n\n\t\t\tmemcpy(content_type, ctype.buf, copy_len);\n\t\t\tcontent_type[copy_len] = '\\0';\n\t\t}\n\t}\n\t/* extract doc from msg */\n\tif ((*doc_length = response.msg.entity.length) == (size_t)0) {\n\t\t/* 0-length msg */\n\t\t*document = NULL;\n\t} else if (response.msg.status_code == HTTP_OK) {\n\t\t/*LEAK_FIX_MK */\n\t\t/* copy entity */\n\t\tentity_start = response.msg.entity.buf;\t/* what we want */\n\t\tmsg_length = response.msg.msg.length;\t/* save for posterity    */\n\t\tmsg_start = membuffer_detach(&response.msg.msg);\t/* whole msg */\n\t\t/* move entity to the start; copy null-terminator too */\n\t\tmemmove(msg_start, entity_start, *doc_length + (size_t)1);\n\t\t/* save mem for body only */\n\t\t*document = realloc(msg_start, *doc_length + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/* *document = Realloc( msg_start,msg_length, *doc_length + 1 ); LEAK_FIX_MK */\n\t\t/* shrink can't fail */\n\t\tassert(msg_length > *doc_length);\n\t\tassert(*document != NULL);\n\t\tif (msg_length <= *doc_length || *document == NULL)\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"msg_length(%\" PRIzu \") <= *doc_length(%\"\n\t\t\t\tPRIzu \") or document is NULL\",\n\t\t\t\tmsg_length, *doc_length);\n\t}\n\tif (response.msg.status_code == HTTP_OK) {\n\t\tret_code = 0;\t/* success */\n\t} else {\n\t\t/* server sent error msg (not requested doc) */\n\t\tret_code = response.msg.status_code;\n\t}\n\thttpmsg_destroy(&response.msg);\n\tmembuffer_destroy(&request);\n\n\treturn ret_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpDownloadUrlItem(const char *url, char **outBuf, char *contentType)\n{\n\tint ret_code;\n\tsize_t dummy;\n\n\tif (url == NULL || outBuf == NULL || contentType == NULL)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tret_code = http_Download(url, HTTP_DEFAULT_TIMEOUT, outBuf, &dummy,\n\t\t\t\t contentType);\n\tif (ret_code > 0)\n\t\t/* error reply was received */\n\t\tret_code = UPNP_E_INVALID_URL;\n\n\treturn ret_code;\n}"
  },
  {
    "function_name": "UpnpCloseHttpConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3233-3236",
    "snippet": "int UpnpCloseHttpConnection(void *handle)\n{\n\treturn http_CloseHttpConnection(handle);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_CloseHttpConnection",
          "args": [
            "handle"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "http_CloseHttpConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1413-1423",
          "snippet": "int http_CloseHttpConnection(void *Handle)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t/*should shutdown completely */\n\tsock_destroy(&handle->sock_info, SD_BOTH);\n\thttpmsg_destroy(&handle->response.msg);\n\tfree(handle);\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_CloseHttpConnection(void *Handle)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t/*should shutdown completely */\n\tsock_destroy(&handle->sock_info, SD_BOTH);\n\thttpmsg_destroy(&handle->response.msg);\n\tfree(handle);\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpCloseHttpConnection(void *handle)\n{\n\treturn http_CloseHttpConnection(handle);\n}"
  },
  {
    "function_name": "UpnpReadHttpResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3226-3230",
    "snippet": "int UpnpReadHttpResponse(void *handle, char *buf,\n\t\t\t size_t *size, int timeout)\n{\n\treturn http_ReadHttpResponse(handle, buf, size, timeout);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_ReadHttpResponse",
          "args": [
            "handle",
            "buf",
            "size",
            "timeout"
          ],
          "line": 3229
        },
        "resolved": true,
        "details": {
          "function_name": "http_ReadHttpResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1315-1411",
          "snippet": "int http_ReadHttpResponse(void *Handle, char *buf, size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar tempbuf[2 * 1024];\n\tint ret_code = 0;\n\n\tif (!handle || !size || (*size > 0 && !buf)) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\t/* first parse what has already been gotten */\n\tif (handle->response.position != POS_COMPLETE)\n\t\tstatus = parser_parse_entity(&handle->response);\n\telse\n\t\tstatus = PARSE_SUCCESS;\n\tif (status == PARSE_INCOMPLETE_ENTITY)\n\t\t/* read until close */\n\t\tok_on_close = TRUE;\n\telse if ((status != PARSE_SUCCESS)\n\t\t && (status != PARSE_CONTINUE_1)\n\t\t && (status != PARSE_INCOMPLETE)) {\n\t\t/*error */\n\t\t*size = 0;\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\t/* read more if necessary entity */\n\twhile (handle->response.msg.amount_discarded + *size >\n\t       handle->response.msg.entity.length &&\n\t       !handle->cancel &&\n\t       handle->response.position != POS_COMPLETE) {\n\t\tnum_read = sock_read(&handle->sock_info, tempbuf,\n\t\t\t\t     sizeof(tempbuf), &timeout);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code = membuffer_append(&handle->response.msg.msg,\n\t\t\t\t\t\t    tempbuf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\thandle->response.http_error_code =\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t*size = 0;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_entity(&handle->response);\n\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t/*error */\n\t\t\t\t*size = 0;\n\t\t\t\treturn UPNP_E_BAD_RESPONSE;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t   handle->response.msg.msg.buf);\n\t\t\t\thandle->response.position = POS_COMPLETE;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*size = 0;\n\t\t\t\thandle->response.http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t\t}\n\t\t} else {\n\t\t\t*size = 0;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tif (handle->cancel) {\n\t\treturn UPNP_E_CANCELED;\n\t}\n\t/* truncate size to fall within available data */\n\tif (handle->response.msg.amount_discarded + *size >\n\t    handle->response.msg.entity.length)\n\t\t*size = handle->response.msg.entity.length -\n\t\t\thandle->response.msg.amount_discarded;\n\t/* copy data to user buffer. delete copied data */\n\tif (*size > 0) {\n\t\tmemcpy(buf, &handle->response.msg.msg.buf[handle->response.entity_start_position],\n\t\t       *size);\n\t\tmembuffer_delete(&handle->response.msg.msg,\n\t\t\t\t handle->response.entity_start_position, *size);\n\t\t/* update scanner position. needed for chunked transfers */\n\t\thandle->response.scanner.cursor -= *size;\n\t\t/* update amount discarded */\n\t\thandle->response.msg.amount_discarded += *size;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_ReadHttpResponse(void *Handle, char *buf, size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar tempbuf[2 * 1024];\n\tint ret_code = 0;\n\n\tif (!handle || !size || (*size > 0 && !buf)) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\t/* first parse what has already been gotten */\n\tif (handle->response.position != POS_COMPLETE)\n\t\tstatus = parser_parse_entity(&handle->response);\n\telse\n\t\tstatus = PARSE_SUCCESS;\n\tif (status == PARSE_INCOMPLETE_ENTITY)\n\t\t/* read until close */\n\t\tok_on_close = TRUE;\n\telse if ((status != PARSE_SUCCESS)\n\t\t && (status != PARSE_CONTINUE_1)\n\t\t && (status != PARSE_INCOMPLETE)) {\n\t\t/*error */\n\t\t*size = 0;\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\t/* read more if necessary entity */\n\twhile (handle->response.msg.amount_discarded + *size >\n\t       handle->response.msg.entity.length &&\n\t       !handle->cancel &&\n\t       handle->response.position != POS_COMPLETE) {\n\t\tnum_read = sock_read(&handle->sock_info, tempbuf,\n\t\t\t\t     sizeof(tempbuf), &timeout);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code = membuffer_append(&handle->response.msg.msg,\n\t\t\t\t\t\t    tempbuf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\thandle->response.http_error_code =\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t*size = 0;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_entity(&handle->response);\n\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t/*error */\n\t\t\t\t*size = 0;\n\t\t\t\treturn UPNP_E_BAD_RESPONSE;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t   handle->response.msg.msg.buf);\n\t\t\t\thandle->response.position = POS_COMPLETE;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*size = 0;\n\t\t\t\thandle->response.http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t\t}\n\t\t} else {\n\t\t\t*size = 0;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tif (handle->cancel) {\n\t\treturn UPNP_E_CANCELED;\n\t}\n\t/* truncate size to fall within available data */\n\tif (handle->response.msg.amount_discarded + *size >\n\t    handle->response.msg.entity.length)\n\t\t*size = handle->response.msg.entity.length -\n\t\t\thandle->response.msg.amount_discarded;\n\t/* copy data to user buffer. delete copied data */\n\tif (*size > 0) {\n\t\tmemcpy(buf, &handle->response.msg.msg.buf[handle->response.entity_start_position],\n\t\t       *size);\n\t\tmembuffer_delete(&handle->response.msg.msg,\n\t\t\t\t handle->response.entity_start_position, *size);\n\t\t/* update scanner position. needed for chunked transfers */\n\t\thandle->response.scanner.cursor -= *size;\n\t\t/* update amount discarded */\n\t\thandle->response.msg.amount_discarded += *size;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpReadHttpResponse(void *handle, char *buf,\n\t\t\t size_t *size, int timeout)\n{\n\treturn http_ReadHttpResponse(handle, buf, size, timeout);\n}"
  },
  {
    "function_name": "UpnpGetHttpResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3217-3223",
    "snippet": "int UpnpGetHttpResponse(void *handle, UpnpString *headers,\n\t\t\tchar **contentType, int *contentLength, int *httpStatus,\n\t\t\tint timeout)\n{\n\treturn http_GetHttpResponse(handle, headers, contentType, contentLength,\n\t\t\t\t    httpStatus, timeout);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_GetHttpResponse",
          "args": [
            "handle",
            "headers",
            "contentType",
            "contentLength",
            "httpStatus",
            "timeout"
          ],
          "line": 3221
        },
        "resolved": true,
        "details": {
          "function_name": "http_GetHttpResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1256-1313",
          "snippet": "int http_GetHttpResponse(void *Handle, UpnpString *headers,\n\t\t\t char **contentType, int *contentLength,\n\t\t\t int *httpStatus, int timeout)\n{\n\tint ret_code;\n\tint http_error_code;\n\tmemptr ctype;\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\n\tstatus = ReadResponseLineAndHeaders(&handle->sock_info,\n\t\t\t\t\t    &handle->response, &timeout,\n\t\t\t\t\t    &http_error_code);\n\tif (status != (parse_status_t)PARSE_OK) {\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tstatus = parser_get_entity_read_method(&handle->response);\n\tswitch (status) {\n\tcase PARSE_CONTINUE_1:\n\tcase PARSE_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tret_code = UPNP_E_SUCCESS;\n\tif (httpStatus) {\n\t\t*httpStatus = handle->response.msg.status_code;\n\t}\n\tif (contentType) {\n\t\tif (!httpmsg_find_hdr(&handle->response.msg, HDR_CONTENT_TYPE, &ctype))\n\t\t\t/* no content-type */\n\t\t\t*contentType = NULL;\n\t\telse\n\t\t\t*contentType = ctype.buf;\n\t}\n\tif (contentLength) {\n\t\tif (handle->response.position == (parser_pos_t)POS_COMPLETE)\n\t\t\t*contentLength = 0;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CHUNKED)\n\t\t\t*contentLength = UPNP_USING_CHUNKED;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CLEN)\n\t\t\t*contentLength = (int)handle->response.content_length;\n\t\telse if (handle->response.ent_position == ENTREAD_UNTIL_CLOSE)\n\t\t\t*contentLength = UPNP_UNTIL_CLOSE;\n\t}\n\n\tif (headers) {\n\t\tcopy_msg_headers(&handle->response.msg.headers, headers);\n\n\t}\n\nerrorHandler:\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\thttpmsg_destroy(&handle->response.msg);\n\treturn ret_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_GetHttpResponse(void *Handle, UpnpString *headers,\n\t\t\t char **contentType, int *contentLength,\n\t\t\t int *httpStatus, int timeout)\n{\n\tint ret_code;\n\tint http_error_code;\n\tmemptr ctype;\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\n\tstatus = ReadResponseLineAndHeaders(&handle->sock_info,\n\t\t\t\t\t    &handle->response, &timeout,\n\t\t\t\t\t    &http_error_code);\n\tif (status != (parse_status_t)PARSE_OK) {\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tstatus = parser_get_entity_read_method(&handle->response);\n\tswitch (status) {\n\tcase PARSE_CONTINUE_1:\n\tcase PARSE_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tret_code = UPNP_E_SUCCESS;\n\tif (httpStatus) {\n\t\t*httpStatus = handle->response.msg.status_code;\n\t}\n\tif (contentType) {\n\t\tif (!httpmsg_find_hdr(&handle->response.msg, HDR_CONTENT_TYPE, &ctype))\n\t\t\t/* no content-type */\n\t\t\t*contentType = NULL;\n\t\telse\n\t\t\t*contentType = ctype.buf;\n\t}\n\tif (contentLength) {\n\t\tif (handle->response.position == (parser_pos_t)POS_COMPLETE)\n\t\t\t*contentLength = 0;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CHUNKED)\n\t\t\t*contentLength = UPNP_USING_CHUNKED;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CLEN)\n\t\t\t*contentLength = (int)handle->response.content_length;\n\t\telse if (handle->response.ent_position == ENTREAD_UNTIL_CLOSE)\n\t\t\t*contentLength = UPNP_UNTIL_CLOSE;\n\t}\n\n\tif (headers) {\n\t\tcopy_msg_headers(&handle->response.msg.headers, headers);\n\n\t}\n\nerrorHandler:\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\thttpmsg_destroy(&handle->response.msg);\n\treturn ret_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpGetHttpResponse(void *handle, UpnpString *headers,\n\t\t\tchar **contentType, int *contentLength, int *httpStatus,\n\t\t\tint timeout)\n{\n\treturn http_GetHttpResponse(handle, headers, contentType, contentLength,\n\t\t\t\t    httpStatus, timeout);\n}"
  },
  {
    "function_name": "UpnpEndHttpRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3211-3214",
    "snippet": "int UpnpEndHttpRequest(void *handle, int timeout)\n{\n\treturn http_EndHttpRequest(handle, timeout);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_EndHttpRequest",
          "args": [
            "handle",
            "timeout"
          ],
          "line": 3213
        },
        "resolved": true,
        "details": {
          "function_name": "http_EndHttpRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1238-1254",
          "snippet": "int http_EndHttpRequest(void *Handle, int timeout)\n{\n\tint retc = 0;\n\tconst char *zcrlf = \"0\\r\\n\\r\\n\";\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (!handle->requestStarted) {\n\t\treturn UPNP_E_SUCCESS;\n\t}\n\thandle->requestStarted = 0;\n\tif (handle->contentLength == UPNP_USING_CHUNKED)\n\t\t/*send last chunk */\n\t\tretc = sock_write(&handle->sock_info, zcrlf, strlen(zcrlf), &timeout);\n\n\treturn retc >= 0 ? UPNP_E_SUCCESS : UPNP_E_SOCKET_WRITE;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_EndHttpRequest(void *Handle, int timeout)\n{\n\tint retc = 0;\n\tconst char *zcrlf = \"0\\r\\n\\r\\n\";\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (!handle->requestStarted) {\n\t\treturn UPNP_E_SUCCESS;\n\t}\n\thandle->requestStarted = 0;\n\tif (handle->contentLength == UPNP_USING_CHUNKED)\n\t\t/*send last chunk */\n\t\tretc = sock_write(&handle->sock_info, zcrlf, strlen(zcrlf), &timeout);\n\n\treturn retc >= 0 ? UPNP_E_SUCCESS : UPNP_E_SOCKET_WRITE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpEndHttpRequest(void *handle, int timeout)\n{\n\treturn http_EndHttpRequest(handle, timeout);\n}"
  },
  {
    "function_name": "UpnpWriteHttpRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3204-3208",
    "snippet": "int UpnpWriteHttpRequest(void *handle, char *buf,\n\t\t\t size_t *size, int timeout)\n{\n\treturn http_WriteHttpRequest(handle, buf, size, timeout);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_WriteHttpRequest",
          "args": [
            "handle",
            "buf",
            "size",
            "timeout"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "http_WriteHttpRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1191-1236",
          "snippet": "int http_WriteHttpRequest(void *Handle, char *buf,\n\t\t\t  size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = (http_connection_handle_t *)Handle;\n\tchar *tempbuf = NULL;\n\tsize_t tempbufSize = 0;\n\tint freeTempbuf = 0;\n\tint numWritten = 0;\n\n\tif (!handle || !size || !buf) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\tif (handle->contentLength == UPNP_USING_CHUNKED) {\n\t\tif (*size) {\n\t\t\tsize_t tempSize = 0;\n\t\t\ttempbuf = malloc(*size +\n\t\t\t\t\t CHUNK_HEADER_SIZE + CHUNK_TAIL_SIZE);\n\t\t\tif (!tempbuf)\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t/* begin chunk */\n\t\t\tsprintf(tempbuf, \"%zx\\r\\n\", *size);\n\t\t\ttempSize = strlen(tempbuf);\n\t\t\tmemcpy(tempbuf + tempSize, buf, *size);\n\t\t\tmemcpy(tempbuf + tempSize + *size, \"\\r\\n\", 2);\n\t\t\t/* end of chunk */\n\t\t\ttempbufSize = tempSize + *size + 2;\n\t\t\tfreeTempbuf = 1;\n\t\t}\n\t} else {\n\t\ttempbuf = buf;\n\t\ttempbufSize = *size;\n\t}\n\tnumWritten =\n\t\tsock_write(&handle->sock_info, tempbuf, tempbufSize, &timeout);\n\tif (freeTempbuf)\n\t\tfree(tempbuf);\n\tif (numWritten < 0) {\n\t\t*size = 0;\n\t\treturn numWritten;\n\t} else {\n\t\t*size = (size_t)numWritten;\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n\nint http_WriteHttpRequest(void *Handle, char *buf,\n\t\t\t  size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = (http_connection_handle_t *)Handle;\n\tchar *tempbuf = NULL;\n\tsize_t tempbufSize = 0;\n\tint freeTempbuf = 0;\n\tint numWritten = 0;\n\n\tif (!handle || !size || !buf) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\tif (handle->contentLength == UPNP_USING_CHUNKED) {\n\t\tif (*size) {\n\t\t\tsize_t tempSize = 0;\n\t\t\ttempbuf = malloc(*size +\n\t\t\t\t\t CHUNK_HEADER_SIZE + CHUNK_TAIL_SIZE);\n\t\t\tif (!tempbuf)\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t/* begin chunk */\n\t\t\tsprintf(tempbuf, \"%zx\\r\\n\", *size);\n\t\t\ttempSize = strlen(tempbuf);\n\t\t\tmemcpy(tempbuf + tempSize, buf, *size);\n\t\t\tmemcpy(tempbuf + tempSize + *size, \"\\r\\n\", 2);\n\t\t\t/* end of chunk */\n\t\t\ttempbufSize = tempSize + *size + 2;\n\t\t\tfreeTempbuf = 1;\n\t\t}\n\t} else {\n\t\ttempbuf = buf;\n\t\ttempbufSize = *size;\n\t}\n\tnumWritten =\n\t\tsock_write(&handle->sock_info, tempbuf, tempbufSize, &timeout);\n\tif (freeTempbuf)\n\t\tfree(tempbuf);\n\tif (numWritten < 0) {\n\t\t*size = 0;\n\t\treturn numWritten;\n\t} else {\n\t\t*size = (size_t)numWritten;\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpWriteHttpRequest(void *handle, char *buf,\n\t\t\t size_t *size, int timeout)\n{\n\treturn http_WriteHttpRequest(handle, buf, size, timeout);\n}"
  },
  {
    "function_name": "UpnpMakeHttpRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3195-3202",
    "snippet": "int UpnpMakeHttpRequest(Upnp_HttpMethod method, const char *url,\n\t\t\tvoid *handle, UpnpString *headers,\n\t\t\tconst char *contentType, int contentLength,\n\t\t\tint timeout)\n{\n\treturn http_MakeHttpRequest(method, url, handle, headers, contentType,\n\t\t\t\t    contentLength, timeout);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_MakeHttpRequest",
          "args": [
            "method",
            "url",
            "handle",
            "headers",
            "contentType",
            "contentLength",
            "timeout"
          ],
          "line": 3200
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeHttpRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1162-1189",
          "snippet": "int http_MakeHttpRequest(Upnp_HttpMethod method,\n\t\t\t const char *url_str, void *Handle, UpnpString *headers,\n\t\t\t const char *contentType, int contentLength,\n\t\t\t int timeout)\n{\n\tint ret_code;\n\tmembuffer request;\n\thttp_connection_handle_t *handle = Handle;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (handle->requestStarted) {\n\t\t/* TODO: Log an error that a previous request is already in progress. */\n\t}\n\thandle->requestStarted = 1;\n\thandle->cancel = 0;\n\tret_code = MakeGenericMessage(method, url_str, &request, &url, contentLength,\n\t\t\t\t      contentType, headers);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* send request */\n\tret_code = http_SendMessage(&handle->sock_info, &timeout, \"b\",\n\t\t\t\t    request.buf, request.length);\n\tmembuffer_destroy(&request);\n\thttpmsg_destroy(&handle->response.msg);\n\tparser_response_init(&handle->response, method);\n\treturn ret_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_MakeHttpRequest(Upnp_HttpMethod method,\n\t\t\t const char *url_str, void *Handle, UpnpString *headers,\n\t\t\t const char *contentType, int contentLength,\n\t\t\t int timeout)\n{\n\tint ret_code;\n\tmembuffer request;\n\thttp_connection_handle_t *handle = Handle;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (handle->requestStarted) {\n\t\t/* TODO: Log an error that a previous request is already in progress. */\n\t}\n\thandle->requestStarted = 1;\n\thandle->cancel = 0;\n\tret_code = MakeGenericMessage(method, url_str, &request, &url, contentLength,\n\t\t\t\t      contentType, headers);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* send request */\n\tret_code = http_SendMessage(&handle->sock_info, &timeout, \"b\",\n\t\t\t\t    request.buf, request.length);\n\tmembuffer_destroy(&request);\n\thttpmsg_destroy(&handle->response.msg);\n\tparser_response_init(&handle->response, method);\n\treturn ret_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpMakeHttpRequest(Upnp_HttpMethod method, const char *url,\n\t\t\tvoid *handle, UpnpString *headers,\n\t\t\tconst char *contentType, int contentLength,\n\t\t\tint timeout)\n{\n\treturn http_MakeHttpRequest(method, url, handle, headers, contentType,\n\t\t\t\t    contentLength, timeout);\n}"
  },
  {
    "function_name": "UpnpOpenHttpConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3188-3192",
    "snippet": "int UpnpOpenHttpConnection(const char *url,\n\t\t\t   void **handle, int timeout)\n{\n\treturn http_OpenHttpConnection(url, handle, timeout);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_OpenHttpConnection",
          "args": [
            "url",
            "handle",
            "timeout"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "http_OpenHttpConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1103-1160",
          "snippet": "int http_OpenHttpConnection(const char *url_str, void **Handle, int timeout)\n{\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tSOCKET tcp_connection;\n\thttp_connection_handle_t *handle = NULL;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t*Handle = handle;\n\t/* parse url_str */\n\tret_code = http_FixStrUrl(url_str, strlen(url_str), &url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* create the handle */\n\thandle = malloc(sizeof(http_connection_handle_t));\n\tif (!handle) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thandle->requestStarted = 0;\n\tmemset(&handle->response, 0, sizeof(handle->response));\n\t/* connect to the server */\n\ttcp_connection = socket(url.hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tif (sock_init(&handle->sock_info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tsockaddr_len = url.hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(handle->sock_info.socket,\n\t\t\t\t   (struct sockaddr *)&(url.hostport.IPaddress),\n\t\t\t\t   (socklen_t) sockaddr_len);\n\tif (ret_code == -1) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto errorHandler;\n\t}\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t/* For HTTPS connections start the TLS/SSL handshake. */\n\tif (token_string_casecmp(&url.scheme, \"https\") == 0) {\n\t\tret_code = sock_ssl_connect(&handle->sock_info);\n\t\tif (ret_code != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\tgoto errorHandler;\n\t\t}\n\t}\n#endif\nerrorHandler:\n\t*Handle = handle;\n\treturn ret_code;\n\t/* Unused parameter */\n\ttimeout = timeout;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_OpenHttpConnection(const char *url_str, void **Handle, int timeout)\n{\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tSOCKET tcp_connection;\n\thttp_connection_handle_t *handle = NULL;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t*Handle = handle;\n\t/* parse url_str */\n\tret_code = http_FixStrUrl(url_str, strlen(url_str), &url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* create the handle */\n\thandle = malloc(sizeof(http_connection_handle_t));\n\tif (!handle) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thandle->requestStarted = 0;\n\tmemset(&handle->response, 0, sizeof(handle->response));\n\t/* connect to the server */\n\ttcp_connection = socket(url.hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tif (sock_init(&handle->sock_info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tsockaddr_len = url.hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(handle->sock_info.socket,\n\t\t\t\t   (struct sockaddr *)&(url.hostport.IPaddress),\n\t\t\t\t   (socklen_t) sockaddr_len);\n\tif (ret_code == -1) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto errorHandler;\n\t}\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t/* For HTTPS connections start the TLS/SSL handshake. */\n\tif (token_string_casecmp(&url.scheme, \"https\") == 0) {\n\t\tret_code = sock_ssl_connect(&handle->sock_info);\n\t\tif (ret_code != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\tgoto errorHandler;\n\t\t}\n\t}\n#endif\nerrorHandler:\n\t*Handle = handle;\n\treturn ret_code;\n\t/* Unused parameter */\n\ttimeout = timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpOpenHttpConnection(const char *url,\n\t\t\t   void **handle, int timeout)\n{\n\treturn http_OpenHttpConnection(url, handle, timeout);\n}"
  },
  {
    "function_name": "UpnpHttpGetProgress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3182-3185",
    "snippet": "int UpnpHttpGetProgress(void *Handle, size_t *length, size_t *total)\n{\n\treturn http_HttpGetProgress(Handle, length, total);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_HttpGetProgress",
          "args": [
            "Handle",
            "length",
            "total"
          ],
          "line": 3184
        },
        "resolved": true,
        "details": {
          "function_name": "http_HttpGetProgress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1062-1076",
          "snippet": "int http_HttpGetProgress(\n\tIN void *Handle,\n\tOUT size_t *length,\n\tOUT size_t *total)\n{\n\thttp_connection_handle_t *handle = Handle;\n\n\tif (!handle || !length || !total) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\t*length = handle->response.msg.entity.length;\n\t*total = handle->response.content_length;\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_HttpGetProgress(\n\tIN void *Handle,\n\tOUT size_t *length,\n\tOUT size_t *total)\n{\n\thttp_connection_handle_t *handle = Handle;\n\n\tif (!handle || !length || !total) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\t*length = handle->response.msg.entity.length;\n\t*total = handle->response.content_length;\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpHttpGetProgress(void *Handle, size_t *length, size_t *total)\n{\n\treturn http_HttpGetProgress(Handle, length, total);\n}"
  },
  {
    "function_name": "UpnpReadHttpGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3176-3179",
    "snippet": "int UpnpReadHttpGet(void *Handle, char *buf, size_t *size, int timeout)\n{\n\treturn http_ReadHttpResponse(Handle, buf, size, timeout);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_ReadHttpResponse",
          "args": [
            "Handle",
            "buf",
            "size",
            "timeout"
          ],
          "line": 3178
        },
        "resolved": true,
        "details": {
          "function_name": "http_ReadHttpResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1315-1411",
          "snippet": "int http_ReadHttpResponse(void *Handle, char *buf, size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar tempbuf[2 * 1024];\n\tint ret_code = 0;\n\n\tif (!handle || !size || (*size > 0 && !buf)) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\t/* first parse what has already been gotten */\n\tif (handle->response.position != POS_COMPLETE)\n\t\tstatus = parser_parse_entity(&handle->response);\n\telse\n\t\tstatus = PARSE_SUCCESS;\n\tif (status == PARSE_INCOMPLETE_ENTITY)\n\t\t/* read until close */\n\t\tok_on_close = TRUE;\n\telse if ((status != PARSE_SUCCESS)\n\t\t && (status != PARSE_CONTINUE_1)\n\t\t && (status != PARSE_INCOMPLETE)) {\n\t\t/*error */\n\t\t*size = 0;\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\t/* read more if necessary entity */\n\twhile (handle->response.msg.amount_discarded + *size >\n\t       handle->response.msg.entity.length &&\n\t       !handle->cancel &&\n\t       handle->response.position != POS_COMPLETE) {\n\t\tnum_read = sock_read(&handle->sock_info, tempbuf,\n\t\t\t\t     sizeof(tempbuf), &timeout);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code = membuffer_append(&handle->response.msg.msg,\n\t\t\t\t\t\t    tempbuf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\thandle->response.http_error_code =\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t*size = 0;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_entity(&handle->response);\n\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t/*error */\n\t\t\t\t*size = 0;\n\t\t\t\treturn UPNP_E_BAD_RESPONSE;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t   handle->response.msg.msg.buf);\n\t\t\t\thandle->response.position = POS_COMPLETE;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*size = 0;\n\t\t\t\thandle->response.http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t\t}\n\t\t} else {\n\t\t\t*size = 0;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tif (handle->cancel) {\n\t\treturn UPNP_E_CANCELED;\n\t}\n\t/* truncate size to fall within available data */\n\tif (handle->response.msg.amount_discarded + *size >\n\t    handle->response.msg.entity.length)\n\t\t*size = handle->response.msg.entity.length -\n\t\t\thandle->response.msg.amount_discarded;\n\t/* copy data to user buffer. delete copied data */\n\tif (*size > 0) {\n\t\tmemcpy(buf, &handle->response.msg.msg.buf[handle->response.entity_start_position],\n\t\t       *size);\n\t\tmembuffer_delete(&handle->response.msg.msg,\n\t\t\t\t handle->response.entity_start_position, *size);\n\t\t/* update scanner position. needed for chunked transfers */\n\t\thandle->response.scanner.cursor -= *size;\n\t\t/* update amount discarded */\n\t\thandle->response.msg.amount_discarded += *size;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_ReadHttpResponse(void *Handle, char *buf, size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar tempbuf[2 * 1024];\n\tint ret_code = 0;\n\n\tif (!handle || !size || (*size > 0 && !buf)) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\t/* first parse what has already been gotten */\n\tif (handle->response.position != POS_COMPLETE)\n\t\tstatus = parser_parse_entity(&handle->response);\n\telse\n\t\tstatus = PARSE_SUCCESS;\n\tif (status == PARSE_INCOMPLETE_ENTITY)\n\t\t/* read until close */\n\t\tok_on_close = TRUE;\n\telse if ((status != PARSE_SUCCESS)\n\t\t && (status != PARSE_CONTINUE_1)\n\t\t && (status != PARSE_INCOMPLETE)) {\n\t\t/*error */\n\t\t*size = 0;\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\t/* read more if necessary entity */\n\twhile (handle->response.msg.amount_discarded + *size >\n\t       handle->response.msg.entity.length &&\n\t       !handle->cancel &&\n\t       handle->response.position != POS_COMPLETE) {\n\t\tnum_read = sock_read(&handle->sock_info, tempbuf,\n\t\t\t\t     sizeof(tempbuf), &timeout);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code = membuffer_append(&handle->response.msg.msg,\n\t\t\t\t\t\t    tempbuf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\thandle->response.http_error_code =\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t*size = 0;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_entity(&handle->response);\n\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t/*error */\n\t\t\t\t*size = 0;\n\t\t\t\treturn UPNP_E_BAD_RESPONSE;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t   handle->response.msg.msg.buf);\n\t\t\t\thandle->response.position = POS_COMPLETE;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*size = 0;\n\t\t\t\thandle->response.http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t\t}\n\t\t} else {\n\t\t\t*size = 0;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tif (handle->cancel) {\n\t\treturn UPNP_E_CANCELED;\n\t}\n\t/* truncate size to fall within available data */\n\tif (handle->response.msg.amount_discarded + *size >\n\t    handle->response.msg.entity.length)\n\t\t*size = handle->response.msg.entity.length -\n\t\t\thandle->response.msg.amount_discarded;\n\t/* copy data to user buffer. delete copied data */\n\tif (*size > 0) {\n\t\tmemcpy(buf, &handle->response.msg.msg.buf[handle->response.entity_start_position],\n\t\t       *size);\n\t\tmembuffer_delete(&handle->response.msg.msg,\n\t\t\t\t handle->response.entity_start_position, *size);\n\t\t/* update scanner position. needed for chunked transfers */\n\t\thandle->response.scanner.cursor -= *size;\n\t\t/* update amount discarded */\n\t\thandle->response.msg.amount_discarded += *size;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpReadHttpGet(void *Handle, char *buf, size_t *size, int timeout)\n{\n\treturn http_ReadHttpResponse(Handle, buf, size, timeout);\n}"
  },
  {
    "function_name": "UpnpCloseHttpGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3170-3173",
    "snippet": "int UpnpCloseHttpGet(void *Handle)\n{\n\treturn UpnpCloseHttpConnection(Handle);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpCloseHttpConnection",
          "args": [
            "Handle"
          ],
          "line": 3172
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpCloseHttpConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3233-3236",
          "snippet": "int UpnpCloseHttpConnection(void *handle)\n{\n\treturn http_CloseHttpConnection(handle);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpCloseHttpConnection(void *handle)\n{\n\treturn http_CloseHttpConnection(handle);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpCloseHttpGet(void *Handle)\n{\n\treturn UpnpCloseHttpConnection(Handle);\n}"
  },
  {
    "function_name": "UpnpCancelHttpGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3164-3167",
    "snippet": "int UpnpCancelHttpGet(void *Handle)\n{\n\treturn http_CancelHttpGet(Handle);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_CancelHttpGet",
          "args": [
            "Handle"
          ],
          "line": 3166
        },
        "resolved": true,
        "details": {
          "function_name": "http_CancelHttpGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1091-1100",
          "snippet": "int http_CancelHttpGet(IN void *Handle)\n{\n\thttp_connection_handle_t *handle = Handle;\n\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\thandle->cancel = 1;\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_CancelHttpGet(IN void *Handle)\n{\n\thttp_connection_handle_t *handle = Handle;\n\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\thandle->cancel = 1;\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpCancelHttpGet(void *Handle)\n{\n\treturn http_CancelHttpGet(Handle);\n}"
  },
  {
    "function_name": "UpnpOpenHttpGetEx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3148-3161",
    "snippet": "int UpnpOpenHttpGetEx(\n\tconst char *url_str,\n\tvoid **Handle,\n\tchar **contentType,\n\tint *contentLength,\n\tint *httpStatus,\n\tint lowRange,\n\tint highRange,\n\tint timeout)\n{\n\treturn http_OpenHttpGetEx(\n\t\turl_str, Handle, contentType, contentLength, httpStatus,\n\t\tlowRange, highRange, timeout);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_OpenHttpGetEx",
          "args": [
            "url_str",
            "Handle",
            "contentType",
            "contentLength",
            "httpStatus",
            "lowRange",
            "highRange",
            "timeout"
          ],
          "line": 3158
        },
        "resolved": true,
        "details": {
          "function_name": "http_OpenHttpGetEx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1842-1965",
          "snippet": "int http_OpenHttpGetEx(\n\tIN const char *url_str,\n\tIN OUT void **Handle,\n\tIN OUT char **contentType,\n\tOUT int *contentLength,\n\tOUT int *httpStatus,\n\tIN int lowRange,\n\tIN int highRange,\n\tIN int timeout)\n{\n\tint http_error_code;\n\tmemptr ctype;\n\tSOCKET tcp_connection;\n\tsize_t sockaddr_len;\n\tmembuffer request;\n\thttp_connection_handle_t *handle = NULL;\n\turi_type url;\n\tparse_status_t status;\n\tint errCode = UPNP_E_SUCCESS;\n\t/* char rangeBuf[SIZE_RANGE_BUFFER]; */\n\tstruct SendInstruction rangeBuf;\n\tint rc = 0;\n\n\tmembuffer_init(&request);\n\n\tdo {\n\t\t/* Checking Input parameters */\n\t\tif (!url_str || !Handle || !contentType || !httpStatus ) {\n\t\t\terrCode = UPNP_E_INVALID_PARAM;\n\t\t\tbreak;\n\t\t}\n\t\t/* Initialize output parameters */\n\t\t*httpStatus = 0;\n\t\t*Handle = handle;\n\t\t*contentType = NULL;\n\t\t*contentLength = 0;\n\t\tif (lowRange > highRange) {\n\t\t\terrCode = UPNP_E_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(&rangeBuf, 0, sizeof(rangeBuf));\n\t\trc = snprintf(rangeBuf.RangeHeader, sizeof(rangeBuf.RangeHeader),\n\t\t\t\"Range: bytes=%d-%d\\r\\n\", lowRange, highRange);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(rangeBuf.RangeHeader))\n\t\t\tbreak;\n\t\tmembuffer_init(&request);\n\t\terrCode = MakeGetMessageEx(url_str, &request, &url, &rangeBuf);\n\t\tif (errCode != UPNP_E_SUCCESS)\n\t\t\tbreak;\n\t\thandle = (http_connection_handle_t *)malloc(sizeof(http_connection_handle_t));\n\t\tif (!handle) {\n\t\t\terrCode = UPNP_E_OUTOF_MEMORY;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(handle, 0, sizeof(*handle));\n\t\tparser_response_init(&handle->response, HTTPMETHOD_GET);\n\t\ttcp_connection = socket((int)url.hostport.IPaddress.ss_family,\n\t\t\tSOCK_STREAM, 0);\n\t\tif (tcp_connection == INVALID_SOCKET) {\n\t\t\terrCode = UPNP_E_SOCKET_ERROR;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tif (sock_init(&handle->sock_info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\terrCode = UPNP_E_SOCKET_ERROR;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tsockaddr_len = url.hostport.IPaddress.ss_family == AF_INET6 ?\n\t\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\t\terrCode  = private_connect(handle->sock_info.socket,\n\t\t\t(struct sockaddr *)&(url.hostport.IPaddress),\n\t\t\t(socklen_t)sockaddr_len);\n\t\tif (errCode == -1) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\terrCode = UPNP_E_SOCKET_CONNECT;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\t/* send request */\n\t\terrCode = http_SendMessage(&handle->sock_info, &timeout,\n\t\t\t\"b\", request.buf, request.length);\n\t\tif (errCode != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tif (ReadResponseLineAndHeaders(&handle->sock_info,\n\t\t\t&handle->response, &timeout, &http_error_code) != (int)PARSE_OK) {\n\t\t\terrCode = UPNP_E_BAD_RESPONSE;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tstatus = parser_get_entity_read_method(&handle->response);\n\t\tif (status != (parse_status_t)PARSE_CONTINUE_1 &&\n\t\t\tstatus != (parse_status_t)PARSE_SUCCESS) {\n\t\t\terrCode = UPNP_E_BAD_RESPONSE;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\t*httpStatus = handle->response.msg.status_code;\n\t\terrCode = UPNP_E_SUCCESS;\n\n\t\tif (!httpmsg_find_hdr(&handle->response.msg, HDR_CONTENT_TYPE, &ctype))\n\t\t\t/* no content-type */\n\t\t\t*contentType = NULL;\n\t\telse\n\t\t\t*contentType = ctype.buf;\n\t\tif (handle->response.position == (parser_pos_t)POS_COMPLETE)\n\t\t\t*contentLength = 0;\n\t\telse if(handle->response.ent_position == ENTREAD_USING_CHUNKED)\n\t\t\t*contentLength = UPNP_USING_CHUNKED;\n\t\telse if(handle->response.ent_position == ENTREAD_USING_CLEN)\n\t\t\t*contentLength = (int)handle->response.content_length;\n\t\telse if(handle->response.ent_position == ENTREAD_UNTIL_CLOSE)\n\t\t\t*contentLength = UPNP_UNTIL_CLOSE;\n\t\t*Handle = handle;\n\t} while (0);\n\n\tmembuffer_destroy(&request);\n\n\treturn errCode;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SIZE_RANGE_BUFFER 50",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define SIZE_RANGE_BUFFER 50\n#define snprintf _snprintf\n\nint http_OpenHttpGetEx(\n\tIN const char *url_str,\n\tIN OUT void **Handle,\n\tIN OUT char **contentType,\n\tOUT int *contentLength,\n\tOUT int *httpStatus,\n\tIN int lowRange,\n\tIN int highRange,\n\tIN int timeout)\n{\n\tint http_error_code;\n\tmemptr ctype;\n\tSOCKET tcp_connection;\n\tsize_t sockaddr_len;\n\tmembuffer request;\n\thttp_connection_handle_t *handle = NULL;\n\turi_type url;\n\tparse_status_t status;\n\tint errCode = UPNP_E_SUCCESS;\n\t/* char rangeBuf[SIZE_RANGE_BUFFER]; */\n\tstruct SendInstruction rangeBuf;\n\tint rc = 0;\n\n\tmembuffer_init(&request);\n\n\tdo {\n\t\t/* Checking Input parameters */\n\t\tif (!url_str || !Handle || !contentType || !httpStatus ) {\n\t\t\terrCode = UPNP_E_INVALID_PARAM;\n\t\t\tbreak;\n\t\t}\n\t\t/* Initialize output parameters */\n\t\t*httpStatus = 0;\n\t\t*Handle = handle;\n\t\t*contentType = NULL;\n\t\t*contentLength = 0;\n\t\tif (lowRange > highRange) {\n\t\t\terrCode = UPNP_E_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(&rangeBuf, 0, sizeof(rangeBuf));\n\t\trc = snprintf(rangeBuf.RangeHeader, sizeof(rangeBuf.RangeHeader),\n\t\t\t\"Range: bytes=%d-%d\\r\\n\", lowRange, highRange);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(rangeBuf.RangeHeader))\n\t\t\tbreak;\n\t\tmembuffer_init(&request);\n\t\terrCode = MakeGetMessageEx(url_str, &request, &url, &rangeBuf);\n\t\tif (errCode != UPNP_E_SUCCESS)\n\t\t\tbreak;\n\t\thandle = (http_connection_handle_t *)malloc(sizeof(http_connection_handle_t));\n\t\tif (!handle) {\n\t\t\terrCode = UPNP_E_OUTOF_MEMORY;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(handle, 0, sizeof(*handle));\n\t\tparser_response_init(&handle->response, HTTPMETHOD_GET);\n\t\ttcp_connection = socket((int)url.hostport.IPaddress.ss_family,\n\t\t\tSOCK_STREAM, 0);\n\t\tif (tcp_connection == INVALID_SOCKET) {\n\t\t\terrCode = UPNP_E_SOCKET_ERROR;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tif (sock_init(&handle->sock_info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\terrCode = UPNP_E_SOCKET_ERROR;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tsockaddr_len = url.hostport.IPaddress.ss_family == AF_INET6 ?\n\t\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\t\terrCode  = private_connect(handle->sock_info.socket,\n\t\t\t(struct sockaddr *)&(url.hostport.IPaddress),\n\t\t\t(socklen_t)sockaddr_len);\n\t\tif (errCode == -1) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\terrCode = UPNP_E_SOCKET_CONNECT;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\t/* send request */\n\t\terrCode = http_SendMessage(&handle->sock_info, &timeout,\n\t\t\t\"b\", request.buf, request.length);\n\t\tif (errCode != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tif (ReadResponseLineAndHeaders(&handle->sock_info,\n\t\t\t&handle->response, &timeout, &http_error_code) != (int)PARSE_OK) {\n\t\t\terrCode = UPNP_E_BAD_RESPONSE;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tstatus = parser_get_entity_read_method(&handle->response);\n\t\tif (status != (parse_status_t)PARSE_CONTINUE_1 &&\n\t\t\tstatus != (parse_status_t)PARSE_SUCCESS) {\n\t\t\terrCode = UPNP_E_BAD_RESPONSE;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\t*httpStatus = handle->response.msg.status_code;\n\t\terrCode = UPNP_E_SUCCESS;\n\n\t\tif (!httpmsg_find_hdr(&handle->response.msg, HDR_CONTENT_TYPE, &ctype))\n\t\t\t/* no content-type */\n\t\t\t*contentType = NULL;\n\t\telse\n\t\t\t*contentType = ctype.buf;\n\t\tif (handle->response.position == (parser_pos_t)POS_COMPLETE)\n\t\t\t*contentLength = 0;\n\t\telse if(handle->response.ent_position == ENTREAD_USING_CHUNKED)\n\t\t\t*contentLength = UPNP_USING_CHUNKED;\n\t\telse if(handle->response.ent_position == ENTREAD_USING_CLEN)\n\t\t\t*contentLength = (int)handle->response.content_length;\n\t\telse if(handle->response.ent_position == ENTREAD_UNTIL_CLOSE)\n\t\t\t*contentLength = UPNP_UNTIL_CLOSE;\n\t\t*Handle = handle;\n\t} while (0);\n\n\tmembuffer_destroy(&request);\n\n\treturn errCode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpOpenHttpGetEx(\n\tconst char *url_str,\n\tvoid **Handle,\n\tchar **contentType,\n\tint *contentLength,\n\tint *httpStatus,\n\tint lowRange,\n\tint highRange,\n\tint timeout)\n{\n\treturn http_OpenHttpGetEx(\n\t\turl_str, Handle, contentType, contentLength, httpStatus,\n\t\tlowRange, highRange, timeout);\n}"
  },
  {
    "function_name": "UpnpOpenHttpGetProxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3125-3145",
    "snippet": "int UpnpOpenHttpGetProxy(\n\tconst char *url,\n\tconst char *proxy_str,\n\tvoid **handle,\n\tchar **contentType,\n\tint *contentLength,\n\tint *httpStatus,\n\tint timeout)\n{\n\tint status = UpnpOpenHttpConnection(proxy_str, handle, timeout);\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpMakeHttpRequest(HTTPMETHOD_GET, url, *handle, NULL, NULL, 0, timeout);\n\t}\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpEndHttpRequest(*handle, timeout);\n\t}\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpGetHttpResponse(*handle, NULL, contentType, contentLength, httpStatus, timeout);\n\t}\n\treturn status;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpGetHttpResponse",
          "args": [
            "*handle",
            "NULL",
            "contentType",
            "contentLength",
            "httpStatus",
            "timeout"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpGetHttpResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3217-3223",
          "snippet": "int UpnpGetHttpResponse(void *handle, UpnpString *headers,\n\t\t\tchar **contentType, int *contentLength, int *httpStatus,\n\t\t\tint timeout)\n{\n\treturn http_GetHttpResponse(handle, headers, contentType, contentLength,\n\t\t\t\t    httpStatus, timeout);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpGetHttpResponse(void *handle, UpnpString *headers,\n\t\t\tchar **contentType, int *contentLength, int *httpStatus,\n\t\t\tint timeout)\n{\n\treturn http_GetHttpResponse(handle, headers, contentType, contentLength,\n\t\t\t\t    httpStatus, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpEndHttpRequest",
          "args": [
            "*handle",
            "timeout"
          ],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpEndHttpRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3211-3214",
          "snippet": "int UpnpEndHttpRequest(void *handle, int timeout)\n{\n\treturn http_EndHttpRequest(handle, timeout);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpEndHttpRequest(void *handle, int timeout)\n{\n\treturn http_EndHttpRequest(handle, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpMakeHttpRequest",
          "args": [
            "HTTPMETHOD_GET",
            "url",
            "*handle",
            "NULL",
            "NULL",
            "0",
            "timeout"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpMakeHttpRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3195-3202",
          "snippet": "int UpnpMakeHttpRequest(Upnp_HttpMethod method, const char *url,\n\t\t\tvoid *handle, UpnpString *headers,\n\t\t\tconst char *contentType, int contentLength,\n\t\t\tint timeout)\n{\n\treturn http_MakeHttpRequest(method, url, handle, headers, contentType,\n\t\t\t\t    contentLength, timeout);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpMakeHttpRequest(Upnp_HttpMethod method, const char *url,\n\t\t\tvoid *handle, UpnpString *headers,\n\t\t\tconst char *contentType, int contentLength,\n\t\t\tint timeout)\n{\n\treturn http_MakeHttpRequest(method, url, handle, headers, contentType,\n\t\t\t\t    contentLength, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpOpenHttpConnection",
          "args": [
            "proxy_str",
            "handle",
            "timeout"
          ],
          "line": 3134
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpOpenHttpConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3188-3192",
          "snippet": "int UpnpOpenHttpConnection(const char *url,\n\t\t\t   void **handle, int timeout)\n{\n\treturn http_OpenHttpConnection(url, handle, timeout);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpOpenHttpConnection(const char *url,\n\t\t\t   void **handle, int timeout)\n{\n\treturn http_OpenHttpConnection(url, handle, timeout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpOpenHttpGetProxy(\n\tconst char *url,\n\tconst char *proxy_str,\n\tvoid **handle,\n\tchar **contentType,\n\tint *contentLength,\n\tint *httpStatus,\n\tint timeout)\n{\n\tint status = UpnpOpenHttpConnection(proxy_str, handle, timeout);\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpMakeHttpRequest(HTTPMETHOD_GET, url, *handle, NULL, NULL, 0, timeout);\n\t}\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpEndHttpRequest(*handle, timeout);\n\t}\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpGetHttpResponse(*handle, NULL, contentType, contentLength, httpStatus, timeout);\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "UpnpOpenHttpGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3103-3122",
    "snippet": "int UpnpOpenHttpGet(\n\tconst char *url,\n\tvoid **handle,\n\tchar **contentType,\n\tint *contentLength,\n\tint *httpStatus,\n\tint timeout)\n{\n\tint status = UpnpOpenHttpConnection(url, handle, timeout);\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpMakeHttpRequest(HTTPMETHOD_GET, url, *handle, NULL, NULL, 0, timeout);\n\t}\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpEndHttpRequest(*handle, timeout);\n\t}\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpGetHttpResponse(*handle, NULL, contentType, contentLength, httpStatus, timeout);\n\t}\n\treturn status;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpGetHttpResponse",
          "args": [
            "*handle",
            "NULL",
            "contentType",
            "contentLength",
            "httpStatus",
            "timeout"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpGetHttpResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3217-3223",
          "snippet": "int UpnpGetHttpResponse(void *handle, UpnpString *headers,\n\t\t\tchar **contentType, int *contentLength, int *httpStatus,\n\t\t\tint timeout)\n{\n\treturn http_GetHttpResponse(handle, headers, contentType, contentLength,\n\t\t\t\t    httpStatus, timeout);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpGetHttpResponse(void *handle, UpnpString *headers,\n\t\t\tchar **contentType, int *contentLength, int *httpStatus,\n\t\t\tint timeout)\n{\n\treturn http_GetHttpResponse(handle, headers, contentType, contentLength,\n\t\t\t\t    httpStatus, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpEndHttpRequest",
          "args": [
            "*handle",
            "timeout"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpEndHttpRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3211-3214",
          "snippet": "int UpnpEndHttpRequest(void *handle, int timeout)\n{\n\treturn http_EndHttpRequest(handle, timeout);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpEndHttpRequest(void *handle, int timeout)\n{\n\treturn http_EndHttpRequest(handle, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpMakeHttpRequest",
          "args": [
            "HTTPMETHOD_GET",
            "url",
            "*handle",
            "NULL",
            "NULL",
            "0",
            "timeout"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpMakeHttpRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3195-3202",
          "snippet": "int UpnpMakeHttpRequest(Upnp_HttpMethod method, const char *url,\n\t\t\tvoid *handle, UpnpString *headers,\n\t\t\tconst char *contentType, int contentLength,\n\t\t\tint timeout)\n{\n\treturn http_MakeHttpRequest(method, url, handle, headers, contentType,\n\t\t\t\t    contentLength, timeout);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpMakeHttpRequest(Upnp_HttpMethod method, const char *url,\n\t\t\tvoid *handle, UpnpString *headers,\n\t\t\tconst char *contentType, int contentLength,\n\t\t\tint timeout)\n{\n\treturn http_MakeHttpRequest(method, url, handle, headers, contentType,\n\t\t\t\t    contentLength, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpOpenHttpConnection",
          "args": [
            "url",
            "handle",
            "timeout"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpOpenHttpConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3188-3192",
          "snippet": "int UpnpOpenHttpConnection(const char *url,\n\t\t\t   void **handle, int timeout)\n{\n\treturn http_OpenHttpConnection(url, handle, timeout);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpOpenHttpConnection(const char *url,\n\t\t\t   void **handle, int timeout)\n{\n\treturn http_OpenHttpConnection(url, handle, timeout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpOpenHttpGet(\n\tconst char *url,\n\tvoid **handle,\n\tchar **contentType,\n\tint *contentLength,\n\tint *httpStatus,\n\tint timeout)\n{\n\tint status = UpnpOpenHttpConnection(url, handle, timeout);\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpMakeHttpRequest(HTTPMETHOD_GET, url, *handle, NULL, NULL, 0, timeout);\n\t}\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpEndHttpRequest(*handle, timeout);\n\t}\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = UpnpGetHttpResponse(*handle, NULL, contentType, contentLength, httpStatus, timeout);\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "UpnpCloseHttpPost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3090-3100",
    "snippet": "int UpnpCloseHttpPost(\n\tvoid *handle,\n\tint *httpStatus,\n\tint timeout)\n{\n\tint status = http_EndHttpRequest(handle, timeout);\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = http_GetHttpResponse(handle, NULL, NULL, NULL, httpStatus, timeout);\n\t}\n\tstatus = http_CloseHttpConnection(handle);\n\treturn status;}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_CloseHttpConnection",
          "args": [
            "handle"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "http_CloseHttpConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1413-1423",
          "snippet": "int http_CloseHttpConnection(void *Handle)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t/*should shutdown completely */\n\tsock_destroy(&handle->sock_info, SD_BOTH);\n\thttpmsg_destroy(&handle->response.msg);\n\tfree(handle);\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_CloseHttpConnection(void *Handle)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t/*should shutdown completely */\n\tsock_destroy(&handle->sock_info, SD_BOTH);\n\thttpmsg_destroy(&handle->response.msg);\n\tfree(handle);\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_GetHttpResponse",
          "args": [
            "handle",
            "NULL",
            "NULL",
            "NULL",
            "httpStatus",
            "timeout"
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "http_GetHttpResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1256-1313",
          "snippet": "int http_GetHttpResponse(void *Handle, UpnpString *headers,\n\t\t\t char **contentType, int *contentLength,\n\t\t\t int *httpStatus, int timeout)\n{\n\tint ret_code;\n\tint http_error_code;\n\tmemptr ctype;\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\n\tstatus = ReadResponseLineAndHeaders(&handle->sock_info,\n\t\t\t\t\t    &handle->response, &timeout,\n\t\t\t\t\t    &http_error_code);\n\tif (status != (parse_status_t)PARSE_OK) {\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tstatus = parser_get_entity_read_method(&handle->response);\n\tswitch (status) {\n\tcase PARSE_CONTINUE_1:\n\tcase PARSE_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tret_code = UPNP_E_SUCCESS;\n\tif (httpStatus) {\n\t\t*httpStatus = handle->response.msg.status_code;\n\t}\n\tif (contentType) {\n\t\tif (!httpmsg_find_hdr(&handle->response.msg, HDR_CONTENT_TYPE, &ctype))\n\t\t\t/* no content-type */\n\t\t\t*contentType = NULL;\n\t\telse\n\t\t\t*contentType = ctype.buf;\n\t}\n\tif (contentLength) {\n\t\tif (handle->response.position == (parser_pos_t)POS_COMPLETE)\n\t\t\t*contentLength = 0;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CHUNKED)\n\t\t\t*contentLength = UPNP_USING_CHUNKED;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CLEN)\n\t\t\t*contentLength = (int)handle->response.content_length;\n\t\telse if (handle->response.ent_position == ENTREAD_UNTIL_CLOSE)\n\t\t\t*contentLength = UPNP_UNTIL_CLOSE;\n\t}\n\n\tif (headers) {\n\t\tcopy_msg_headers(&handle->response.msg.headers, headers);\n\n\t}\n\nerrorHandler:\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\thttpmsg_destroy(&handle->response.msg);\n\treturn ret_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_GetHttpResponse(void *Handle, UpnpString *headers,\n\t\t\t char **contentType, int *contentLength,\n\t\t\t int *httpStatus, int timeout)\n{\n\tint ret_code;\n\tint http_error_code;\n\tmemptr ctype;\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\n\tstatus = ReadResponseLineAndHeaders(&handle->sock_info,\n\t\t\t\t\t    &handle->response, &timeout,\n\t\t\t\t\t    &http_error_code);\n\tif (status != (parse_status_t)PARSE_OK) {\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tstatus = parser_get_entity_read_method(&handle->response);\n\tswitch (status) {\n\tcase PARSE_CONTINUE_1:\n\tcase PARSE_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tret_code = UPNP_E_SUCCESS;\n\tif (httpStatus) {\n\t\t*httpStatus = handle->response.msg.status_code;\n\t}\n\tif (contentType) {\n\t\tif (!httpmsg_find_hdr(&handle->response.msg, HDR_CONTENT_TYPE, &ctype))\n\t\t\t/* no content-type */\n\t\t\t*contentType = NULL;\n\t\telse\n\t\t\t*contentType = ctype.buf;\n\t}\n\tif (contentLength) {\n\t\tif (handle->response.position == (parser_pos_t)POS_COMPLETE)\n\t\t\t*contentLength = 0;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CHUNKED)\n\t\t\t*contentLength = UPNP_USING_CHUNKED;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CLEN)\n\t\t\t*contentLength = (int)handle->response.content_length;\n\t\telse if (handle->response.ent_position == ENTREAD_UNTIL_CLOSE)\n\t\t\t*contentLength = UPNP_UNTIL_CLOSE;\n\t}\n\n\tif (headers) {\n\t\tcopy_msg_headers(&handle->response.msg.headers, headers);\n\n\t}\n\nerrorHandler:\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\thttpmsg_destroy(&handle->response.msg);\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_EndHttpRequest",
          "args": [
            "handle",
            "timeout"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "http_EndHttpRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1238-1254",
          "snippet": "int http_EndHttpRequest(void *Handle, int timeout)\n{\n\tint retc = 0;\n\tconst char *zcrlf = \"0\\r\\n\\r\\n\";\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (!handle->requestStarted) {\n\t\treturn UPNP_E_SUCCESS;\n\t}\n\thandle->requestStarted = 0;\n\tif (handle->contentLength == UPNP_USING_CHUNKED)\n\t\t/*send last chunk */\n\t\tretc = sock_write(&handle->sock_info, zcrlf, strlen(zcrlf), &timeout);\n\n\treturn retc >= 0 ? UPNP_E_SUCCESS : UPNP_E_SOCKET_WRITE;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_EndHttpRequest(void *Handle, int timeout)\n{\n\tint retc = 0;\n\tconst char *zcrlf = \"0\\r\\n\\r\\n\";\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (!handle->requestStarted) {\n\t\treturn UPNP_E_SUCCESS;\n\t}\n\thandle->requestStarted = 0;\n\tif (handle->contentLength == UPNP_USING_CHUNKED)\n\t\t/*send last chunk */\n\t\tretc = sock_write(&handle->sock_info, zcrlf, strlen(zcrlf), &timeout);\n\n\treturn retc >= 0 ? UPNP_E_SUCCESS : UPNP_E_SOCKET_WRITE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpCloseHttpPost(\n\tvoid *handle,\n\tint *httpStatus,\n\tint timeout)\n{\n\tint status = http_EndHttpRequest(handle, timeout);\n\tif (status == UPNP_E_SUCCESS) {\n\t\tstatus = http_GetHttpResponse(handle, NULL, NULL, NULL, httpStatus, timeout);\n\t}\n\tstatus = http_CloseHttpConnection(handle);\n\treturn status;}"
  },
  {
    "function_name": "UpnpWriteHttpPost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3080-3087",
    "snippet": "int UpnpWriteHttpPost(\n\tvoid *handle,\n\tchar *buf,\n\tsize_t *size,\n\tint timeout)\n{\n\treturn http_WriteHttpRequest(handle, buf, size, timeout);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_WriteHttpRequest",
          "args": [
            "handle",
            "buf",
            "size",
            "timeout"
          ],
          "line": 3086
        },
        "resolved": true,
        "details": {
          "function_name": "http_WriteHttpRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1191-1236",
          "snippet": "int http_WriteHttpRequest(void *Handle, char *buf,\n\t\t\t  size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = (http_connection_handle_t *)Handle;\n\tchar *tempbuf = NULL;\n\tsize_t tempbufSize = 0;\n\tint freeTempbuf = 0;\n\tint numWritten = 0;\n\n\tif (!handle || !size || !buf) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\tif (handle->contentLength == UPNP_USING_CHUNKED) {\n\t\tif (*size) {\n\t\t\tsize_t tempSize = 0;\n\t\t\ttempbuf = malloc(*size +\n\t\t\t\t\t CHUNK_HEADER_SIZE + CHUNK_TAIL_SIZE);\n\t\t\tif (!tempbuf)\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t/* begin chunk */\n\t\t\tsprintf(tempbuf, \"%zx\\r\\n\", *size);\n\t\t\ttempSize = strlen(tempbuf);\n\t\t\tmemcpy(tempbuf + tempSize, buf, *size);\n\t\t\tmemcpy(tempbuf + tempSize + *size, \"\\r\\n\", 2);\n\t\t\t/* end of chunk */\n\t\t\ttempbufSize = tempSize + *size + 2;\n\t\t\tfreeTempbuf = 1;\n\t\t}\n\t} else {\n\t\ttempbuf = buf;\n\t\ttempbufSize = *size;\n\t}\n\tnumWritten =\n\t\tsock_write(&handle->sock_info, tempbuf, tempbufSize, &timeout);\n\tif (freeTempbuf)\n\t\tfree(tempbuf);\n\tif (numWritten < 0) {\n\t\t*size = 0;\n\t\treturn numWritten;\n\t} else {\n\t\t*size = (size_t)numWritten;\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n\nint http_WriteHttpRequest(void *Handle, char *buf,\n\t\t\t  size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = (http_connection_handle_t *)Handle;\n\tchar *tempbuf = NULL;\n\tsize_t tempbufSize = 0;\n\tint freeTempbuf = 0;\n\tint numWritten = 0;\n\n\tif (!handle || !size || !buf) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\tif (handle->contentLength == UPNP_USING_CHUNKED) {\n\t\tif (*size) {\n\t\t\tsize_t tempSize = 0;\n\t\t\ttempbuf = malloc(*size +\n\t\t\t\t\t CHUNK_HEADER_SIZE + CHUNK_TAIL_SIZE);\n\t\t\tif (!tempbuf)\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t/* begin chunk */\n\t\t\tsprintf(tempbuf, \"%zx\\r\\n\", *size);\n\t\t\ttempSize = strlen(tempbuf);\n\t\t\tmemcpy(tempbuf + tempSize, buf, *size);\n\t\t\tmemcpy(tempbuf + tempSize + *size, \"\\r\\n\", 2);\n\t\t\t/* end of chunk */\n\t\t\ttempbufSize = tempSize + *size + 2;\n\t\t\tfreeTempbuf = 1;\n\t\t}\n\t} else {\n\t\ttempbuf = buf;\n\t\ttempbufSize = *size;\n\t}\n\tnumWritten =\n\t\tsock_write(&handle->sock_info, tempbuf, tempbufSize, &timeout);\n\tif (freeTempbuf)\n\t\tfree(tempbuf);\n\tif (numWritten < 0) {\n\t\t*size = 0;\n\t\treturn numWritten;\n\t} else {\n\t\t*size = (size_t)numWritten;\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpWriteHttpPost(\n\tvoid *handle,\n\tchar *buf,\n\tsize_t *size,\n\tint timeout)\n{\n\treturn http_WriteHttpRequest(handle, buf, size, timeout);\n}"
  },
  {
    "function_name": "UpnpOpenHttpPost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3064-3077",
    "snippet": "int UpnpOpenHttpPost(\n\tconst char *url,\n\tvoid **handle,\n\tconst char *contentType,\n\tint contentLength,\n\tint timeout)\n{\n\tint status = http_OpenHttpConnection(url, handle, timeout);\n\tif (status == UPNP_E_SUCCESS) {\n\t\treturn http_MakeHttpRequest(HTTPMETHOD_POST, url, handle, NULL, contentType,\n\t\t\t\t\t    contentLength, timeout);\n\t}\n\treturn status;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_MakeHttpRequest",
          "args": [
            "HTTPMETHOD_POST",
            "url",
            "handle",
            "NULL",
            "contentType",
            "contentLength",
            "timeout"
          ],
          "line": 3073
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeHttpRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1162-1189",
          "snippet": "int http_MakeHttpRequest(Upnp_HttpMethod method,\n\t\t\t const char *url_str, void *Handle, UpnpString *headers,\n\t\t\t const char *contentType, int contentLength,\n\t\t\t int timeout)\n{\n\tint ret_code;\n\tmembuffer request;\n\thttp_connection_handle_t *handle = Handle;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (handle->requestStarted) {\n\t\t/* TODO: Log an error that a previous request is already in progress. */\n\t}\n\thandle->requestStarted = 1;\n\thandle->cancel = 0;\n\tret_code = MakeGenericMessage(method, url_str, &request, &url, contentLength,\n\t\t\t\t      contentType, headers);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* send request */\n\tret_code = http_SendMessage(&handle->sock_info, &timeout, \"b\",\n\t\t\t\t    request.buf, request.length);\n\tmembuffer_destroy(&request);\n\thttpmsg_destroy(&handle->response.msg);\n\tparser_response_init(&handle->response, method);\n\treturn ret_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_MakeHttpRequest(Upnp_HttpMethod method,\n\t\t\t const char *url_str, void *Handle, UpnpString *headers,\n\t\t\t const char *contentType, int contentLength,\n\t\t\t int timeout)\n{\n\tint ret_code;\n\tmembuffer request;\n\thttp_connection_handle_t *handle = Handle;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (handle->requestStarted) {\n\t\t/* TODO: Log an error that a previous request is already in progress. */\n\t}\n\thandle->requestStarted = 1;\n\thandle->cancel = 0;\n\tret_code = MakeGenericMessage(method, url_str, &request, &url, contentLength,\n\t\t\t\t      contentType, headers);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* send request */\n\tret_code = http_SendMessage(&handle->sock_info, &timeout, \"b\",\n\t\t\t\t    request.buf, request.length);\n\tmembuffer_destroy(&request);\n\thttpmsg_destroy(&handle->response.msg);\n\tparser_response_init(&handle->response, method);\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_OpenHttpConnection",
          "args": [
            "url",
            "handle",
            "timeout"
          ],
          "line": 3071
        },
        "resolved": true,
        "details": {
          "function_name": "http_OpenHttpConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1103-1160",
          "snippet": "int http_OpenHttpConnection(const char *url_str, void **Handle, int timeout)\n{\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tSOCKET tcp_connection;\n\thttp_connection_handle_t *handle = NULL;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t*Handle = handle;\n\t/* parse url_str */\n\tret_code = http_FixStrUrl(url_str, strlen(url_str), &url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* create the handle */\n\thandle = malloc(sizeof(http_connection_handle_t));\n\tif (!handle) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thandle->requestStarted = 0;\n\tmemset(&handle->response, 0, sizeof(handle->response));\n\t/* connect to the server */\n\ttcp_connection = socket(url.hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tif (sock_init(&handle->sock_info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tsockaddr_len = url.hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(handle->sock_info.socket,\n\t\t\t\t   (struct sockaddr *)&(url.hostport.IPaddress),\n\t\t\t\t   (socklen_t) sockaddr_len);\n\tif (ret_code == -1) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto errorHandler;\n\t}\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t/* For HTTPS connections start the TLS/SSL handshake. */\n\tif (token_string_casecmp(&url.scheme, \"https\") == 0) {\n\t\tret_code = sock_ssl_connect(&handle->sock_info);\n\t\tif (ret_code != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\tgoto errorHandler;\n\t\t}\n\t}\n#endif\nerrorHandler:\n\t*Handle = handle;\n\treturn ret_code;\n\t/* Unused parameter */\n\ttimeout = timeout;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_OpenHttpConnection(const char *url_str, void **Handle, int timeout)\n{\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tSOCKET tcp_connection;\n\thttp_connection_handle_t *handle = NULL;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t*Handle = handle;\n\t/* parse url_str */\n\tret_code = http_FixStrUrl(url_str, strlen(url_str), &url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* create the handle */\n\thandle = malloc(sizeof(http_connection_handle_t));\n\tif (!handle) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thandle->requestStarted = 0;\n\tmemset(&handle->response, 0, sizeof(handle->response));\n\t/* connect to the server */\n\ttcp_connection = socket(url.hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tif (sock_init(&handle->sock_info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tsockaddr_len = url.hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(handle->sock_info.socket,\n\t\t\t\t   (struct sockaddr *)&(url.hostport.IPaddress),\n\t\t\t\t   (socklen_t) sockaddr_len);\n\tif (ret_code == -1) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto errorHandler;\n\t}\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t/* For HTTPS connections start the TLS/SSL handshake. */\n\tif (token_string_casecmp(&url.scheme, \"https\") == 0) {\n\t\tret_code = sock_ssl_connect(&handle->sock_info);\n\t\tif (ret_code != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\tgoto errorHandler;\n\t\t}\n\t}\n#endif\nerrorHandler:\n\t*Handle = handle;\n\treturn ret_code;\n\t/* Unused parameter */\n\ttimeout = timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpOpenHttpPost(\n\tconst char *url,\n\tvoid **handle,\n\tconst char *contentType,\n\tint contentLength,\n\tint timeout)\n{\n\tint status = http_OpenHttpConnection(url, handle, timeout);\n\tif (status == UPNP_E_SUCCESS) {\n\t\treturn http_MakeHttpRequest(HTTPMETHOD_POST, url, handle, NULL, contentType,\n\t\t\t\t\t    contentLength, timeout);\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "UpnpGetServiceVarStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "3008-3052",
    "snippet": "int UpnpGetServiceVarStatus(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *VarName_const,\n\tDOMString *StVar)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0;\n    char *StVarPtr;\n    char *ActionURL = (char *)ActionURL_const;\n    char *VarName = (char *)VarName_const;\n\n    if(UpnpSdkInit != 1) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpGetServiceVarStatus\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( VarName == NULL || StVar == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    retVal = SoapGetServiceVarStatus( ActionURL, VarName, &StVarPtr );\n    *StVar = StVarPtr;\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpGetServiceVarStatus \\n\");\n\n    return retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpGetServiceVarStatus \\n\""
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SoapGetServiceVarStatus",
          "args": [
            "ActionURL",
            "VarName",
            "&StVarPtr"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "SoapGetServiceVarStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "821-885",
          "snippet": "int\nSoapGetServiceVarStatus( IN char *action_url,\n                         IN char *var_name,\n                         OUT char **var_value )\n{\n    const memptr host;                /* value for HOST header */\n    const memptr path;                /* ctrl path in first line in msg */\n    uri_type url;\n    membuffer request;\n    int ret_code;\n    http_parser_t response;\n    int upnp_error_code;\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\\r\\n\"\n        \"<u:QueryStateVariable xmlns:u=\\\"urn:schemas-upnp-org:control-1-0\\\">\\r\\n\"\n        \"<u:varName>\";\n    const char *xml_end =\n        \"</u:varName>\\r\\n\"\n        \"</u:QueryStateVariable>\\r\\n\"\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\";\n\n    *var_value = NULL;          /* return NULL in case of an error */\n    membuffer_init( &request );\n    /* get host hdr and url path */\n    if( get_host_and_path( action_url, &host, &path, &url ) == -1 ) {\n        return UPNP_E_INVALID_URL;\n    }\n    /* make headers */\n    request.size_inc = 50;\n    content_length = (off_t)(strlen(xml_start) + strlen(var_name) +\n\tstrlen(xml_end));\n    if (http_MakeMessage(\n\t&request, 1, 1,\n\t\"Q\" \"sbc\" \"N\" \"s\" \"sc\" \"Ucc\" \"sss\",\n\tSOAPMETHOD_POST, path.buf, path.length,\n\t\"HOST: \", host.buf, host.length,\n\tcontent_length,\n\tContentTypeHeader,\n\t\"SOAPACTION: \\\"urn:schemas-upnp-org:control-1-0#QueryStateVariable\\\"\",\n\txml_start, var_name, xml_end ) != 0 ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    /* send msg and get reply */\n    ret_code = soap_request_and_response( &request, &url, &response );\n    membuffer_destroy( &request );\n    if( ret_code != UPNP_E_SUCCESS ) {\n        return ret_code;\n    }\n    /* get variable value from the response */\n    ret_code = get_response_value( &response.msg, SOAP_VAR_RESP, NULL,\n                                   &upnp_error_code, NULL, var_value );\n    httpmsg_destroy( &response.msg );\n    if( ret_code == SOAP_VAR_RESP ) {\n        return UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_VAR_RESP_ERROR ) {\n        return upnp_error_code;\n    } else {\n        return ret_code;\n    }\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_VAR_RESP_ERROR\t4",
            "#define SOAP_VAR_RESP\t\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_VAR_RESP_ERROR\t4\n#define SOAP_VAR_RESP\t\t2\n\nint\nSoapGetServiceVarStatus( IN char *action_url,\n                         IN char *var_name,\n                         OUT char **var_value )\n{\n    const memptr host;                /* value for HOST header */\n    const memptr path;                /* ctrl path in first line in msg */\n    uri_type url;\n    membuffer request;\n    int ret_code;\n    http_parser_t response;\n    int upnp_error_code;\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\\r\\n\"\n        \"<u:QueryStateVariable xmlns:u=\\\"urn:schemas-upnp-org:control-1-0\\\">\\r\\n\"\n        \"<u:varName>\";\n    const char *xml_end =\n        \"</u:varName>\\r\\n\"\n        \"</u:QueryStateVariable>\\r\\n\"\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\";\n\n    *var_value = NULL;          /* return NULL in case of an error */\n    membuffer_init( &request );\n    /* get host hdr and url path */\n    if( get_host_and_path( action_url, &host, &path, &url ) == -1 ) {\n        return UPNP_E_INVALID_URL;\n    }\n    /* make headers */\n    request.size_inc = 50;\n    content_length = (off_t)(strlen(xml_start) + strlen(var_name) +\n\tstrlen(xml_end));\n    if (http_MakeMessage(\n\t&request, 1, 1,\n\t\"Q\" \"sbc\" \"N\" \"s\" \"sc\" \"Ucc\" \"sss\",\n\tSOAPMETHOD_POST, path.buf, path.length,\n\t\"HOST: \", host.buf, host.length,\n\tcontent_length,\n\tContentTypeHeader,\n\t\"SOAPACTION: \\\"urn:schemas-upnp-org:control-1-0#QueryStateVariable\\\"\",\n\txml_start, var_name, xml_end ) != 0 ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    /* send msg and get reply */\n    ret_code = soap_request_and_response( &request, &url, &response );\n    membuffer_destroy( &request );\n    if( ret_code != UPNP_E_SUCCESS ) {\n        return ret_code;\n    }\n    /* get variable value from the response */\n    ret_code = get_response_value( &response.msg, SOAP_VAR_RESP, NULL,\n                                   &upnp_error_code, NULL, var_value );\n    httpmsg_destroy( &response.msg );\n    if( ret_code == SOAP_VAR_RESP ) {\n        return UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_VAR_RESP_ERROR ) {\n        return upnp_error_code;\n    } else {\n        return ret_code;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpGetServiceVarStatus(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *VarName_const,\n\tDOMString *StVar)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0;\n    char *StVarPtr;\n    char *ActionURL = (char *)ActionURL_const;\n    char *VarName = (char *)VarName_const;\n\n    if(UpnpSdkInit != 1) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpGetServiceVarStatus\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( VarName == NULL || StVar == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    retVal = SoapGetServiceVarStatus( ActionURL, VarName, &StVarPtr );\n    *StVar = StVarPtr;\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpGetServiceVarStatus \\n\");\n\n    return retVal;\n}"
  },
  {
    "function_name": "UpnpGetServiceVarStatusAsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2939-3005",
    "snippet": "int UpnpGetServiceVarStatusAsync(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *VarName_const,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    ThreadPoolJob job;\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n    char *ActionURL = (char *)ActionURL_const;\n    char *VarName = (char *)VarName_const;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpGetServiceVarStatusAsync\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( VarName == NULL || Fun == NULL )\n        return UPNP_E_INVALID_PARAM;\n\n    Param =\n        ( struct UpnpNonblockParam * )\n        malloc( sizeof( struct UpnpNonblockParam ) );\n    if( Param == NULL ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset( Param, 0, sizeof( struct UpnpNonblockParam ) ); \n\n    Param->FunName = STATUS;\n    Param->Handle = Hnd;\n    strncpy( Param->Url, ActionURL, sizeof( Param->Url ) - 1);\n    strncpy( Param->VarName, VarName, sizeof( Param->VarName ) - 1 );\n    Param->Fun = Fun;\n    Param->Cookie = ( void * )Cookie_const;\n\n    TPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n    TPJobSetFreeFunction( &job, ( free_routine ) free );\n\n    TPJobSetPriority( &job, MED_PRIORITY );\n\n    if (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpGetServiceVarStatusAsync\\n\");\n\n    return UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ThreadPool gSendThreadPool;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpGetServiceVarStatusAsync\\n\""
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "Param"
          ],
          "line": 2998
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gSendThreadPool",
            "&job",
            "NULL"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "( free_routine ) free"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "( start_routine ) UpnpThreadDistribution",
            "Param"
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Param->VarName",
            "VarName",
            "sizeof( Param->VarName ) - 1"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Param->Url",
            "ActionURL",
            "sizeof( Param->Url ) - 1"
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Param",
            "0",
            "sizeof( struct UpnpNonblockParam )"
          ],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof( struct UpnpNonblockParam )"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nThreadPool gSendThreadPool;\nint UpnpSdkInit = 0;\n\nint UpnpGetServiceVarStatusAsync(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *VarName_const,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    ThreadPoolJob job;\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n    char *ActionURL = (char *)ActionURL_const;\n    char *VarName = (char *)VarName_const;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpGetServiceVarStatusAsync\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( VarName == NULL || Fun == NULL )\n        return UPNP_E_INVALID_PARAM;\n\n    Param =\n        ( struct UpnpNonblockParam * )\n        malloc( sizeof( struct UpnpNonblockParam ) );\n    if( Param == NULL ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset( Param, 0, sizeof( struct UpnpNonblockParam ) ); \n\n    Param->FunName = STATUS;\n    Param->Handle = Hnd;\n    strncpy( Param->Url, ActionURL, sizeof( Param->Url ) - 1);\n    strncpy( Param->VarName, VarName, sizeof( Param->VarName ) - 1 );\n    Param->Fun = Fun;\n    Param->Cookie = ( void * )Cookie_const;\n\n    TPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n    TPJobSetFreeFunction( &job, ( free_routine ) free );\n\n    TPJobSetPriority( &job, MED_PRIORITY );\n\n    if (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpGetServiceVarStatusAsync\\n\");\n\n    return UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpSendActionExAsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2817-2936",
    "snippet": "int UpnpSendActionExAsync(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Header,\n\tIXML_Document *Act,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n    DOMString tmpStr;\n    DOMString headerStr = NULL;\n    char *ActionURL = ( char * )ActionURL_const;\n    char *ServiceType = ( char * )ServiceType_const;\n    ThreadPoolJob job;\n    int retVal = 0;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendActionExAsync\\n\");\n\n    if( Header == NULL ) {\n        retVal = UpnpSendActionAsync( Hnd, ActionURL_const,\n                                      ServiceType_const, DevUDN_const, Act,\n                                      Fun, Cookie_const );\n        return retVal;\n    }\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServiceType == NULL || Act == NULL || Fun == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    headerStr = ixmlPrintNode( ( IXML_Node * ) Header );\n\n    tmpStr = ixmlPrintNode( ( IXML_Node * ) Act );\n    if( tmpStr == NULL ) {\n        ixmlFreeDOMString( headerStr );\n        return UPNP_E_INVALID_ACTION;\n    }\n\n    Param =\n        ( struct UpnpNonblockParam * )\n        malloc( sizeof( struct UpnpNonblockParam ) );\n    if( Param == NULL ) {\n        ixmlFreeDOMString( tmpStr );\n        ixmlFreeDOMString( headerStr );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset( Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n    Param->FunName = ACTION;\n    Param->Handle = Hnd;\n    strncpy( Param->Url, ActionURL, sizeof( Param->Url ) - 1 );\n    strncpy( Param->ServiceType, ServiceType,\n\tsizeof ( Param->ServiceType ) - 1 );\n    retVal = ixmlParseBufferEx( headerStr, &( Param->Header ) );\n    if( retVal != IXML_SUCCESS ) {\n        free( Param );\n        ixmlFreeDOMString( tmpStr );\n        ixmlFreeDOMString( headerStr );\n        if( retVal == IXML_INSUFFICIENT_MEMORY ) {\n            return UPNP_E_OUTOF_MEMORY;\n        } else {\n            return UPNP_E_INVALID_ACTION;\n        }\n    }\n\n    retVal = ixmlParseBufferEx( tmpStr, &( Param->Act ) );\n    if( retVal != IXML_SUCCESS ) {\n        ixmlDocument_free( Param->Header );\n        free( Param );\n        ixmlFreeDOMString( tmpStr );\n        ixmlFreeDOMString( headerStr );\n        if( retVal == IXML_INSUFFICIENT_MEMORY ) {\n            return UPNP_E_OUTOF_MEMORY;\n        } else {\n            return UPNP_E_INVALID_ACTION;\n        }\n\n    }\n\n    ixmlFreeDOMString( tmpStr );\n    ixmlFreeDOMString( headerStr );\n\n    Param->Cookie = ( void * )Cookie_const;\n    Param->Fun = Fun;\n\n    TPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n    TPJobSetFreeFunction( &job, ( free_routine ) free );\n\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendActionAsync\\n\");\n\n    return UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ThreadPool gSendThreadPool;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpSendActionAsync\\n\""
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "Param"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gSendThreadPool",
            "&job",
            "NULL"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "( free_routine ) free"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "( start_routine ) UpnpThreadDistribution",
            "Param"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "headerStr"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "tmpStr"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "headerStr"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "tmpStr"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "Param->Header"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "tmpStr",
            "&( Param->Act )"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "headerStr"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "tmpStr"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "headerStr",
            "&( Param->Header )"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Param->ServiceType",
            "ServiceType",
            "sizeof ( Param->ServiceType ) - 1"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Param->Url",
            "ActionURL",
            "sizeof( Param->Url ) - 1"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Param",
            "0",
            "sizeof( struct UpnpNonblockParam )"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "headerStr"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "tmpStr"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof( struct UpnpNonblockParam )"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "headerStr"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "( IXML_Node * ) Act"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "( IXML_Node * ) Header"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpSendActionAsync",
          "args": [
            "Hnd",
            "ActionURL_const",
            "ServiceType_const",
            "DevUDN_const",
            "Act",
            "Fun",
            "Cookie_const"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpSendActionAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "2722-2814",
          "snippet": "int UpnpSendActionAsync(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Act,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    int rc;\n    ThreadPoolJob job;\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n    DOMString tmpStr;\n    char *ActionURL = (char *)ActionURL_const;\n    char *ServiceType = (char *)ServiceType_const;\n    /* udn not used? */\n    /*char *DevUDN = (char *)DevUDN_const;*/\n\n    memset(&job, 0, sizeof(job));\n\n    if(UpnpSdkInit != 1) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendActionAsync\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServiceType == NULL ||\n        Act == NULL || Fun == NULL || DevUDN_const != NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    tmpStr = ixmlPrintNode( ( IXML_Node * ) Act );\n    if( tmpStr == NULL ) {\n        return UPNP_E_INVALID_ACTION;\n    }\n\n    Param =\n        ( struct UpnpNonblockParam * )\n        malloc( sizeof( struct UpnpNonblockParam ) );\n\n    if( Param == NULL ) {\n        ixmlFreeDOMString( tmpStr );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset( Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n    Param->FunName = ACTION;\n    Param->Handle = Hnd;\n    strncpy( Param->Url, ActionURL, sizeof ( Param->Url ) - 1 );\n    strncpy( Param->ServiceType, ServiceType,\n\tsizeof ( Param->ServiceType ) - 1 );\n\n    rc = ixmlParseBufferEx( tmpStr, &( Param->Act ) );\n    if( rc != IXML_SUCCESS ) {\n        free( Param );\n        ixmlFreeDOMString( tmpStr );\n        if( rc == IXML_INSUFFICIENT_MEMORY ) {\n            return UPNP_E_OUTOF_MEMORY;\n        } else {\n            return UPNP_E_INVALID_ACTION;\n        }\n    }\n    ixmlFreeDOMString( tmpStr );\n    Param->Cookie = ( void * )Cookie_const;\n    Param->Fun = Fun;\n\n    TPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n    TPJobSetFreeFunction( &job, ( free_routine ) free );\n\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendActionAsync \\n\");\n\n    return UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ThreadPool gSendThreadPool;",
            "int UpnpSdkInit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nThreadPool gSendThreadPool;\nint UpnpSdkInit = 0;\n\nint UpnpSendActionAsync(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Act,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    int rc;\n    ThreadPoolJob job;\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n    DOMString tmpStr;\n    char *ActionURL = (char *)ActionURL_const;\n    char *ServiceType = (char *)ServiceType_const;\n    /* udn not used? */\n    /*char *DevUDN = (char *)DevUDN_const;*/\n\n    memset(&job, 0, sizeof(job));\n\n    if(UpnpSdkInit != 1) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendActionAsync\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServiceType == NULL ||\n        Act == NULL || Fun == NULL || DevUDN_const != NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    tmpStr = ixmlPrintNode( ( IXML_Node * ) Act );\n    if( tmpStr == NULL ) {\n        return UPNP_E_INVALID_ACTION;\n    }\n\n    Param =\n        ( struct UpnpNonblockParam * )\n        malloc( sizeof( struct UpnpNonblockParam ) );\n\n    if( Param == NULL ) {\n        ixmlFreeDOMString( tmpStr );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset( Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n    Param->FunName = ACTION;\n    Param->Handle = Hnd;\n    strncpy( Param->Url, ActionURL, sizeof ( Param->Url ) - 1 );\n    strncpy( Param->ServiceType, ServiceType,\n\tsizeof ( Param->ServiceType ) - 1 );\n\n    rc = ixmlParseBufferEx( tmpStr, &( Param->Act ) );\n    if( rc != IXML_SUCCESS ) {\n        free( Param );\n        ixmlFreeDOMString( tmpStr );\n        if( rc == IXML_INSUFFICIENT_MEMORY ) {\n            return UPNP_E_OUTOF_MEMORY;\n        } else {\n            return UPNP_E_INVALID_ACTION;\n        }\n    }\n    ixmlFreeDOMString( tmpStr );\n    Param->Cookie = ( void * )Cookie_const;\n    Param->Fun = Fun;\n\n    TPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n    TPJobSetFreeFunction( &job, ( free_routine ) free );\n\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendActionAsync \\n\");\n\n    return UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nThreadPool gSendThreadPool;\nint UpnpSdkInit = 0;\n\nint UpnpSendActionExAsync(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Header,\n\tIXML_Document *Act,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n    DOMString tmpStr;\n    DOMString headerStr = NULL;\n    char *ActionURL = ( char * )ActionURL_const;\n    char *ServiceType = ( char * )ServiceType_const;\n    ThreadPoolJob job;\n    int retVal = 0;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendActionExAsync\\n\");\n\n    if( Header == NULL ) {\n        retVal = UpnpSendActionAsync( Hnd, ActionURL_const,\n                                      ServiceType_const, DevUDN_const, Act,\n                                      Fun, Cookie_const );\n        return retVal;\n    }\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServiceType == NULL || Act == NULL || Fun == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    headerStr = ixmlPrintNode( ( IXML_Node * ) Header );\n\n    tmpStr = ixmlPrintNode( ( IXML_Node * ) Act );\n    if( tmpStr == NULL ) {\n        ixmlFreeDOMString( headerStr );\n        return UPNP_E_INVALID_ACTION;\n    }\n\n    Param =\n        ( struct UpnpNonblockParam * )\n        malloc( sizeof( struct UpnpNonblockParam ) );\n    if( Param == NULL ) {\n        ixmlFreeDOMString( tmpStr );\n        ixmlFreeDOMString( headerStr );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset( Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n    Param->FunName = ACTION;\n    Param->Handle = Hnd;\n    strncpy( Param->Url, ActionURL, sizeof( Param->Url ) - 1 );\n    strncpy( Param->ServiceType, ServiceType,\n\tsizeof ( Param->ServiceType ) - 1 );\n    retVal = ixmlParseBufferEx( headerStr, &( Param->Header ) );\n    if( retVal != IXML_SUCCESS ) {\n        free( Param );\n        ixmlFreeDOMString( tmpStr );\n        ixmlFreeDOMString( headerStr );\n        if( retVal == IXML_INSUFFICIENT_MEMORY ) {\n            return UPNP_E_OUTOF_MEMORY;\n        } else {\n            return UPNP_E_INVALID_ACTION;\n        }\n    }\n\n    retVal = ixmlParseBufferEx( tmpStr, &( Param->Act ) );\n    if( retVal != IXML_SUCCESS ) {\n        ixmlDocument_free( Param->Header );\n        free( Param );\n        ixmlFreeDOMString( tmpStr );\n        ixmlFreeDOMString( headerStr );\n        if( retVal == IXML_INSUFFICIENT_MEMORY ) {\n            return UPNP_E_OUTOF_MEMORY;\n        } else {\n            return UPNP_E_INVALID_ACTION;\n        }\n\n    }\n\n    ixmlFreeDOMString( tmpStr );\n    ixmlFreeDOMString( headerStr );\n\n    Param->Cookie = ( void * )Cookie_const;\n    Param->Fun = Fun;\n\n    TPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n    TPJobSetFreeFunction( &job, ( free_routine ) free );\n\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendActionAsync\\n\");\n\n    return UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpSendActionAsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2722-2814",
    "snippet": "int UpnpSendActionAsync(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Act,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    int rc;\n    ThreadPoolJob job;\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n    DOMString tmpStr;\n    char *ActionURL = (char *)ActionURL_const;\n    char *ServiceType = (char *)ServiceType_const;\n    /* udn not used? */\n    /*char *DevUDN = (char *)DevUDN_const;*/\n\n    memset(&job, 0, sizeof(job));\n\n    if(UpnpSdkInit != 1) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendActionAsync\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServiceType == NULL ||\n        Act == NULL || Fun == NULL || DevUDN_const != NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    tmpStr = ixmlPrintNode( ( IXML_Node * ) Act );\n    if( tmpStr == NULL ) {\n        return UPNP_E_INVALID_ACTION;\n    }\n\n    Param =\n        ( struct UpnpNonblockParam * )\n        malloc( sizeof( struct UpnpNonblockParam ) );\n\n    if( Param == NULL ) {\n        ixmlFreeDOMString( tmpStr );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset( Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n    Param->FunName = ACTION;\n    Param->Handle = Hnd;\n    strncpy( Param->Url, ActionURL, sizeof ( Param->Url ) - 1 );\n    strncpy( Param->ServiceType, ServiceType,\n\tsizeof ( Param->ServiceType ) - 1 );\n\n    rc = ixmlParseBufferEx( tmpStr, &( Param->Act ) );\n    if( rc != IXML_SUCCESS ) {\n        free( Param );\n        ixmlFreeDOMString( tmpStr );\n        if( rc == IXML_INSUFFICIENT_MEMORY ) {\n            return UPNP_E_OUTOF_MEMORY;\n        } else {\n            return UPNP_E_INVALID_ACTION;\n        }\n    }\n    ixmlFreeDOMString( tmpStr );\n    Param->Cookie = ( void * )Cookie_const;\n    Param->Fun = Fun;\n\n    TPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n    TPJobSetFreeFunction( &job, ( free_routine ) free );\n\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendActionAsync \\n\");\n\n    return UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ThreadPool gSendThreadPool;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpSendActionAsync \\n\""
          ],
          "line": 2810
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "Param"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gSendThreadPool",
            "&job",
            "NULL"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "( free_routine ) free"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "( start_routine ) UpnpThreadDistribution",
            "Param"
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "tmpStr"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "tmpStr"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "tmpStr",
            "&( Param->Act )"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Param->ServiceType",
            "ServiceType",
            "sizeof ( Param->ServiceType ) - 1"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Param->Url",
            "ActionURL",
            "sizeof ( Param->Url ) - 1"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Param",
            "0",
            "sizeof( struct UpnpNonblockParam )"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "tmpStr"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof( struct UpnpNonblockParam )"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "( IXML_Node * ) Act"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nThreadPool gSendThreadPool;\nint UpnpSdkInit = 0;\n\nint UpnpSendActionAsync(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Act,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    int rc;\n    ThreadPoolJob job;\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n    DOMString tmpStr;\n    char *ActionURL = (char *)ActionURL_const;\n    char *ServiceType = (char *)ServiceType_const;\n    /* udn not used? */\n    /*char *DevUDN = (char *)DevUDN_const;*/\n\n    memset(&job, 0, sizeof(job));\n\n    if(UpnpSdkInit != 1) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendActionAsync\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServiceType == NULL ||\n        Act == NULL || Fun == NULL || DevUDN_const != NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    tmpStr = ixmlPrintNode( ( IXML_Node * ) Act );\n    if( tmpStr == NULL ) {\n        return UPNP_E_INVALID_ACTION;\n    }\n\n    Param =\n        ( struct UpnpNonblockParam * )\n        malloc( sizeof( struct UpnpNonblockParam ) );\n\n    if( Param == NULL ) {\n        ixmlFreeDOMString( tmpStr );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset( Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n    Param->FunName = ACTION;\n    Param->Handle = Hnd;\n    strncpy( Param->Url, ActionURL, sizeof ( Param->Url ) - 1 );\n    strncpy( Param->ServiceType, ServiceType,\n\tsizeof ( Param->ServiceType ) - 1 );\n\n    rc = ixmlParseBufferEx( tmpStr, &( Param->Act ) );\n    if( rc != IXML_SUCCESS ) {\n        free( Param );\n        ixmlFreeDOMString( tmpStr );\n        if( rc == IXML_INSUFFICIENT_MEMORY ) {\n            return UPNP_E_OUTOF_MEMORY;\n        } else {\n            return UPNP_E_INVALID_ACTION;\n        }\n    }\n    ixmlFreeDOMString( tmpStr );\n    Param->Cookie = ( void * )Cookie_const;\n    Param->Fun = Fun;\n\n    TPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n    TPJobSetFreeFunction( &job, ( free_routine ) free );\n\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendActionAsync \\n\");\n\n    return UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpSendActionEx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2666-2719",
    "snippet": "int UpnpSendActionEx(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Header,\n\tIXML_Document *Action,\n\tIXML_Document **RespNodePtr)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0;\n    char *ActionURL = (char *)ActionURL_const;\n    char *ServiceType = (char *)ServiceType_const;\n    /* udn not used? */\n    /*char *DevUDN = (char *)DevUDN_const;*/\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendActionEx\\n\");\n\n    if( Header == NULL ) {\n        retVal = UpnpSendAction( Hnd, ActionURL_const, ServiceType_const,\n                                 DevUDN_const, Action, RespNodePtr );\n        return retVal;\n    }\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServiceType == NULL || Action == NULL || RespNodePtr == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    retVal = SoapSendActionEx( ActionURL, ServiceType, Header,\n                               Action, RespNodePtr );\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendAction \\n\");\n\n    return retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpSendAction \\n\""
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SoapSendActionEx",
          "args": [
            "ActionURL",
            "ServiceType",
            "Header",
            "Action",
            "RespNodePtr"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "SoapSendActionEx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "657-803",
          "snippet": "int SoapSendActionEx(\n\tIN char *action_url,\n\tIN char *service_type,\n\tIN IXML_Document * header,\n\tIN IXML_Document * action_node,\n\tOUT IXML_Document ** response_node )\n{\n    char *xml_header_str = NULL;\n    char *action_str = NULL;\n    memptr name;\n    membuffer request;\n    membuffer responsename;\n    int err_code;\n    int ret_code;\n    http_parser_t response;\n    uri_type url;\n    int upnp_error_code;\n    char *upnp_error_str;\n    int got_response = FALSE;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\";\n    const char *xml_header_start =\n        \"<s:Header>\\r\\n\";\n    const char *xml_header_end =\n        \"</s:Header>\\r\\n\";\n    const char *xml_body_start =\n        \"<s:Body>\";\n    const char *xml_end =\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\";\n    size_t xml_start_len;\n    size_t xml_header_start_len;\n    size_t xml_header_str_len;\n    size_t xml_header_end_len;\n    size_t xml_body_start_len;\n    size_t action_str_len;\n    size_t xml_end_len;\n    off_t content_length;\n\n    *response_node = NULL;      /* init */\n\n    err_code = UPNP_E_OUTOF_MEMORY; /* default error */\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"Inside SoapSendActionEx():\" );\n    /* init */\n    membuffer_init( &request );\n    membuffer_init( &responsename );\n\n    /* header string */\n    xml_header_str = ixmlPrintNode( ( IXML_Node * ) header );\n    if( xml_header_str == NULL ) {\n        goto error_handler;\n    }\n    /* print action */\n    action_str = ixmlPrintNode( ( IXML_Node * ) action_node );\n    if( action_str == NULL ) {\n        goto error_handler;\n    }\n    /* get action name */\n    if( get_action_name( action_str, &name ) != 0 ) {\n        err_code = UPNP_E_INVALID_ACTION;\n        goto error_handler;\n    }\n    /* parse url */\n    if( http_FixStrUrl( action_url, strlen( action_url ), &url ) != 0 ) {\n        err_code = UPNP_E_INVALID_URL;\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"path=%.*s, hostport=%.*s\\n\",\n        (int)url.pathquery.size,\n        url.pathquery.buff,\n        (int)url.hostport.text.size,\n        url.hostport.text.buff );\n\n    xml_start_len = strlen( xml_start );\n    xml_body_start_len = strlen( xml_body_start );\n    xml_end_len = strlen( xml_end );\n    action_str_len = strlen( action_str );\n\n    xml_header_start_len = strlen( xml_header_start );\n    xml_header_end_len = strlen( xml_header_end );\n    xml_header_str_len = strlen( xml_header_str );\n\n    /* make request msg */\n    request.size_inc = 50;\n    content_length = (off_t)(xml_start_len + xml_header_start_len +\n\txml_header_str_len + xml_header_end_len +\n        xml_body_start_len + action_str_len + xml_end_len);\n    if (http_MakeMessage(\n        &request, 1, 1,\n        \"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\" \"b\" \"b\" \"b\" \"b\",\n        SOAPMETHOD_POST, &url,\n        content_length,\n        ContentTypeHeader,\n        \"SOAPACTION: \\\"\", service_type, \"#\", name.buf, name.length, \"\\\"\",\n        xml_start, xml_start_len,\n        xml_header_start, xml_header_start_len,\n        xml_header_str, xml_header_str_len,\n        xml_header_end, xml_header_end_len,\n        xml_body_start, xml_body_start_len,\n        action_str, action_str_len,\n        xml_end, xml_end_len ) != 0 ) {\n        goto error_handler;\n    }\n\n    ret_code = soap_request_and_response( &request, &url, &response );\n    got_response = TRUE;\n    if( ret_code != UPNP_E_SUCCESS ) {\n        err_code = ret_code;\n        goto error_handler;\n    }\n\n    if( membuffer_append( &responsename, name.buf, name.length ) != 0 ||\n        membuffer_append_str( &responsename, \"Response\" ) != 0 ) {\n        goto error_handler;\n    }\n    /* get action node from the response */\n    ret_code = get_response_value( &response.msg, SOAP_ACTION_RESP,\n                                   responsename.buf, &upnp_error_code,\n                                   ( IXML_Node ** ) response_node,\n                                   &upnp_error_str );\n\n    if( ret_code == SOAP_ACTION_RESP ) {\n        err_code = UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_ACTION_RESP_ERROR ) {\n        err_code = upnp_error_code;\n    } else {\n        err_code = ret_code;\n    }\n\n  error_handler:\n\n    ixmlFreeDOMString( action_str );\n    ixmlFreeDOMString( xml_header_str );\n    membuffer_destroy( &request );\n    membuffer_destroy( &responsename );\n    if( got_response ) {\n        httpmsg_destroy( &response.msg );\n    }\n\n    return err_code;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_ACTION_RESP_ERROR  3",
            "#define SOAP_ACTION_RESP\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_ACTION_RESP_ERROR  3\n#define SOAP_ACTION_RESP\t1\n\nint SoapSendActionEx(\n\tIN char *action_url,\n\tIN char *service_type,\n\tIN IXML_Document * header,\n\tIN IXML_Document * action_node,\n\tOUT IXML_Document ** response_node )\n{\n    char *xml_header_str = NULL;\n    char *action_str = NULL;\n    memptr name;\n    membuffer request;\n    membuffer responsename;\n    int err_code;\n    int ret_code;\n    http_parser_t response;\n    uri_type url;\n    int upnp_error_code;\n    char *upnp_error_str;\n    int got_response = FALSE;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\";\n    const char *xml_header_start =\n        \"<s:Header>\\r\\n\";\n    const char *xml_header_end =\n        \"</s:Header>\\r\\n\";\n    const char *xml_body_start =\n        \"<s:Body>\";\n    const char *xml_end =\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\";\n    size_t xml_start_len;\n    size_t xml_header_start_len;\n    size_t xml_header_str_len;\n    size_t xml_header_end_len;\n    size_t xml_body_start_len;\n    size_t action_str_len;\n    size_t xml_end_len;\n    off_t content_length;\n\n    *response_node = NULL;      /* init */\n\n    err_code = UPNP_E_OUTOF_MEMORY; /* default error */\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"Inside SoapSendActionEx():\" );\n    /* init */\n    membuffer_init( &request );\n    membuffer_init( &responsename );\n\n    /* header string */\n    xml_header_str = ixmlPrintNode( ( IXML_Node * ) header );\n    if( xml_header_str == NULL ) {\n        goto error_handler;\n    }\n    /* print action */\n    action_str = ixmlPrintNode( ( IXML_Node * ) action_node );\n    if( action_str == NULL ) {\n        goto error_handler;\n    }\n    /* get action name */\n    if( get_action_name( action_str, &name ) != 0 ) {\n        err_code = UPNP_E_INVALID_ACTION;\n        goto error_handler;\n    }\n    /* parse url */\n    if( http_FixStrUrl( action_url, strlen( action_url ), &url ) != 0 ) {\n        err_code = UPNP_E_INVALID_URL;\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"path=%.*s, hostport=%.*s\\n\",\n        (int)url.pathquery.size,\n        url.pathquery.buff,\n        (int)url.hostport.text.size,\n        url.hostport.text.buff );\n\n    xml_start_len = strlen( xml_start );\n    xml_body_start_len = strlen( xml_body_start );\n    xml_end_len = strlen( xml_end );\n    action_str_len = strlen( action_str );\n\n    xml_header_start_len = strlen( xml_header_start );\n    xml_header_end_len = strlen( xml_header_end );\n    xml_header_str_len = strlen( xml_header_str );\n\n    /* make request msg */\n    request.size_inc = 50;\n    content_length = (off_t)(xml_start_len + xml_header_start_len +\n\txml_header_str_len + xml_header_end_len +\n        xml_body_start_len + action_str_len + xml_end_len);\n    if (http_MakeMessage(\n        &request, 1, 1,\n        \"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\" \"b\" \"b\" \"b\" \"b\",\n        SOAPMETHOD_POST, &url,\n        content_length,\n        ContentTypeHeader,\n        \"SOAPACTION: \\\"\", service_type, \"#\", name.buf, name.length, \"\\\"\",\n        xml_start, xml_start_len,\n        xml_header_start, xml_header_start_len,\n        xml_header_str, xml_header_str_len,\n        xml_header_end, xml_header_end_len,\n        xml_body_start, xml_body_start_len,\n        action_str, action_str_len,\n        xml_end, xml_end_len ) != 0 ) {\n        goto error_handler;\n    }\n\n    ret_code = soap_request_and_response( &request, &url, &response );\n    got_response = TRUE;\n    if( ret_code != UPNP_E_SUCCESS ) {\n        err_code = ret_code;\n        goto error_handler;\n    }\n\n    if( membuffer_append( &responsename, name.buf, name.length ) != 0 ||\n        membuffer_append_str( &responsename, \"Response\" ) != 0 ) {\n        goto error_handler;\n    }\n    /* get action node from the response */\n    ret_code = get_response_value( &response.msg, SOAP_ACTION_RESP,\n                                   responsename.buf, &upnp_error_code,\n                                   ( IXML_Node ** ) response_node,\n                                   &upnp_error_str );\n\n    if( ret_code == SOAP_ACTION_RESP ) {\n        err_code = UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_ACTION_RESP_ERROR ) {\n        err_code = upnp_error_code;\n    } else {\n        err_code = ret_code;\n    }\n\n  error_handler:\n\n    ixmlFreeDOMString( action_str );\n    ixmlFreeDOMString( xml_header_str );\n    membuffer_destroy( &request );\n    membuffer_destroy( &responsename );\n    if( got_response ) {\n        httpmsg_destroy( &response.msg );\n    }\n\n    return err_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpSendAction",
          "args": [
            "Hnd",
            "ActionURL_const",
            "ServiceType_const",
            "DevUDN_const",
            "Action",
            "RespNodePtr"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpSendAction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "2610-2663",
          "snippet": "int UpnpSendAction(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Action,\n\tIXML_Document **RespNodePtr)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0;\n    char *ActionURL = (char *)ActionURL_const;\n    char *ServiceType = (char *)ServiceType_const;\n    /* udn not used? */\n    /*char *DevUDN = (char *)DevUDN_const;*/\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAction\\n\");\n    if (DevUDN_const !=NULL) {\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"non NULL DevUDN is ignored\\n\");\n    }\n    DevUDN_const = NULL;\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    if( ServiceType == NULL || Action == NULL || RespNodePtr == NULL\n        || DevUDN_const != NULL ) {\n\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    retVal = SoapSendAction( ActionURL, ServiceType, Action, RespNodePtr );\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\"Exiting UpnpSendAction\\n\");\n\n    return retVal;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int UpnpSdkInit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpSendAction(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Action,\n\tIXML_Document **RespNodePtr)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0;\n    char *ActionURL = (char *)ActionURL_const;\n    char *ServiceType = (char *)ServiceType_const;\n    /* udn not used? */\n    /*char *DevUDN = (char *)DevUDN_const;*/\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAction\\n\");\n    if (DevUDN_const !=NULL) {\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"non NULL DevUDN is ignored\\n\");\n    }\n    DevUDN_const = NULL;\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    if( ServiceType == NULL || Action == NULL || RespNodePtr == NULL\n        || DevUDN_const != NULL ) {\n\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    retVal = SoapSendAction( ActionURL, ServiceType, Action, RespNodePtr );\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\"Exiting UpnpSendAction\\n\");\n\n    return retVal;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpSendActionEx(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Header,\n\tIXML_Document *Action,\n\tIXML_Document **RespNodePtr)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0;\n    char *ActionURL = (char *)ActionURL_const;\n    char *ServiceType = (char *)ServiceType_const;\n    /* udn not used? */\n    /*char *DevUDN = (char *)DevUDN_const;*/\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendActionEx\\n\");\n\n    if( Header == NULL ) {\n        retVal = UpnpSendAction( Hnd, ActionURL_const, ServiceType_const,\n                                 DevUDN_const, Action, RespNodePtr );\n        return retVal;\n    }\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServiceType == NULL || Action == NULL || RespNodePtr == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    retVal = SoapSendActionEx( ActionURL, ServiceType, Header,\n                               Action, RespNodePtr );\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendAction \\n\");\n\n    return retVal;\n}"
  },
  {
    "function_name": "UpnpSendAction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2610-2663",
    "snippet": "int UpnpSendAction(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Action,\n\tIXML_Document **RespNodePtr)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0;\n    char *ActionURL = (char *)ActionURL_const;\n    char *ServiceType = (char *)ServiceType_const;\n    /* udn not used? */\n    /*char *DevUDN = (char *)DevUDN_const;*/\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAction\\n\");\n    if (DevUDN_const !=NULL) {\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"non NULL DevUDN is ignored\\n\");\n    }\n    DevUDN_const = NULL;\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    if( ServiceType == NULL || Action == NULL || RespNodePtr == NULL\n        || DevUDN_const != NULL ) {\n\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    retVal = SoapSendAction( ActionURL, ServiceType, Action, RespNodePtr );\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\"Exiting UpnpSendAction\\n\");\n\n    return retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpSendAction\\n\""
          ],
          "line": 2659
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SoapSendAction",
          "args": [
            "ActionURL",
            "ServiceType",
            "Action",
            "RespNodePtr"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "SoapSendAction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "517-635",
          "snippet": "int\nSoapSendAction( IN char *action_url,\n                IN char *service_type,\n                IN IXML_Document * action_node,\n                OUT IXML_Document ** response_node )\n{\n    char *action_str = NULL;\n    memptr name;\n    membuffer request;\n    membuffer responsename;\n    int err_code;\n    int ret_code;\n    http_parser_t response;\n    uri_type url;\n    int upnp_error_code;\n    char *upnp_error_str;\n    int got_response = FALSE;\n\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\";\n    const char *xml_end =\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\\r\\n\";\n    size_t xml_start_len;\n    size_t xml_end_len;\n    size_t action_str_len;\n\n    *response_node = NULL;      /* init */\n\n    err_code = UPNP_E_OUTOF_MEMORY; /* default error */\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"Inside SoapSendAction():\" );\n    /* init */\n    membuffer_init( &request );\n    membuffer_init( &responsename );\n\n    /* print action */\n    action_str = ixmlPrintNode( ( IXML_Node * ) action_node );\n    if( action_str == NULL ) {\n        goto error_handler;\n    }\n    /* get action name */\n    if( get_action_name( action_str, &name ) != 0 ) {\n        err_code = UPNP_E_INVALID_ACTION;\n        goto error_handler;\n    }\n    /* parse url */\n    if( http_FixStrUrl( action_url, strlen( action_url ), &url ) != 0 ) {\n        err_code = UPNP_E_INVALID_URL;\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"path=%.*s, hostport=%.*s\\n\",\n        (int)url.pathquery.size,\n        url.pathquery.buff,\n        (int)url.hostport.text.size,\n        url.hostport.text.buff );\n\n    xml_start_len = strlen( xml_start );\n    xml_end_len = strlen( xml_end );\n    action_str_len = strlen( action_str );\n\n    /* make request msg */\n    request.size_inc = 50;\n    content_length = (off_t)(xml_start_len + action_str_len + xml_end_len);\n    if (http_MakeMessage(\n       \t&request, 1, 1,\n        \"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\",\n        SOAPMETHOD_POST, &url, \n        content_length,\n        ContentTypeHeader,\n        \"SOAPACTION: \\\"\", service_type, \"#\", name.buf, name.length, \"\\\"\",\n        xml_start, xml_start_len,\n        action_str, action_str_len,\n        xml_end, xml_end_len ) != 0 ) {\n        goto error_handler;\n    }\n\n    ret_code = soap_request_and_response( &request, &url, &response );\n    got_response = TRUE;\n    if( ret_code != UPNP_E_SUCCESS ) {\n        err_code = ret_code;\n        goto error_handler;\n    }\n\n    if( membuffer_append( &responsename, name.buf, name.length ) != 0 ||\n        membuffer_append_str( &responsename, \"Response\" ) != 0 ) {\n        goto error_handler;\n    }\n    /* get action node from the response */\n    ret_code = get_response_value( &response.msg, SOAP_ACTION_RESP,\n                                   responsename.buf, &upnp_error_code,\n                                   ( IXML_Node ** ) response_node,\n                                   &upnp_error_str );\n\n    if( ret_code == SOAP_ACTION_RESP ) {\n        err_code = UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_ACTION_RESP_ERROR ) {\n        err_code = upnp_error_code;\n    } else {\n        err_code = ret_code;\n    }\n\nerror_handler:\n    ixmlFreeDOMString( action_str );\n    membuffer_destroy( &request );\n    membuffer_destroy( &responsename );\n    if( got_response ) {\n        httpmsg_destroy( &response.msg );\n    }\n\n    return err_code;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_ACTION_RESP_ERROR  3",
            "#define SOAP_ACTION_RESP\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_ACTION_RESP_ERROR  3\n#define SOAP_ACTION_RESP\t1\n\nint\nSoapSendAction( IN char *action_url,\n                IN char *service_type,\n                IN IXML_Document * action_node,\n                OUT IXML_Document ** response_node )\n{\n    char *action_str = NULL;\n    memptr name;\n    membuffer request;\n    membuffer responsename;\n    int err_code;\n    int ret_code;\n    http_parser_t response;\n    uri_type url;\n    int upnp_error_code;\n    char *upnp_error_str;\n    int got_response = FALSE;\n\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\";\n    const char *xml_end =\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\\r\\n\";\n    size_t xml_start_len;\n    size_t xml_end_len;\n    size_t action_str_len;\n\n    *response_node = NULL;      /* init */\n\n    err_code = UPNP_E_OUTOF_MEMORY; /* default error */\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"Inside SoapSendAction():\" );\n    /* init */\n    membuffer_init( &request );\n    membuffer_init( &responsename );\n\n    /* print action */\n    action_str = ixmlPrintNode( ( IXML_Node * ) action_node );\n    if( action_str == NULL ) {\n        goto error_handler;\n    }\n    /* get action name */\n    if( get_action_name( action_str, &name ) != 0 ) {\n        err_code = UPNP_E_INVALID_ACTION;\n        goto error_handler;\n    }\n    /* parse url */\n    if( http_FixStrUrl( action_url, strlen( action_url ), &url ) != 0 ) {\n        err_code = UPNP_E_INVALID_URL;\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"path=%.*s, hostport=%.*s\\n\",\n        (int)url.pathquery.size,\n        url.pathquery.buff,\n        (int)url.hostport.text.size,\n        url.hostport.text.buff );\n\n    xml_start_len = strlen( xml_start );\n    xml_end_len = strlen( xml_end );\n    action_str_len = strlen( action_str );\n\n    /* make request msg */\n    request.size_inc = 50;\n    content_length = (off_t)(xml_start_len + action_str_len + xml_end_len);\n    if (http_MakeMessage(\n       \t&request, 1, 1,\n        \"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\",\n        SOAPMETHOD_POST, &url, \n        content_length,\n        ContentTypeHeader,\n        \"SOAPACTION: \\\"\", service_type, \"#\", name.buf, name.length, \"\\\"\",\n        xml_start, xml_start_len,\n        action_str, action_str_len,\n        xml_end, xml_end_len ) != 0 ) {\n        goto error_handler;\n    }\n\n    ret_code = soap_request_and_response( &request, &url, &response );\n    got_response = TRUE;\n    if( ret_code != UPNP_E_SUCCESS ) {\n        err_code = ret_code;\n        goto error_handler;\n    }\n\n    if( membuffer_append( &responsename, name.buf, name.length ) != 0 ||\n        membuffer_append_str( &responsename, \"Response\" ) != 0 ) {\n        goto error_handler;\n    }\n    /* get action node from the response */\n    ret_code = get_response_value( &response.msg, SOAP_ACTION_RESP,\n                                   responsename.buf, &upnp_error_code,\n                                   ( IXML_Node ** ) response_node,\n                                   &upnp_error_str );\n\n    if( ret_code == SOAP_ACTION_RESP ) {\n        err_code = UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_ACTION_RESP_ERROR ) {\n        err_code = upnp_error_code;\n    } else {\n        err_code = ret_code;\n    }\n\nerror_handler:\n    ixmlFreeDOMString( action_str );\n    membuffer_destroy( &request );\n    membuffer_destroy( &responsename );\n    if( got_response ) {\n        httpmsg_destroy( &response.msg );\n    }\n\n    return err_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpSendAction(\n\tUpnpClient_Handle Hnd,\n\tconst char *ActionURL_const,\n\tconst char *ServiceType_const,\n\tconst char *DevUDN_const,\n\tIXML_Document *Action,\n\tIXML_Document **RespNodePtr)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0;\n    char *ActionURL = (char *)ActionURL_const;\n    char *ServiceType = (char *)ServiceType_const;\n    /* udn not used? */\n    /*char *DevUDN = (char *)DevUDN_const;*/\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAction\\n\");\n    if (DevUDN_const !=NULL) {\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"non NULL DevUDN is ignored\\n\");\n    }\n    DevUDN_const = NULL;\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    HandleUnlock();\n\n    if( ActionURL == NULL ) {\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    if( ServiceType == NULL || Action == NULL || RespNodePtr == NULL\n        || DevUDN_const != NULL ) {\n\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    retVal = SoapSendAction( ActionURL, ServiceType, Action, RespNodePtr );\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\"Exiting UpnpSendAction\\n\");\n\n    return retVal;\n}"
  },
  {
    "function_name": "UpnpAcceptSubscriptionExt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2525-2596",
    "snippet": "int UpnpAcceptSubscriptionExt(\n\tUpnpDevice_Handle Hnd,\n\tconst char *DevID_const,\n\tconst char *ServName_const,\n\tIXML_Document *PropSet,\n\tconst Upnp_SID SubsId)\n{\n\tint ret = 0;\n\tint line = 0;\n\tstruct Handle_Info *SInfo = NULL;\n\tchar *DevID = (char *)DevID_const;\n\tchar *ServName = (char *)ServName_const;\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpAcceptSubscription\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tHandleReadLock();\n\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tif (DevID == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tif (ServName == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tif (SubsId == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\t/* Now accepts an empty state list, so the code below is commented out */\n#if 0\n\tif (PropSet == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n#endif\n\n\tHandleUnlock();\n\n\tline = __LINE__;\n\tret = genaInitNotifyExt(Hnd, DevID, ServName, PropSet, SubsId);\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, line,\n\t\t\"Exiting UpnpAcceptSubscription, ret = %d.\\n\", ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "line",
            "\"Exiting UpnpAcceptSubscription, ret = %d.\\n\"",
            "ret"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "genaInitNotifyExt",
          "args": [
            "Hnd",
            "DevID",
            "ServName",
            "PropSet",
            "SubsId"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "genaInitNotifyExt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "602-754",
          "snippet": "int genaInitNotifyExt(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tIXML_Document *PropSet,\n\tconst Upnp_SID sid)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *sub = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN INITIAL NOTIFY EXT\");\n\t\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t\tgoto ExitFunction;\n\t}\n\n\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\tif (service == NULL) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SERVICE;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SERVICE IN INIT NOTFY EXT: UDN %s, ServID: %s\",\n\t\tUDN, servId);\n\n\tsub = GetSubscriptionSID(sid, service);\n\tif (sub == NULL || sub->active) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SID;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SUBSCRIPTION IN INIT NOTIFY EXT: SID %s\", sid);\n\tsub->active = 1;\n\n\tif (PropSet == 0) {\n\t\tline = __LINE__;\n\t\tret = GENA_SUCCESS;\n\t\tgoto ExitFunction;\n\t}\n\n\tpropertySet = ixmlPrintNode((IXML_Node *)PropSet);\n\tif (propertySet == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN INIT EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\t/* schedule thread for initial notification */\n\n\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\tif (thread_struct == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t} else {\n\t\t*reference_count = 1;\n\t\tthread_struct->servId = servId_copy;\n\t\tthread_struct->UDN = UDN_copy;\n\t\tthread_struct->headers = headers;\n\t\tthread_struct->propertySet = propertySet;\n\t\tmemset(thread_struct->sid, 0, sizeof(thread_struct->sid));\n\t\tstrncpy(thread_struct->sid, sid,\n\t\t\tsizeof(thread_struct->sid) - 1);\n\t\tthread_struct->eventKey = sub->eventKey++;\n\t\tthread_struct->reference_count = reference_count;\n\t\tthread_struct->device_handle = device_handle;\n\n\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\tif (ret != 0) {\n\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_SUCCESS;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || PropSet == 0) {\n\t\tfree(thread_struct);\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END INITIAL NOTIFY EXT, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nint genaInitNotifyExt(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tIXML_Document *PropSet,\n\tconst Upnp_SID sid)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *sub = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN INITIAL NOTIFY EXT\");\n\t\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t\tgoto ExitFunction;\n\t}\n\n\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\tif (service == NULL) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SERVICE;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SERVICE IN INIT NOTFY EXT: UDN %s, ServID: %s\",\n\t\tUDN, servId);\n\n\tsub = GetSubscriptionSID(sid, service);\n\tif (sub == NULL || sub->active) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SID;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SUBSCRIPTION IN INIT NOTIFY EXT: SID %s\", sid);\n\tsub->active = 1;\n\n\tif (PropSet == 0) {\n\t\tline = __LINE__;\n\t\tret = GENA_SUCCESS;\n\t\tgoto ExitFunction;\n\t}\n\n\tpropertySet = ixmlPrintNode((IXML_Node *)PropSet);\n\tif (propertySet == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN INIT EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\t/* schedule thread for initial notification */\n\n\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\tif (thread_struct == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t} else {\n\t\t*reference_count = 1;\n\t\tthread_struct->servId = servId_copy;\n\t\tthread_struct->UDN = UDN_copy;\n\t\tthread_struct->headers = headers;\n\t\tthread_struct->propertySet = propertySet;\n\t\tmemset(thread_struct->sid, 0, sizeof(thread_struct->sid));\n\t\tstrncpy(thread_struct->sid, sid,\n\t\t\tsizeof(thread_struct->sid) - 1);\n\t\tthread_struct->eventKey = sub->eventKey++;\n\t\tthread_struct->reference_count = reference_count;\n\t\tthread_struct->device_handle = device_handle;\n\n\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\tif (ret != 0) {\n\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_SUCCESS;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || PropSet == 0) {\n\t\tfree(thread_struct);\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END INITIAL NOTIFY EXT, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpAcceptSubscriptionExt(\n\tUpnpDevice_Handle Hnd,\n\tconst char *DevID_const,\n\tconst char *ServName_const,\n\tIXML_Document *PropSet,\n\tconst Upnp_SID SubsId)\n{\n\tint ret = 0;\n\tint line = 0;\n\tstruct Handle_Info *SInfo = NULL;\n\tchar *DevID = (char *)DevID_const;\n\tchar *ServName = (char *)ServName_const;\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpAcceptSubscription\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tHandleReadLock();\n\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tif (DevID == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tif (ServName == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tif (SubsId == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\t/* Now accepts an empty state list, so the code below is commented out */\n#if 0\n\tif (PropSet == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n#endif\n\n\tHandleUnlock();\n\n\tline = __LINE__;\n\tret = genaInitNotifyExt(Hnd, DevID, ServName, PropSet, SubsId);\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, line,\n\t\t\"Exiting UpnpAcceptSubscription, ret = %d.\\n\", ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "UpnpAcceptSubscription",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2446-2522",
    "snippet": "int UpnpAcceptSubscription(\n\tUpnpDevice_Handle Hnd,\n\tconst char *DevID_const,\n\tconst char *ServName_const,\n\tconst char **VarName_const,\n\tconst char **NewVal_const,\n\tint cVariables,\n\tconst Upnp_SID SubsId)\n{\n\tint ret = 0;\n\tint line = 0;\n\tstruct Handle_Info *SInfo = NULL;\n\tchar *DevID = (char *)DevID_const;\n\tchar *ServName = (char *)ServName_const;\n\tchar **VarName = (char **)VarName_const;\n\tchar **NewVal = (char **)NewVal_const;\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpAcceptSubscription\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tHandleReadLock();\n\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tif (DevID == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tif (ServName == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tif (SubsId == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\t/* Now accepts an empty state list, so the code below is commented out */\n#if 0\n\tif (VarName == NULL || NewVal == NULL || cVariables < 0) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n#endif\n\n\tHandleUnlock();\n\n\tline = __LINE__;\n\tret = genaInitNotify(\n\t\tHnd, DevID, ServName, VarName, NewVal, cVariables, SubsId);\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, line,\n\t\t\"Exiting UpnpAcceptSubscription, ret = %d\\n\", ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "line",
            "\"Exiting UpnpAcceptSubscription, ret = %d\\n\"",
            "ret"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "genaInitNotify",
          "args": [
            "Hnd",
            "DevID",
            "ServName",
            "VarName",
            "NewVal",
            "cVariables",
            "SubsId"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "genaInitNotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "446-599",
          "snippet": "int genaInitNotify(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tchar **VarNames,\n\tchar **VarValues,\n\tint var_count,\n\tconst Upnp_SID sid)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *sub = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN INITIAL NOTIFY\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif (servId_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t\tgoto ExitFunction;\n\t}\n\n\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\tif (service == NULL) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SERVICE;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SERVICE IN INIT NOTFY: UDN %s, ServID: %s\",\n\t\tUDN, servId);\n\n\tsub = GetSubscriptionSID(sid, service);\n\tif (sub == NULL || sub->active) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SID;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SUBSCRIPTION IN INIT NOTIFY: SID %s\", sid);\n\tsub->active = 1;\n\n\tif (var_count <= 0) {\n\t\tline = __LINE__;\n\t\tret = GENA_SUCCESS;\n\t\tgoto ExitFunction;\n\t}\n\n\tret = GeneratePropertySet(VarNames, VarValues, var_count, &propertySet);\n\tif (ret != XML_SUCCESS) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN INIT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\t/* schedule thread for initial notification */\n\n\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\tif (thread_struct == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t} else {\n\t\t*reference_count = 1;\n\t\tthread_struct->servId = servId_copy;\n\t\tthread_struct->UDN = UDN_copy;\n\t\tthread_struct->headers = headers;\n\t\tthread_struct->propertySet = propertySet;\n\t\tmemset(thread_struct->sid, 0, sizeof(thread_struct->sid));\n\t\tstrncpy(thread_struct->sid, sid,\n\t\t\tsizeof(thread_struct->sid) - 1);\n\t\tthread_struct->eventKey = sub->eventKey++;\n\t\tthread_struct->reference_count = reference_count;\n\t\tthread_struct->device_handle = device_handle;\n\n\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\tif (ret != 0) {\n\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_SUCCESS;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || var_count <= 0) {\n\t\tfree(thread_struct);\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END INITIAL NOTIFY, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nint genaInitNotify(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tchar **VarNames,\n\tchar **VarValues,\n\tint var_count,\n\tconst Upnp_SID sid)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *sub = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN INITIAL NOTIFY\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif (servId_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t\tgoto ExitFunction;\n\t}\n\n\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\tif (service == NULL) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SERVICE;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SERVICE IN INIT NOTFY: UDN %s, ServID: %s\",\n\t\tUDN, servId);\n\n\tsub = GetSubscriptionSID(sid, service);\n\tif (sub == NULL || sub->active) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SID;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SUBSCRIPTION IN INIT NOTIFY: SID %s\", sid);\n\tsub->active = 1;\n\n\tif (var_count <= 0) {\n\t\tline = __LINE__;\n\t\tret = GENA_SUCCESS;\n\t\tgoto ExitFunction;\n\t}\n\n\tret = GeneratePropertySet(VarNames, VarValues, var_count, &propertySet);\n\tif (ret != XML_SUCCESS) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN INIT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\t/* schedule thread for initial notification */\n\n\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\tif (thread_struct == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t} else {\n\t\t*reference_count = 1;\n\t\tthread_struct->servId = servId_copy;\n\t\tthread_struct->UDN = UDN_copy;\n\t\tthread_struct->headers = headers;\n\t\tthread_struct->propertySet = propertySet;\n\t\tmemset(thread_struct->sid, 0, sizeof(thread_struct->sid));\n\t\tstrncpy(thread_struct->sid, sid,\n\t\t\tsizeof(thread_struct->sid) - 1);\n\t\tthread_struct->eventKey = sub->eventKey++;\n\t\tthread_struct->reference_count = reference_count;\n\t\tthread_struct->device_handle = device_handle;\n\n\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\tif (ret != 0) {\n\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_SUCCESS;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || var_count <= 0) {\n\t\tfree(thread_struct);\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END INITIAL NOTIFY, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpAcceptSubscription(\n\tUpnpDevice_Handle Hnd,\n\tconst char *DevID_const,\n\tconst char *ServName_const,\n\tconst char **VarName_const,\n\tconst char **NewVal_const,\n\tint cVariables,\n\tconst Upnp_SID SubsId)\n{\n\tint ret = 0;\n\tint line = 0;\n\tstruct Handle_Info *SInfo = NULL;\n\tchar *DevID = (char *)DevID_const;\n\tchar *ServName = (char *)ServName_const;\n\tchar **VarName = (char **)VarName_const;\n\tchar **NewVal = (char **)NewVal_const;\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpAcceptSubscription\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tHandleReadLock();\n\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tif (DevID == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tif (ServName == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tif (SubsId == NULL) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\t/* Now accepts an empty state list, so the code below is commented out */\n#if 0\n\tif (VarName == NULL || NewVal == NULL || cVariables < 0) {\n\t\tHandleUnlock();\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n#endif\n\n\tHandleUnlock();\n\n\tline = __LINE__;\n\tret = genaInitNotify(\n\t\tHnd, DevID, ServName, VarName, NewVal, cVariables, SubsId);\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, line,\n\t\t\"Exiting UpnpAcceptSubscription, ret = %d\\n\", ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "UpnpNotifyExt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2399-2441",
    "snippet": "int UpnpNotifyExt(\n\tUpnpDevice_Handle Hnd,\n\tconst char *DevID_const,\n\tconst char *ServName_const,\n\tIXML_Document *PropSet)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal;\n    char *DevID = (char *)DevID_const;\n    char *ServName = (char *)ServName_const;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpNotify \\n\" );\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( DevID == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServName == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    HandleUnlock();\n    retVal = genaNotifyAllExt( Hnd, DevID, ServName, PropSet );\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpNotify \\n\" );\n\n    return retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpNotify \\n\""
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "genaNotifyAllExt",
          "args": [
            "Hnd",
            "DevID",
            "ServName",
            "PropSet"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "genaNotifyAllExt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "757-893",
          "snippet": "int genaNotifyAllExt(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tIXML_Document *PropSet)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *finger = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN NOTIFY ALL EXT\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tpropertySet = ixmlPrintNode((IXML_Node *)PropSet);\n\tif (propertySet == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\t\tif (service != NULL) {\n\t\t\tfinger = GetFirstSubscription(service);\n\t\t\twhile (finger) {\n\t\t\t\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\t\t\t\tif (thread_struct == NULL) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t(*reference_count)++;\n\t\t\t\tthread_struct->reference_count = reference_count;\n\t\t\t\tthread_struct->UDN = UDN_copy;\n\t\t\t\tthread_struct->servId = servId_copy;\n\t\t\t\tthread_struct->headers = headers;\n\t\t\t\tthread_struct->propertySet = propertySet;\n\t\t\t\tmemset(thread_struct->sid, 0,\n\t\t\t\t\tsizeof(thread_struct->sid));\n\t\t\t\tstrncpy(thread_struct->sid, finger->sid,\n\t\t\t\t\tsizeof(thread_struct->sid) - 1);\n\t\t\t\tthread_struct->eventKey = finger->eventKey++;\n\t\t\t\tthread_struct->device_handle = device_handle;\n\t\t\t\t/* if overflow, wrap to 1 */\n\t\t\t\tif (finger->eventKey < 0) {\n\t\t\t\t\tfinger->eventKey = 1;\n\t\t\t\t}\n\n\t\t\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\t\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\t\t\tline = __LINE__;\n\t\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfinger = GetNextSubscription(service, finger);\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_E_BAD_SERVICE;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || *reference_count == 0) {\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END NOTIFY ALL EXT, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nint genaNotifyAllExt(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tIXML_Document *PropSet)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *finger = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN NOTIFY ALL EXT\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tpropertySet = ixmlPrintNode((IXML_Node *)PropSet);\n\tif (propertySet == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\t\tif (service != NULL) {\n\t\t\tfinger = GetFirstSubscription(service);\n\t\t\twhile (finger) {\n\t\t\t\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\t\t\t\tif (thread_struct == NULL) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t(*reference_count)++;\n\t\t\t\tthread_struct->reference_count = reference_count;\n\t\t\t\tthread_struct->UDN = UDN_copy;\n\t\t\t\tthread_struct->servId = servId_copy;\n\t\t\t\tthread_struct->headers = headers;\n\t\t\t\tthread_struct->propertySet = propertySet;\n\t\t\t\tmemset(thread_struct->sid, 0,\n\t\t\t\t\tsizeof(thread_struct->sid));\n\t\t\t\tstrncpy(thread_struct->sid, finger->sid,\n\t\t\t\t\tsizeof(thread_struct->sid) - 1);\n\t\t\t\tthread_struct->eventKey = finger->eventKey++;\n\t\t\t\tthread_struct->device_handle = device_handle;\n\t\t\t\t/* if overflow, wrap to 1 */\n\t\t\t\tif (finger->eventKey < 0) {\n\t\t\t\t\tfinger->eventKey = 1;\n\t\t\t\t}\n\n\t\t\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\t\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\t\t\tline = __LINE__;\n\t\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfinger = GetNextSubscription(service, finger);\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_E_BAD_SERVICE;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || *reference_count == 0) {\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END NOTIFY ALL EXT, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpNotifyExt(\n\tUpnpDevice_Handle Hnd,\n\tconst char *DevID_const,\n\tconst char *ServName_const,\n\tIXML_Document *PropSet)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal;\n    char *DevID = (char *)DevID_const;\n    char *ServName = (char *)ServName_const;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpNotify \\n\" );\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( DevID == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServName == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    HandleUnlock();\n    retVal = genaNotifyAllExt( Hnd, DevID, ServName, PropSet );\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpNotify \\n\" );\n\n    return retVal;\n}"
  },
  {
    "function_name": "UpnpNotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2345-2396",
    "snippet": "int UpnpNotify(\n\tUpnpDevice_Handle Hnd,\n\tconst char *DevID_const,\n\tconst char *ServName_const,\n\tconst char **VarName_const,\n\tconst char **NewVal_const,\n\tint cVariables)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal;\n    char *DevID = (char *)DevID_const;\n    char *ServName = (char *)ServName_const;\n    char **VarName = (char **)VarName_const;\n    char **NewVal = (char **)NewVal_const;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpNotify\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( DevID == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServName == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( VarName == NULL || NewVal == NULL || cVariables < 0 ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    HandleUnlock();\n    retVal =\n        genaNotifyAll( Hnd, DevID, ServName, VarName, NewVal, cVariables );\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpNotify\\n\");\n\n    return retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpNotify\\n\""
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "genaNotifyAll",
          "args": [
            "Hnd",
            "DevID",
            "ServName",
            "VarName",
            "NewVal",
            "cVariables"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "genaNotifyAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "896-1034",
          "snippet": "int genaNotifyAll(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tchar **VarNames,\n\tchar **VarValues,\n\tint var_count)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *finger = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN NOTIFY ALL\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tret = GeneratePropertySet(VarNames, VarValues, var_count, &propertySet);\n\tif (ret != XML_SUCCESS) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\t\tif (service != NULL) {\n\t\t\tfinger = GetFirstSubscription(service);\n\t\t\twhile (finger) {\n\t\t\t\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\t\t\t\tif (thread_struct == NULL) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t(*reference_count)++;\n\t\t\t\tthread_struct->reference_count = reference_count;\n\t\t\t\tthread_struct->UDN = UDN_copy;\n\t\t\t\tthread_struct->servId = servId_copy;\n\t\t\t\tthread_struct->headers = headers;\n\t\t\t\tthread_struct->propertySet = propertySet;\n\t\t\t\tmemset(thread_struct->sid, 0,\n\t\t\t\t\tsizeof(thread_struct->sid));\n\t\t\t\tstrncpy(thread_struct->sid, finger->sid,\n\t\t\t\t\tsizeof(thread_struct->sid) - 1);\n\t\t\t\tthread_struct->eventKey = finger->eventKey++;\n\t\t\t\tthread_struct->device_handle = device_handle;\n\t\t\t\t/* if overflow, wrap to 1 */\n\t\t\t\tif (finger->eventKey < 0) {\n\t\t\t\t\tfinger->eventKey = 1;\n\t\t\t\t}\n\n\n\t\t\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\t\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\t\t\tline = __LINE__;\n\t\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfinger = GetNextSubscription(service, finger);\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_E_BAD_SERVICE;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || *reference_count == 0) {\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END NOTIFY ALL, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nint genaNotifyAll(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tchar **VarNames,\n\tchar **VarValues,\n\tint var_count)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *finger = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN NOTIFY ALL\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tret = GeneratePropertySet(VarNames, VarValues, var_count, &propertySet);\n\tif (ret != XML_SUCCESS) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\t\tif (service != NULL) {\n\t\t\tfinger = GetFirstSubscription(service);\n\t\t\twhile (finger) {\n\t\t\t\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\t\t\t\tif (thread_struct == NULL) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t(*reference_count)++;\n\t\t\t\tthread_struct->reference_count = reference_count;\n\t\t\t\tthread_struct->UDN = UDN_copy;\n\t\t\t\tthread_struct->servId = servId_copy;\n\t\t\t\tthread_struct->headers = headers;\n\t\t\t\tthread_struct->propertySet = propertySet;\n\t\t\t\tmemset(thread_struct->sid, 0,\n\t\t\t\t\tsizeof(thread_struct->sid));\n\t\t\t\tstrncpy(thread_struct->sid, finger->sid,\n\t\t\t\t\tsizeof(thread_struct->sid) - 1);\n\t\t\t\tthread_struct->eventKey = finger->eventKey++;\n\t\t\t\tthread_struct->device_handle = device_handle;\n\t\t\t\t/* if overflow, wrap to 1 */\n\t\t\t\tif (finger->eventKey < 0) {\n\t\t\t\t\tfinger->eventKey = 1;\n\t\t\t\t}\n\n\n\t\t\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\t\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\t\t\tline = __LINE__;\n\t\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfinger = GetNextSubscription(service, finger);\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_E_BAD_SERVICE;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || *reference_count == 0) {\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END NOTIFY ALL, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpNotify(\n\tUpnpDevice_Handle Hnd,\n\tconst char *DevID_const,\n\tconst char *ServName_const,\n\tconst char **VarName_const,\n\tconst char **NewVal_const,\n\tint cVariables)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal;\n    char *DevID = (char *)DevID_const;\n    char *ServName = (char *)ServName_const;\n    char **VarName = (char **)VarName_const;\n    char **NewVal = (char **)NewVal_const;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpNotify\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( DevID == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( ServName == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( VarName == NULL || NewVal == NULL || cVariables < 0 ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    HandleUnlock();\n    retVal =\n        genaNotifyAll( Hnd, DevID, ServName, VarName, NewVal, cVariables );\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpNotify\\n\");\n\n    return retVal;\n}"
  },
  {
    "function_name": "UpnpRenewSubscriptionAsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2273-2340",
    "snippet": "int UpnpRenewSubscriptionAsync(\n\tUpnpClient_Handle Hnd,\n\tint TimeOut,\n\tUpnp_SID SubsId,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    ThreadPoolJob job;\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpRenewSubscriptionAsync\\n\");\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( TimeOut != UPNP_INFINITE && TimeOut < 1 ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( SubsId == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( Fun == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    HandleUnlock();\n\n    Param =\n        ( struct UpnpNonblockParam * )\n        malloc( sizeof( struct UpnpNonblockParam ) );\n    if( Param == NULL ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset(Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n    Param->FunName = RENEW;\n    Param->Handle = Hnd;\n    strncpy( Param->SubsId, SubsId, sizeof( Param->SubsId ) - 1 );\n    Param->Fun = Fun;\n    Param->Cookie = ( void * )Cookie_const;\n    Param->TimeOut = TimeOut;\n\n    TPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n    TPJobSetFreeFunction( &job, ( free_routine ) free );\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpRenewSubscriptionAsync\\n\");\n\n    return UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ThreadPool gSendThreadPool;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpRenewSubscriptionAsync\\n\""
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "Param"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gSendThreadPool",
            "&job",
            "NULL"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "( free_routine ) free"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "( start_routine ) UpnpThreadDistribution",
            "Param"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Param->SubsId",
            "SubsId",
            "sizeof( Param->SubsId ) - 1"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Param",
            "0",
            "sizeof( struct UpnpNonblockParam )"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof( struct UpnpNonblockParam )"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nThreadPool gSendThreadPool;\nint UpnpSdkInit = 0;\n\nint UpnpRenewSubscriptionAsync(\n\tUpnpClient_Handle Hnd,\n\tint TimeOut,\n\tUpnp_SID SubsId,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    ThreadPoolJob job;\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpRenewSubscriptionAsync\\n\");\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( TimeOut != UPNP_INFINITE && TimeOut < 1 ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( SubsId == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( Fun == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    HandleUnlock();\n\n    Param =\n        ( struct UpnpNonblockParam * )\n        malloc( sizeof( struct UpnpNonblockParam ) );\n    if( Param == NULL ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset(Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n    Param->FunName = RENEW;\n    Param->Handle = Hnd;\n    strncpy( Param->SubsId, SubsId, sizeof( Param->SubsId ) - 1 );\n    Param->Fun = Fun;\n    Param->Cookie = ( void * )Cookie_const;\n    Param->TimeOut = TimeOut;\n\n    TPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n    TPJobSetFreeFunction( &job, ( free_routine ) free );\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpRenewSubscriptionAsync\\n\");\n\n    return UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpRenewSubscription",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2217-2268",
    "snippet": "int UpnpRenewSubscription(\n\tUpnpClient_Handle Hnd,\n\tint *TimeOut,\n\tconst Upnp_SID SubsId)\n{\n\tstruct Handle_Info *SInfo = NULL;\n\tint retVal;\n\tUpnpString *SubsIdTmp = UpnpString_new();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"Inside UpnpRenewSubscription\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (SubsIdTmp == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tif (SubsId == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tUpnpString_set_String(SubsIdTmp, SubsId);\n\n\tif (TimeOut == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\n\tHandleReadLock();\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tHandleUnlock();\n\n\tretVal = genaRenewSubscription(Hnd, SubsIdTmp, TimeOut);\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpRenewSubscription, retVal=%d\\n\", retVal);\n\n\tUpnpString_delete(SubsIdTmp);\n\n\treturn retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpString_delete",
          "args": [
            "SubsIdTmp"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "99-111",
          "snippet": "void UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nvoid UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpRenewSubscription, retVal=%d\\n\"",
            "retVal"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "genaRenewSubscription",
          "args": [
            "Hnd",
            "SubsIdTmp",
            "TimeOut"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "genaRenewSubscription",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "598-693",
          "snippet": "int genaRenewSubscription(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid,\n\tint *TimeOut)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *sub = NULL;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tstruct Handle_Info *handle_info;\n\tUpnpString *ActualSID = UpnpString_new();\n\tThreadPoolJob tempJob;\n\n\tHandleLock();\n\n\t/* validate handle and sid */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* remove old events */\n\tif (TimerThreadRemove(\n\t\t&gTimerThread,\n\t\tGenlibClientSubscription_get_RenewEventId(sub),\n\t\t&tempJob) == 0 ) {\n\t\tfree_upnp_timeout((upnp_timeout *)tempJob.arg);\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"REMOVED AUTO RENEW  EVENT\");\n\n\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\n\tHandleUnlock();\n\n\treturn_code = gena_subscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tTimeOut,\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\tActualSID);\n\n\tHandleLock();\n\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\t/* we just called GetHandleInfo, so we don't check for return value */\n\t/*GetHandleInfo(client_handle, &handle_info); */\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\t/* network failure (remove client sub) */\n\t\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription */\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* store actual sid */\n\tGenlibClientSubscription_set_ActualSID(sub, ActualSID);\n\n\t/* start renew subscription timer */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, sub);\n\tif (return_code != GENA_SUCCESS) {\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub));\n\t}\n\tfree_client_subscription(sub_copy);\n\tHandleUnlock();\n\nexit_function:\n\tUpnpString_delete(ActualSID);\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nint genaRenewSubscription(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid,\n\tint *TimeOut)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *sub = NULL;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tstruct Handle_Info *handle_info;\n\tUpnpString *ActualSID = UpnpString_new();\n\tThreadPoolJob tempJob;\n\n\tHandleLock();\n\n\t/* validate handle and sid */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* remove old events */\n\tif (TimerThreadRemove(\n\t\t&gTimerThread,\n\t\tGenlibClientSubscription_get_RenewEventId(sub),\n\t\t&tempJob) == 0 ) {\n\t\tfree_upnp_timeout((upnp_timeout *)tempJob.arg);\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"REMOVED AUTO RENEW  EVENT\");\n\n\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\n\tHandleUnlock();\n\n\treturn_code = gena_subscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tTimeOut,\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\tActualSID);\n\n\tHandleLock();\n\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\t/* we just called GetHandleInfo, so we don't check for return value */\n\t/*GetHandleInfo(client_handle, &handle_info); */\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\t/* network failure (remove client sub) */\n\t\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription */\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* store actual sid */\n\tGenlibClientSubscription_set_ActualSID(sub, ActualSID);\n\n\t/* start renew subscription timer */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, sub);\n\tif (return_code != GENA_SUCCESS) {\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub));\n\t}\n\tfree_client_subscription(sub_copy);\n\tHandleUnlock();\n\nexit_function:\n\tUpnpString_delete(ActualSID);\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_set_String",
          "args": [
            "SubsIdTmp",
            "SubsId"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_set_String",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "160-170",
          "snippet": "int UpnpString_set_String(UpnpString *p, const char *s)\n{\n\tchar *q = strdup(s);\n\tif (!q) goto error_handler1;\n\tfree(((struct SUpnpString *)p)->m_string);\n\t((struct SUpnpString *)p)->m_length = strlen(q);\n\t((struct SUpnpString *)p)->m_string = q;\n\nerror_handler1:\n\treturn q != NULL;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nint UpnpString_set_String(UpnpString *p, const char *s)\n{\n\tchar *q = strdup(s);\n\tif (!q) goto error_handler1;\n\tfree(((struct SUpnpString *)p)->m_string);\n\t((struct SUpnpString *)p)->m_length = strlen(q);\n\t((struct SUpnpString *)p)->m_string = q;\n\nerror_handler1:\n\treturn q != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_new",
          "args": [],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "73-97",
          "snippet": "UpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nUpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpRenewSubscription(\n\tUpnpClient_Handle Hnd,\n\tint *TimeOut,\n\tconst Upnp_SID SubsId)\n{\n\tstruct Handle_Info *SInfo = NULL;\n\tint retVal;\n\tUpnpString *SubsIdTmp = UpnpString_new();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"Inside UpnpRenewSubscription\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (SubsIdTmp == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tif (SubsId == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tUpnpString_set_String(SubsIdTmp, SubsId);\n\n\tif (TimeOut == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\n\tHandleReadLock();\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tHandleUnlock();\n\n\tretVal = genaRenewSubscription(Hnd, SubsIdTmp, TimeOut);\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpRenewSubscription, retVal=%d\\n\", retVal);\n\n\tUpnpString_delete(SubsIdTmp);\n\n\treturn retVal;\n}"
  },
  {
    "function_name": "UpnpUnSubscribeAsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2149-2212",
    "snippet": "int UpnpUnSubscribeAsync(\n\tUpnpClient_Handle Hnd,\n\tUpnp_SID SubsId,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tThreadPoolJob job;\n\tstruct Handle_Info *SInfo = NULL;\n\tstruct UpnpNonblockParam *Param;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"Inside UpnpUnSubscribeAsync\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (SubsId == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tif (Fun == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\n\tHandleReadLock();\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tHandleUnlock();\n\n\tParam = (struct UpnpNonblockParam *)malloc(sizeof(struct UpnpNonblockParam));\n\tif (Param == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tmemset( Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n\tParam->FunName = UNSUBSCRIBE;\n\tParam->Handle = Hnd;\n\tstrncpy( Param->SubsId, SubsId, sizeof( Param->SubsId ) - 1 );\n\tParam->Fun = Fun;\n\tParam->Cookie = (void *)Cookie_const;\n\tTPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n\tTPJobSetFreeFunction( &job, ( free_routine ) free );\n\tTPJobSetPriority( &job, MED_PRIORITY );\n\tif (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\t\tfree(Param);\n\t}\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"Exiting UpnpUnSubscribeAsync\\n\");\n\n\treturn retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ThreadPool gSendThreadPool;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpUnSubscribeAsync\\n\""
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "Param"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gSendThreadPool",
            "&job",
            "NULL"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "( free_routine ) free"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "( start_routine ) UpnpThreadDistribution",
            "Param"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Param->SubsId",
            "SubsId",
            "sizeof( Param->SubsId ) - 1"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Param",
            "0",
            "sizeof( struct UpnpNonblockParam )"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct UpnpNonblockParam)"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nThreadPool gSendThreadPool;\nint UpnpSdkInit = 0;\n\nint UpnpUnSubscribeAsync(\n\tUpnpClient_Handle Hnd,\n\tUpnp_SID SubsId,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tThreadPoolJob job;\n\tstruct Handle_Info *SInfo = NULL;\n\tstruct UpnpNonblockParam *Param;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"Inside UpnpUnSubscribeAsync\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (SubsId == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tif (Fun == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\n\tHandleReadLock();\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tHandleUnlock();\n\n\tParam = (struct UpnpNonblockParam *)malloc(sizeof(struct UpnpNonblockParam));\n\tif (Param == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tmemset( Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n\tParam->FunName = UNSUBSCRIBE;\n\tParam->Handle = Hnd;\n\tstrncpy( Param->SubsId, SubsId, sizeof( Param->SubsId ) - 1 );\n\tParam->Fun = Fun;\n\tParam->Cookie = (void *)Cookie_const;\n\tTPJobInit( &job, ( start_routine ) UpnpThreadDistribution, Param );\n\tTPJobSetFreeFunction( &job, ( free_routine ) free );\n\tTPJobSetPriority( &job, MED_PRIORITY );\n\tif (ThreadPoolAdd( &gSendThreadPool, &job, NULL ) != 0) {\n\t\tfree(Param);\n\t}\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"Exiting UpnpUnSubscribeAsync\\n\");\n\n\treturn retVal;\n}"
  },
  {
    "function_name": "UpnpUnSubscribe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2101-2144",
    "snippet": "int UpnpUnSubscribe(UpnpClient_Handle Hnd, const Upnp_SID SubsId)\n{\n\tstruct Handle_Info *SInfo = NULL;\n\tint retVal;\n\tUpnpString *SubsIdTmp = UpnpString_new();\n\n\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__, \"Inside UpnpUnSubscribe\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (SubsIdTmp == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tif (SubsId == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tUpnpString_set_String(SubsIdTmp, SubsId);\n\n\tHandleReadLock();\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tHandleUnlock();\n\n\tretVal = genaUnSubscribe(Hnd, SubsIdTmp);\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpUnSubscribe, retVal=%d\\n\", retVal);\n\n\tUpnpString_delete(SubsIdTmp);\n\n\treturn retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpString_delete",
          "args": [
            "SubsIdTmp"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "99-111",
          "snippet": "void UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nvoid UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpUnSubscribe, retVal=%d\\n\"",
            "retVal"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "genaUnSubscribe",
          "args": [
            "Hnd",
            "SubsIdTmp"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "genaUnSubscribe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "457-504",
          "snippet": "int genaUnSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid)\n{\n\tGenlibClientSubscription *sub = NULL;\n\tint return_code = GENA_SUCCESS;\n\tstruct Handle_Info *handle_info;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\thttp_parser_t response;\n\n\t/* validate handle and sid */\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\tHandleUnlock();\n\n\treturn_code = gena_unsubscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\t&response);\n\tif (return_code == 0) {\n\t\thttpmsg_destroy(&response.msg);\n\t}\n\tfree_client_subscription(sub_copy);\n\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\tHandleUnlock();\n\nexit_function:\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nint genaUnSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid)\n{\n\tGenlibClientSubscription *sub = NULL;\n\tint return_code = GENA_SUCCESS;\n\tstruct Handle_Info *handle_info;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\thttp_parser_t response;\n\n\t/* validate handle and sid */\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\tHandleUnlock();\n\n\treturn_code = gena_unsubscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\t&response);\n\tif (return_code == 0) {\n\t\thttpmsg_destroy(&response.msg);\n\t}\n\tfree_client_subscription(sub_copy);\n\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\tHandleUnlock();\n\nexit_function:\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_set_String",
          "args": [
            "SubsIdTmp",
            "SubsId"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_set_String",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "160-170",
          "snippet": "int UpnpString_set_String(UpnpString *p, const char *s)\n{\n\tchar *q = strdup(s);\n\tif (!q) goto error_handler1;\n\tfree(((struct SUpnpString *)p)->m_string);\n\t((struct SUpnpString *)p)->m_length = strlen(q);\n\t((struct SUpnpString *)p)->m_string = q;\n\nerror_handler1:\n\treturn q != NULL;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nint UpnpString_set_String(UpnpString *p, const char *s)\n{\n\tchar *q = strdup(s);\n\tif (!q) goto error_handler1;\n\tfree(((struct SUpnpString *)p)->m_string);\n\t((struct SUpnpString *)p)->m_length = strlen(q);\n\t((struct SUpnpString *)p)->m_string = q;\n\nerror_handler1:\n\treturn q != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_new",
          "args": [],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "73-97",
          "snippet": "UpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nUpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpUnSubscribe(UpnpClient_Handle Hnd, const Upnp_SID SubsId)\n{\n\tstruct Handle_Info *SInfo = NULL;\n\tint retVal;\n\tUpnpString *SubsIdTmp = UpnpString_new();\n\n\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__, \"Inside UpnpUnSubscribe\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (SubsIdTmp == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tif (SubsId == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tUpnpString_set_String(SubsIdTmp, SubsId);\n\n\tHandleReadLock();\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tHandleUnlock();\n\n\tretVal = genaUnSubscribe(Hnd, SubsIdTmp);\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpUnSubscribe, retVal=%d\\n\", retVal);\n\n\tUpnpString_delete(SubsIdTmp);\n\n\treturn retVal;\n}"
  },
  {
    "function_name": "UpnpSubscribe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "2030-2096",
    "snippet": "int UpnpSubscribe(\n\tUpnpClient_Handle Hnd,\n\tconst char *EvtUrl_const,\n\tint *TimeOut,\n\tUpnp_SID SubsId)\n{\n\tint retVal;\n\tstruct Handle_Info *SInfo = NULL;\n\tUpnpString *EvtUrl = UpnpString_new();\n\tUpnpString *SubsIdTmp = UpnpString_new();\n\t\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"Inside UpnpSubscribe\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (EvtUrl == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tif (EvtUrl_const == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tUpnpString_set_String(EvtUrl, EvtUrl_const);\n\n\tif (SubsIdTmp == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tif (SubsId == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tUpnpString_set_String(SubsIdTmp, SubsId);\n\n\tif (TimeOut == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\n\tHandleReadLock();\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tHandleUnlock();\n\n\tretVal = genaSubscribe(Hnd, EvtUrl, TimeOut, SubsIdTmp);\n\tmemset(SubsId, 0, sizeof(Upnp_SID));\n\tstrncpy(SubsId, UpnpString_get_String(SubsIdTmp), sizeof(Upnp_SID) - 1);\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpSubscribe, retVal=%d\\n\", retVal);\n\n\tUpnpString_delete(SubsIdTmp);\n\tUpnpString_delete(EvtUrl);\n\n\treturn retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpString_delete",
          "args": [
            "EvtUrl"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "99-111",
          "snippet": "void UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nvoid UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpSubscribe, retVal=%d\\n\"",
            "retVal"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "SubsId",
            "UpnpString_get_String(SubsIdTmp)",
            "sizeof(Upnp_SID) - 1"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_get_String",
          "args": [
            "SubsIdTmp"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_get_String",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "155-158",
          "snippet": "const char *UpnpString_get_String(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_string;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nconst char *UpnpString_get_String(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "SubsId",
            "0",
            "sizeof(Upnp_SID)"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "genaSubscribe",
          "args": [
            "Hnd",
            "EvtUrl",
            "TimeOut",
            "SubsIdTmp"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "genaSubscribe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "509-594",
          "snippet": "int genaSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *PublisherURL,\n\tint *TimeOut,\n\tUpnpString *out_sid)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *newSubscription = GenlibClientSubscription_new();\n\tuuid_upnp uid;\n\tUpnp_SID temp_sid;\n\tUpnp_SID temp_sid2;\n\tUpnpString *ActualSID = UpnpString_new();\n\tUpnpString *EventURL = UpnpString_new();\n\tstruct Handle_Info *handle_info;\n\tint rc = 0;\n\n\tmemset(temp_sid, 0, sizeof(temp_sid));\n\tmemset(temp_sid2, 0, sizeof(temp_sid2));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"GENA SUBSCRIBE BEGIN\");\n\n\tUpnpString_clear(out_sid);\n\n\tHandleReadLock();\n\t/* validate handle */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tSubscribeLock();\n\t\tgoto error_handler;\n\t}\n\tHandleUnlock();\n\n\t/* subscribe */\n\tSubscribeLock();\n\treturn_code = gena_subscribe(PublisherURL, TimeOut, NULL, ActualSID);\n\tHandleLock();\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf( UPNP_CRITICAL, GENA, __FILE__, __LINE__,\n\t\t\t\"SUBSCRIBE FAILED in transfer error code: %d returned\\n\",\n\t\t\treturn_code );\n\t\tgoto error_handler;\n\t}\n\n\tif(GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto error_handler;\n\t}\n\n\t/* generate client SID */\n\tuuid_create(&uid );\n\tuuid_unpack(&uid, temp_sid);\n\trc = snprintf(temp_sid2, sizeof(temp_sid2), \"uuid:%s\", temp_sid);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(temp_sid2)) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tUpnpString_set_String(out_sid, temp_sid2);\n\n\t/* create event url */\n\tUpnpString_assign(EventURL, PublisherURL);\n\n\t/* fill subscription */\n\tif (newSubscription == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tGenlibClientSubscription_set_RenewEventId(newSubscription, -1);\n\tGenlibClientSubscription_set_SID(newSubscription, out_sid);\n\tGenlibClientSubscription_set_ActualSID(newSubscription, ActualSID);\n\tGenlibClientSubscription_set_EventURL(newSubscription, EventURL);\n\tGenlibClientSubscription_set_Next(newSubscription, handle_info->ClientSubList);\n\thandle_info->ClientSubList = newSubscription;\n\n\t/* schedule expiration event */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, newSubscription);\n\nerror_handler:\n\tUpnpString_delete(ActualSID);\n\tUpnpString_delete(EventURL);\n\tif (return_code != UPNP_E_SUCCESS)\n\t\tGenlibClientSubscription_delete(newSubscription);\n\tHandleUnlock();\n\tSubscribeUnlock();\n\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint genaSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *PublisherURL,\n\tint *TimeOut,\n\tUpnpString *out_sid)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *newSubscription = GenlibClientSubscription_new();\n\tuuid_upnp uid;\n\tUpnp_SID temp_sid;\n\tUpnp_SID temp_sid2;\n\tUpnpString *ActualSID = UpnpString_new();\n\tUpnpString *EventURL = UpnpString_new();\n\tstruct Handle_Info *handle_info;\n\tint rc = 0;\n\n\tmemset(temp_sid, 0, sizeof(temp_sid));\n\tmemset(temp_sid2, 0, sizeof(temp_sid2));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"GENA SUBSCRIBE BEGIN\");\n\n\tUpnpString_clear(out_sid);\n\n\tHandleReadLock();\n\t/* validate handle */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tSubscribeLock();\n\t\tgoto error_handler;\n\t}\n\tHandleUnlock();\n\n\t/* subscribe */\n\tSubscribeLock();\n\treturn_code = gena_subscribe(PublisherURL, TimeOut, NULL, ActualSID);\n\tHandleLock();\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf( UPNP_CRITICAL, GENA, __FILE__, __LINE__,\n\t\t\t\"SUBSCRIBE FAILED in transfer error code: %d returned\\n\",\n\t\t\treturn_code );\n\t\tgoto error_handler;\n\t}\n\n\tif(GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto error_handler;\n\t}\n\n\t/* generate client SID */\n\tuuid_create(&uid );\n\tuuid_unpack(&uid, temp_sid);\n\trc = snprintf(temp_sid2, sizeof(temp_sid2), \"uuid:%s\", temp_sid);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(temp_sid2)) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tUpnpString_set_String(out_sid, temp_sid2);\n\n\t/* create event url */\n\tUpnpString_assign(EventURL, PublisherURL);\n\n\t/* fill subscription */\n\tif (newSubscription == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tGenlibClientSubscription_set_RenewEventId(newSubscription, -1);\n\tGenlibClientSubscription_set_SID(newSubscription, out_sid);\n\tGenlibClientSubscription_set_ActualSID(newSubscription, ActualSID);\n\tGenlibClientSubscription_set_EventURL(newSubscription, EventURL);\n\tGenlibClientSubscription_set_Next(newSubscription, handle_info->ClientSubList);\n\thandle_info->ClientSubList = newSubscription;\n\n\t/* schedule expiration event */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, newSubscription);\n\nerror_handler:\n\tUpnpString_delete(ActualSID);\n\tUpnpString_delete(EventURL);\n\tif (return_code != UPNP_E_SUCCESS)\n\t\tGenlibClientSubscription_delete(newSubscription);\n\tHandleUnlock();\n\tSubscribeUnlock();\n\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_set_String",
          "args": [
            "SubsIdTmp",
            "SubsId"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_set_String",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "160-170",
          "snippet": "int UpnpString_set_String(UpnpString *p, const char *s)\n{\n\tchar *q = strdup(s);\n\tif (!q) goto error_handler1;\n\tfree(((struct SUpnpString *)p)->m_string);\n\t((struct SUpnpString *)p)->m_length = strlen(q);\n\t((struct SUpnpString *)p)->m_string = q;\n\nerror_handler1:\n\treturn q != NULL;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nint UpnpString_set_String(UpnpString *p, const char *s)\n{\n\tchar *q = strdup(s);\n\tif (!q) goto error_handler1;\n\tfree(((struct SUpnpString *)p)->m_string);\n\t((struct SUpnpString *)p)->m_length = strlen(q);\n\t((struct SUpnpString *)p)->m_string = q;\n\nerror_handler1:\n\treturn q != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_new",
          "args": [],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "73-97",
          "snippet": "UpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nUpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpSubscribe(\n\tUpnpClient_Handle Hnd,\n\tconst char *EvtUrl_const,\n\tint *TimeOut,\n\tUpnp_SID SubsId)\n{\n\tint retVal;\n\tstruct Handle_Info *SInfo = NULL;\n\tUpnpString *EvtUrl = UpnpString_new();\n\tUpnpString *SubsIdTmp = UpnpString_new();\n\t\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"Inside UpnpSubscribe\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (EvtUrl == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tif (EvtUrl_const == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tUpnpString_set_String(EvtUrl, EvtUrl_const);\n\n\tif (SubsIdTmp == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tif (SubsId == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\tUpnpString_set_String(SubsIdTmp, SubsId);\n\n\tif (TimeOut == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\n\tHandleReadLock();\n\tswitch (GetHandleInfo(Hnd, &SInfo)) {\n\tcase HND_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tHandleUnlock();\n\n\tretVal = genaSubscribe(Hnd, EvtUrl, TimeOut, SubsIdTmp);\n\tmemset(SubsId, 0, sizeof(Upnp_SID));\n\tstrncpy(SubsId, UpnpString_get_String(SubsIdTmp), sizeof(Upnp_SID) - 1);\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpSubscribe, retVal=%d\\n\", retVal);\n\n\tUpnpString_delete(SubsIdTmp);\n\tUpnpString_delete(EvtUrl);\n\n\treturn retVal;\n}"
  },
  {
    "function_name": "UpnpSubscribeAsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1956-2025",
    "snippet": "int UpnpSubscribeAsync(\n\tUpnpClient_Handle Hnd,\n\tconst char *EvtUrl_const,\n\tint TimeOut,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n    char *EvtUrl = ( char * )EvtUrl_const;\n    ThreadPoolJob job;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSubscribeAsync\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( EvtUrl == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( TimeOut != UPNP_INFINITE && TimeOut < 1 ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( Fun == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    HandleUnlock();\n\n    Param = (struct UpnpNonblockParam *)\n        malloc(sizeof (struct UpnpNonblockParam));\n    if( Param == NULL ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset( Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n    Param->FunName = SUBSCRIBE;\n    Param->Handle = Hnd;\n    strncpy( Param->Url, EvtUrl, sizeof( Param->Url ) - 1 );\n    Param->TimeOut = TimeOut;\n    Param->Fun = Fun;\n    Param->Cookie = (void *)Cookie_const;\n\n    TPJobInit(&job, (start_routine)UpnpThreadDistribution, Param);\n    TPJobSetFreeFunction(&job, (free_routine)free);\n    TPJobSetPriority(&job, MED_PRIORITY);\n    if (ThreadPoolAdd(&gSendThreadPool, &job, NULL) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSubscribeAsync\\n\");\n\n    return UPNP_E_SUCCESS;\n\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ThreadPool gSendThreadPool;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpSubscribeAsync\\n\""
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "Param"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gSendThreadPool",
            "&job",
            "NULL"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "(free_routine)free"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine)UpnpThreadDistribution",
            "Param"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Param->Url",
            "EvtUrl",
            "sizeof( Param->Url ) - 1"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Param",
            "0",
            "sizeof( struct UpnpNonblockParam )"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (struct UpnpNonblockParam)"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nThreadPool gSendThreadPool;\nint UpnpSdkInit = 0;\n\nint UpnpSubscribeAsync(\n\tUpnpClient_Handle Hnd,\n\tconst char *EvtUrl_const,\n\tint TimeOut,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie_const)\n{\n    struct Handle_Info *SInfo = NULL;\n    struct UpnpNonblockParam *Param;\n    char *EvtUrl = ( char * )EvtUrl_const;\n    ThreadPoolJob job;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSubscribeAsync\\n\");\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( EvtUrl == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( TimeOut != UPNP_INFINITE && TimeOut < 1 ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    if( Fun == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n    HandleUnlock();\n\n    Param = (struct UpnpNonblockParam *)\n        malloc(sizeof (struct UpnpNonblockParam));\n    if( Param == NULL ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    memset( Param, 0, sizeof( struct UpnpNonblockParam ) );\n\n    Param->FunName = SUBSCRIBE;\n    Param->Handle = Hnd;\n    strncpy( Param->Url, EvtUrl, sizeof( Param->Url ) - 1 );\n    Param->TimeOut = TimeOut;\n    Param->Fun = Fun;\n    Param->Cookie = (void *)Cookie_const;\n\n    TPJobInit(&job, (start_routine)UpnpThreadDistribution, Param);\n    TPJobSetFreeFunction(&job, (free_routine)free);\n    TPJobSetPriority(&job, MED_PRIORITY);\n    if (ThreadPoolAdd(&gSendThreadPool, &job, NULL) != 0) {\n\tfree(Param);\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSubscribeAsync\\n\");\n\n    return UPNP_E_SUCCESS;\n\n}"
  },
  {
    "function_name": "UpnpSetMaxSubscriptionTimeOut",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1917-1951",
    "snippet": "int UpnpSetMaxSubscriptionTimeOut(UpnpDevice_Handle Hnd, int MaxSubscriptionTimeOut)\n{\n    struct Handle_Info *SInfo = NULL;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSetMaxSubscriptionTimeOut\\n\" );\n\n    HandleLock();\n\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n        case HND_DEVICE:\n            break;\n        default:\n            HandleUnlock();\n            return UPNP_E_INVALID_HANDLE;\n    }\n    if( ( MaxSubscriptionTimeOut != UPNP_INFINITE )\n          && ( MaxSubscriptionTimeOut < 0 ) ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n\n    SInfo->MaxSubscriptionTimeOut = MaxSubscriptionTimeOut;\n    HandleUnlock();\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSetMaxSubscriptionTimeOut\\n\");\n\n    return UPNP_E_SUCCESS;\n\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpSetMaxSubscriptionTimeOut\\n\""
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpSetMaxSubscriptionTimeOut(UpnpDevice_Handle Hnd, int MaxSubscriptionTimeOut)\n{\n    struct Handle_Info *SInfo = NULL;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSetMaxSubscriptionTimeOut\\n\" );\n\n    HandleLock();\n\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n        case HND_DEVICE:\n            break;\n        default:\n            HandleUnlock();\n            return UPNP_E_INVALID_HANDLE;\n    }\n    if( ( MaxSubscriptionTimeOut != UPNP_INFINITE )\n          && ( MaxSubscriptionTimeOut < 0 ) ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n\n    SInfo->MaxSubscriptionTimeOut = MaxSubscriptionTimeOut;\n    HandleUnlock();\n\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSetMaxSubscriptionTimeOut\\n\");\n\n    return UPNP_E_SUCCESS;\n\n}"
  },
  {
    "function_name": "UpnpSetMaxSubscriptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1880-1912",
    "snippet": "int UpnpSetMaxSubscriptions(UpnpDevice_Handle Hnd, int MaxSubscriptions)\n{\n    struct Handle_Info *SInfo = NULL;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSetMaxSubscriptions \\n\" );\n\n    HandleLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n        case HND_DEVICE:\n            break;\n        default:\n            HandleUnlock();\n            return UPNP_E_INVALID_HANDLE;\n    }\n    if( ( MaxSubscriptions != UPNP_INFINITE )\n          && ( MaxSubscriptions < 0 ) ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    SInfo->MaxSubscriptions = MaxSubscriptions;\n    HandleUnlock();\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSetMaxSubscriptions \\n\" );\n\n    return UPNP_E_SUCCESS;\n\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpSetMaxSubscriptions \\n\""
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpSetMaxSubscriptions(UpnpDevice_Handle Hnd, int MaxSubscriptions)\n{\n    struct Handle_Info *SInfo = NULL;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSetMaxSubscriptions \\n\" );\n\n    HandleLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n        case HND_DEVICE:\n            break;\n        default:\n            HandleUnlock();\n            return UPNP_E_INVALID_HANDLE;\n    }\n    if( ( MaxSubscriptions != UPNP_INFINITE )\n          && ( MaxSubscriptions < 0 ) ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    SInfo->MaxSubscriptions = MaxSubscriptions;\n    HandleUnlock();\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSetMaxSubscriptions \\n\" );\n\n    return UPNP_E_SUCCESS;\n\n}"
  },
  {
    "function_name": "UpnpSearchAsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1823-1866",
    "snippet": "int UpnpSearchAsync(\n\tUpnpClient_Handle Hnd,\n\tint Mx,\n\tconst char *Target_const,\n\tconst void *Cookie_const )\n{\n    struct Handle_Info *SInfo = NULL;\n    char *Target = ( char * )Target_const;\n    int retVal;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSearchAsync\\n\" );\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( Mx < 1 )\n        Mx = DEFAULT_MX;\n\n    if( Target == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    HandleUnlock();\n    retVal = SearchByTarget( Mx, Target, ( void * )Cookie_const );\n    if (retVal != 1)\n        return retVal;\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSearchAsync \\n\" );\n\n    return UPNP_E_SUCCESS;\n\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpSearchAsync \\n\""
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SearchByTarget",
          "args": [
            "Mx",
            "Target",
            "( void * )Cookie_const"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "SearchByTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_ctrlpt.c",
          "lines": "510-674",
          "snippet": "int SearchByTarget(int Mx, char *St, void *Cookie)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tint *id = NULL;\n\tint ret = 0;\n\tchar ReqBufv4[BUFSIZE];\n#ifdef UPNP_ENABLE_IPV6\n\tchar ReqBufv6[BUFSIZE];\n\tchar ReqBufv6UlaGua[BUFSIZE];\n#endif\n\tstruct sockaddr_storage __ss_v4;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n#endif\n\tstruct sockaddr_in *destAddr4 = (struct sockaddr_in *)&__ss_v4;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_in6 *destAddr6 = (struct sockaddr_in6 *)&__ss_v6;\n#endif\n\tfd_set wrSet;\n\tSsdpSearchArg *newArg = NULL;\n\tint timeTillRead = 0;\n\tint handle;\n\tstruct Handle_Info *ctrlpt_info = NULL;\n\tenum SsdpSearchType requestType;\n\tunsigned long addrv4 = inet_addr(gIF_IPV4);\n\tSOCKET max_fd = 0;\n\tint retVal;\n\n\t/*ThreadData *ThData; */\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequestType = ssdp_request_type1(St);\n\tif (requestType == SSDP_SERROR)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t   \"Inside SearchByTarget\\n\");\n\ttimeTillRead = Mx;\n\tif (timeTillRead < MIN_SEARCH_TIME)\n\t\ttimeTillRead = MIN_SEARCH_TIME;\n\telse if (timeTillRead > MAX_SEARCH_TIME)\n\t\ttimeTillRead = MAX_SEARCH_TIME;\n\tretVal = CreateClientRequestPacket(ReqBufv4, sizeof(ReqBufv4), timeTillRead, St, AF_INET);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n#ifdef UPNP_ENABLE_IPV6\n\tretVal = CreateClientRequestPacket(ReqBufv6, sizeof(ReqBufv6), timeTillRead, St, AF_INET6);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n\tretVal = CreateClientRequestPacketUlaGua(ReqBufv6UlaGua, sizeof(ReqBufv6UlaGua), timeTillRead, St, AF_INET6);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n#endif\n\n\tmemset(&__ss_v4, 0, sizeof(__ss_v4));\n\tdestAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, SSDP_IP, &destAddr4->sin_addr);\n\tdestAddr4->sin_port = htons(SSDP_PORT);\n\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof(__ss_v6));\n\tdestAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, SSDP_IPV6_SITELOCAL, &destAddr6->sin6_addr);\n\tdestAddr6->sin6_port = htons(SSDP_PORT);\n\tdestAddr6->sin6_scope_id = gIF_INDEX;\n#endif\n\n\t/* add search criteria to list */\n\tHandleLock();\n\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tnewArg = (SsdpSearchArg *) malloc(sizeof(SsdpSearchArg));\n\tnewArg->searchTarget = strdup(St);\n\tnewArg->cookie = Cookie;\n\tnewArg->requestType = requestType;\n\tid = (int *)malloc(sizeof(int));\n\tTPJobInit(&job, (start_routine) searchExpired, id);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tTPJobSetFreeFunction(&job, (free_routine) free);\n\t/* Schedule a timeout event to remove search Arg */\n\tTimerThreadSchedule(&gTimerThread, timeTillRead,\n\t\t\t    REL_SEC, &job, SHORT_TERM, id);\n\tnewArg->timeoutEventId = *id;\n\tListAddTail(&ctrlpt_info->SsdpSearchList, newArg);\n\tHandleUnlock();\n\t/* End of lock */\n\n\tFD_ZERO(&wrSet);\n\tif (gSsdpReqSocket4 != INVALID_SOCKET) {\n\t\tsetsockopt(gSsdpReqSocket4, IPPROTO_IP, IP_MULTICAST_IF,\n\t\t\t   (char *)&addrv4, sizeof(addrv4));\n\t\tFD_SET(gSsdpReqSocket4, &wrSet);\n\t\tmax_fd = max(max_fd, gSsdpReqSocket4);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (gSsdpReqSocket6 != INVALID_SOCKET) {\n\t\tsetsockopt(gSsdpReqSocket6, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n\t\t\t   (char *)&gIF_INDEX, sizeof(gIF_INDEX));\n\t\tFD_SET(gSsdpReqSocket6, &wrSet);\n\t\tmax_fd = max(max_fd, gSsdpReqSocket6);\n\t}\n#endif\n\tret = select(max_fd + 1, NULL, &wrSet, NULL, NULL);\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"SSDP_LIB: Error in select(): %s\\n\", errorBuffer);\n\t\tUpnpCloseSocket(gSsdpReqSocket4);\n#ifdef UPNP_ENABLE_IPV6\n\t\tUpnpCloseSocket(gSsdpReqSocket6);\n#endif\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (gSsdpReqSocket6 != INVALID_SOCKET &&\n\t    FD_ISSET(gSsdpReqSocket6, &wrSet)) {\n\t\tint NumCopy = 0;\n\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv6UlaGua);\n\t\t\tsendto(gSsdpReqSocket6,\n\t\t\t       ReqBufv6UlaGua, strlen(ReqBufv6UlaGua), 0,\n\t\t\t       (struct sockaddr *)&__ss_v6,\n\t\t\t       sizeof(struct sockaddr_in6));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t\tNumCopy = 0;\n\t\tinet_pton(AF_INET6, SSDP_IPV6_LINKLOCAL, &destAddr6->sin6_addr);\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv6);\n\t\t\tsendto(gSsdpReqSocket6,\n\t\t\t       ReqBufv6, strlen(ReqBufv6), 0,\n\t\t\t       (struct sockaddr *)&__ss_v6,\n\t\t\t       sizeof(struct sockaddr_in6));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t}\n#endif /* IPv6 */\n\tif (gSsdpReqSocket4 != INVALID_SOCKET &&\n\t    FD_ISSET(gSsdpReqSocket4, &wrSet)) {\n\t\tint NumCopy = 0;\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv4);\n\t\t\tsendto(gSsdpReqSocket4,\n\t\t\t       ReqBufv4, strlen(ReqBufv4), 0,\n\t\t\t       (struct sockaddr *)&__ss_v4,\n\t\t\t       sizeof(struct sockaddr_in));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"ThreadPool.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ssdp_ResultData.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"upnputil.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include \"ThreadPool.h\"\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ssdp_ResultData.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"upnputil.h\"\n#include \"config.h\"\n\nint SearchByTarget(int Mx, char *St, void *Cookie)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tint *id = NULL;\n\tint ret = 0;\n\tchar ReqBufv4[BUFSIZE];\n#ifdef UPNP_ENABLE_IPV6\n\tchar ReqBufv6[BUFSIZE];\n\tchar ReqBufv6UlaGua[BUFSIZE];\n#endif\n\tstruct sockaddr_storage __ss_v4;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n#endif\n\tstruct sockaddr_in *destAddr4 = (struct sockaddr_in *)&__ss_v4;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_in6 *destAddr6 = (struct sockaddr_in6 *)&__ss_v6;\n#endif\n\tfd_set wrSet;\n\tSsdpSearchArg *newArg = NULL;\n\tint timeTillRead = 0;\n\tint handle;\n\tstruct Handle_Info *ctrlpt_info = NULL;\n\tenum SsdpSearchType requestType;\n\tunsigned long addrv4 = inet_addr(gIF_IPV4);\n\tSOCKET max_fd = 0;\n\tint retVal;\n\n\t/*ThreadData *ThData; */\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequestType = ssdp_request_type1(St);\n\tif (requestType == SSDP_SERROR)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t   \"Inside SearchByTarget\\n\");\n\ttimeTillRead = Mx;\n\tif (timeTillRead < MIN_SEARCH_TIME)\n\t\ttimeTillRead = MIN_SEARCH_TIME;\n\telse if (timeTillRead > MAX_SEARCH_TIME)\n\t\ttimeTillRead = MAX_SEARCH_TIME;\n\tretVal = CreateClientRequestPacket(ReqBufv4, sizeof(ReqBufv4), timeTillRead, St, AF_INET);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n#ifdef UPNP_ENABLE_IPV6\n\tretVal = CreateClientRequestPacket(ReqBufv6, sizeof(ReqBufv6), timeTillRead, St, AF_INET6);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n\tretVal = CreateClientRequestPacketUlaGua(ReqBufv6UlaGua, sizeof(ReqBufv6UlaGua), timeTillRead, St, AF_INET6);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n#endif\n\n\tmemset(&__ss_v4, 0, sizeof(__ss_v4));\n\tdestAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, SSDP_IP, &destAddr4->sin_addr);\n\tdestAddr4->sin_port = htons(SSDP_PORT);\n\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof(__ss_v6));\n\tdestAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, SSDP_IPV6_SITELOCAL, &destAddr6->sin6_addr);\n\tdestAddr6->sin6_port = htons(SSDP_PORT);\n\tdestAddr6->sin6_scope_id = gIF_INDEX;\n#endif\n\n\t/* add search criteria to list */\n\tHandleLock();\n\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tnewArg = (SsdpSearchArg *) malloc(sizeof(SsdpSearchArg));\n\tnewArg->searchTarget = strdup(St);\n\tnewArg->cookie = Cookie;\n\tnewArg->requestType = requestType;\n\tid = (int *)malloc(sizeof(int));\n\tTPJobInit(&job, (start_routine) searchExpired, id);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tTPJobSetFreeFunction(&job, (free_routine) free);\n\t/* Schedule a timeout event to remove search Arg */\n\tTimerThreadSchedule(&gTimerThread, timeTillRead,\n\t\t\t    REL_SEC, &job, SHORT_TERM, id);\n\tnewArg->timeoutEventId = *id;\n\tListAddTail(&ctrlpt_info->SsdpSearchList, newArg);\n\tHandleUnlock();\n\t/* End of lock */\n\n\tFD_ZERO(&wrSet);\n\tif (gSsdpReqSocket4 != INVALID_SOCKET) {\n\t\tsetsockopt(gSsdpReqSocket4, IPPROTO_IP, IP_MULTICAST_IF,\n\t\t\t   (char *)&addrv4, sizeof(addrv4));\n\t\tFD_SET(gSsdpReqSocket4, &wrSet);\n\t\tmax_fd = max(max_fd, gSsdpReqSocket4);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (gSsdpReqSocket6 != INVALID_SOCKET) {\n\t\tsetsockopt(gSsdpReqSocket6, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n\t\t\t   (char *)&gIF_INDEX, sizeof(gIF_INDEX));\n\t\tFD_SET(gSsdpReqSocket6, &wrSet);\n\t\tmax_fd = max(max_fd, gSsdpReqSocket6);\n\t}\n#endif\n\tret = select(max_fd + 1, NULL, &wrSet, NULL, NULL);\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"SSDP_LIB: Error in select(): %s\\n\", errorBuffer);\n\t\tUpnpCloseSocket(gSsdpReqSocket4);\n#ifdef UPNP_ENABLE_IPV6\n\t\tUpnpCloseSocket(gSsdpReqSocket6);\n#endif\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (gSsdpReqSocket6 != INVALID_SOCKET &&\n\t    FD_ISSET(gSsdpReqSocket6, &wrSet)) {\n\t\tint NumCopy = 0;\n\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv6UlaGua);\n\t\t\tsendto(gSsdpReqSocket6,\n\t\t\t       ReqBufv6UlaGua, strlen(ReqBufv6UlaGua), 0,\n\t\t\t       (struct sockaddr *)&__ss_v6,\n\t\t\t       sizeof(struct sockaddr_in6));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t\tNumCopy = 0;\n\t\tinet_pton(AF_INET6, SSDP_IPV6_LINKLOCAL, &destAddr6->sin6_addr);\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv6);\n\t\t\tsendto(gSsdpReqSocket6,\n\t\t\t       ReqBufv6, strlen(ReqBufv6), 0,\n\t\t\t       (struct sockaddr *)&__ss_v6,\n\t\t\t       sizeof(struct sockaddr_in6));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t}\n#endif /* IPv6 */\n\tif (gSsdpReqSocket4 != INVALID_SOCKET &&\n\t    FD_ISSET(gSsdpReqSocket4, &wrSet)) {\n\t\tint NumCopy = 0;\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv4);\n\t\t\tsendto(gSsdpReqSocket4,\n\t\t\t       ReqBufv4, strlen(ReqBufv4), 0,\n\t\t\t       (struct sockaddr *)&__ss_v4,\n\t\t\t       sizeof(struct sockaddr_in));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\n\nint UpnpSearchAsync(\n\tUpnpClient_Handle Hnd,\n\tint Mx,\n\tconst char *Target_const,\n\tconst void *Cookie_const )\n{\n    struct Handle_Info *SInfo = NULL;\n    char *Target = ( char * )Target_const;\n    int retVal;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSearchAsync\\n\" );\n\n    HandleReadLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_CLIENT:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( Mx < 1 )\n        Mx = DEFAULT_MX;\n\n    if( Target == NULL ) {\n        HandleUnlock();\n        return UPNP_E_INVALID_PARAM;\n    }\n\n    HandleUnlock();\n    retVal = SearchByTarget( Mx, Target, ( void * )Cookie_const );\n    if (retVal != 1)\n        return retVal;\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSearchAsync \\n\" );\n\n    return UPNP_E_SUCCESS;\n\n}"
  },
  {
    "function_name": "UpnpSendAdvertisementLowPower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1713-1814",
    "snippet": "int UpnpSendAdvertisementLowPower(UpnpDevice_Handle Hnd, int Exp,\n    int PowerState, int SleepPeriod, int RegistrationState)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0,\n     *ptrMx;\n    upnp_timeout *adEvent;\n    ThreadPoolJob job;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAdvertisementLowPower \\n\" );\n\n    HandleLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( Exp < 1 )\n        Exp = DEFAULT_MAXAGE;\n    SInfo->MaxAge = Exp;\n    SInfo->PowerState = PowerState;\n    if( SleepPeriod < 0 )\n        SleepPeriod = -1;\n    SInfo->SleepPeriod = SleepPeriod;\n    SInfo->RegistrationState = RegistrationState;\n    HandleUnlock();\n    retVal = AdvertiseAndReply( 1, Hnd, ( enum SsdpSearchType )0,\n                                ( struct sockaddr * )NULL, ( char * )NULL,\n                                ( char * )NULL, ( char * )NULL, Exp );\n\n    if( retVal != UPNP_E_SUCCESS )\n        return retVal;\n    ptrMx = ( int * )malloc( sizeof( int ) );\n    if( ptrMx == NULL )\n        return UPNP_E_OUTOF_MEMORY;\n    adEvent = ( upnp_timeout * ) malloc( sizeof( upnp_timeout ) );\n\n    if( adEvent == NULL ) {\n        free( ptrMx );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    *ptrMx = Exp;\n    adEvent->handle = Hnd;\n    adEvent->Event = ptrMx;\n\n    HandleLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return UPNP_E_INVALID_HANDLE;\n    }\n#ifdef SSDP_PACKET_DISTRIBUTE\n    TPJobInit( &job, ( start_routine ) AutoAdvertise, adEvent );\n    TPJobSetFreeFunction( &job, ( free_routine ) free_upnp_timeout );\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if( ( retVal = TimerThreadSchedule( &gTimerThread,\n                                        ( ( Exp / 2 ) -\n                                          ( AUTO_ADVERTISEMENT_TIME ) ),\n                                        REL_SEC, &job, SHORT_TERM,\n                                        &( adEvent->eventId ) ) )\n        != UPNP_E_SUCCESS ) {\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return retVal;\n    }\n#else\n    TPJobInit( &job, ( start_routine ) AutoAdvertise, adEvent );\n    TPJobSetFreeFunction( &job, ( free_routine ) free_upnp_timeout );\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if( ( retVal = TimerThreadSchedule( &gTimerThread,\n                                        Exp - AUTO_ADVERTISEMENT_TIME,\n                                        REL_SEC, &job, SHORT_TERM,\n                                        &( adEvent->eventId ) ) )\n        != UPNP_E_SUCCESS ) {\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return retVal;\n    }\n#endif\n\n    HandleUnlock();\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendAdvertisementLowPower \\n\" );\n\n    return retVal;\n\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "TimerThread gTimerThread;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpSendAdvertisementLowPower \\n\""
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptrMx"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimerThreadSchedule",
          "args": [
            "&gTimerThread",
            "Exp - AUTO_ADVERTISEMENT_TIME",
            "REL_SEC",
            "&job",
            "SHORT_TERM",
            "&( adEvent->eventId )"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "( free_routine ) free_upnp_timeout"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "( start_routine ) AutoAdvertise",
            "adEvent"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimerThreadSchedule",
          "args": [
            "&gTimerThread",
            "( ( Exp / 2 ) -\n                                          ( AUTO_ADVERTISEMENT_TIME ) )",
            "REL_SEC",
            "&job",
            "SHORT_TERM",
            "&( adEvent->eventId )"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "( free_routine ) free_upnp_timeout"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "( start_routine ) AutoAdvertise",
            "adEvent"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof( upnp_timeout )"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof( int )"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvertiseAndReply",
          "args": [
            "1",
            "Hnd",
            "( enum SsdpSearchType )0",
            "( struct sockaddr * )NULL",
            "( char * )NULL",
            "( char * )NULL",
            "( char * )NULL",
            "Exp"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "AdvertiseAndReply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "92-445",
          "snippet": "int AdvertiseAndReply(int AdFlag, UpnpDevice_Handle Hnd,\n\t\t      enum SsdpSearchType SearchType,\n\t\t      struct sockaddr *DestAddr, char *DeviceType,\n\t\t      char *DeviceUDN, char *ServiceType, int Exp)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tlong unsigned int i;\n\tlong unsigned int j;\n\tint defaultExp = DEFAULT_MAXAGE;\n\tstruct Handle_Info *SInfo = NULL;\n\tchar UDNstr[100];\n\tchar devType[100];\n\tchar servType[100];\n\tIXML_NodeList *nodeList = NULL;\n\tIXML_NodeList *tmpNodeList = NULL;\n\tIXML_Node *tmpNode = NULL;\n\tIXML_Node *tmpNode2 = NULL;\n\tIXML_Node *textNode = NULL;\n\tconst DOMString tmpStr;\n\tconst DOMString dbgStr;\n\tint NumCopy = 0;\n\n\tmemset(UDNstr, 0, sizeof(UDNstr));\n\tmemset(devType, 0, sizeof(devType));\n\tmemset(servType, 0, sizeof(servType));\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside AdvertiseAndReply with AdFlag = %d\\n\", AdFlag);\n\n\t/* Use a read lock */\n\tHandleReadLock();\n\tif (GetHandleInfo(Hnd, &SInfo) != HND_DEVICE) {\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto end_function;\n\t}\n\tdefaultExp = SInfo->MaxAge;\n\t/* parse the device list and send advertisements/replies */\n\twhile (NumCopy == 0 || (AdFlag && NumCopy < NUM_SSDP_COPY)) {\n\t\tif (NumCopy != 0)\n\t\t\timillisleep(SSDP_PAUSE);\n\t\tNumCopy++;\n\t\tfor (i = 0lu;; i++) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Entering new device list with i = %lu\\n\\n\",\n\t\t\t\t   i);\n\t\t\ttmpNode = ixmlNodeList_item(SInfo->DeviceList, i);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Exiting new device list with i = %lu\\n\\n\",\n\t\t\t\t\t   i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type once for %s\\n\",\n\t\t\t\t   dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"deviceType\");\n\t\t\tif (!nodeList)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type\\n\");\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2)\n\t\t\t\tcontinue;\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type \\n\");\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr)\n\t\t\t\tcontinue;\n\t\t\tstrncpy(devType, tmpStr, sizeof(devType) - 1);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type = %s\\n\", devType);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"TempNode is NULL\\n\");\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"UDN\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrncpy(UDNstr, tmpStr, sizeof(UDNstr) - 1);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending UDNStr = %s \\n\", UDNstr);\n\t\t\tif (AdFlag) {\n\t\t\t\t/* send the device advertisement */\n\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\tDeviceAdvertisement(devType, i == 0lu,\n\t\t\t\t\t\t\t    UDNstr,\n\t\t\t\t\t\t\t    SInfo->DescURL, Exp,\n\t\t\t\t\t\t\t    SInfo->DeviceAf,\n\t\t\t\t\t\t\t    SInfo->PowerState,\n\t                                                    SInfo->SleepPeriod,\n\t                                                    SInfo->RegistrationState);\n\t\t\t\t} else {\n\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\tDeviceShutdown(devType, i == 0lu, UDNstr,\n\t\t\t\t\t\t       SInfo->DescURL,\n\t\t\t\t\t\t       Exp, SInfo->DeviceAf,\n\t\t\t\t\t\t       SInfo->PowerState,\n\t\t\t\t\t\t       SInfo->SleepPeriod,\n\t\t\t\t\t\t       SInfo->RegistrationState);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (SearchType) {\n\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\tDeviceReply(DestAddr, devType, i == 0lu,\n\t\t\t\t\t\t    UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t    defaultExp, SInfo->PowerState,\n\t\t\t\t\t\t    SInfo->SleepPeriod,\n\t\t\t\t\t\t    SInfo->RegistrationState);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_ROOTDEVICE:\n\t\t\t\t\tif (i == 0lu) {\n\t\t\t\t\t\tSendReply(DestAddr, devType, 1,\n\t\t\t\t\t\t\t  UDNstr,\n\t\t\t\t\t\t\t  SInfo->DescURL,\n\t\t\t\t\t\t\t  defaultExp, 0,\n\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_DEVICEUDN: {\n\t\t\t\t\tif (DeviceUDN && strlen(DeviceUDN) != (size_t)0) {\n\t\t\t\t\t\tif (strcasecmp(DeviceUDN, UDNstr)) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s DID NOT match\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s MATCH\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tSendReply(DestAddr, devType, 0, UDNstr, SInfo->DescURL, defaultExp, 0,\n\t\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase SSDP_DEVICETYPE: {\n\t\t\t\t\tif (!strncasecmp(DeviceType, devType, strlen(DeviceType) - (size_t)2)) {\n\t\t\t\t\t\tif (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t    < atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\t/* the requested version is lower than the device version\n\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else if (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t\t   == atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* send service advertisements for services corresponding\n\t\t\t * to the same device */\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending service Advertisement\\n\");\n\t\t\t/* Correct service traversal such that each device's serviceList\n\t\t\t * is directly traversed as a child of its parent device. This\n\t\t\t * ensures that the service's alive message uses the UDN of\n\t\t\t * the parent device. */\n\t\t\ttmpNode = ixmlNode_getFirstChild(tmpNode);\n\t\t\twhile (tmpNode) {\n\t\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\t\tif (!strncmp\n\t\t\t\t    (dbgStr, SERVICELIST_STR,\n\t\t\t\t     sizeof SERVICELIST_STR)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmpNode = ixmlNode_getNextSibling(tmpNode);\n\t\t\t}\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tif (!tmpNode) {\n\t\t\t\tnodeList = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"service\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Service not found 3\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j = 0lu;; j++) {\n\t\t\t\ttmpNode = ixmlNodeList_item(nodeList, j);\n\t\t\t\tif (!tmpNode) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\t\ttmpNodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"serviceType\");\n\t\t\t\tif (!tmpNodeList) {\n\t\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t\t   __LINE__,\n\t\t\t\t\t\t   \"ServiceType not found \\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttmpNode2 = ixmlNodeList_item(tmpNodeList, 0lu);\n\t\t\t\tif (!tmpNode2)\n\t\t\t\t\tcontinue;\n\t\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\t\tif (!textNode)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* servType is of format Servicetype:ServiceVersion */\n\t\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\t\tif (!tmpStr)\n\t\t\t\t\tcontinue;\n\t\t\t\tstrncpy(servType, tmpStr, sizeof(servType) - 1);\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"ServiceType = %s\\n\", servType);\n\t\t\t\tif (AdFlag) {\n\t\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\t\tServiceAdvertisement(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\t\tServiceShutdown(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (SearchType) {\n\t\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\t\tServiceReply(DestAddr, servType,\n\t\t\t\t\t\t\t     UDNstr,\n\t\t\t\t\t\t\t     SInfo->DescURL,\n\t\t\t\t\t\t\t     defaultExp,\n\t\t\t\t\t\t\t     SInfo->PowerState,\n\t\t\t\t\t\t\t     SInfo->SleepPeriod,\n\t\t\t\t\t\t\t     SInfo->RegistrationState);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SSDP_SERVICE:\n\t\t\t\t\t\tif (ServiceType) {\n\t\t\t\t\t\t\tif (!strncasecmp(ServiceType, servType, strlen(ServiceType) - (size_t)2)) {\n\t\t\t\t\t\t\t\tif (atoi(strrchr(ServiceType, ':') + 1) <\n\t\t\t\t\t\t\t\t    atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\t/* the requested version is lower than the service version\n\t\t\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else if (atoi(strrchr (ServiceType, ':') + 1) ==\n\t\t\t\t\t\t\t\t\t   atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\ttmpNodeList = NULL;\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = NULL;\n\t\t}\n\t}\n\nend_function:\n\tixmlNodeList_free(tmpNodeList);\n\tixmlNodeList_free(nodeList);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting AdvertiseAndReply.\\n\");\n\tHandleUnlock();\n\n\treturn retVal;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nint AdvertiseAndReply(int AdFlag, UpnpDevice_Handle Hnd,\n\t\t      enum SsdpSearchType SearchType,\n\t\t      struct sockaddr *DestAddr, char *DeviceType,\n\t\t      char *DeviceUDN, char *ServiceType, int Exp)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tlong unsigned int i;\n\tlong unsigned int j;\n\tint defaultExp = DEFAULT_MAXAGE;\n\tstruct Handle_Info *SInfo = NULL;\n\tchar UDNstr[100];\n\tchar devType[100];\n\tchar servType[100];\n\tIXML_NodeList *nodeList = NULL;\n\tIXML_NodeList *tmpNodeList = NULL;\n\tIXML_Node *tmpNode = NULL;\n\tIXML_Node *tmpNode2 = NULL;\n\tIXML_Node *textNode = NULL;\n\tconst DOMString tmpStr;\n\tconst DOMString dbgStr;\n\tint NumCopy = 0;\n\n\tmemset(UDNstr, 0, sizeof(UDNstr));\n\tmemset(devType, 0, sizeof(devType));\n\tmemset(servType, 0, sizeof(servType));\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside AdvertiseAndReply with AdFlag = %d\\n\", AdFlag);\n\n\t/* Use a read lock */\n\tHandleReadLock();\n\tif (GetHandleInfo(Hnd, &SInfo) != HND_DEVICE) {\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto end_function;\n\t}\n\tdefaultExp = SInfo->MaxAge;\n\t/* parse the device list and send advertisements/replies */\n\twhile (NumCopy == 0 || (AdFlag && NumCopy < NUM_SSDP_COPY)) {\n\t\tif (NumCopy != 0)\n\t\t\timillisleep(SSDP_PAUSE);\n\t\tNumCopy++;\n\t\tfor (i = 0lu;; i++) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Entering new device list with i = %lu\\n\\n\",\n\t\t\t\t   i);\n\t\t\ttmpNode = ixmlNodeList_item(SInfo->DeviceList, i);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Exiting new device list with i = %lu\\n\\n\",\n\t\t\t\t\t   i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type once for %s\\n\",\n\t\t\t\t   dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"deviceType\");\n\t\t\tif (!nodeList)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type\\n\");\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2)\n\t\t\t\tcontinue;\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type \\n\");\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr)\n\t\t\t\tcontinue;\n\t\t\tstrncpy(devType, tmpStr, sizeof(devType) - 1);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type = %s\\n\", devType);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"TempNode is NULL\\n\");\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"UDN\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrncpy(UDNstr, tmpStr, sizeof(UDNstr) - 1);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending UDNStr = %s \\n\", UDNstr);\n\t\t\tif (AdFlag) {\n\t\t\t\t/* send the device advertisement */\n\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\tDeviceAdvertisement(devType, i == 0lu,\n\t\t\t\t\t\t\t    UDNstr,\n\t\t\t\t\t\t\t    SInfo->DescURL, Exp,\n\t\t\t\t\t\t\t    SInfo->DeviceAf,\n\t\t\t\t\t\t\t    SInfo->PowerState,\n\t                                                    SInfo->SleepPeriod,\n\t                                                    SInfo->RegistrationState);\n\t\t\t\t} else {\n\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\tDeviceShutdown(devType, i == 0lu, UDNstr,\n\t\t\t\t\t\t       SInfo->DescURL,\n\t\t\t\t\t\t       Exp, SInfo->DeviceAf,\n\t\t\t\t\t\t       SInfo->PowerState,\n\t\t\t\t\t\t       SInfo->SleepPeriod,\n\t\t\t\t\t\t       SInfo->RegistrationState);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (SearchType) {\n\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\tDeviceReply(DestAddr, devType, i == 0lu,\n\t\t\t\t\t\t    UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t    defaultExp, SInfo->PowerState,\n\t\t\t\t\t\t    SInfo->SleepPeriod,\n\t\t\t\t\t\t    SInfo->RegistrationState);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_ROOTDEVICE:\n\t\t\t\t\tif (i == 0lu) {\n\t\t\t\t\t\tSendReply(DestAddr, devType, 1,\n\t\t\t\t\t\t\t  UDNstr,\n\t\t\t\t\t\t\t  SInfo->DescURL,\n\t\t\t\t\t\t\t  defaultExp, 0,\n\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_DEVICEUDN: {\n\t\t\t\t\tif (DeviceUDN && strlen(DeviceUDN) != (size_t)0) {\n\t\t\t\t\t\tif (strcasecmp(DeviceUDN, UDNstr)) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s DID NOT match\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s MATCH\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tSendReply(DestAddr, devType, 0, UDNstr, SInfo->DescURL, defaultExp, 0,\n\t\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase SSDP_DEVICETYPE: {\n\t\t\t\t\tif (!strncasecmp(DeviceType, devType, strlen(DeviceType) - (size_t)2)) {\n\t\t\t\t\t\tif (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t    < atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\t/* the requested version is lower than the device version\n\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else if (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t\t   == atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* send service advertisements for services corresponding\n\t\t\t * to the same device */\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending service Advertisement\\n\");\n\t\t\t/* Correct service traversal such that each device's serviceList\n\t\t\t * is directly traversed as a child of its parent device. This\n\t\t\t * ensures that the service's alive message uses the UDN of\n\t\t\t * the parent device. */\n\t\t\ttmpNode = ixmlNode_getFirstChild(tmpNode);\n\t\t\twhile (tmpNode) {\n\t\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\t\tif (!strncmp\n\t\t\t\t    (dbgStr, SERVICELIST_STR,\n\t\t\t\t     sizeof SERVICELIST_STR)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmpNode = ixmlNode_getNextSibling(tmpNode);\n\t\t\t}\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tif (!tmpNode) {\n\t\t\t\tnodeList = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"service\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Service not found 3\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j = 0lu;; j++) {\n\t\t\t\ttmpNode = ixmlNodeList_item(nodeList, j);\n\t\t\t\tif (!tmpNode) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\t\ttmpNodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"serviceType\");\n\t\t\t\tif (!tmpNodeList) {\n\t\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t\t   __LINE__,\n\t\t\t\t\t\t   \"ServiceType not found \\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttmpNode2 = ixmlNodeList_item(tmpNodeList, 0lu);\n\t\t\t\tif (!tmpNode2)\n\t\t\t\t\tcontinue;\n\t\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\t\tif (!textNode)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* servType is of format Servicetype:ServiceVersion */\n\t\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\t\tif (!tmpStr)\n\t\t\t\t\tcontinue;\n\t\t\t\tstrncpy(servType, tmpStr, sizeof(servType) - 1);\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"ServiceType = %s\\n\", servType);\n\t\t\t\tif (AdFlag) {\n\t\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\t\tServiceAdvertisement(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\t\tServiceShutdown(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (SearchType) {\n\t\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\t\tServiceReply(DestAddr, servType,\n\t\t\t\t\t\t\t     UDNstr,\n\t\t\t\t\t\t\t     SInfo->DescURL,\n\t\t\t\t\t\t\t     defaultExp,\n\t\t\t\t\t\t\t     SInfo->PowerState,\n\t\t\t\t\t\t\t     SInfo->SleepPeriod,\n\t\t\t\t\t\t\t     SInfo->RegistrationState);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SSDP_SERVICE:\n\t\t\t\t\t\tif (ServiceType) {\n\t\t\t\t\t\t\tif (!strncasecmp(ServiceType, servType, strlen(ServiceType) - (size_t)2)) {\n\t\t\t\t\t\t\t\tif (atoi(strrchr(ServiceType, ':') + 1) <\n\t\t\t\t\t\t\t\t    atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\t/* the requested version is lower than the service version\n\t\t\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else if (atoi(strrchr (ServiceType, ':') + 1) ==\n\t\t\t\t\t\t\t\t\t   atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\ttmpNodeList = NULL;\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = NULL;\n\t\t}\n\t}\n\nend_function:\n\tixmlNodeList_free(tmpNodeList);\n\tixmlNodeList_free(nodeList);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting AdvertiseAndReply.\\n\");\n\tHandleUnlock();\n\n\treturn retVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&job",
            "0",
            "sizeof(job)"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nTimerThread gTimerThread;\nint UpnpSdkInit = 0;\n\nint UpnpSendAdvertisementLowPower(UpnpDevice_Handle Hnd, int Exp,\n    int PowerState, int SleepPeriod, int RegistrationState)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0,\n     *ptrMx;\n    upnp_timeout *adEvent;\n    ThreadPoolJob job;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAdvertisementLowPower \\n\" );\n\n    HandleLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( Exp < 1 )\n        Exp = DEFAULT_MAXAGE;\n    SInfo->MaxAge = Exp;\n    SInfo->PowerState = PowerState;\n    if( SleepPeriod < 0 )\n        SleepPeriod = -1;\n    SInfo->SleepPeriod = SleepPeriod;\n    SInfo->RegistrationState = RegistrationState;\n    HandleUnlock();\n    retVal = AdvertiseAndReply( 1, Hnd, ( enum SsdpSearchType )0,\n                                ( struct sockaddr * )NULL, ( char * )NULL,\n                                ( char * )NULL, ( char * )NULL, Exp );\n\n    if( retVal != UPNP_E_SUCCESS )\n        return retVal;\n    ptrMx = ( int * )malloc( sizeof( int ) );\n    if( ptrMx == NULL )\n        return UPNP_E_OUTOF_MEMORY;\n    adEvent = ( upnp_timeout * ) malloc( sizeof( upnp_timeout ) );\n\n    if( adEvent == NULL ) {\n        free( ptrMx );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    *ptrMx = Exp;\n    adEvent->handle = Hnd;\n    adEvent->Event = ptrMx;\n\n    HandleLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return UPNP_E_INVALID_HANDLE;\n    }\n#ifdef SSDP_PACKET_DISTRIBUTE\n    TPJobInit( &job, ( start_routine ) AutoAdvertise, adEvent );\n    TPJobSetFreeFunction( &job, ( free_routine ) free_upnp_timeout );\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if( ( retVal = TimerThreadSchedule( &gTimerThread,\n                                        ( ( Exp / 2 ) -\n                                          ( AUTO_ADVERTISEMENT_TIME ) ),\n                                        REL_SEC, &job, SHORT_TERM,\n                                        &( adEvent->eventId ) ) )\n        != UPNP_E_SUCCESS ) {\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return retVal;\n    }\n#else\n    TPJobInit( &job, ( start_routine ) AutoAdvertise, adEvent );\n    TPJobSetFreeFunction( &job, ( free_routine ) free_upnp_timeout );\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if( ( retVal = TimerThreadSchedule( &gTimerThread,\n                                        Exp - AUTO_ADVERTISEMENT_TIME,\n                                        REL_SEC, &job, SHORT_TERM,\n                                        &( adEvent->eventId ) ) )\n        != UPNP_E_SUCCESS ) {\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return retVal;\n    }\n#endif\n\n    HandleUnlock();\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendAdvertisementLowPower \\n\" );\n\n    return retVal;\n\n}"
  },
  {
    "function_name": "UpnpSendAdvertisement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1706-1711",
    "snippet": "int UpnpSendAdvertisement(UpnpDevice_Handle Hnd, int Exp)\n{\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAdvertisement \\n\");\n    return UpnpSendAdvertisementLowPower (Hnd, Exp, -1, -1, -1);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpSendAdvertisementLowPower",
          "args": [
            "Hnd",
            "Exp",
            "-1",
            "-1",
            "-1"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpSendAdvertisementLowPower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "1713-1814",
          "snippet": "int UpnpSendAdvertisementLowPower(UpnpDevice_Handle Hnd, int Exp,\n    int PowerState, int SleepPeriod, int RegistrationState)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0,\n     *ptrMx;\n    upnp_timeout *adEvent;\n    ThreadPoolJob job;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAdvertisementLowPower \\n\" );\n\n    HandleLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( Exp < 1 )\n        Exp = DEFAULT_MAXAGE;\n    SInfo->MaxAge = Exp;\n    SInfo->PowerState = PowerState;\n    if( SleepPeriod < 0 )\n        SleepPeriod = -1;\n    SInfo->SleepPeriod = SleepPeriod;\n    SInfo->RegistrationState = RegistrationState;\n    HandleUnlock();\n    retVal = AdvertiseAndReply( 1, Hnd, ( enum SsdpSearchType )0,\n                                ( struct sockaddr * )NULL, ( char * )NULL,\n                                ( char * )NULL, ( char * )NULL, Exp );\n\n    if( retVal != UPNP_E_SUCCESS )\n        return retVal;\n    ptrMx = ( int * )malloc( sizeof( int ) );\n    if( ptrMx == NULL )\n        return UPNP_E_OUTOF_MEMORY;\n    adEvent = ( upnp_timeout * ) malloc( sizeof( upnp_timeout ) );\n\n    if( adEvent == NULL ) {\n        free( ptrMx );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    *ptrMx = Exp;\n    adEvent->handle = Hnd;\n    adEvent->Event = ptrMx;\n\n    HandleLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return UPNP_E_INVALID_HANDLE;\n    }\n#ifdef SSDP_PACKET_DISTRIBUTE\n    TPJobInit( &job, ( start_routine ) AutoAdvertise, adEvent );\n    TPJobSetFreeFunction( &job, ( free_routine ) free_upnp_timeout );\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if( ( retVal = TimerThreadSchedule( &gTimerThread,\n                                        ( ( Exp / 2 ) -\n                                          ( AUTO_ADVERTISEMENT_TIME ) ),\n                                        REL_SEC, &job, SHORT_TERM,\n                                        &( adEvent->eventId ) ) )\n        != UPNP_E_SUCCESS ) {\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return retVal;\n    }\n#else\n    TPJobInit( &job, ( start_routine ) AutoAdvertise, adEvent );\n    TPJobSetFreeFunction( &job, ( free_routine ) free_upnp_timeout );\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if( ( retVal = TimerThreadSchedule( &gTimerThread,\n                                        Exp - AUTO_ADVERTISEMENT_TIME,\n                                        REL_SEC, &job, SHORT_TERM,\n                                        &( adEvent->eventId ) ) )\n        != UPNP_E_SUCCESS ) {\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return retVal;\n    }\n#endif\n\n    HandleUnlock();\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendAdvertisementLowPower \\n\" );\n\n    return retVal;\n\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "TimerThread gTimerThread;",
            "int UpnpSdkInit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nTimerThread gTimerThread;\nint UpnpSdkInit = 0;\n\nint UpnpSendAdvertisementLowPower(UpnpDevice_Handle Hnd, int Exp,\n    int PowerState, int SleepPeriod, int RegistrationState)\n{\n    struct Handle_Info *SInfo = NULL;\n    int retVal = 0,\n     *ptrMx;\n    upnp_timeout *adEvent;\n    ThreadPoolJob job;\n\n    memset(&job, 0, sizeof(job));\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAdvertisementLowPower \\n\" );\n\n    HandleLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        return UPNP_E_INVALID_HANDLE;\n    }\n    if( Exp < 1 )\n        Exp = DEFAULT_MAXAGE;\n    SInfo->MaxAge = Exp;\n    SInfo->PowerState = PowerState;\n    if( SleepPeriod < 0 )\n        SleepPeriod = -1;\n    SInfo->SleepPeriod = SleepPeriod;\n    SInfo->RegistrationState = RegistrationState;\n    HandleUnlock();\n    retVal = AdvertiseAndReply( 1, Hnd, ( enum SsdpSearchType )0,\n                                ( struct sockaddr * )NULL, ( char * )NULL,\n                                ( char * )NULL, ( char * )NULL, Exp );\n\n    if( retVal != UPNP_E_SUCCESS )\n        return retVal;\n    ptrMx = ( int * )malloc( sizeof( int ) );\n    if( ptrMx == NULL )\n        return UPNP_E_OUTOF_MEMORY;\n    adEvent = ( upnp_timeout * ) malloc( sizeof( upnp_timeout ) );\n\n    if( adEvent == NULL ) {\n        free( ptrMx );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    *ptrMx = Exp;\n    adEvent->handle = Hnd;\n    adEvent->Event = ptrMx;\n\n    HandleLock();\n    switch( GetHandleInfo( Hnd, &SInfo ) ) {\n    case HND_DEVICE:\n        break;\n    default:\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return UPNP_E_INVALID_HANDLE;\n    }\n#ifdef SSDP_PACKET_DISTRIBUTE\n    TPJobInit( &job, ( start_routine ) AutoAdvertise, adEvent );\n    TPJobSetFreeFunction( &job, ( free_routine ) free_upnp_timeout );\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if( ( retVal = TimerThreadSchedule( &gTimerThread,\n                                        ( ( Exp / 2 ) -\n                                          ( AUTO_ADVERTISEMENT_TIME ) ),\n                                        REL_SEC, &job, SHORT_TERM,\n                                        &( adEvent->eventId ) ) )\n        != UPNP_E_SUCCESS ) {\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return retVal;\n    }\n#else\n    TPJobInit( &job, ( start_routine ) AutoAdvertise, adEvent );\n    TPJobSetFreeFunction( &job, ( free_routine ) free_upnp_timeout );\n    TPJobSetPriority( &job, MED_PRIORITY );\n    if( ( retVal = TimerThreadSchedule( &gTimerThread,\n                                        Exp - AUTO_ADVERTISEMENT_TIME,\n                                        REL_SEC, &job, SHORT_TERM,\n                                        &( adEvent->eventId ) ) )\n        != UPNP_E_SUCCESS ) {\n        HandleUnlock();\n        free( adEvent );\n        free( ptrMx );\n        return retVal;\n    }\n#endif\n\n    HandleUnlock();\n    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n        \"Exiting UpnpSendAdvertisementLowPower \\n\" );\n\n    return retVal;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Inside UpnpSendAdvertisement \\n\""
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSendAdvertisement(UpnpDevice_Handle Hnd, int Exp)\n{\n    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n        \"Inside UpnpSendAdvertisement \\n\");\n    return UpnpSendAdvertisementLowPower (Hnd, Exp, -1, -1, -1);\n}"
  },
  {
    "function_name": "GetDescDocumentAndURL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1661-1692",
    "snippet": "static int GetDescDocumentAndURL(\n\tUpnp_DescType descriptionType,\n\tchar *description,\n\tint config_baseURL,\n\tint AddressFamily,\n\tIXML_Document **xmlDoc,\n\tchar descURL[LINE_SIZE])\n{\n\tint retVal = 0;\n\n\tif (descriptionType != (enum Upnp_DescType_e)UPNPREG_URL_DESC ||\n\t\tconfig_baseURL) {\n\t\treturn UPNP_E_NO_WEB_SERVER;\n\t}\n\n\tif (description == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (strlen(description) > LINE_SIZE - (size_t)1) {\n\t\treturn UPNP_E_URL_TOO_BIG;\n\t}\n\tstrncpy(descURL, description, LINE_SIZE - 1);\n\tdescURL[LINE_SIZE - 1] = '\\0';\n\n\tretVal = UpnpDownloadXmlDoc(description, xmlDoc);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int GetDescDocumentAndURL(\n\t/* [in] pointer to server address structure. */\n\tUpnp_DescType descriptionType,\n\t/* [in] . */\n\tchar *description,\n\t/* [in] . */\n\tint config_baseURL,\n\t/* [in] . */\n\tint AddressFamily,\n\t/* [out] . */\n\tIXML_Document **xmlDoc,\n\t/* [out] . */\n\tchar descURL[LINE_SIZE]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpDownloadXmlDoc",
          "args": [
            "description",
            "xmlDoc"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpDownloadXmlDoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3256-3314",
          "snippet": "int UpnpDownloadXmlDoc(const char *url, IXML_Document **xmlDoc)\n{\n\tint ret_code;\n\tchar *xml_buf;\n\tchar content_type[LINE_SIZE];\n\n\tif (url == NULL || xmlDoc == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tret_code = UpnpDownloadUrlItem(url, &xml_buf, content_type);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Error downloading document, retCode: %d\\n\", ret_code);\n\t\treturn ret_code;\n\t}\n\n\tif (strncasecmp(content_type, \"text/xml\", strlen(\"text/xml\"))) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__, \"Not text/xml\\n\");\n\t\t/* Linksys WRT54G router returns\n\t\t * \"CONTENT-TYPE: application/octet-stream\".\n\t\t * Let's be nice to Linksys and try to parse document anyway.\n\t\t * If the data sended is not a xml file, ixmlParseBufferEx\n\t\t * will fail and the function will return UPNP_E_INVALID_DESC too. */\n#if 0\n\t\tfree(xml_buf);\n\t\treturn UPNP_E_INVALID_DESC;\n#endif\n\t}\n\n\tret_code = ixmlParseBufferEx(xml_buf, xmlDoc);\n\tfree(xml_buf);\n\tif (ret_code != IXML_SUCCESS) {\n\t\tif (ret_code == IXML_INSUFFICIENT_MEMORY) {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Out of memory, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t} else {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Invalid Description, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t}\n\t} else {\n#ifdef DEBUG\n\t\txml_buf = ixmlPrintNode((IXML_Node *)*xmlDoc);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Printing the Parsed xml document \\n %s\\n\", xml_buf);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"****************** END OF Parsed XML Doc *****************\\n\");\n\t\tixmlFreeDOMString(xml_buf);\n#endif\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Exiting UpnpDownloadXmlDoc\\n\");\n\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpDownloadXmlDoc(const char *url, IXML_Document **xmlDoc)\n{\n\tint ret_code;\n\tchar *xml_buf;\n\tchar content_type[LINE_SIZE];\n\n\tif (url == NULL || xmlDoc == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tret_code = UpnpDownloadUrlItem(url, &xml_buf, content_type);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Error downloading document, retCode: %d\\n\", ret_code);\n\t\treturn ret_code;\n\t}\n\n\tif (strncasecmp(content_type, \"text/xml\", strlen(\"text/xml\"))) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__, \"Not text/xml\\n\");\n\t\t/* Linksys WRT54G router returns\n\t\t * \"CONTENT-TYPE: application/octet-stream\".\n\t\t * Let's be nice to Linksys and try to parse document anyway.\n\t\t * If the data sended is not a xml file, ixmlParseBufferEx\n\t\t * will fail and the function will return UPNP_E_INVALID_DESC too. */\n#if 0\n\t\tfree(xml_buf);\n\t\treturn UPNP_E_INVALID_DESC;\n#endif\n\t}\n\n\tret_code = ixmlParseBufferEx(xml_buf, xmlDoc);\n\tfree(xml_buf);\n\tif (ret_code != IXML_SUCCESS) {\n\t\tif (ret_code == IXML_INSUFFICIENT_MEMORY) {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Out of memory, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t} else {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Invalid Description, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t}\n\t} else {\n#ifdef DEBUG\n\t\txml_buf = ixmlPrintNode((IXML_Node *)*xmlDoc);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Printing the Parsed xml document \\n %s\\n\", xml_buf);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"****************** END OF Parsed XML Doc *****************\\n\");\n\t\tixmlFreeDOMString(xml_buf);\n#endif\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Exiting UpnpDownloadXmlDoc\\n\");\n\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "descURL",
            "description",
            "LINE_SIZE - 1"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "description"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic int GetDescDocumentAndURL(\n\t/* [in] pointer to server address structure. */\n\tUpnp_DescType descriptionType,\n\t/* [in] . */\n\tchar *description,\n\t/* [in] . */\n\tint config_baseURL,\n\t/* [in] . */\n\tint AddressFamily,\n\t/* [out] . */\n\tIXML_Document **xmlDoc,\n\t/* [out] . */\n\tchar descURL[LINE_SIZE]);\n\nstatic int GetDescDocumentAndURL(\n\tUpnp_DescType descriptionType,\n\tchar *description,\n\tint config_baseURL,\n\tint AddressFamily,\n\tIXML_Document **xmlDoc,\n\tchar descURL[LINE_SIZE])\n{\n\tint retVal = 0;\n\n\tif (descriptionType != (enum Upnp_DescType_e)UPNPREG_URL_DESC ||\n\t\tconfig_baseURL) {\n\t\treturn UPNP_E_NO_WEB_SERVER;\n\t}\n\n\tif (description == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (strlen(description) > LINE_SIZE - (size_t)1) {\n\t\treturn UPNP_E_URL_TOO_BIG;\n\t}\n\tstrncpy(descURL, description, LINE_SIZE - 1);\n\tdescURL[LINE_SIZE - 1] = '\\0';\n\n\tretVal = UpnpDownloadXmlDoc(description, xmlDoc);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "GetDescDocumentAndURL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1541-1657",
    "snippet": "static int GetDescDocumentAndURL(\n\tUpnp_DescType descriptionType,\n\tchar *description,\n\tint config_baseURL,\n\tint AddressFamily,\n\tIXML_Document **xmlDoc,\n\tchar descURL[LINE_SIZE])\n{\n\tint retVal = 0;\n\tchar *membuf = NULL;\n\tchar aliasStr[LINE_SIZE];\n\tchar *temp_str = NULL;\n\tFILE *fp = NULL;\n\tsize_t fileLen;\n\tsize_t num_read;\n\ttime_t last_modified;\n\tstruct stat file_info;\n\tstruct sockaddr_storage serverAddr;\n\tint rc = UPNP_E_SUCCESS;\n\n\tmemset(aliasStr, 0, sizeof(aliasStr));\n\tif (description == NULL)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t/* non-URL description must have configuration specified */\n\tif (descriptionType != (enum Upnp_DescType_e)UPNPREG_URL_DESC &&\n\t\t!config_baseURL)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t/* Get XML doc and last modified time */\n\tif (descriptionType == (enum Upnp_DescType_e)UPNPREG_URL_DESC) {\n\t\tretVal = UpnpDownloadXmlDoc(description, xmlDoc);\n\t\tif (retVal != UPNP_E_SUCCESS)\n\t\t\treturn retVal;\n\t\tlast_modified = time(NULL);\n\t} else if (descriptionType == (enum Upnp_DescType_e)UPNPREG_FILENAME_DESC) {\n\t\tretVal = stat(description, &file_info);\n\t\tif (retVal == -1)\n\t\t\treturn UPNP_E_FILE_NOT_FOUND;\n\t\tfileLen = (size_t)file_info.st_size;\n\t\tlast_modified = file_info.st_mtime;\n\t\tfp = fopen(description, \"rb\");\n\t\tif (fp == NULL)\n\t\t\treturn UPNP_E_FILE_NOT_FOUND;\n\t\tmembuf = (char *)malloc(fileLen + (size_t)1);\n\t\tif (membuf == NULL) {\n\t\t\tfclose(fp);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t\tnum_read = fread(membuf, (size_t)1, fileLen, fp);\n\t\tif (num_read != fileLen) {\n\t\t\tfclose(fp);\n\t\t\tfree(membuf);\n\t\t\treturn UPNP_E_FILE_READ_ERROR;\n\t\t}\n\t\tmembuf[fileLen] = 0;\n\t\tfclose(fp);\n\t\trc = ixmlParseBufferEx(membuf, xmlDoc);\n\t\tfree(membuf);\n\t} else if (descriptionType == (enum Upnp_DescType_e)UPNPREG_BUF_DESC) {\n\t\tlast_modified = time(NULL);\n\t\trc = ixmlParseBufferEx(description, xmlDoc);\n\t} else {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (rc != IXML_SUCCESS &&\n\t\tdescriptionType != (enum Upnp_DescType_e)UPNPREG_URL_DESC) {\n\t\tif (rc == IXML_INSUFFICIENT_MEMORY)\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\telse\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t}\n\t/* Determine alias */\n\tif (config_baseURL) {\n\t\tif (descriptionType == (enum Upnp_DescType_e)UPNPREG_BUF_DESC) {\n\t\t\tstrncpy(aliasStr, \"description.xml\",\n\t\t\t\tsizeof(aliasStr) - 1);\n\t\t} else {\n\t\t\t/* URL or filename */\n\t\t\tretVal = GetNameForAlias(description, &temp_str);\n\t\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\t\tixmlDocument_free(*xmlDoc);\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tif (strlen(temp_str) > (LINE_SIZE - 1)) {\n\t\t\t\tixmlDocument_free(*xmlDoc);\n\t\t\t\treturn UPNP_E_URL_TOO_BIG;\n\t\t\t}\n\t\t\tstrncpy(aliasStr, temp_str, sizeof(aliasStr) - 1);\n\t\t}\n\t\tif (AddressFamily == AF_INET) {\n\t\t\tget_server_addr((struct sockaddr *)&serverAddr);\n\t\t} else {\n\t\t\tget_server_addr6((struct sockaddr *)&serverAddr);\n\t\t}\n\n\t\t/* config */\n\t\tretVal =\n\t\t    configure_urlbase(*xmlDoc, (struct sockaddr *)&serverAddr,\n\t\t\t\t      aliasStr, last_modified, descURL);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tixmlDocument_free(*xmlDoc);\n\t\t\treturn retVal;\n\t\t}\n\t} else {\n\t\t/* Manual */\n\t\tif (strlen(description) > LINE_SIZE - 1) {\n\t\t\tixmlDocument_free(*xmlDoc);\n\t\t\treturn UPNP_E_URL_TOO_BIG;\n\t\t}\n\t\tstrncpy(descURL, description, LINE_SIZE - 1);\n\t\tdescURL[LINE_SIZE - 1] = '\\0';\n\t}\n\n\tassert(*xmlDoc != NULL);\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int GetDescDocumentAndURL(\n\t/* [in] pointer to server address structure. */\n\tUpnp_DescType descriptionType,\n\t/* [in] . */\n\tchar *description,\n\t/* [in] . */\n\tint config_baseURL,\n\t/* [in] . */\n\tint AddressFamily,\n\t/* [out] . */\n\tIXML_Document **xmlDoc,\n\t/* [out] . */\n\tchar descURL[LINE_SIZE]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "*xmlDoc != NULL"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "descURL",
            "description",
            "LINE_SIZE - 1"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "*xmlDoc"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "description"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "*xmlDoc"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configure_urlbase",
          "args": [
            "*xmlDoc",
            "(struct sockaddr *)&serverAddr",
            "aliasStr",
            "last_modified",
            "descURL"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "configure_urlbase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/urlconfig/urlconfig.c",
          "lines": "373-430",
          "snippet": "int\nconfigure_urlbase( INOUT IXML_Document * doc,\n                   IN const struct sockaddr *serverAddr,\n                   IN const char *alias,\n                   IN time_t last_modified,\n                   OUT char docURL[LINE_SIZE] )\n{\n    char *root_path = NULL;\n    char *new_alias = NULL;\n    char *xml_str = NULL;\n    int err_code;\n    char ipaddr_port[LINE_SIZE];\n\n    /* get IP address and port */\n    err_code = addrToString( serverAddr, ipaddr_port, sizeof(ipaddr_port) );\n    if ( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n\n    /* config url-base in 'doc' */\n    err_code = config_description_doc( doc, ipaddr_port, &root_path );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* calc alias */\n    err_code = calc_alias( alias, root_path, &new_alias );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* calc full url for desc doc */\n    err_code = calc_descURL( ipaddr_port, new_alias, docURL );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* xml doc to str */\n    xml_str = ixmlPrintDocument( doc );\n    if( xml_str == NULL ) {\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n        \"desc url: %s\\n\", docURL );\n    UpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n        \"doc = %s\\n\", xml_str );\n    /* store in web server */\n    err_code =\n        web_server_set_alias( new_alias, xml_str, strlen( xml_str ),\n                              last_modified );\n\nerror_handler:\n    free( root_path );\n    free( new_alias );\n\n    if( err_code != UPNP_E_SUCCESS ) {\n        ixmlFreeDOMString( xml_str );\n    }\n    return err_code;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"upnputil.h\"",
            "#include \"urlconfig.h\"",
            "#include \"uri.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"membuffer.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"upnputil.h\"\n#include \"urlconfig.h\"\n#include \"uri.h\"\n#include \"UpnpInet.h\"\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"membuffer.h\"\n#include \"config.h\"\n\nint\nconfigure_urlbase( INOUT IXML_Document * doc,\n                   IN const struct sockaddr *serverAddr,\n                   IN const char *alias,\n                   IN time_t last_modified,\n                   OUT char docURL[LINE_SIZE] )\n{\n    char *root_path = NULL;\n    char *new_alias = NULL;\n    char *xml_str = NULL;\n    int err_code;\n    char ipaddr_port[LINE_SIZE];\n\n    /* get IP address and port */\n    err_code = addrToString( serverAddr, ipaddr_port, sizeof(ipaddr_port) );\n    if ( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n\n    /* config url-base in 'doc' */\n    err_code = config_description_doc( doc, ipaddr_port, &root_path );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* calc alias */\n    err_code = calc_alias( alias, root_path, &new_alias );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* calc full url for desc doc */\n    err_code = calc_descURL( ipaddr_port, new_alias, docURL );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* xml doc to str */\n    xml_str = ixmlPrintDocument( doc );\n    if( xml_str == NULL ) {\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n        \"desc url: %s\\n\", docURL );\n    UpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n        \"doc = %s\\n\", xml_str );\n    /* store in web server */\n    err_code =\n        web_server_set_alias( new_alias, xml_str, strlen( xml_str ),\n                              last_modified );\n\nerror_handler:\n    free( root_path );\n    free( new_alias );\n\n    if( err_code != UPNP_E_SUCCESS ) {\n        ixmlFreeDOMString( xml_str );\n    }\n    return err_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_server_addr6",
          "args": [
            "(struct sockaddr *)&serverAddr"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "get_server_addr6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "1527-1538",
          "snippet": "static void get_server_addr6(\n\t/*! [out] pointer to server address structure. */\n\tstruct sockaddr *serverAddr)\n{\n    struct sockaddr_in6* sa6 = (struct sockaddr_in6*)serverAddr;\n\n    memset( serverAddr, 0, sizeof(struct sockaddr_storage) );\n\n    sa6->sin6_family = AF_INET6;\n    inet_pton(AF_INET6, gIF_IPV6, &sa6->sin6_addr );\n    sa6->sin6_port = htons( LOCAL_PORT_V6 );\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char gIF_IPV6[INET6_ADDRSTRLEN] = { '\\0' };",
            "unsigned short LOCAL_PORT_V6;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nchar gIF_IPV6[INET6_ADDRSTRLEN] = { '\\0' };\nunsigned short LOCAL_PORT_V6;\n\nstatic void get_server_addr6(\n\t/*! [out] pointer to server address structure. */\n\tstruct sockaddr *serverAddr)\n{\n    struct sockaddr_in6* sa6 = (struct sockaddr_in6*)serverAddr;\n\n    memset( serverAddr, 0, sizeof(struct sockaddr_storage) );\n\n    sa6->sin6_family = AF_INET6;\n    inet_pton(AF_INET6, gIF_IPV6, &sa6->sin6_addr );\n    sa6->sin6_port = htons( LOCAL_PORT_V6 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "aliasStr",
            "temp_str",
            "sizeof(aliasStr) - 1"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "*xmlDoc"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "temp_str"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "*xmlDoc"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNameForAlias",
          "args": [
            "description",
            "&temp_str"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "GetNameForAlias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "1484-1506",
          "snippet": "static int GetNameForAlias(\n\t/*! [in] Name of the file. */\n\tchar *name,\n\t/*! [out] Pointer to alias string. */\n\tchar **alias)\n{\n    char *ext;\n    char *al;\n\n    ext = strrchr( name, '.' );\n    if( ext == NULL || strcasecmp( ext, \".xml\" ) != 0 ) {\n        return UPNP_E_EXT_NOT_XML;\n    }\n\n    al = strrchr( name, '/' );\n    if( al == NULL ) {\n        *alias = name;\n    } else {\n        *alias = al;\n    }\n\n    return UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic int GetNameForAlias(\n\t/*! [in] Name of the file. */\n\tchar *name,\n\t/*! [out] Pointer to alias string. */\n\tchar **alias)\n{\n    char *ext;\n    char *al;\n\n    ext = strrchr( name, '.' );\n    if( ext == NULL || strcasecmp( ext, \".xml\" ) != 0 ) {\n        return UPNP_E_EXT_NOT_XML;\n    }\n\n    al = strrchr( name, '/' );\n    if( al == NULL ) {\n        *alias = name;\n    } else {\n        *alias = al;\n    }\n\n    return UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "aliasStr",
            "\"description.xml\"",
            "sizeof(aliasStr) - 1"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "description",
            "xmlDoc"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "get_system_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/sysdep.c",
          "lines": "115-127",
          "snippet": "void get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpInet.h\"",
            "#include \"sysdep.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <string.h>\n#include \"UpnpInet.h\"\n#include \"sysdep.h\"\n#include \"config.h\"\n\nvoid get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "membuf"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "membuf",
            "xmlDoc"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "membuf",
            "(size_t)1",
            "fileLen",
            "fp"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "fileLen + (size_t)1"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "description",
            "\"rb\""
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "description",
            "&file_info"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDownloadXmlDoc",
          "args": [
            "description",
            "xmlDoc"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpDownloadXmlDoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3256-3314",
          "snippet": "int UpnpDownloadXmlDoc(const char *url, IXML_Document **xmlDoc)\n{\n\tint ret_code;\n\tchar *xml_buf;\n\tchar content_type[LINE_SIZE];\n\n\tif (url == NULL || xmlDoc == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tret_code = UpnpDownloadUrlItem(url, &xml_buf, content_type);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Error downloading document, retCode: %d\\n\", ret_code);\n\t\treturn ret_code;\n\t}\n\n\tif (strncasecmp(content_type, \"text/xml\", strlen(\"text/xml\"))) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__, \"Not text/xml\\n\");\n\t\t/* Linksys WRT54G router returns\n\t\t * \"CONTENT-TYPE: application/octet-stream\".\n\t\t * Let's be nice to Linksys and try to parse document anyway.\n\t\t * If the data sended is not a xml file, ixmlParseBufferEx\n\t\t * will fail and the function will return UPNP_E_INVALID_DESC too. */\n#if 0\n\t\tfree(xml_buf);\n\t\treturn UPNP_E_INVALID_DESC;\n#endif\n\t}\n\n\tret_code = ixmlParseBufferEx(xml_buf, xmlDoc);\n\tfree(xml_buf);\n\tif (ret_code != IXML_SUCCESS) {\n\t\tif (ret_code == IXML_INSUFFICIENT_MEMORY) {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Out of memory, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t} else {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Invalid Description, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t}\n\t} else {\n#ifdef DEBUG\n\t\txml_buf = ixmlPrintNode((IXML_Node *)*xmlDoc);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Printing the Parsed xml document \\n %s\\n\", xml_buf);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"****************** END OF Parsed XML Doc *****************\\n\");\n\t\tixmlFreeDOMString(xml_buf);\n#endif\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Exiting UpnpDownloadXmlDoc\\n\");\n\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpDownloadXmlDoc(const char *url, IXML_Document **xmlDoc)\n{\n\tint ret_code;\n\tchar *xml_buf;\n\tchar content_type[LINE_SIZE];\n\n\tif (url == NULL || xmlDoc == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tret_code = UpnpDownloadUrlItem(url, &xml_buf, content_type);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Error downloading document, retCode: %d\\n\", ret_code);\n\t\treturn ret_code;\n\t}\n\n\tif (strncasecmp(content_type, \"text/xml\", strlen(\"text/xml\"))) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__, \"Not text/xml\\n\");\n\t\t/* Linksys WRT54G router returns\n\t\t * \"CONTENT-TYPE: application/octet-stream\".\n\t\t * Let's be nice to Linksys and try to parse document anyway.\n\t\t * If the data sended is not a xml file, ixmlParseBufferEx\n\t\t * will fail and the function will return UPNP_E_INVALID_DESC too. */\n#if 0\n\t\tfree(xml_buf);\n\t\treturn UPNP_E_INVALID_DESC;\n#endif\n\t}\n\n\tret_code = ixmlParseBufferEx(xml_buf, xmlDoc);\n\tfree(xml_buf);\n\tif (ret_code != IXML_SUCCESS) {\n\t\tif (ret_code == IXML_INSUFFICIENT_MEMORY) {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Out of memory, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t} else {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Invalid Description, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t}\n\t} else {\n#ifdef DEBUG\n\t\txml_buf = ixmlPrintNode((IXML_Node *)*xmlDoc);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Printing the Parsed xml document \\n %s\\n\", xml_buf);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"****************** END OF Parsed XML Doc *****************\\n\");\n\t\tixmlFreeDOMString(xml_buf);\n#endif\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Exiting UpnpDownloadXmlDoc\\n\");\n\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "aliasStr",
            "0",
            "sizeof(aliasStr)"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic int GetDescDocumentAndURL(\n\t/* [in] pointer to server address structure. */\n\tUpnp_DescType descriptionType,\n\t/* [in] . */\n\tchar *description,\n\t/* [in] . */\n\tint config_baseURL,\n\t/* [in] . */\n\tint AddressFamily,\n\t/* [out] . */\n\tIXML_Document **xmlDoc,\n\t/* [out] . */\n\tchar descURL[LINE_SIZE]);\n\nstatic int GetDescDocumentAndURL(\n\tUpnp_DescType descriptionType,\n\tchar *description,\n\tint config_baseURL,\n\tint AddressFamily,\n\tIXML_Document **xmlDoc,\n\tchar descURL[LINE_SIZE])\n{\n\tint retVal = 0;\n\tchar *membuf = NULL;\n\tchar aliasStr[LINE_SIZE];\n\tchar *temp_str = NULL;\n\tFILE *fp = NULL;\n\tsize_t fileLen;\n\tsize_t num_read;\n\ttime_t last_modified;\n\tstruct stat file_info;\n\tstruct sockaddr_storage serverAddr;\n\tint rc = UPNP_E_SUCCESS;\n\n\tmemset(aliasStr, 0, sizeof(aliasStr));\n\tif (description == NULL)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t/* non-URL description must have configuration specified */\n\tif (descriptionType != (enum Upnp_DescType_e)UPNPREG_URL_DESC &&\n\t\t!config_baseURL)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t/* Get XML doc and last modified time */\n\tif (descriptionType == (enum Upnp_DescType_e)UPNPREG_URL_DESC) {\n\t\tretVal = UpnpDownloadXmlDoc(description, xmlDoc);\n\t\tif (retVal != UPNP_E_SUCCESS)\n\t\t\treturn retVal;\n\t\tlast_modified = time(NULL);\n\t} else if (descriptionType == (enum Upnp_DescType_e)UPNPREG_FILENAME_DESC) {\n\t\tretVal = stat(description, &file_info);\n\t\tif (retVal == -1)\n\t\t\treturn UPNP_E_FILE_NOT_FOUND;\n\t\tfileLen = (size_t)file_info.st_size;\n\t\tlast_modified = file_info.st_mtime;\n\t\tfp = fopen(description, \"rb\");\n\t\tif (fp == NULL)\n\t\t\treturn UPNP_E_FILE_NOT_FOUND;\n\t\tmembuf = (char *)malloc(fileLen + (size_t)1);\n\t\tif (membuf == NULL) {\n\t\t\tfclose(fp);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t\tnum_read = fread(membuf, (size_t)1, fileLen, fp);\n\t\tif (num_read != fileLen) {\n\t\t\tfclose(fp);\n\t\t\tfree(membuf);\n\t\t\treturn UPNP_E_FILE_READ_ERROR;\n\t\t}\n\t\tmembuf[fileLen] = 0;\n\t\tfclose(fp);\n\t\trc = ixmlParseBufferEx(membuf, xmlDoc);\n\t\tfree(membuf);\n\t} else if (descriptionType == (enum Upnp_DescType_e)UPNPREG_BUF_DESC) {\n\t\tlast_modified = time(NULL);\n\t\trc = ixmlParseBufferEx(description, xmlDoc);\n\t} else {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (rc != IXML_SUCCESS &&\n\t\tdescriptionType != (enum Upnp_DescType_e)UPNPREG_URL_DESC) {\n\t\tif (rc == IXML_INSUFFICIENT_MEMORY)\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\telse\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t}\n\t/* Determine alias */\n\tif (config_baseURL) {\n\t\tif (descriptionType == (enum Upnp_DescType_e)UPNPREG_BUF_DESC) {\n\t\t\tstrncpy(aliasStr, \"description.xml\",\n\t\t\t\tsizeof(aliasStr) - 1);\n\t\t} else {\n\t\t\t/* URL or filename */\n\t\t\tretVal = GetNameForAlias(description, &temp_str);\n\t\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\t\tixmlDocument_free(*xmlDoc);\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tif (strlen(temp_str) > (LINE_SIZE - 1)) {\n\t\t\t\tixmlDocument_free(*xmlDoc);\n\t\t\t\treturn UPNP_E_URL_TOO_BIG;\n\t\t\t}\n\t\t\tstrncpy(aliasStr, temp_str, sizeof(aliasStr) - 1);\n\t\t}\n\t\tif (AddressFamily == AF_INET) {\n\t\t\tget_server_addr((struct sockaddr *)&serverAddr);\n\t\t} else {\n\t\t\tget_server_addr6((struct sockaddr *)&serverAddr);\n\t\t}\n\n\t\t/* config */\n\t\tretVal =\n\t\t    configure_urlbase(*xmlDoc, (struct sockaddr *)&serverAddr,\n\t\t\t\t      aliasStr, last_modified, descURL);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tixmlDocument_free(*xmlDoc);\n\t\t\treturn retVal;\n\t\t}\n\t} else {\n\t\t/* Manual */\n\t\tif (strlen(description) > LINE_SIZE - 1) {\n\t\t\tixmlDocument_free(*xmlDoc);\n\t\t\treturn UPNP_E_URL_TOO_BIG;\n\t\t}\n\t\tstrncpy(descURL, description, LINE_SIZE - 1);\n\t\tdescURL[LINE_SIZE - 1] = '\\0';\n\t}\n\n\tassert(*xmlDoc != NULL);\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "get_server_addr6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1527-1538",
    "snippet": "static void get_server_addr6(\n\t/*! [out] pointer to server address structure. */\n\tstruct sockaddr *serverAddr)\n{\n    struct sockaddr_in6* sa6 = (struct sockaddr_in6*)serverAddr;\n\n    memset( serverAddr, 0, sizeof(struct sockaddr_storage) );\n\n    sa6->sin6_family = AF_INET6;\n    inet_pton(AF_INET6, gIF_IPV6, &sa6->sin6_addr );\n    sa6->sin6_port = htons( LOCAL_PORT_V6 );\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char gIF_IPV6[INET6_ADDRSTRLEN] = { '\\0' };",
      "unsigned short LOCAL_PORT_V6;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "LOCAL_PORT_V6"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET6",
            "gIF_IPV6",
            "&sa6->sin6_addr"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "inet_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "307-321",
          "snippet": "int inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nint inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "serverAddr",
            "0",
            "sizeof(struct sockaddr_storage)"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nchar gIF_IPV6[INET6_ADDRSTRLEN] = { '\\0' };\nunsigned short LOCAL_PORT_V6;\n\nstatic void get_server_addr6(\n\t/*! [out] pointer to server address structure. */\n\tstruct sockaddr *serverAddr)\n{\n    struct sockaddr_in6* sa6 = (struct sockaddr_in6*)serverAddr;\n\n    memset( serverAddr, 0, sizeof(struct sockaddr_storage) );\n\n    sa6->sin6_family = AF_INET6;\n    inet_pton(AF_INET6, gIF_IPV6, &sa6->sin6_addr );\n    sa6->sin6_port = htons( LOCAL_PORT_V6 );\n}"
  },
  {
    "function_name": "get_server_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1511-1522",
    "snippet": "static void get_server_addr(\n\t/*! [out] pointer to server address structure. */\n\tstruct sockaddr *serverAddr)\n{\n    struct sockaddr_in* sa4 = (struct sockaddr_in*)serverAddr;\n\n    memset( serverAddr, 0, sizeof(struct sockaddr_storage) );\n\n    sa4->sin_family = AF_INET;\n    inet_pton( AF_INET, gIF_IPV4, &sa4->sin_addr );\n    sa4->sin_port = htons( LOCAL_PORT_V4 );\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char gIF_IPV4[INET_ADDRSTRLEN] = { '\\0' };",
      "unsigned short LOCAL_PORT_V4;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "LOCAL_PORT_V4"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET",
            "gIF_IPV4",
            "&sa4->sin_addr"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "inet_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "307-321",
          "snippet": "int inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nint inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "serverAddr",
            "0",
            "sizeof(struct sockaddr_storage)"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nchar gIF_IPV4[INET_ADDRSTRLEN] = { '\\0' };\nunsigned short LOCAL_PORT_V4;\n\nstatic void get_server_addr(\n\t/*! [out] pointer to server address structure. */\n\tstruct sockaddr *serverAddr)\n{\n    struct sockaddr_in* sa4 = (struct sockaddr_in*)serverAddr;\n\n    memset( serverAddr, 0, sizeof(struct sockaddr_storage) );\n\n    sa4->sin_family = AF_INET;\n    inet_pton( AF_INET, gIF_IPV4, &sa4->sin_addr );\n    sa4->sin_port = htons( LOCAL_PORT_V4 );\n}"
  },
  {
    "function_name": "GetNameForAlias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1484-1506",
    "snippet": "static int GetNameForAlias(\n\t/*! [in] Name of the file. */\n\tchar *name,\n\t/*! [out] Pointer to alias string. */\n\tchar **alias)\n{\n    char *ext;\n    char *al;\n\n    ext = strrchr( name, '.' );\n    if( ext == NULL || strcasecmp( ext, \".xml\" ) != 0 ) {\n        return UPNP_E_EXT_NOT_XML;\n    }\n\n    al = strrchr( name, '/' );\n    if( al == NULL ) {\n        *alias = name;\n    } else {\n        *alias = al;\n    }\n\n    return UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "name",
            "'/'"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "ext",
            "\".xml\""
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "name",
            "'.'"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic int GetNameForAlias(\n\t/*! [in] Name of the file. */\n\tchar *name,\n\t/*! [out] Pointer to alias string. */\n\tchar **alias)\n{\n    char *ext;\n    char *al;\n\n    ext = strrchr( name, '.' );\n    if( ext == NULL || strcasecmp( ext, \".xml\" ) != 0 ) {\n        return UPNP_E_EXT_NOT_XML;\n    }\n\n    al = strrchr( name, '/' );\n    if( al == NULL ) {\n        *alias = name;\n    } else {\n        *alias = al;\n    }\n\n    return UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpUnRegisterClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1424-1474",
    "snippet": "int UpnpUnRegisterClient(UpnpClient_Handle Hnd)\n{\n\tstruct Handle_Info *HInfo;\n\tListNode *node = NULL;\n\tSsdpSearchArg *searchArg = NULL;\n\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterClient \\n\");\n\n\tHandleLock();\n\tif (!UpnpSdkClientRegistered) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\t}\n\tHandleUnlock();\n\n#if EXCLUDE_GENA == 0\n\tif (genaUnregisterClient(Hnd) != UPNP_E_SUCCESS)\n\t\treturn UPNP_E_INVALID_HANDLE;\n#endif\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* clean up search list */\n\tnode = ListHead(&HInfo->SsdpSearchList);\n\twhile (node != NULL) {\n\t\tsearchArg = (SsdpSearchArg *) node->item;\n\t\tif (searchArg) {\n\t\t\tfree(searchArg->searchTarget);\n\t\t\tfree(searchArg);\n\t\t}\n\t\tListDelNode(&HInfo->SsdpSearchList, node, 0);\n\t\tnode = ListHead(&HInfo->SsdpSearchList);\n\t}\n\tListDestroy(&HInfo->SsdpSearchList, 0);\n\tFreeHandle(Hnd);\n\tUpnpSdkClientRegistered = 0;\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting UpnpUnRegisterClient \\n\");\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;",
      "int UpnpSdkClientRegistered = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpUnRegisterClient \\n\""
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeHandle",
          "args": [
            "Hnd"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "FreeHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "777-802",
          "snippet": "static int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListDestroy",
          "args": [
            "&HInfo->SsdpSearchList",
            "0"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListHead",
          "args": [
            "&HInfo->SsdpSearchList"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListDelNode",
          "args": [
            "&HInfo->SsdpSearchList",
            "node",
            "0"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "searchArg"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListHead",
          "args": [
            "&HInfo->SsdpSearchList"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&HInfo"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genaUnregisterClient",
          "args": [
            "Hnd"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "genaUnregisterClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "411-453",
          "snippet": "int genaUnregisterClient(UpnpClient_Handle client_handle)\n{\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tint return_code = UPNP_E_SUCCESS;\n\tstruct Handle_Info *handle_info = NULL;\n\thttp_parser_t response;\n\n\twhile (TRUE) {\n\t\tHandleLock();\n\n\t\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\t\tHandleUnlock();\n\t\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\t\tgoto exit_function;\n\t\t}\n\t\tif (handle_info->ClientSubList == NULL) {\n\t\t\treturn_code = UPNP_E_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tGenlibClientSubscription_assign(sub_copy, handle_info->ClientSubList);\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub_copy));\n\n\t\tHandleUnlock();\n\n\t\treturn_code = gena_unsubscribe(\n\t\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\t\t&response);\n\t\tif (return_code == 0) {\n\t\t\thttpmsg_destroy(&response.msg);\n\t\t}\n\t\tfree_client_subscription(sub_copy);\n\t}\n\n\tfreeClientSubList(handle_info->ClientSubList);\n\tHandleUnlock();\n\nexit_function:\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nint genaUnregisterClient(UpnpClient_Handle client_handle)\n{\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tint return_code = UPNP_E_SUCCESS;\n\tstruct Handle_Info *handle_info = NULL;\n\thttp_parser_t response;\n\n\twhile (TRUE) {\n\t\tHandleLock();\n\n\t\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\t\tHandleUnlock();\n\t\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\t\tgoto exit_function;\n\t\t}\n\t\tif (handle_info->ClientSubList == NULL) {\n\t\t\treturn_code = UPNP_E_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tGenlibClientSubscription_assign(sub_copy, handle_info->ClientSubList);\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub_copy));\n\n\t\tHandleUnlock();\n\n\t\treturn_code = gena_unsubscribe(\n\t\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\t\t&response);\n\t\tif (return_code == 0) {\n\t\t\thttpmsg_destroy(&response.msg);\n\t\t}\n\t\tfree_client_subscription(sub_copy);\n\t}\n\n\tfreeClientSubList(handle_info->ClientSubList);\n\tHandleUnlock();\n\nexit_function:\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\nint UpnpSdkClientRegistered = 0;\n\nint UpnpUnRegisterClient(UpnpClient_Handle Hnd)\n{\n\tstruct Handle_Info *HInfo;\n\tListNode *node = NULL;\n\tSsdpSearchArg *searchArg = NULL;\n\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterClient \\n\");\n\n\tHandleLock();\n\tif (!UpnpSdkClientRegistered) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\t}\n\tHandleUnlock();\n\n#if EXCLUDE_GENA == 0\n\tif (genaUnregisterClient(Hnd) != UPNP_E_SUCCESS)\n\t\treturn UPNP_E_INVALID_HANDLE;\n#endif\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* clean up search list */\n\tnode = ListHead(&HInfo->SsdpSearchList);\n\twhile (node != NULL) {\n\t\tsearchArg = (SsdpSearchArg *) node->item;\n\t\tif (searchArg) {\n\t\t\tfree(searchArg->searchTarget);\n\t\t\tfree(searchArg);\n\t\t}\n\t\tListDelNode(&HInfo->SsdpSearchList, node, 0);\n\t\tnode = ListHead(&HInfo->SsdpSearchList);\n\t}\n\tListDestroy(&HInfo->SsdpSearchList, 0);\n\tFreeHandle(Hnd);\n\tUpnpSdkClientRegistered = 0;\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting UpnpUnRegisterClient \\n\");\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpRegisterClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1376-1420",
    "snippet": "int UpnpRegisterClient(Upnp_FunPtr Fun, const void *Cookie,\n\tUpnpClient_Handle *Hnd)\n{\n\tstruct Handle_Info *HInfo;\n\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpRegisterClient \\n\");\n\tif (Fun == NULL || Hnd == NULL)\n\t\treturn UPNP_E_INVALID_PARAM;\n\n\tHandleLock();\n\tif (UpnpSdkClientRegistered) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_ALREADY_REGISTERED;\n\t}\n\tif ((*Hnd = GetFreeHandle()) == UPNP_E_OUTOF_HANDLE) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tHInfo = (struct Handle_Info *)malloc(sizeof(struct Handle_Info));\n\tif (HInfo == NULL) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tHInfo->HType = HND_CLIENT;\n\tHInfo->Callback = Fun;\n\tHInfo->Cookie = (void *)Cookie;\n\tHInfo->ClientSubList = NULL;\n\tListInit(&HInfo->SsdpSearchList, NULL, NULL);\n#ifdef INCLUDE_DEVICE_APIS\n\tHInfo->MaxAge = 0;\n\tHInfo->MaxSubscriptions = UPNP_INFINITE;\n\tHInfo->MaxSubscriptionTimeOut = UPNP_INFINITE;\n#endif\n\tHandleTable[*Hnd] = HInfo;\n\tUpnpSdkClientRegistered = 1;\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting UpnpRegisterClient \\n\");\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *HandleTable[NUM_HANDLE];",
      "int UpnpSdkInit = 0;",
      "int UpnpSdkClientRegistered = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpRegisterClient \\n\""
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListInit",
          "args": [
            "&HInfo->SsdpSearchList",
            "NULL",
            "NULL"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct Handle_Info)"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetFreeHandle",
          "args": [],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "GetFreeHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "759-770",
          "snippet": "static int GetFreeHandle()\n{\n\t/* Handle 0 is not used as NULL translates to 0 when passed as a handle */\n\tint i = 1;\n\n\twhile (i < NUM_HANDLE && HandleTable[i] != NULL)\n\t\t++i;\n\tif (i == NUM_HANDLE)\n\t\treturn UPNP_E_OUTOF_HANDLE;\n\telse\n\t\treturn i;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int GetFreeHandle()\n{\n\t/* Handle 0 is not used as NULL translates to 0 when passed as a handle */\n\tint i = 1;\n\n\twhile (i < NUM_HANDLE && HandleTable[i] != NULL)\n\t\t++i;\n\tif (i == NUM_HANDLE)\n\t\treturn UPNP_E_OUTOF_HANDLE;\n\telse\n\t\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic void *HandleTable[NUM_HANDLE];\nint UpnpSdkInit = 0;\nint UpnpSdkClientRegistered = 0;\n\nint UpnpRegisterClient(Upnp_FunPtr Fun, const void *Cookie,\n\tUpnpClient_Handle *Hnd)\n{\n\tstruct Handle_Info *HInfo;\n\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpRegisterClient \\n\");\n\tif (Fun == NULL || Hnd == NULL)\n\t\treturn UPNP_E_INVALID_PARAM;\n\n\tHandleLock();\n\tif (UpnpSdkClientRegistered) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_ALREADY_REGISTERED;\n\t}\n\tif ((*Hnd = GetFreeHandle()) == UPNP_E_OUTOF_HANDLE) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tHInfo = (struct Handle_Info *)malloc(sizeof(struct Handle_Info));\n\tif (HInfo == NULL) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tHInfo->HType = HND_CLIENT;\n\tHInfo->Callback = Fun;\n\tHInfo->Cookie = (void *)Cookie;\n\tHInfo->ClientSubList = NULL;\n\tListInit(&HInfo->SsdpSearchList, NULL, NULL);\n#ifdef INCLUDE_DEVICE_APIS\n\tHInfo->MaxAge = 0;\n\tHInfo->MaxSubscriptions = UPNP_INFINITE;\n\tHInfo->MaxSubscriptionTimeOut = UPNP_INFINITE;\n#endif\n\tHandleTable[*Hnd] = HInfo;\n\tUpnpSdkClientRegistered = 1;\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting UpnpRegisterClient \\n\");\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpUnRegisterRootDeviceLowPower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1301-1372",
    "snippet": "int UpnpUnRegisterRootDeviceLowPower(UpnpDevice_Handle Hnd, int PowerState,\n\tint SleepPeriod, int RegistrationState)\n{\n\tint retVal = 0;\n\tstruct Handle_Info *HInfo = NULL;\n\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterRootDeviceLowPower\\n\");\n#if EXCLUDE_GENA == 0\n\tif (genaUnregisterDevice(Hnd) != UPNP_E_SUCCESS)\n\t\treturn UPNP_E_INVALID_HANDLE;\n#endif\n\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\tHInfo->PowerState = PowerState;\n\tif( SleepPeriod < 0 )\n\t\tSleepPeriod = -1;\n\tHInfo->SleepPeriod = SleepPeriod;\n\tHInfo->RegistrationState = RegistrationState;\n\tHandleUnlock();\n\n#if EXCLUDE_SSDP == 0\n\tretVal = AdvertiseAndReply(-1, Hnd, (enum SsdpSearchType)0,\n\t\t(struct sockaddr *)NULL, (char *)NULL, (char *)NULL,\n\t\t(char *)NULL, HInfo->MaxAge);\n#endif\n\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\tixmlNodeList_free(HInfo->DeviceList);\n\tixmlNodeList_free(HInfo->ServiceList);\n\tixmlDocument_free(HInfo->DescDocument);\n#ifdef INCLUDE_CLIENT_APIS\n\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n#ifdef INTERNAL_WEB_SERVER\n\tif (HInfo->aliasInstalled)\n\t\tweb_server_set_alias(NULL, NULL, 0, 0);\n#endif /* INTERNAL_WEB_SERVER */\n\tswitch (HInfo->DeviceAf) {\n\tcase AF_INET:\n\t\tUpnpSdkDeviceRegisteredV4 = 0;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tUpnpSdkDeviceregisteredV6 = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tFreeHandle(Hnd);\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Exiting UpnpUnRegisterRootDeviceLowPower\\n\");\n\n\treturn retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int UpnpSdkInit = 0;",
      "int UpnpSdkDeviceRegisteredV4 = 0;",
      "int UpnpSdkDeviceregisteredV6 = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpUnRegisterRootDeviceLowPower\\n\""
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeHandle",
          "args": [
            "Hnd"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "FreeHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "777-802",
          "snippet": "static int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "web_server_set_alias",
          "args": [
            "NULL",
            "NULL",
            "0",
            "0"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "web_server_set_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "421-465",
          "snippet": "int web_server_set_alias(const char *alias_name, \n\tconst char *alias_content, size_t alias_content_length,\n\ttime_t last_modified)\n{\n\tint ret_code;\n\tstruct xml_alias_t alias;\n\n\talias_release(&gAliasDoc);\n\tif (alias_name == NULL) {\n\t\t/* don't serve aliased doc anymore */\n\t\treturn 0;\n\t}\n\tassert(alias_content != NULL);\n\tmembuffer_init(&alias.doc);\n\tmembuffer_init(&alias.name);\n\talias.ct = NULL;\n\tdo {\n\t\t/* insert leading /, if missing */\n\t\tif (*alias_name != '/')\n\t\t\tif (membuffer_assign_str(&alias.name, \"/\") != 0)\n\t\t\t\tbreak;\t/* error; out of mem */\n\t\tret_code = membuffer_append_str(&alias.name, alias_name);\n\t\tif (ret_code != 0)\n\t\t\tbreak;\t/* error */\n\t\tif ((alias.ct = (int *)malloc(sizeof(int))) == NULL)\n\t\t\tbreak;\t/* error */\n\t\t*alias.ct = 1;\n\t\tmembuffer_attach(&alias.doc, (char *)alias_content,\n\t\t\t\t alias_content_length);\n\t\talias.last_modified = last_modified;\n\t\t/* save in module var */\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tgAliasDoc = alias;\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\treturn 0;\n\t} while (FALSE);\n\t/* error handler */\n\t/* free temp alias */\n\tmembuffer_destroy(&alias.name);\n\tmembuffer_destroy(&alias.doc);\n\tfree(alias.ct);\n\n\treturn UPNP_E_OUTOF_MEMORY;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nint web_server_set_alias(const char *alias_name, \n\tconst char *alias_content, size_t alias_content_length,\n\ttime_t last_modified)\n{\n\tint ret_code;\n\tstruct xml_alias_t alias;\n\n\talias_release(&gAliasDoc);\n\tif (alias_name == NULL) {\n\t\t/* don't serve aliased doc anymore */\n\t\treturn 0;\n\t}\n\tassert(alias_content != NULL);\n\tmembuffer_init(&alias.doc);\n\tmembuffer_init(&alias.name);\n\talias.ct = NULL;\n\tdo {\n\t\t/* insert leading /, if missing */\n\t\tif (*alias_name != '/')\n\t\t\tif (membuffer_assign_str(&alias.name, \"/\") != 0)\n\t\t\t\tbreak;\t/* error; out of mem */\n\t\tret_code = membuffer_append_str(&alias.name, alias_name);\n\t\tif (ret_code != 0)\n\t\t\tbreak;\t/* error */\n\t\tif ((alias.ct = (int *)malloc(sizeof(int))) == NULL)\n\t\t\tbreak;\t/* error */\n\t\t*alias.ct = 1;\n\t\tmembuffer_attach(&alias.doc, (char *)alias_content,\n\t\t\t\t alias_content_length);\n\t\talias.last_modified = last_modified;\n\t\t/* save in module var */\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tgAliasDoc = alias;\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\treturn 0;\n\t} while (FALSE);\n\t/* error handler */\n\t/* free temp alias */\n\tmembuffer_destroy(&alias.name);\n\tmembuffer_destroy(&alias.doc);\n\tfree(alias.ct);\n\n\treturn UPNP_E_OUTOF_MEMORY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListDestroy",
          "args": [
            "&HInfo->SsdpSearchList",
            "0"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "HInfo->DescDocument"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_free",
          "args": [
            "HInfo->ServiceList"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_free",
          "args": [
            "HInfo->DeviceList"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&HInfo"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdvertiseAndReply",
          "args": [
            "-1",
            "Hnd",
            "(enum SsdpSearchType)0",
            "(struct sockaddr *)NULL",
            "(char *)NULL",
            "(char *)NULL",
            "(char *)NULL",
            "HInfo->MaxAge"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "AdvertiseAndReply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "92-445",
          "snippet": "int AdvertiseAndReply(int AdFlag, UpnpDevice_Handle Hnd,\n\t\t      enum SsdpSearchType SearchType,\n\t\t      struct sockaddr *DestAddr, char *DeviceType,\n\t\t      char *DeviceUDN, char *ServiceType, int Exp)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tlong unsigned int i;\n\tlong unsigned int j;\n\tint defaultExp = DEFAULT_MAXAGE;\n\tstruct Handle_Info *SInfo = NULL;\n\tchar UDNstr[100];\n\tchar devType[100];\n\tchar servType[100];\n\tIXML_NodeList *nodeList = NULL;\n\tIXML_NodeList *tmpNodeList = NULL;\n\tIXML_Node *tmpNode = NULL;\n\tIXML_Node *tmpNode2 = NULL;\n\tIXML_Node *textNode = NULL;\n\tconst DOMString tmpStr;\n\tconst DOMString dbgStr;\n\tint NumCopy = 0;\n\n\tmemset(UDNstr, 0, sizeof(UDNstr));\n\tmemset(devType, 0, sizeof(devType));\n\tmemset(servType, 0, sizeof(servType));\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside AdvertiseAndReply with AdFlag = %d\\n\", AdFlag);\n\n\t/* Use a read lock */\n\tHandleReadLock();\n\tif (GetHandleInfo(Hnd, &SInfo) != HND_DEVICE) {\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto end_function;\n\t}\n\tdefaultExp = SInfo->MaxAge;\n\t/* parse the device list and send advertisements/replies */\n\twhile (NumCopy == 0 || (AdFlag && NumCopy < NUM_SSDP_COPY)) {\n\t\tif (NumCopy != 0)\n\t\t\timillisleep(SSDP_PAUSE);\n\t\tNumCopy++;\n\t\tfor (i = 0lu;; i++) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Entering new device list with i = %lu\\n\\n\",\n\t\t\t\t   i);\n\t\t\ttmpNode = ixmlNodeList_item(SInfo->DeviceList, i);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Exiting new device list with i = %lu\\n\\n\",\n\t\t\t\t\t   i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type once for %s\\n\",\n\t\t\t\t   dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"deviceType\");\n\t\t\tif (!nodeList)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type\\n\");\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2)\n\t\t\t\tcontinue;\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type \\n\");\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr)\n\t\t\t\tcontinue;\n\t\t\tstrncpy(devType, tmpStr, sizeof(devType) - 1);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type = %s\\n\", devType);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"TempNode is NULL\\n\");\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"UDN\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrncpy(UDNstr, tmpStr, sizeof(UDNstr) - 1);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending UDNStr = %s \\n\", UDNstr);\n\t\t\tif (AdFlag) {\n\t\t\t\t/* send the device advertisement */\n\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\tDeviceAdvertisement(devType, i == 0lu,\n\t\t\t\t\t\t\t    UDNstr,\n\t\t\t\t\t\t\t    SInfo->DescURL, Exp,\n\t\t\t\t\t\t\t    SInfo->DeviceAf,\n\t\t\t\t\t\t\t    SInfo->PowerState,\n\t                                                    SInfo->SleepPeriod,\n\t                                                    SInfo->RegistrationState);\n\t\t\t\t} else {\n\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\tDeviceShutdown(devType, i == 0lu, UDNstr,\n\t\t\t\t\t\t       SInfo->DescURL,\n\t\t\t\t\t\t       Exp, SInfo->DeviceAf,\n\t\t\t\t\t\t       SInfo->PowerState,\n\t\t\t\t\t\t       SInfo->SleepPeriod,\n\t\t\t\t\t\t       SInfo->RegistrationState);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (SearchType) {\n\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\tDeviceReply(DestAddr, devType, i == 0lu,\n\t\t\t\t\t\t    UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t    defaultExp, SInfo->PowerState,\n\t\t\t\t\t\t    SInfo->SleepPeriod,\n\t\t\t\t\t\t    SInfo->RegistrationState);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_ROOTDEVICE:\n\t\t\t\t\tif (i == 0lu) {\n\t\t\t\t\t\tSendReply(DestAddr, devType, 1,\n\t\t\t\t\t\t\t  UDNstr,\n\t\t\t\t\t\t\t  SInfo->DescURL,\n\t\t\t\t\t\t\t  defaultExp, 0,\n\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_DEVICEUDN: {\n\t\t\t\t\tif (DeviceUDN && strlen(DeviceUDN) != (size_t)0) {\n\t\t\t\t\t\tif (strcasecmp(DeviceUDN, UDNstr)) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s DID NOT match\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s MATCH\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tSendReply(DestAddr, devType, 0, UDNstr, SInfo->DescURL, defaultExp, 0,\n\t\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase SSDP_DEVICETYPE: {\n\t\t\t\t\tif (!strncasecmp(DeviceType, devType, strlen(DeviceType) - (size_t)2)) {\n\t\t\t\t\t\tif (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t    < atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\t/* the requested version is lower than the device version\n\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else if (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t\t   == atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* send service advertisements for services corresponding\n\t\t\t * to the same device */\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending service Advertisement\\n\");\n\t\t\t/* Correct service traversal such that each device's serviceList\n\t\t\t * is directly traversed as a child of its parent device. This\n\t\t\t * ensures that the service's alive message uses the UDN of\n\t\t\t * the parent device. */\n\t\t\ttmpNode = ixmlNode_getFirstChild(tmpNode);\n\t\t\twhile (tmpNode) {\n\t\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\t\tif (!strncmp\n\t\t\t\t    (dbgStr, SERVICELIST_STR,\n\t\t\t\t     sizeof SERVICELIST_STR)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmpNode = ixmlNode_getNextSibling(tmpNode);\n\t\t\t}\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tif (!tmpNode) {\n\t\t\t\tnodeList = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"service\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Service not found 3\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j = 0lu;; j++) {\n\t\t\t\ttmpNode = ixmlNodeList_item(nodeList, j);\n\t\t\t\tif (!tmpNode) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\t\ttmpNodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"serviceType\");\n\t\t\t\tif (!tmpNodeList) {\n\t\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t\t   __LINE__,\n\t\t\t\t\t\t   \"ServiceType not found \\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttmpNode2 = ixmlNodeList_item(tmpNodeList, 0lu);\n\t\t\t\tif (!tmpNode2)\n\t\t\t\t\tcontinue;\n\t\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\t\tif (!textNode)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* servType is of format Servicetype:ServiceVersion */\n\t\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\t\tif (!tmpStr)\n\t\t\t\t\tcontinue;\n\t\t\t\tstrncpy(servType, tmpStr, sizeof(servType) - 1);\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"ServiceType = %s\\n\", servType);\n\t\t\t\tif (AdFlag) {\n\t\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\t\tServiceAdvertisement(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\t\tServiceShutdown(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (SearchType) {\n\t\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\t\tServiceReply(DestAddr, servType,\n\t\t\t\t\t\t\t     UDNstr,\n\t\t\t\t\t\t\t     SInfo->DescURL,\n\t\t\t\t\t\t\t     defaultExp,\n\t\t\t\t\t\t\t     SInfo->PowerState,\n\t\t\t\t\t\t\t     SInfo->SleepPeriod,\n\t\t\t\t\t\t\t     SInfo->RegistrationState);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SSDP_SERVICE:\n\t\t\t\t\t\tif (ServiceType) {\n\t\t\t\t\t\t\tif (!strncasecmp(ServiceType, servType, strlen(ServiceType) - (size_t)2)) {\n\t\t\t\t\t\t\t\tif (atoi(strrchr(ServiceType, ':') + 1) <\n\t\t\t\t\t\t\t\t    atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\t/* the requested version is lower than the service version\n\t\t\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else if (atoi(strrchr (ServiceType, ':') + 1) ==\n\t\t\t\t\t\t\t\t\t   atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\ttmpNodeList = NULL;\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = NULL;\n\t\t}\n\t}\n\nend_function:\n\tixmlNodeList_free(tmpNodeList);\n\tixmlNodeList_free(nodeList);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting AdvertiseAndReply.\\n\");\n\tHandleUnlock();\n\n\treturn retVal;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nint AdvertiseAndReply(int AdFlag, UpnpDevice_Handle Hnd,\n\t\t      enum SsdpSearchType SearchType,\n\t\t      struct sockaddr *DestAddr, char *DeviceType,\n\t\t      char *DeviceUDN, char *ServiceType, int Exp)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tlong unsigned int i;\n\tlong unsigned int j;\n\tint defaultExp = DEFAULT_MAXAGE;\n\tstruct Handle_Info *SInfo = NULL;\n\tchar UDNstr[100];\n\tchar devType[100];\n\tchar servType[100];\n\tIXML_NodeList *nodeList = NULL;\n\tIXML_NodeList *tmpNodeList = NULL;\n\tIXML_Node *tmpNode = NULL;\n\tIXML_Node *tmpNode2 = NULL;\n\tIXML_Node *textNode = NULL;\n\tconst DOMString tmpStr;\n\tconst DOMString dbgStr;\n\tint NumCopy = 0;\n\n\tmemset(UDNstr, 0, sizeof(UDNstr));\n\tmemset(devType, 0, sizeof(devType));\n\tmemset(servType, 0, sizeof(servType));\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside AdvertiseAndReply with AdFlag = %d\\n\", AdFlag);\n\n\t/* Use a read lock */\n\tHandleReadLock();\n\tif (GetHandleInfo(Hnd, &SInfo) != HND_DEVICE) {\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto end_function;\n\t}\n\tdefaultExp = SInfo->MaxAge;\n\t/* parse the device list and send advertisements/replies */\n\twhile (NumCopy == 0 || (AdFlag && NumCopy < NUM_SSDP_COPY)) {\n\t\tif (NumCopy != 0)\n\t\t\timillisleep(SSDP_PAUSE);\n\t\tNumCopy++;\n\t\tfor (i = 0lu;; i++) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Entering new device list with i = %lu\\n\\n\",\n\t\t\t\t   i);\n\t\t\ttmpNode = ixmlNodeList_item(SInfo->DeviceList, i);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Exiting new device list with i = %lu\\n\\n\",\n\t\t\t\t\t   i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type once for %s\\n\",\n\t\t\t\t   dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"deviceType\");\n\t\t\tif (!nodeList)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type\\n\");\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2)\n\t\t\t\tcontinue;\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type \\n\");\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr)\n\t\t\t\tcontinue;\n\t\t\tstrncpy(devType, tmpStr, sizeof(devType) - 1);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type = %s\\n\", devType);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"TempNode is NULL\\n\");\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"UDN\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrncpy(UDNstr, tmpStr, sizeof(UDNstr) - 1);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending UDNStr = %s \\n\", UDNstr);\n\t\t\tif (AdFlag) {\n\t\t\t\t/* send the device advertisement */\n\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\tDeviceAdvertisement(devType, i == 0lu,\n\t\t\t\t\t\t\t    UDNstr,\n\t\t\t\t\t\t\t    SInfo->DescURL, Exp,\n\t\t\t\t\t\t\t    SInfo->DeviceAf,\n\t\t\t\t\t\t\t    SInfo->PowerState,\n\t                                                    SInfo->SleepPeriod,\n\t                                                    SInfo->RegistrationState);\n\t\t\t\t} else {\n\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\tDeviceShutdown(devType, i == 0lu, UDNstr,\n\t\t\t\t\t\t       SInfo->DescURL,\n\t\t\t\t\t\t       Exp, SInfo->DeviceAf,\n\t\t\t\t\t\t       SInfo->PowerState,\n\t\t\t\t\t\t       SInfo->SleepPeriod,\n\t\t\t\t\t\t       SInfo->RegistrationState);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (SearchType) {\n\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\tDeviceReply(DestAddr, devType, i == 0lu,\n\t\t\t\t\t\t    UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t    defaultExp, SInfo->PowerState,\n\t\t\t\t\t\t    SInfo->SleepPeriod,\n\t\t\t\t\t\t    SInfo->RegistrationState);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_ROOTDEVICE:\n\t\t\t\t\tif (i == 0lu) {\n\t\t\t\t\t\tSendReply(DestAddr, devType, 1,\n\t\t\t\t\t\t\t  UDNstr,\n\t\t\t\t\t\t\t  SInfo->DescURL,\n\t\t\t\t\t\t\t  defaultExp, 0,\n\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_DEVICEUDN: {\n\t\t\t\t\tif (DeviceUDN && strlen(DeviceUDN) != (size_t)0) {\n\t\t\t\t\t\tif (strcasecmp(DeviceUDN, UDNstr)) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s DID NOT match\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s MATCH\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tSendReply(DestAddr, devType, 0, UDNstr, SInfo->DescURL, defaultExp, 0,\n\t\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase SSDP_DEVICETYPE: {\n\t\t\t\t\tif (!strncasecmp(DeviceType, devType, strlen(DeviceType) - (size_t)2)) {\n\t\t\t\t\t\tif (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t    < atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\t/* the requested version is lower than the device version\n\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else if (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t\t   == atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* send service advertisements for services corresponding\n\t\t\t * to the same device */\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending service Advertisement\\n\");\n\t\t\t/* Correct service traversal such that each device's serviceList\n\t\t\t * is directly traversed as a child of its parent device. This\n\t\t\t * ensures that the service's alive message uses the UDN of\n\t\t\t * the parent device. */\n\t\t\ttmpNode = ixmlNode_getFirstChild(tmpNode);\n\t\t\twhile (tmpNode) {\n\t\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\t\tif (!strncmp\n\t\t\t\t    (dbgStr, SERVICELIST_STR,\n\t\t\t\t     sizeof SERVICELIST_STR)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmpNode = ixmlNode_getNextSibling(tmpNode);\n\t\t\t}\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tif (!tmpNode) {\n\t\t\t\tnodeList = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"service\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Service not found 3\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j = 0lu;; j++) {\n\t\t\t\ttmpNode = ixmlNodeList_item(nodeList, j);\n\t\t\t\tif (!tmpNode) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\t\ttmpNodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"serviceType\");\n\t\t\t\tif (!tmpNodeList) {\n\t\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t\t   __LINE__,\n\t\t\t\t\t\t   \"ServiceType not found \\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttmpNode2 = ixmlNodeList_item(tmpNodeList, 0lu);\n\t\t\t\tif (!tmpNode2)\n\t\t\t\t\tcontinue;\n\t\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\t\tif (!textNode)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* servType is of format Servicetype:ServiceVersion */\n\t\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\t\tif (!tmpStr)\n\t\t\t\t\tcontinue;\n\t\t\t\tstrncpy(servType, tmpStr, sizeof(servType) - 1);\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"ServiceType = %s\\n\", servType);\n\t\t\t\tif (AdFlag) {\n\t\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\t\tServiceAdvertisement(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\t\tServiceShutdown(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (SearchType) {\n\t\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\t\tServiceReply(DestAddr, servType,\n\t\t\t\t\t\t\t     UDNstr,\n\t\t\t\t\t\t\t     SInfo->DescURL,\n\t\t\t\t\t\t\t     defaultExp,\n\t\t\t\t\t\t\t     SInfo->PowerState,\n\t\t\t\t\t\t\t     SInfo->SleepPeriod,\n\t\t\t\t\t\t\t     SInfo->RegistrationState);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SSDP_SERVICE:\n\t\t\t\t\t\tif (ServiceType) {\n\t\t\t\t\t\t\tif (!strncasecmp(ServiceType, servType, strlen(ServiceType) - (size_t)2)) {\n\t\t\t\t\t\t\t\tif (atoi(strrchr(ServiceType, ':') + 1) <\n\t\t\t\t\t\t\t\t    atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\t/* the requested version is lower than the service version\n\t\t\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else if (atoi(strrchr (ServiceType, ':') + 1) ==\n\t\t\t\t\t\t\t\t\t   atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\ttmpNodeList = NULL;\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = NULL;\n\t\t}\n\t}\n\nend_function:\n\tixmlNodeList_free(tmpNodeList);\n\tixmlNodeList_free(nodeList);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting AdvertiseAndReply.\\n\");\n\tHandleUnlock();\n\n\treturn retVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genaUnregisterDevice",
          "args": [
            "Hnd"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "genaUnregisterDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "62-82",
          "snippet": "int genaUnregisterDevice(\n\t/*! [in] Device handle. */\n\tUpnpDevice_Handle device_handle)\n{\n\tint ret = 0;\n\tstruct Handle_Info *handle_info;\n\n\tHandleLock();\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, GENA, __FILE__, __LINE__,\n\t\t\t\"genaUnregisterDevice: BAD Handle: %d\\n\",\n\t\t\tdevice_handle);\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tfreeServiceTable(&handle_info->ServiceTable);\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tHandleUnlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nint genaUnregisterDevice(\n\t/*! [in] Device handle. */\n\tUpnpDevice_Handle device_handle)\n{\n\tint ret = 0;\n\tstruct Handle_Info *handle_info;\n\n\tHandleLock();\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, GENA, __FILE__, __LINE__,\n\t\t\t\"genaUnregisterDevice: BAD Handle: %d\\n\",\n\t\t\tdevice_handle);\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tfreeServiceTable(&handle_info->ServiceTable);\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tHandleUnlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\nint UpnpSdkDeviceRegisteredV4 = 0;\nint UpnpSdkDeviceregisteredV6 = 0;\n\nint UpnpUnRegisterRootDeviceLowPower(UpnpDevice_Handle Hnd, int PowerState,\n\tint SleepPeriod, int RegistrationState)\n{\n\tint retVal = 0;\n\tstruct Handle_Info *HInfo = NULL;\n\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterRootDeviceLowPower\\n\");\n#if EXCLUDE_GENA == 0\n\tif (genaUnregisterDevice(Hnd) != UPNP_E_SUCCESS)\n\t\treturn UPNP_E_INVALID_HANDLE;\n#endif\n\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\tHInfo->PowerState = PowerState;\n\tif( SleepPeriod < 0 )\n\t\tSleepPeriod = -1;\n\tHInfo->SleepPeriod = SleepPeriod;\n\tHInfo->RegistrationState = RegistrationState;\n\tHandleUnlock();\n\n#if EXCLUDE_SSDP == 0\n\tretVal = AdvertiseAndReply(-1, Hnd, (enum SsdpSearchType)0,\n\t\t(struct sockaddr *)NULL, (char *)NULL, (char *)NULL,\n\t\t(char *)NULL, HInfo->MaxAge);\n#endif\n\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\tixmlNodeList_free(HInfo->DeviceList);\n\tixmlNodeList_free(HInfo->ServiceList);\n\tixmlDocument_free(HInfo->DescDocument);\n#ifdef INCLUDE_CLIENT_APIS\n\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n#ifdef INTERNAL_WEB_SERVER\n\tif (HInfo->aliasInstalled)\n\t\tweb_server_set_alias(NULL, NULL, 0, 0);\n#endif /* INTERNAL_WEB_SERVER */\n\tswitch (HInfo->DeviceAf) {\n\tcase AF_INET:\n\t\tUpnpSdkDeviceRegisteredV4 = 0;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tUpnpSdkDeviceregisteredV6 = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tFreeHandle(Hnd);\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Exiting UpnpUnRegisterRootDeviceLowPower\\n\");\n\n\treturn retVal;\n}"
  },
  {
    "function_name": "UpnpUnRegisterRootDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1294-1299",
    "snippet": "int UpnpUnRegisterRootDevice(UpnpDevice_Handle Hnd)\n{\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterRootDevice\\n\");\n\treturn UpnpUnRegisterRootDeviceLowPower(Hnd, -1, -1, -1);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpUnRegisterRootDeviceLowPower",
          "args": [
            "Hnd",
            "-1",
            "-1",
            "-1"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpUnRegisterRootDeviceLowPower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "1301-1372",
          "snippet": "int UpnpUnRegisterRootDeviceLowPower(UpnpDevice_Handle Hnd, int PowerState,\n\tint SleepPeriod, int RegistrationState)\n{\n\tint retVal = 0;\n\tstruct Handle_Info *HInfo = NULL;\n\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterRootDeviceLowPower\\n\");\n#if EXCLUDE_GENA == 0\n\tif (genaUnregisterDevice(Hnd) != UPNP_E_SUCCESS)\n\t\treturn UPNP_E_INVALID_HANDLE;\n#endif\n\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\tHInfo->PowerState = PowerState;\n\tif( SleepPeriod < 0 )\n\t\tSleepPeriod = -1;\n\tHInfo->SleepPeriod = SleepPeriod;\n\tHInfo->RegistrationState = RegistrationState;\n\tHandleUnlock();\n\n#if EXCLUDE_SSDP == 0\n\tretVal = AdvertiseAndReply(-1, Hnd, (enum SsdpSearchType)0,\n\t\t(struct sockaddr *)NULL, (char *)NULL, (char *)NULL,\n\t\t(char *)NULL, HInfo->MaxAge);\n#endif\n\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\tixmlNodeList_free(HInfo->DeviceList);\n\tixmlNodeList_free(HInfo->ServiceList);\n\tixmlDocument_free(HInfo->DescDocument);\n#ifdef INCLUDE_CLIENT_APIS\n\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n#ifdef INTERNAL_WEB_SERVER\n\tif (HInfo->aliasInstalled)\n\t\tweb_server_set_alias(NULL, NULL, 0, 0);\n#endif /* INTERNAL_WEB_SERVER */\n\tswitch (HInfo->DeviceAf) {\n\tcase AF_INET:\n\t\tUpnpSdkDeviceRegisteredV4 = 0;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tUpnpSdkDeviceregisteredV6 = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tFreeHandle(Hnd);\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Exiting UpnpUnRegisterRootDeviceLowPower\\n\");\n\n\treturn retVal;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int UpnpSdkInit = 0;",
            "int UpnpSdkDeviceRegisteredV4 = 0;",
            "int UpnpSdkDeviceregisteredV6 = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\nint UpnpSdkDeviceRegisteredV4 = 0;\nint UpnpSdkDeviceregisteredV6 = 0;\n\nint UpnpUnRegisterRootDeviceLowPower(UpnpDevice_Handle Hnd, int PowerState,\n\tint SleepPeriod, int RegistrationState)\n{\n\tint retVal = 0;\n\tstruct Handle_Info *HInfo = NULL;\n\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterRootDeviceLowPower\\n\");\n#if EXCLUDE_GENA == 0\n\tif (genaUnregisterDevice(Hnd) != UPNP_E_SUCCESS)\n\t\treturn UPNP_E_INVALID_HANDLE;\n#endif\n\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\tHInfo->PowerState = PowerState;\n\tif( SleepPeriod < 0 )\n\t\tSleepPeriod = -1;\n\tHInfo->SleepPeriod = SleepPeriod;\n\tHInfo->RegistrationState = RegistrationState;\n\tHandleUnlock();\n\n#if EXCLUDE_SSDP == 0\n\tretVal = AdvertiseAndReply(-1, Hnd, (enum SsdpSearchType)0,\n\t\t(struct sockaddr *)NULL, (char *)NULL, (char *)NULL,\n\t\t(char *)NULL, HInfo->MaxAge);\n#endif\n\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\tixmlNodeList_free(HInfo->DeviceList);\n\tixmlNodeList_free(HInfo->ServiceList);\n\tixmlDocument_free(HInfo->DescDocument);\n#ifdef INCLUDE_CLIENT_APIS\n\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n#ifdef INTERNAL_WEB_SERVER\n\tif (HInfo->aliasInstalled)\n\t\tweb_server_set_alias(NULL, NULL, 0, 0);\n#endif /* INTERNAL_WEB_SERVER */\n\tswitch (HInfo->DeviceAf) {\n\tcase AF_INET:\n\t\tUpnpSdkDeviceRegisteredV4 = 0;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tUpnpSdkDeviceregisteredV6 = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tFreeHandle(Hnd);\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Exiting UpnpUnRegisterRootDeviceLowPower\\n\");\n\n\treturn retVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Inside UpnpUnRegisterRootDevice\\n\""
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpUnRegisterRootDevice(UpnpDevice_Handle Hnd)\n{\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterRootDevice\\n\");\n\treturn UpnpUnRegisterRootDeviceLowPower(Hnd, -1, -1, -1);\n}"
  },
  {
    "function_name": "UpnpRegisterRootDevice4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1132-1289",
    "snippet": "int UpnpRegisterRootDevice4(\n\tconst char *DescUrl,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie,\n\tUpnpDevice_Handle *Hnd,\n\tint AddressFamily,\n\tconst char *LowerDescUrl)\n{\n\tstruct Handle_Info *HInfo;\n\tint retVal = 0;\n#if EXCLUDE_GENA == 0\n\tint hasServiceTable = 0;\n#endif /* EXCLUDE_GENA */\n\tint handler_index = 0;\n\n\tHandleLock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpRegisterRootDevice4\\n\");\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\tif (Hnd == NULL ||\n\t    Fun == NULL ||\n\t    DescUrl == NULL ||\n\t    strlen(DescUrl) == (size_t)0 ||\n\t    (AddressFamily != AF_INET && AddressFamily != AF_INET6)) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\t/* Test for already regsitered IPV4. */\n\tif (AddressFamily == AF_INET && UpnpSdkDeviceRegisteredV4 == 1) {\n\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\tgoto exit_function;\n\t}\n\t/* Test for already registered IPV6. IPV6 devices might register on multiple\n\t * IPv6 addresses (link local and GUA or ULA), so we must to check the\n\t * description URL in the HandleTable. */\n\twhile (handler_index < NUM_HANDLE && HandleTable[handler_index] != NULL) {\n\t\tif (strcmp(((struct Handle_Info *)HandleTable[handler_index])->DescURL, DescUrl)) {\n\t\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\t\tgoto exit_function;\n\t\t}\n\t\thandler_index++;\n\t}\n\t*Hnd = GetFreeHandle();\n\tif (*Hnd == UPNP_E_OUTOF_HANDLE) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tHInfo = (struct Handle_Info *)malloc(sizeof (struct Handle_Info));\n\tif (HInfo == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tmemset(HInfo, 0, sizeof(struct Handle_Info));\n\tHandleTable[*Hnd] = HInfo;\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Root device URL is %s\\n\", DescUrl);\n\tHInfo->aliasInstalled = 0;\n\tHInfo->HType = HND_DEVICE;\n\tstrncpy(HInfo->DescURL, DescUrl, sizeof(HInfo->DescURL) - 1);\n\tif (LowerDescUrl == NULL)\n\t\tstrncpy(HInfo->LowerDescURL, DescUrl,\n\t\t\tsizeof(HInfo->LowerDescURL) - 1);\n\telse\n\t\tstrncpy(HInfo->LowerDescURL, LowerDescUrl,\n\t\t\tsizeof(HInfo->LowerDescURL) - 1);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Following Root Device URL will be used when answering to legacy CPs %s\\n\",\n\t\tHInfo->LowerDescURL);\n\tHInfo->Callback = Fun;\n\tHInfo->Cookie = (void *)Cookie;\n\tHInfo->MaxAge = DEFAULT_MAXAGE;\n\tHInfo->DeviceList = NULL;\n\tHInfo->ServiceList = NULL;\n\tHInfo->DescDocument = NULL;\n#ifdef INCLUDE_CLIENT_APIS\n\tListInit(&HInfo->SsdpSearchList, NULL, NULL);\n\tHInfo->ClientSubList = NULL;\n#endif /* INCLUDE_CLIENT_APIS */\n\tHInfo->MaxSubscriptions = UPNP_INFINITE;\n\tHInfo->MaxSubscriptionTimeOut = UPNP_INFINITE;\n\tHInfo->DeviceAf = AddressFamily;\n\tretVal = UpnpDownloadXmlDoc(HInfo->DescURL, &(HInfo->DescDocument));\n\tif (retVal != UPNP_E_SUCCESS) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tFreeHandle(*Hnd);\n\t\tgoto exit_function;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice4: Valid Description\\n\"\n\t\t\"UpnpRegisterRootDevice4: DescURL : %s\\n\",\n\t\tHInfo->DescURL);\n\n\tHInfo->DeviceList = ixmlDocument_getElementsByTagName(\n\t\tHInfo->DescDocument, \"device\");\n\tif (!HInfo->DeviceList) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tixmlDocument_free(HInfo->DescDocument);\n\t\tFreeHandle(*Hnd);\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: No devices found for RootDevice\\n\");\n\t\tretVal = UPNP_E_INVALID_DESC;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo->ServiceList = ixmlDocument_getElementsByTagName(\n\tHInfo->DescDocument, \"serviceList\" );\n\tif (!HInfo->ServiceList) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: No services found for RootDevice\\n\");\n\t}\n\n#if EXCLUDE_GENA == 0\n\t/*\n\t * GENA SET UP\n\t */\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice4: Gena Check\\n\" );\n\tmemset(&HInfo->ServiceTable, 0, sizeof(HInfo->ServiceTable));\n\thasServiceTable = getServiceTable(\n\t\t(IXML_Node *)HInfo->DescDocument,\n\t\t&HInfo->ServiceTable,\n\t\tHInfo->DescURL);\n\tif (hasServiceTable) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: GENA Service Table \\n\"\n\t\t\t\"Here are the known services: \\n\" );\n\t\tprintServiceTable(&HInfo->ServiceTable, UPNP_ALL, API);\n\t} else {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"\\nUpnpRegisterRootDevice4: Empty service table\\n\");\n\t}\n#endif /* EXCLUDE_GENA */\n\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tUpnpSdkDeviceRegisteredV4 = 1;\n\t\tbreak;\n\tdefault:\n\t\tUpnpSdkDeviceregisteredV6 = 1;\n\t}\n\n\tretVal = UPNP_E_SUCCESS;\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting RegisterRootDevice4, return value == %d\\n\", retVal);\n\tHandleUnlock();\n\n\treturn retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_HANDLE 200"
    ],
    "globals_used": [
      "static void *HandleTable[NUM_HANDLE];",
      "int UpnpSdkInit = 0;",
      "int UpnpSdkDeviceRegisteredV4 = 0;",
      "int UpnpSdkDeviceregisteredV6 = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting RegisterRootDevice4, return value == %d\\n\"",
            "retVal"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printServiceTable",
          "args": [
            "&HInfo->ServiceTable",
            "UPNP_ALL",
            "API"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "printServiceTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/service_table.h",
          "lines": "260-269",
          "snippet": "static UPNP_INLINE void printServiceTable(\n\tservice_table *table,\n\tUpnp_LogLevel level,\n\tDbg_Module module)\n{\n\treturn;\n\ttable = table;\n\tlevel = level;\n\tmodule = module;\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdio.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdio.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"uri.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void printServiceTable(\n\tservice_table *table,\n\tUpnp_LogLevel level,\n\tDbg_Module module)\n{\n\treturn;\n\ttable = table;\n\tlevel = level;\n\tmodule = module;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getServiceTable",
          "args": [
            "(IXML_Node *)HInfo->DescDocument",
            "&HInfo->ServiceTable",
            "HInfo->DescURL"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "getServiceTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "1043-1070",
          "snippet": "int\ngetServiceTable( IXML_Node * node,\n                 service_table * out,\n                 const char *DefaultURLBase )\n{\n    IXML_Node *root = NULL;\n    IXML_Node *URLBase = NULL;\n\n    if( getSubElement( \"root\", node, &root ) ) {\n        if( getSubElement( \"URLBase\", root, &URLBase ) ) {\n            out->URLBase = getElementValue( URLBase );\n        } else {\n            if( DefaultURLBase ) {\n                out->URLBase = ixmlCloneDOMString( DefaultURLBase );\n            } else {\n                out->URLBase = ixmlCloneDOMString( \"\" );\n            }\n        }\n\n        if( ( out->serviceList = getAllServiceList(\n            root, out->URLBase, &out->endServiceList ) ) ) {\n            return 1;\n        }\n\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nint\ngetServiceTable( IXML_Node * node,\n                 service_table * out,\n                 const char *DefaultURLBase )\n{\n    IXML_Node *root = NULL;\n    IXML_Node *URLBase = NULL;\n\n    if( getSubElement( \"root\", node, &root ) ) {\n        if( getSubElement( \"URLBase\", root, &URLBase ) ) {\n            out->URLBase = getElementValue( URLBase );\n        } else {\n            if( DefaultURLBase ) {\n                out->URLBase = ixmlCloneDOMString( DefaultURLBase );\n            } else {\n                out->URLBase = ixmlCloneDOMString( \"\" );\n            }\n        }\n\n        if( ( out->serviceList = getAllServiceList(\n            root, out->URLBase, &out->endServiceList ) ) ) {\n            return 1;\n        }\n\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&HInfo->ServiceTable",
            "0",
            "sizeof(HInfo->ServiceTable)"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlDocument_getElementsByTagName",
          "args": [
            "HInfo->DescDocument",
            "\"serviceList\""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeHandle",
          "args": [
            "*Hnd"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "FreeHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "777-802",
          "snippet": "static int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "HInfo->DescDocument"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListDestroy",
          "args": [
            "&HInfo->SsdpSearchList",
            "0"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_getElementsByTagName",
          "args": [
            "HInfo->DescDocument",
            "\"device\""
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListDestroy",
          "args": [
            "&HInfo->SsdpSearchList",
            "0"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDownloadXmlDoc",
          "args": [
            "HInfo->DescURL",
            "&(HInfo->DescDocument)"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpDownloadXmlDoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3256-3314",
          "snippet": "int UpnpDownloadXmlDoc(const char *url, IXML_Document **xmlDoc)\n{\n\tint ret_code;\n\tchar *xml_buf;\n\tchar content_type[LINE_SIZE];\n\n\tif (url == NULL || xmlDoc == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tret_code = UpnpDownloadUrlItem(url, &xml_buf, content_type);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Error downloading document, retCode: %d\\n\", ret_code);\n\t\treturn ret_code;\n\t}\n\n\tif (strncasecmp(content_type, \"text/xml\", strlen(\"text/xml\"))) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__, \"Not text/xml\\n\");\n\t\t/* Linksys WRT54G router returns\n\t\t * \"CONTENT-TYPE: application/octet-stream\".\n\t\t * Let's be nice to Linksys and try to parse document anyway.\n\t\t * If the data sended is not a xml file, ixmlParseBufferEx\n\t\t * will fail and the function will return UPNP_E_INVALID_DESC too. */\n#if 0\n\t\tfree(xml_buf);\n\t\treturn UPNP_E_INVALID_DESC;\n#endif\n\t}\n\n\tret_code = ixmlParseBufferEx(xml_buf, xmlDoc);\n\tfree(xml_buf);\n\tif (ret_code != IXML_SUCCESS) {\n\t\tif (ret_code == IXML_INSUFFICIENT_MEMORY) {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Out of memory, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t} else {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Invalid Description, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t}\n\t} else {\n#ifdef DEBUG\n\t\txml_buf = ixmlPrintNode((IXML_Node *)*xmlDoc);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Printing the Parsed xml document \\n %s\\n\", xml_buf);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"****************** END OF Parsed XML Doc *****************\\n\");\n\t\tixmlFreeDOMString(xml_buf);\n#endif\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Exiting UpnpDownloadXmlDoc\\n\");\n\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpDownloadXmlDoc(const char *url, IXML_Document **xmlDoc)\n{\n\tint ret_code;\n\tchar *xml_buf;\n\tchar content_type[LINE_SIZE];\n\n\tif (url == NULL || xmlDoc == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tret_code = UpnpDownloadUrlItem(url, &xml_buf, content_type);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Error downloading document, retCode: %d\\n\", ret_code);\n\t\treturn ret_code;\n\t}\n\n\tif (strncasecmp(content_type, \"text/xml\", strlen(\"text/xml\"))) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__, \"Not text/xml\\n\");\n\t\t/* Linksys WRT54G router returns\n\t\t * \"CONTENT-TYPE: application/octet-stream\".\n\t\t * Let's be nice to Linksys and try to parse document anyway.\n\t\t * If the data sended is not a xml file, ixmlParseBufferEx\n\t\t * will fail and the function will return UPNP_E_INVALID_DESC too. */\n#if 0\n\t\tfree(xml_buf);\n\t\treturn UPNP_E_INVALID_DESC;\n#endif\n\t}\n\n\tret_code = ixmlParseBufferEx(xml_buf, xmlDoc);\n\tfree(xml_buf);\n\tif (ret_code != IXML_SUCCESS) {\n\t\tif (ret_code == IXML_INSUFFICIENT_MEMORY) {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Out of memory, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t} else {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Invalid Description, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t}\n\t} else {\n#ifdef DEBUG\n\t\txml_buf = ixmlPrintNode((IXML_Node *)*xmlDoc);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Printing the Parsed xml document \\n %s\\n\", xml_buf);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"****************** END OF Parsed XML Doc *****************\\n\");\n\t\tixmlFreeDOMString(xml_buf);\n#endif\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Exiting UpnpDownloadXmlDoc\\n\");\n\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListInit",
          "args": [
            "&HInfo->SsdpSearchList",
            "NULL",
            "NULL"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "HInfo->LowerDescURL",
            "LowerDescUrl",
            "sizeof(HInfo->LowerDescURL) - 1"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "HInfo->LowerDescURL",
            "DescUrl",
            "sizeof(HInfo->LowerDescURL) - 1"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "HInfo->DescURL",
            "DescUrl",
            "sizeof(HInfo->DescURL) - 1"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (struct Handle_Info)"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetFreeHandle",
          "args": [],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "GetFreeHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "759-770",
          "snippet": "static int GetFreeHandle()\n{\n\t/* Handle 0 is not used as NULL translates to 0 when passed as a handle */\n\tint i = 1;\n\n\twhile (i < NUM_HANDLE && HandleTable[i] != NULL)\n\t\t++i;\n\tif (i == NUM_HANDLE)\n\t\treturn UPNP_E_OUTOF_HANDLE;\n\telse\n\t\treturn i;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int GetFreeHandle()\n{\n\t/* Handle 0 is not used as NULL translates to 0 when passed as a handle */\n\tint i = 1;\n\n\twhile (i < NUM_HANDLE && HandleTable[i] != NULL)\n\t\t++i;\n\tif (i == NUM_HANDLE)\n\t\treturn UPNP_E_OUTOF_HANDLE;\n\telse\n\t\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "((struct Handle_Info *)HandleTable[handler_index])->DescURL",
            "DescUrl"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "DescUrl"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\nint UpnpSdkInit = 0;\nint UpnpSdkDeviceRegisteredV4 = 0;\nint UpnpSdkDeviceregisteredV6 = 0;\n\nint UpnpRegisterRootDevice4(\n\tconst char *DescUrl,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie,\n\tUpnpDevice_Handle *Hnd,\n\tint AddressFamily,\n\tconst char *LowerDescUrl)\n{\n\tstruct Handle_Info *HInfo;\n\tint retVal = 0;\n#if EXCLUDE_GENA == 0\n\tint hasServiceTable = 0;\n#endif /* EXCLUDE_GENA */\n\tint handler_index = 0;\n\n\tHandleLock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpRegisterRootDevice4\\n\");\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\tif (Hnd == NULL ||\n\t    Fun == NULL ||\n\t    DescUrl == NULL ||\n\t    strlen(DescUrl) == (size_t)0 ||\n\t    (AddressFamily != AF_INET && AddressFamily != AF_INET6)) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\t/* Test for already regsitered IPV4. */\n\tif (AddressFamily == AF_INET && UpnpSdkDeviceRegisteredV4 == 1) {\n\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\tgoto exit_function;\n\t}\n\t/* Test for already registered IPV6. IPV6 devices might register on multiple\n\t * IPv6 addresses (link local and GUA or ULA), so we must to check the\n\t * description URL in the HandleTable. */\n\twhile (handler_index < NUM_HANDLE && HandleTable[handler_index] != NULL) {\n\t\tif (strcmp(((struct Handle_Info *)HandleTable[handler_index])->DescURL, DescUrl)) {\n\t\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\t\tgoto exit_function;\n\t\t}\n\t\thandler_index++;\n\t}\n\t*Hnd = GetFreeHandle();\n\tif (*Hnd == UPNP_E_OUTOF_HANDLE) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tHInfo = (struct Handle_Info *)malloc(sizeof (struct Handle_Info));\n\tif (HInfo == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tmemset(HInfo, 0, sizeof(struct Handle_Info));\n\tHandleTable[*Hnd] = HInfo;\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Root device URL is %s\\n\", DescUrl);\n\tHInfo->aliasInstalled = 0;\n\tHInfo->HType = HND_DEVICE;\n\tstrncpy(HInfo->DescURL, DescUrl, sizeof(HInfo->DescURL) - 1);\n\tif (LowerDescUrl == NULL)\n\t\tstrncpy(HInfo->LowerDescURL, DescUrl,\n\t\t\tsizeof(HInfo->LowerDescURL) - 1);\n\telse\n\t\tstrncpy(HInfo->LowerDescURL, LowerDescUrl,\n\t\t\tsizeof(HInfo->LowerDescURL) - 1);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Following Root Device URL will be used when answering to legacy CPs %s\\n\",\n\t\tHInfo->LowerDescURL);\n\tHInfo->Callback = Fun;\n\tHInfo->Cookie = (void *)Cookie;\n\tHInfo->MaxAge = DEFAULT_MAXAGE;\n\tHInfo->DeviceList = NULL;\n\tHInfo->ServiceList = NULL;\n\tHInfo->DescDocument = NULL;\n#ifdef INCLUDE_CLIENT_APIS\n\tListInit(&HInfo->SsdpSearchList, NULL, NULL);\n\tHInfo->ClientSubList = NULL;\n#endif /* INCLUDE_CLIENT_APIS */\n\tHInfo->MaxSubscriptions = UPNP_INFINITE;\n\tHInfo->MaxSubscriptionTimeOut = UPNP_INFINITE;\n\tHInfo->DeviceAf = AddressFamily;\n\tretVal = UpnpDownloadXmlDoc(HInfo->DescURL, &(HInfo->DescDocument));\n\tif (retVal != UPNP_E_SUCCESS) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tFreeHandle(*Hnd);\n\t\tgoto exit_function;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice4: Valid Description\\n\"\n\t\t\"UpnpRegisterRootDevice4: DescURL : %s\\n\",\n\t\tHInfo->DescURL);\n\n\tHInfo->DeviceList = ixmlDocument_getElementsByTagName(\n\t\tHInfo->DescDocument, \"device\");\n\tif (!HInfo->DeviceList) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tixmlDocument_free(HInfo->DescDocument);\n\t\tFreeHandle(*Hnd);\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: No devices found for RootDevice\\n\");\n\t\tretVal = UPNP_E_INVALID_DESC;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo->ServiceList = ixmlDocument_getElementsByTagName(\n\tHInfo->DescDocument, \"serviceList\" );\n\tif (!HInfo->ServiceList) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: No services found for RootDevice\\n\");\n\t}\n\n#if EXCLUDE_GENA == 0\n\t/*\n\t * GENA SET UP\n\t */\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice4: Gena Check\\n\" );\n\tmemset(&HInfo->ServiceTable, 0, sizeof(HInfo->ServiceTable));\n\thasServiceTable = getServiceTable(\n\t\t(IXML_Node *)HInfo->DescDocument,\n\t\t&HInfo->ServiceTable,\n\t\tHInfo->DescURL);\n\tif (hasServiceTable) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: GENA Service Table \\n\"\n\t\t\t\"Here are the known services: \\n\" );\n\t\tprintServiceTable(&HInfo->ServiceTable, UPNP_ALL, API);\n\t} else {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"\\nUpnpRegisterRootDevice4: Empty service table\\n\");\n\t}\n#endif /* EXCLUDE_GENA */\n\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tUpnpSdkDeviceRegisteredV4 = 1;\n\t\tbreak;\n\tdefault:\n\t\tUpnpSdkDeviceregisteredV6 = 1;\n\t}\n\n\tretVal = UPNP_E_SUCCESS;\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting RegisterRootDevice4, return value == %d\\n\", retVal);\n\tHandleUnlock();\n\n\treturn retVal;\n}"
  },
  {
    "function_name": "UpnpRegisterRootDevice3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "1116-1127",
    "snippet": "int UpnpRegisterRootDevice3(\n\tconst char *DescUrl,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie,\n\tUpnpDevice_Handle *Hnd,\n\tint AddressFamily)\n{\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpRegisterRootDevice3\\n\");\n\treturn UpnpRegisterRootDevice4(DescUrl, Fun, Cookie, Hnd,\n\t\tAddressFamily, NULL);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpRegisterRootDevice4",
          "args": [
            "DescUrl",
            "Fun",
            "Cookie",
            "Hnd",
            "AddressFamily",
            "NULL"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpRegisterRootDevice4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "1132-1289",
          "snippet": "int UpnpRegisterRootDevice4(\n\tconst char *DescUrl,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie,\n\tUpnpDevice_Handle *Hnd,\n\tint AddressFamily,\n\tconst char *LowerDescUrl)\n{\n\tstruct Handle_Info *HInfo;\n\tint retVal = 0;\n#if EXCLUDE_GENA == 0\n\tint hasServiceTable = 0;\n#endif /* EXCLUDE_GENA */\n\tint handler_index = 0;\n\n\tHandleLock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpRegisterRootDevice4\\n\");\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\tif (Hnd == NULL ||\n\t    Fun == NULL ||\n\t    DescUrl == NULL ||\n\t    strlen(DescUrl) == (size_t)0 ||\n\t    (AddressFamily != AF_INET && AddressFamily != AF_INET6)) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\t/* Test for already regsitered IPV4. */\n\tif (AddressFamily == AF_INET && UpnpSdkDeviceRegisteredV4 == 1) {\n\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\tgoto exit_function;\n\t}\n\t/* Test for already registered IPV6. IPV6 devices might register on multiple\n\t * IPv6 addresses (link local and GUA or ULA), so we must to check the\n\t * description URL in the HandleTable. */\n\twhile (handler_index < NUM_HANDLE && HandleTable[handler_index] != NULL) {\n\t\tif (strcmp(((struct Handle_Info *)HandleTable[handler_index])->DescURL, DescUrl)) {\n\t\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\t\tgoto exit_function;\n\t\t}\n\t\thandler_index++;\n\t}\n\t*Hnd = GetFreeHandle();\n\tif (*Hnd == UPNP_E_OUTOF_HANDLE) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tHInfo = (struct Handle_Info *)malloc(sizeof (struct Handle_Info));\n\tif (HInfo == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tmemset(HInfo, 0, sizeof(struct Handle_Info));\n\tHandleTable[*Hnd] = HInfo;\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Root device URL is %s\\n\", DescUrl);\n\tHInfo->aliasInstalled = 0;\n\tHInfo->HType = HND_DEVICE;\n\tstrncpy(HInfo->DescURL, DescUrl, sizeof(HInfo->DescURL) - 1);\n\tif (LowerDescUrl == NULL)\n\t\tstrncpy(HInfo->LowerDescURL, DescUrl,\n\t\t\tsizeof(HInfo->LowerDescURL) - 1);\n\telse\n\t\tstrncpy(HInfo->LowerDescURL, LowerDescUrl,\n\t\t\tsizeof(HInfo->LowerDescURL) - 1);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Following Root Device URL will be used when answering to legacy CPs %s\\n\",\n\t\tHInfo->LowerDescURL);\n\tHInfo->Callback = Fun;\n\tHInfo->Cookie = (void *)Cookie;\n\tHInfo->MaxAge = DEFAULT_MAXAGE;\n\tHInfo->DeviceList = NULL;\n\tHInfo->ServiceList = NULL;\n\tHInfo->DescDocument = NULL;\n#ifdef INCLUDE_CLIENT_APIS\n\tListInit(&HInfo->SsdpSearchList, NULL, NULL);\n\tHInfo->ClientSubList = NULL;\n#endif /* INCLUDE_CLIENT_APIS */\n\tHInfo->MaxSubscriptions = UPNP_INFINITE;\n\tHInfo->MaxSubscriptionTimeOut = UPNP_INFINITE;\n\tHInfo->DeviceAf = AddressFamily;\n\tretVal = UpnpDownloadXmlDoc(HInfo->DescURL, &(HInfo->DescDocument));\n\tif (retVal != UPNP_E_SUCCESS) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tFreeHandle(*Hnd);\n\t\tgoto exit_function;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice4: Valid Description\\n\"\n\t\t\"UpnpRegisterRootDevice4: DescURL : %s\\n\",\n\t\tHInfo->DescURL);\n\n\tHInfo->DeviceList = ixmlDocument_getElementsByTagName(\n\t\tHInfo->DescDocument, \"device\");\n\tif (!HInfo->DeviceList) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tixmlDocument_free(HInfo->DescDocument);\n\t\tFreeHandle(*Hnd);\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: No devices found for RootDevice\\n\");\n\t\tretVal = UPNP_E_INVALID_DESC;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo->ServiceList = ixmlDocument_getElementsByTagName(\n\tHInfo->DescDocument, \"serviceList\" );\n\tif (!HInfo->ServiceList) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: No services found for RootDevice\\n\");\n\t}\n\n#if EXCLUDE_GENA == 0\n\t/*\n\t * GENA SET UP\n\t */\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice4: Gena Check\\n\" );\n\tmemset(&HInfo->ServiceTable, 0, sizeof(HInfo->ServiceTable));\n\thasServiceTable = getServiceTable(\n\t\t(IXML_Node *)HInfo->DescDocument,\n\t\t&HInfo->ServiceTable,\n\t\tHInfo->DescURL);\n\tif (hasServiceTable) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: GENA Service Table \\n\"\n\t\t\t\"Here are the known services: \\n\" );\n\t\tprintServiceTable(&HInfo->ServiceTable, UPNP_ALL, API);\n\t} else {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"\\nUpnpRegisterRootDevice4: Empty service table\\n\");\n\t}\n#endif /* EXCLUDE_GENA */\n\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tUpnpSdkDeviceRegisteredV4 = 1;\n\t\tbreak;\n\tdefault:\n\t\tUpnpSdkDeviceregisteredV6 = 1;\n\t}\n\n\tretVal = UPNP_E_SUCCESS;\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting RegisterRootDevice4, return value == %d\\n\", retVal);\n\tHandleUnlock();\n\n\treturn retVal;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];",
            "int UpnpSdkInit = 0;",
            "int UpnpSdkDeviceRegisteredV4 = 0;",
            "int UpnpSdkDeviceregisteredV6 = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\nint UpnpSdkInit = 0;\nint UpnpSdkDeviceRegisteredV4 = 0;\nint UpnpSdkDeviceregisteredV6 = 0;\n\nint UpnpRegisterRootDevice4(\n\tconst char *DescUrl,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie,\n\tUpnpDevice_Handle *Hnd,\n\tint AddressFamily,\n\tconst char *LowerDescUrl)\n{\n\tstruct Handle_Info *HInfo;\n\tint retVal = 0;\n#if EXCLUDE_GENA == 0\n\tint hasServiceTable = 0;\n#endif /* EXCLUDE_GENA */\n\tint handler_index = 0;\n\n\tHandleLock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpRegisterRootDevice4\\n\");\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\tif (Hnd == NULL ||\n\t    Fun == NULL ||\n\t    DescUrl == NULL ||\n\t    strlen(DescUrl) == (size_t)0 ||\n\t    (AddressFamily != AF_INET && AddressFamily != AF_INET6)) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\t/* Test for already regsitered IPV4. */\n\tif (AddressFamily == AF_INET && UpnpSdkDeviceRegisteredV4 == 1) {\n\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\tgoto exit_function;\n\t}\n\t/* Test for already registered IPV6. IPV6 devices might register on multiple\n\t * IPv6 addresses (link local and GUA or ULA), so we must to check the\n\t * description URL in the HandleTable. */\n\twhile (handler_index < NUM_HANDLE && HandleTable[handler_index] != NULL) {\n\t\tif (strcmp(((struct Handle_Info *)HandleTable[handler_index])->DescURL, DescUrl)) {\n\t\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\t\tgoto exit_function;\n\t\t}\n\t\thandler_index++;\n\t}\n\t*Hnd = GetFreeHandle();\n\tif (*Hnd == UPNP_E_OUTOF_HANDLE) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tHInfo = (struct Handle_Info *)malloc(sizeof (struct Handle_Info));\n\tif (HInfo == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tmemset(HInfo, 0, sizeof(struct Handle_Info));\n\tHandleTable[*Hnd] = HInfo;\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Root device URL is %s\\n\", DescUrl);\n\tHInfo->aliasInstalled = 0;\n\tHInfo->HType = HND_DEVICE;\n\tstrncpy(HInfo->DescURL, DescUrl, sizeof(HInfo->DescURL) - 1);\n\tif (LowerDescUrl == NULL)\n\t\tstrncpy(HInfo->LowerDescURL, DescUrl,\n\t\t\tsizeof(HInfo->LowerDescURL) - 1);\n\telse\n\t\tstrncpy(HInfo->LowerDescURL, LowerDescUrl,\n\t\t\tsizeof(HInfo->LowerDescURL) - 1);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Following Root Device URL will be used when answering to legacy CPs %s\\n\",\n\t\tHInfo->LowerDescURL);\n\tHInfo->Callback = Fun;\n\tHInfo->Cookie = (void *)Cookie;\n\tHInfo->MaxAge = DEFAULT_MAXAGE;\n\tHInfo->DeviceList = NULL;\n\tHInfo->ServiceList = NULL;\n\tHInfo->DescDocument = NULL;\n#ifdef INCLUDE_CLIENT_APIS\n\tListInit(&HInfo->SsdpSearchList, NULL, NULL);\n\tHInfo->ClientSubList = NULL;\n#endif /* INCLUDE_CLIENT_APIS */\n\tHInfo->MaxSubscriptions = UPNP_INFINITE;\n\tHInfo->MaxSubscriptionTimeOut = UPNP_INFINITE;\n\tHInfo->DeviceAf = AddressFamily;\n\tretVal = UpnpDownloadXmlDoc(HInfo->DescURL, &(HInfo->DescDocument));\n\tif (retVal != UPNP_E_SUCCESS) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tFreeHandle(*Hnd);\n\t\tgoto exit_function;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice4: Valid Description\\n\"\n\t\t\"UpnpRegisterRootDevice4: DescURL : %s\\n\",\n\t\tHInfo->DescURL);\n\n\tHInfo->DeviceList = ixmlDocument_getElementsByTagName(\n\t\tHInfo->DescDocument, \"device\");\n\tif (!HInfo->DeviceList) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tixmlDocument_free(HInfo->DescDocument);\n\t\tFreeHandle(*Hnd);\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: No devices found for RootDevice\\n\");\n\t\tretVal = UPNP_E_INVALID_DESC;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo->ServiceList = ixmlDocument_getElementsByTagName(\n\tHInfo->DescDocument, \"serviceList\" );\n\tif (!HInfo->ServiceList) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: No services found for RootDevice\\n\");\n\t}\n\n#if EXCLUDE_GENA == 0\n\t/*\n\t * GENA SET UP\n\t */\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice4: Gena Check\\n\" );\n\tmemset(&HInfo->ServiceTable, 0, sizeof(HInfo->ServiceTable));\n\thasServiceTable = getServiceTable(\n\t\t(IXML_Node *)HInfo->DescDocument,\n\t\t&HInfo->ServiceTable,\n\t\tHInfo->DescURL);\n\tif (hasServiceTable) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice4: GENA Service Table \\n\"\n\t\t\t\"Here are the known services: \\n\" );\n\t\tprintServiceTable(&HInfo->ServiceTable, UPNP_ALL, API);\n\t} else {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"\\nUpnpRegisterRootDevice4: Empty service table\\n\");\n\t}\n#endif /* EXCLUDE_GENA */\n\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tUpnpSdkDeviceRegisteredV4 = 1;\n\t\tbreak;\n\tdefault:\n\t\tUpnpSdkDeviceregisteredV6 = 1;\n\t}\n\n\tretVal = UPNP_E_SUCCESS;\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting RegisterRootDevice4, return value == %d\\n\", retVal);\n\tHandleUnlock();\n\n\treturn retVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Inside UpnpRegisterRootDevice3\\n\""
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpRegisterRootDevice3(\n\tconst char *DescUrl,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie,\n\tUpnpDevice_Handle *Hnd,\n\tint AddressFamily)\n{\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpRegisterRootDevice3\\n\");\n\treturn UpnpRegisterRootDevice4(DescUrl, Fun, Cookie, Hnd,\n\t\tAddressFamily, NULL);\n}"
  },
  {
    "function_name": "UpnpRegisterRootDevice2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "970-1111",
    "snippet": "int UpnpRegisterRootDevice2(\n\tUpnp_DescType descriptionType,\n\tconst char *description_const,\n\tsize_t bufferLen,   /* ignored */\n\tint config_baseURL,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie,\n\tUpnpDevice_Handle *Hnd)\n{\n\tstruct Handle_Info *HInfo = NULL;\n\tint retVal = 0;\n#if EXCLUDE_GENA == 0\n\tint hasServiceTable = 0;\n#endif /* EXCLUDE_GENA */\n\tchar *description = (char *)description_const;\n\n\tHandleLock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpRegisterRootDevice2\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (Hnd == NULL || Fun == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\n\tif (UpnpSdkDeviceRegisteredV4 == 1) {\n\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\tgoto exit_function;\n\t}\n\n\t*Hnd = GetFreeHandle();\n\tif (*Hnd == UPNP_E_OUTOF_HANDLE) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo = (struct Handle_Info *)malloc(sizeof (struct Handle_Info));\n\tif (HInfo == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tmemset(HInfo, 0, sizeof(struct Handle_Info));\n\tHandleTable[*Hnd] = HInfo;\n\n\t/* prevent accidental removal of a non-existent alias */\n\tHInfo->aliasInstalled = 0;\n\n\tretVal = GetDescDocumentAndURL(\n\t\tdescriptionType, description,\n\t\tconfig_baseURL, AF_INET, \n\t\t&HInfo->DescDocument, HInfo->DescURL);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tFreeHandle(*Hnd);\n\t\tgoto exit_function;\n\t}\n\n\tstrncpy(HInfo->LowerDescURL, HInfo->DescURL,\n\t\tsizeof(HInfo->LowerDescURL) - 1);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Following Root Device URL will be used when answering to legacy CPs %s\\n\",\n\t\tHInfo->LowerDescURL);\n\tHInfo->aliasInstalled = config_baseURL != 0;\n\tHInfo->HType = HND_DEVICE;\n\tHInfo->Callback = Fun;\n\tHInfo->Cookie = (void *)Cookie;\n\tHInfo->MaxAge = DEFAULT_MAXAGE;\n\tHInfo->DeviceList = NULL;\n\tHInfo->ServiceList = NULL;\n#ifdef INCLUDE_CLIENT_APIS\n\tListInit(&HInfo->SsdpSearchList, NULL, NULL);\n\tHInfo->ClientSubList = NULL;\n#endif /* INCLUDE_CLIENT_APIS */\n\tHInfo->MaxSubscriptions = UPNP_INFINITE;\n\tHInfo->MaxSubscriptionTimeOut = UPNP_INFINITE;\n\tHInfo->DeviceAf = AF_INET;\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice2: Valid Description\\n\"\n\t\t\"UpnpRegisterRootDevice2: DescURL : %s\\n\",\n\t\tHInfo->DescURL);\n\n\tHInfo->DeviceList =\n\t\tixmlDocument_getElementsByTagName( HInfo->DescDocument, \"device\" );\n\tif (!HInfo->DeviceList) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tixmlDocument_free(HInfo->DescDocument);\n\t\tFreeHandle(*Hnd);\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice2: No devices found for RootDevice\\n\" );\n\t\tretVal = UPNP_E_INVALID_DESC;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo->ServiceList = ixmlDocument_getElementsByTagName(\n\t\tHInfo->DescDocument, \"serviceList\" );\n\tif (!HInfo->ServiceList) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice2: No services found for RootDevice\\n\");\n\t}\n\n#if EXCLUDE_GENA == 0\n\t/*\n\t * GENA SET UP\n\t */\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice2: Gena Check\\n\" );\n\tmemset(&HInfo->ServiceTable, 0, sizeof(HInfo->ServiceTable));\n\thasServiceTable = getServiceTable(\n\t\t(IXML_Node *)HInfo->DescDocument,\n\t\t&HInfo->ServiceTable,\n\t\tHInfo->DescURL);\n\tif (hasServiceTable) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice2: GENA Service Table\\n\"\n\t\t\t\"Here are the known services: \\n\");\n\t\tprintServiceTable(&HInfo->ServiceTable, UPNP_ALL, API);\n\t} else {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"\\nUpnpRegisterRootDevice2: Empty service table\\n\");\n\t}\n#endif /* EXCLUDE_GENA */\n\n\tUpnpSdkDeviceRegisteredV4 = 1;\n\n\tretVal = UPNP_E_SUCCESS;\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting RegisterRootDevice2, return value == %d\\n\", retVal);\n\tHandleUnlock();\n\n\treturn retVal;\n\tbufferLen = bufferLen;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *HandleTable[NUM_HANDLE];",
      "int UpnpSdkInit = 0;",
      "int UpnpSdkDeviceRegisteredV4 = 0;",
      "static int GetDescDocumentAndURL(\n\t/* [in] pointer to server address structure. */\n\tUpnp_DescType descriptionType,\n\t/* [in] . */\n\tchar *description,\n\t/* [in] . */\n\tint config_baseURL,\n\t/* [in] . */\n\tint AddressFamily,\n\t/* [out] . */\n\tIXML_Document **xmlDoc,\n\t/* [out] . */\n\tchar descURL[LINE_SIZE]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting RegisterRootDevice2, return value == %d\\n\"",
            "retVal"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printServiceTable",
          "args": [
            "&HInfo->ServiceTable",
            "UPNP_ALL",
            "API"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "printServiceTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/service_table.h",
          "lines": "260-269",
          "snippet": "static UPNP_INLINE void printServiceTable(\n\tservice_table *table,\n\tUpnp_LogLevel level,\n\tDbg_Module module)\n{\n\treturn;\n\ttable = table;\n\tlevel = level;\n\tmodule = module;\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdio.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdio.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"uri.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void printServiceTable(\n\tservice_table *table,\n\tUpnp_LogLevel level,\n\tDbg_Module module)\n{\n\treturn;\n\ttable = table;\n\tlevel = level;\n\tmodule = module;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getServiceTable",
          "args": [
            "(IXML_Node *)HInfo->DescDocument",
            "&HInfo->ServiceTable",
            "HInfo->DescURL"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "getServiceTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "1043-1070",
          "snippet": "int\ngetServiceTable( IXML_Node * node,\n                 service_table * out,\n                 const char *DefaultURLBase )\n{\n    IXML_Node *root = NULL;\n    IXML_Node *URLBase = NULL;\n\n    if( getSubElement( \"root\", node, &root ) ) {\n        if( getSubElement( \"URLBase\", root, &URLBase ) ) {\n            out->URLBase = getElementValue( URLBase );\n        } else {\n            if( DefaultURLBase ) {\n                out->URLBase = ixmlCloneDOMString( DefaultURLBase );\n            } else {\n                out->URLBase = ixmlCloneDOMString( \"\" );\n            }\n        }\n\n        if( ( out->serviceList = getAllServiceList(\n            root, out->URLBase, &out->endServiceList ) ) ) {\n            return 1;\n        }\n\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nint\ngetServiceTable( IXML_Node * node,\n                 service_table * out,\n                 const char *DefaultURLBase )\n{\n    IXML_Node *root = NULL;\n    IXML_Node *URLBase = NULL;\n\n    if( getSubElement( \"root\", node, &root ) ) {\n        if( getSubElement( \"URLBase\", root, &URLBase ) ) {\n            out->URLBase = getElementValue( URLBase );\n        } else {\n            if( DefaultURLBase ) {\n                out->URLBase = ixmlCloneDOMString( DefaultURLBase );\n            } else {\n                out->URLBase = ixmlCloneDOMString( \"\" );\n            }\n        }\n\n        if( ( out->serviceList = getAllServiceList(\n            root, out->URLBase, &out->endServiceList ) ) ) {\n            return 1;\n        }\n\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&HInfo->ServiceTable",
            "0",
            "sizeof(HInfo->ServiceTable)"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlDocument_getElementsByTagName",
          "args": [
            "HInfo->DescDocument",
            "\"serviceList\""
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeHandle",
          "args": [
            "*Hnd"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "FreeHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "777-802",
          "snippet": "static int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "HInfo->DescDocument"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListDestroy",
          "args": [
            "&HInfo->SsdpSearchList",
            "0"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_getElementsByTagName",
          "args": [
            "HInfo->DescDocument",
            "\"device\""
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListInit",
          "args": [
            "&HInfo->SsdpSearchList",
            "NULL",
            "NULL"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "HInfo->LowerDescURL",
            "HInfo->DescURL",
            "sizeof(HInfo->LowerDescURL) - 1"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDescDocumentAndURL",
          "args": [
            "descriptionType",
            "description",
            "config_baseURL",
            "AF_INET",
            "&HInfo->DescDocument",
            "HInfo->DescURL"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "GetDescDocumentAndURL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "1661-1692",
          "snippet": "static int GetDescDocumentAndURL(\n\tUpnp_DescType descriptionType,\n\tchar *description,\n\tint config_baseURL,\n\tint AddressFamily,\n\tIXML_Document **xmlDoc,\n\tchar descURL[LINE_SIZE])\n{\n\tint retVal = 0;\n\n\tif (descriptionType != (enum Upnp_DescType_e)UPNPREG_URL_DESC ||\n\t\tconfig_baseURL) {\n\t\treturn UPNP_E_NO_WEB_SERVER;\n\t}\n\n\tif (description == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (strlen(description) > LINE_SIZE - (size_t)1) {\n\t\treturn UPNP_E_URL_TOO_BIG;\n\t}\n\tstrncpy(descURL, description, LINE_SIZE - 1);\n\tdescURL[LINE_SIZE - 1] = '\\0';\n\n\tretVal = UpnpDownloadXmlDoc(description, xmlDoc);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int GetDescDocumentAndURL(\n\t/* [in] pointer to server address structure. */\n\tUpnp_DescType descriptionType,\n\t/* [in] . */\n\tchar *description,\n\t/* [in] . */\n\tint config_baseURL,\n\t/* [in] . */\n\tint AddressFamily,\n\t/* [out] . */\n\tIXML_Document **xmlDoc,\n\t/* [out] . */\n\tchar descURL[LINE_SIZE]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic int GetDescDocumentAndURL(\n\t/* [in] pointer to server address structure. */\n\tUpnp_DescType descriptionType,\n\t/* [in] . */\n\tchar *description,\n\t/* [in] . */\n\tint config_baseURL,\n\t/* [in] . */\n\tint AddressFamily,\n\t/* [out] . */\n\tIXML_Document **xmlDoc,\n\t/* [out] . */\n\tchar descURL[LINE_SIZE]);\n\nstatic int GetDescDocumentAndURL(\n\tUpnp_DescType descriptionType,\n\tchar *description,\n\tint config_baseURL,\n\tint AddressFamily,\n\tIXML_Document **xmlDoc,\n\tchar descURL[LINE_SIZE])\n{\n\tint retVal = 0;\n\n\tif (descriptionType != (enum Upnp_DescType_e)UPNPREG_URL_DESC ||\n\t\tconfig_baseURL) {\n\t\treturn UPNP_E_NO_WEB_SERVER;\n\t}\n\n\tif (description == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (strlen(description) > LINE_SIZE - (size_t)1) {\n\t\treturn UPNP_E_URL_TOO_BIG;\n\t}\n\tstrncpy(descURL, description, LINE_SIZE - 1);\n\tdescURL[LINE_SIZE - 1] = '\\0';\n\n\tretVal = UpnpDownloadXmlDoc(description, xmlDoc);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (struct Handle_Info)"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetFreeHandle",
          "args": [],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "GetFreeHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "759-770",
          "snippet": "static int GetFreeHandle()\n{\n\t/* Handle 0 is not used as NULL translates to 0 when passed as a handle */\n\tint i = 1;\n\n\twhile (i < NUM_HANDLE && HandleTable[i] != NULL)\n\t\t++i;\n\tif (i == NUM_HANDLE)\n\t\treturn UPNP_E_OUTOF_HANDLE;\n\telse\n\t\treturn i;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int GetFreeHandle()\n{\n\t/* Handle 0 is not used as NULL translates to 0 when passed as a handle */\n\tint i = 1;\n\n\twhile (i < NUM_HANDLE && HandleTable[i] != NULL)\n\t\t++i;\n\tif (i == NUM_HANDLE)\n\t\treturn UPNP_E_OUTOF_HANDLE;\n\telse\n\t\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic void *HandleTable[NUM_HANDLE];\nint UpnpSdkInit = 0;\nint UpnpSdkDeviceRegisteredV4 = 0;\nstatic int GetDescDocumentAndURL(\n\t/* [in] pointer to server address structure. */\n\tUpnp_DescType descriptionType,\n\t/* [in] . */\n\tchar *description,\n\t/* [in] . */\n\tint config_baseURL,\n\t/* [in] . */\n\tint AddressFamily,\n\t/* [out] . */\n\tIXML_Document **xmlDoc,\n\t/* [out] . */\n\tchar descURL[LINE_SIZE]);\n\nint UpnpRegisterRootDevice2(\n\tUpnp_DescType descriptionType,\n\tconst char *description_const,\n\tsize_t bufferLen,   /* ignored */\n\tint config_baseURL,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie,\n\tUpnpDevice_Handle *Hnd)\n{\n\tstruct Handle_Info *HInfo = NULL;\n\tint retVal = 0;\n#if EXCLUDE_GENA == 0\n\tint hasServiceTable = 0;\n#endif /* EXCLUDE_GENA */\n\tchar *description = (char *)description_const;\n\n\tHandleLock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpRegisterRootDevice2\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (Hnd == NULL || Fun == NULL) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\n\tif (UpnpSdkDeviceRegisteredV4 == 1) {\n\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\tgoto exit_function;\n\t}\n\n\t*Hnd = GetFreeHandle();\n\tif (*Hnd == UPNP_E_OUTOF_HANDLE) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo = (struct Handle_Info *)malloc(sizeof (struct Handle_Info));\n\tif (HInfo == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tmemset(HInfo, 0, sizeof(struct Handle_Info));\n\tHandleTable[*Hnd] = HInfo;\n\n\t/* prevent accidental removal of a non-existent alias */\n\tHInfo->aliasInstalled = 0;\n\n\tretVal = GetDescDocumentAndURL(\n\t\tdescriptionType, description,\n\t\tconfig_baseURL, AF_INET, \n\t\t&HInfo->DescDocument, HInfo->DescURL);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tFreeHandle(*Hnd);\n\t\tgoto exit_function;\n\t}\n\n\tstrncpy(HInfo->LowerDescURL, HInfo->DescURL,\n\t\tsizeof(HInfo->LowerDescURL) - 1);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Following Root Device URL will be used when answering to legacy CPs %s\\n\",\n\t\tHInfo->LowerDescURL);\n\tHInfo->aliasInstalled = config_baseURL != 0;\n\tHInfo->HType = HND_DEVICE;\n\tHInfo->Callback = Fun;\n\tHInfo->Cookie = (void *)Cookie;\n\tHInfo->MaxAge = DEFAULT_MAXAGE;\n\tHInfo->DeviceList = NULL;\n\tHInfo->ServiceList = NULL;\n#ifdef INCLUDE_CLIENT_APIS\n\tListInit(&HInfo->SsdpSearchList, NULL, NULL);\n\tHInfo->ClientSubList = NULL;\n#endif /* INCLUDE_CLIENT_APIS */\n\tHInfo->MaxSubscriptions = UPNP_INFINITE;\n\tHInfo->MaxSubscriptionTimeOut = UPNP_INFINITE;\n\tHInfo->DeviceAf = AF_INET;\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice2: Valid Description\\n\"\n\t\t\"UpnpRegisterRootDevice2: DescURL : %s\\n\",\n\t\tHInfo->DescURL);\n\n\tHInfo->DeviceList =\n\t\tixmlDocument_getElementsByTagName( HInfo->DescDocument, \"device\" );\n\tif (!HInfo->DeviceList) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tixmlDocument_free(HInfo->DescDocument);\n\t\tFreeHandle(*Hnd);\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice2: No devices found for RootDevice\\n\" );\n\t\tretVal = UPNP_E_INVALID_DESC;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo->ServiceList = ixmlDocument_getElementsByTagName(\n\t\tHInfo->DescDocument, \"serviceList\" );\n\tif (!HInfo->ServiceList) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice2: No services found for RootDevice\\n\");\n\t}\n\n#if EXCLUDE_GENA == 0\n\t/*\n\t * GENA SET UP\n\t */\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice2: Gena Check\\n\" );\n\tmemset(&HInfo->ServiceTable, 0, sizeof(HInfo->ServiceTable));\n\thasServiceTable = getServiceTable(\n\t\t(IXML_Node *)HInfo->DescDocument,\n\t\t&HInfo->ServiceTable,\n\t\tHInfo->DescURL);\n\tif (hasServiceTable) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice2: GENA Service Table\\n\"\n\t\t\t\"Here are the known services: \\n\");\n\t\tprintServiceTable(&HInfo->ServiceTable, UPNP_ALL, API);\n\t} else {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"\\nUpnpRegisterRootDevice2: Empty service table\\n\");\n\t}\n#endif /* EXCLUDE_GENA */\n\n\tUpnpSdkDeviceRegisteredV4 = 1;\n\n\tretVal = UPNP_E_SUCCESS;\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting RegisterRootDevice2, return value == %d\\n\", retVal);\n\tHandleUnlock();\n\n\treturn retVal;\n\tbufferLen = bufferLen;\n}"
  },
  {
    "function_name": "UpnpRegisterRootDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "805-947",
    "snippet": "int UpnpRegisterRootDevice(\n\tconst char *DescUrl,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie,\n\tUpnpDevice_Handle *Hnd)\n{\n\tstruct Handle_Info *HInfo = NULL;\n\tint retVal = 0;\n#if EXCLUDE_GENA == 0\n\tint hasServiceTable = 0;\n#endif /* EXCLUDE_GENA */\n\n\tHandleLock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpRegisterRootDevice\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (Hnd == NULL ||\n\t    Fun == NULL ||\n\t    DescUrl == NULL ||\n\t    strlen(DescUrl) == (size_t)0) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\n\tif (UpnpSdkDeviceRegisteredV4 == 1) {\n\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\tgoto exit_function;\n\t}\n\n\t*Hnd = GetFreeHandle();\n\tif (*Hnd == UPNP_E_OUTOF_HANDLE) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo = (struct Handle_Info *)malloc(sizeof (struct Handle_Info));\n\tif (HInfo == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tmemset(HInfo, 0, sizeof(struct Handle_Info));\n\tHandleTable[*Hnd] = HInfo;\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Root device URL is %s\\n\", DescUrl );\n\n\tHInfo->aliasInstalled = 0;\n\tHInfo->HType = HND_DEVICE;\n\tstrncpy(HInfo->DescURL, DescUrl, sizeof(HInfo->DescURL) - 1);\n\tstrncpy(HInfo->LowerDescURL, DescUrl, sizeof(HInfo->LowerDescURL) - 1);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Following Root Device URL will be used when answering to legacy CPs %s\\n\",\n\t\tHInfo->LowerDescURL);\n\tHInfo->Callback = Fun;\n\tHInfo->Cookie = (void *)Cookie;\n\tHInfo->MaxAge = DEFAULT_MAXAGE;\n\tHInfo->DeviceList = NULL;\n\tHInfo->ServiceList = NULL;\n\tHInfo->DescDocument = NULL;\n#ifdef INCLUDE_CLIENT_APIS\n\tListInit(&HInfo->SsdpSearchList, NULL, NULL);\n\tHInfo->ClientSubList = NULL;\n#endif /* INCLUDE_CLIENT_APIS */\n\tHInfo->MaxSubscriptions = UPNP_INFINITE;\n\tHInfo->MaxSubscriptionTimeOut = UPNP_INFINITE;\n\tHInfo->DeviceAf = AF_INET;\n\n\tretVal = UpnpDownloadXmlDoc(HInfo->DescURL, &(HInfo->DescDocument));\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice: error downloading Document: %d\\n\",\n\t\t\tretVal);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tFreeHandle(*Hnd);\n\t\tgoto exit_function;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice: Valid Description\\n\"\n\t\t\"UpnpRegisterRootDevice: DescURL : %s\\n\",\n\t\tHInfo->DescURL);\n\n\tHInfo->DeviceList =\n\t\tixmlDocument_getElementsByTagName(HInfo->DescDocument, \"device\");\n\tif (!HInfo->DeviceList) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tixmlDocument_free(HInfo->DescDocument);\n\t\tFreeHandle(*Hnd);\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice: No devices found for RootDevice\\n\");\n\t\tretVal = UPNP_E_INVALID_DESC;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo->ServiceList = ixmlDocument_getElementsByTagName(\n\t\tHInfo->DescDocument, \"serviceList\");\n\tif (!HInfo->ServiceList) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice: No services found for RootDevice\\n\");\n\t}\n\n#if EXCLUDE_GENA == 0\n\t/*\n\t * GENA SET UP\n\t */\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice: Gena Check\\n\");\n\tmemset(&HInfo->ServiceTable, 0, sizeof(HInfo->ServiceTable));\n\thasServiceTable = getServiceTable(\n\t\t(IXML_Node *)HInfo->DescDocument,\n\t\t&HInfo->ServiceTable,\n\t\tHInfo->DescURL);\n\tif (hasServiceTable) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice: GENA Service Table\\n\"\n\t\t\t\"Here are the known services:\\n\");\n\t\tprintServiceTable( &HInfo->ServiceTable, UPNP_ALL, API );\n\t} else {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"\\nUpnpRegisterRootDevice: Empty service table\\n\");\n\t}\n#endif /* EXCLUDE_GENA */\n\n\tUpnpSdkDeviceRegisteredV4 = 1;\n\n\tretVal = UPNP_E_SUCCESS;\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting RegisterRootDevice, return value == %d\\n\", retVal);\n\tHandleUnlock();\n\n\treturn retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *HandleTable[NUM_HANDLE];",
      "int UpnpSdkInit = 0;",
      "int UpnpSdkDeviceRegisteredV4 = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting RegisterRootDevice, return value == %d\\n\"",
            "retVal"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printServiceTable",
          "args": [
            "&HInfo->ServiceTable",
            "UPNP_ALL",
            "API"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "printServiceTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/service_table.h",
          "lines": "260-269",
          "snippet": "static UPNP_INLINE void printServiceTable(\n\tservice_table *table,\n\tUpnp_LogLevel level,\n\tDbg_Module module)\n{\n\treturn;\n\ttable = table;\n\tlevel = level;\n\tmodule = module;\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdio.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdio.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"uri.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void printServiceTable(\n\tservice_table *table,\n\tUpnp_LogLevel level,\n\tDbg_Module module)\n{\n\treturn;\n\ttable = table;\n\tlevel = level;\n\tmodule = module;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getServiceTable",
          "args": [
            "(IXML_Node *)HInfo->DescDocument",
            "&HInfo->ServiceTable",
            "HInfo->DescURL"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "getServiceTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "1043-1070",
          "snippet": "int\ngetServiceTable( IXML_Node * node,\n                 service_table * out,\n                 const char *DefaultURLBase )\n{\n    IXML_Node *root = NULL;\n    IXML_Node *URLBase = NULL;\n\n    if( getSubElement( \"root\", node, &root ) ) {\n        if( getSubElement( \"URLBase\", root, &URLBase ) ) {\n            out->URLBase = getElementValue( URLBase );\n        } else {\n            if( DefaultURLBase ) {\n                out->URLBase = ixmlCloneDOMString( DefaultURLBase );\n            } else {\n                out->URLBase = ixmlCloneDOMString( \"\" );\n            }\n        }\n\n        if( ( out->serviceList = getAllServiceList(\n            root, out->URLBase, &out->endServiceList ) ) ) {\n            return 1;\n        }\n\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nint\ngetServiceTable( IXML_Node * node,\n                 service_table * out,\n                 const char *DefaultURLBase )\n{\n    IXML_Node *root = NULL;\n    IXML_Node *URLBase = NULL;\n\n    if( getSubElement( \"root\", node, &root ) ) {\n        if( getSubElement( \"URLBase\", root, &URLBase ) ) {\n            out->URLBase = getElementValue( URLBase );\n        } else {\n            if( DefaultURLBase ) {\n                out->URLBase = ixmlCloneDOMString( DefaultURLBase );\n            } else {\n                out->URLBase = ixmlCloneDOMString( \"\" );\n            }\n        }\n\n        if( ( out->serviceList = getAllServiceList(\n            root, out->URLBase, &out->endServiceList ) ) ) {\n            return 1;\n        }\n\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&HInfo->ServiceTable",
            "0",
            "sizeof(HInfo->ServiceTable)"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlDocument_getElementsByTagName",
          "args": [
            "HInfo->DescDocument",
            "\"serviceList\""
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeHandle",
          "args": [
            "*Hnd"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "FreeHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "777-802",
          "snippet": "static int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "HInfo->DescDocument"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListDestroy",
          "args": [
            "&HInfo->SsdpSearchList",
            "0"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_getElementsByTagName",
          "args": [
            "HInfo->DescDocument",
            "\"device\""
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListDestroy",
          "args": [
            "&HInfo->SsdpSearchList",
            "0"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDownloadXmlDoc",
          "args": [
            "HInfo->DescURL",
            "&(HInfo->DescDocument)"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpDownloadXmlDoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3256-3314",
          "snippet": "int UpnpDownloadXmlDoc(const char *url, IXML_Document **xmlDoc)\n{\n\tint ret_code;\n\tchar *xml_buf;\n\tchar content_type[LINE_SIZE];\n\n\tif (url == NULL || xmlDoc == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tret_code = UpnpDownloadUrlItem(url, &xml_buf, content_type);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Error downloading document, retCode: %d\\n\", ret_code);\n\t\treturn ret_code;\n\t}\n\n\tif (strncasecmp(content_type, \"text/xml\", strlen(\"text/xml\"))) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__, \"Not text/xml\\n\");\n\t\t/* Linksys WRT54G router returns\n\t\t * \"CONTENT-TYPE: application/octet-stream\".\n\t\t * Let's be nice to Linksys and try to parse document anyway.\n\t\t * If the data sended is not a xml file, ixmlParseBufferEx\n\t\t * will fail and the function will return UPNP_E_INVALID_DESC too. */\n#if 0\n\t\tfree(xml_buf);\n\t\treturn UPNP_E_INVALID_DESC;\n#endif\n\t}\n\n\tret_code = ixmlParseBufferEx(xml_buf, xmlDoc);\n\tfree(xml_buf);\n\tif (ret_code != IXML_SUCCESS) {\n\t\tif (ret_code == IXML_INSUFFICIENT_MEMORY) {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Out of memory, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t} else {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Invalid Description, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t}\n\t} else {\n#ifdef DEBUG\n\t\txml_buf = ixmlPrintNode((IXML_Node *)*xmlDoc);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Printing the Parsed xml document \\n %s\\n\", xml_buf);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"****************** END OF Parsed XML Doc *****************\\n\");\n\t\tixmlFreeDOMString(xml_buf);\n#endif\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Exiting UpnpDownloadXmlDoc\\n\");\n\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpDownloadXmlDoc(const char *url, IXML_Document **xmlDoc)\n{\n\tint ret_code;\n\tchar *xml_buf;\n\tchar content_type[LINE_SIZE];\n\n\tif (url == NULL || xmlDoc == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tret_code = UpnpDownloadUrlItem(url, &xml_buf, content_type);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Error downloading document, retCode: %d\\n\", ret_code);\n\t\treturn ret_code;\n\t}\n\n\tif (strncasecmp(content_type, \"text/xml\", strlen(\"text/xml\"))) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__, \"Not text/xml\\n\");\n\t\t/* Linksys WRT54G router returns\n\t\t * \"CONTENT-TYPE: application/octet-stream\".\n\t\t * Let's be nice to Linksys and try to parse document anyway.\n\t\t * If the data sended is not a xml file, ixmlParseBufferEx\n\t\t * will fail and the function will return UPNP_E_INVALID_DESC too. */\n#if 0\n\t\tfree(xml_buf);\n\t\treturn UPNP_E_INVALID_DESC;\n#endif\n\t}\n\n\tret_code = ixmlParseBufferEx(xml_buf, xmlDoc);\n\tfree(xml_buf);\n\tif (ret_code != IXML_SUCCESS) {\n\t\tif (ret_code == IXML_INSUFFICIENT_MEMORY) {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Out of memory, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t} else {\n\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\t\"Invalid Description, ixml error code: %d\\n\",\n\t\t\t\tret_code);\n\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t}\n\t} else {\n#ifdef DEBUG\n\t\txml_buf = ixmlPrintNode((IXML_Node *)*xmlDoc);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Printing the Parsed xml document \\n %s\\n\", xml_buf);\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"****************** END OF Parsed XML Doc *****************\\n\");\n\t\tixmlFreeDOMString(xml_buf);\n#endif\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Exiting UpnpDownloadXmlDoc\\n\");\n\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListInit",
          "args": [
            "&HInfo->SsdpSearchList",
            "NULL",
            "NULL"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "HInfo->LowerDescURL",
            "DescUrl",
            "sizeof(HInfo->LowerDescURL) - 1"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "HInfo->DescURL",
            "DescUrl",
            "sizeof(HInfo->DescURL) - 1"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (struct Handle_Info)"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetFreeHandle",
          "args": [],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "GetFreeHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "759-770",
          "snippet": "static int GetFreeHandle()\n{\n\t/* Handle 0 is not used as NULL translates to 0 when passed as a handle */\n\tint i = 1;\n\n\twhile (i < NUM_HANDLE && HandleTable[i] != NULL)\n\t\t++i;\n\tif (i == NUM_HANDLE)\n\t\treturn UPNP_E_OUTOF_HANDLE;\n\telse\n\t\treturn i;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int GetFreeHandle()\n{\n\t/* Handle 0 is not used as NULL translates to 0 when passed as a handle */\n\tint i = 1;\n\n\twhile (i < NUM_HANDLE && HandleTable[i] != NULL)\n\t\t++i;\n\tif (i == NUM_HANDLE)\n\t\treturn UPNP_E_OUTOF_HANDLE;\n\telse\n\t\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "DescUrl"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic void *HandleTable[NUM_HANDLE];\nint UpnpSdkInit = 0;\nint UpnpSdkDeviceRegisteredV4 = 0;\n\nint UpnpRegisterRootDevice(\n\tconst char *DescUrl,\n\tUpnp_FunPtr Fun,\n\tconst void *Cookie,\n\tUpnpDevice_Handle *Hnd)\n{\n\tstruct Handle_Info *HInfo = NULL;\n\tint retVal = 0;\n#if EXCLUDE_GENA == 0\n\tint hasServiceTable = 0;\n#endif /* EXCLUDE_GENA */\n\n\tHandleLock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside UpnpRegisterRootDevice\\n\");\n\n\tif (UpnpSdkInit != 1) {\n\t\tretVal = UPNP_E_FINISH;\n\t\tgoto exit_function;\n\t}\n\n\tif (Hnd == NULL ||\n\t    Fun == NULL ||\n\t    DescUrl == NULL ||\n\t    strlen(DescUrl) == (size_t)0) {\n\t\tretVal = UPNP_E_INVALID_PARAM;\n\t\tgoto exit_function;\n\t}\n\n\tif (UpnpSdkDeviceRegisteredV4 == 1) {\n\t\tretVal = UPNP_E_ALREADY_REGISTERED;\n\t\tgoto exit_function;\n\t}\n\n\t*Hnd = GetFreeHandle();\n\tif (*Hnd == UPNP_E_OUTOF_HANDLE) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo = (struct Handle_Info *)malloc(sizeof (struct Handle_Info));\n\tif (HInfo == NULL) {\n\t\tretVal = UPNP_E_OUTOF_MEMORY;\n\t\tgoto exit_function;\n\t}\n\tmemset(HInfo, 0, sizeof(struct Handle_Info));\n\tHandleTable[*Hnd] = HInfo;\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Root device URL is %s\\n\", DescUrl );\n\n\tHInfo->aliasInstalled = 0;\n\tHInfo->HType = HND_DEVICE;\n\tstrncpy(HInfo->DescURL, DescUrl, sizeof(HInfo->DescURL) - 1);\n\tstrncpy(HInfo->LowerDescURL, DescUrl, sizeof(HInfo->LowerDescURL) - 1);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Following Root Device URL will be used when answering to legacy CPs %s\\n\",\n\t\tHInfo->LowerDescURL);\n\tHInfo->Callback = Fun;\n\tHInfo->Cookie = (void *)Cookie;\n\tHInfo->MaxAge = DEFAULT_MAXAGE;\n\tHInfo->DeviceList = NULL;\n\tHInfo->ServiceList = NULL;\n\tHInfo->DescDocument = NULL;\n#ifdef INCLUDE_CLIENT_APIS\n\tListInit(&HInfo->SsdpSearchList, NULL, NULL);\n\tHInfo->ClientSubList = NULL;\n#endif /* INCLUDE_CLIENT_APIS */\n\tHInfo->MaxSubscriptions = UPNP_INFINITE;\n\tHInfo->MaxSubscriptionTimeOut = UPNP_INFINITE;\n\tHInfo->DeviceAf = AF_INET;\n\n\tretVal = UpnpDownloadXmlDoc(HInfo->DescURL, &(HInfo->DescDocument));\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice: error downloading Document: %d\\n\",\n\t\t\tretVal);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tFreeHandle(*Hnd);\n\t\tgoto exit_function;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice: Valid Description\\n\"\n\t\t\"UpnpRegisterRootDevice: DescURL : %s\\n\",\n\t\tHInfo->DescURL);\n\n\tHInfo->DeviceList =\n\t\tixmlDocument_getElementsByTagName(HInfo->DescDocument, \"device\");\n\tif (!HInfo->DeviceList) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tListDestroy(&HInfo->SsdpSearchList, 0);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tixmlDocument_free(HInfo->DescDocument);\n\t\tFreeHandle(*Hnd);\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice: No devices found for RootDevice\\n\");\n\t\tretVal = UPNP_E_INVALID_DESC;\n\t\tgoto exit_function;\n\t}\n\n\tHInfo->ServiceList = ixmlDocument_getElementsByTagName(\n\t\tHInfo->DescDocument, \"serviceList\");\n\tif (!HInfo->ServiceList) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice: No services found for RootDevice\\n\");\n\t}\n\n#if EXCLUDE_GENA == 0\n\t/*\n\t * GENA SET UP\n\t */\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"UpnpRegisterRootDevice: Gena Check\\n\");\n\tmemset(&HInfo->ServiceTable, 0, sizeof(HInfo->ServiceTable));\n\thasServiceTable = getServiceTable(\n\t\t(IXML_Node *)HInfo->DescDocument,\n\t\t&HInfo->ServiceTable,\n\t\tHInfo->DescURL);\n\tif (hasServiceTable) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"UpnpRegisterRootDevice: GENA Service Table\\n\"\n\t\t\t\"Here are the known services:\\n\");\n\t\tprintServiceTable( &HInfo->ServiceTable, UPNP_ALL, API );\n\t} else {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"\\nUpnpRegisterRootDevice: Empty service table\\n\");\n\t}\n#endif /* EXCLUDE_GENA */\n\n\tUpnpSdkDeviceRegisteredV4 = 1;\n\n\tretVal = UPNP_E_SUCCESS;\n\nexit_function:\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Exiting RegisterRootDevice, return value == %d\\n\", retVal);\n\tHandleUnlock();\n\n\treturn retVal;\n}"
  },
  {
    "function_name": "FreeHandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "777-802",
    "snippet": "static int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_HANDLE 200"
    ],
    "globals_used": [
      "static void *HandleTable[NUM_HANDLE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"FreeHandle: exiting, ret = %d.\\n\"",
            "ret"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "HandleTable[Upnp_Handle]"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int FreeHandle(\n\t/*! [in] Handle index. */\n\tint Upnp_Handle)\n{\n\tint ret = UPNP_E_INVALID_HANDLE;\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: entering, Handle is %d\\n\", Upnp_Handle);\n\tif (Upnp_Handle < 1 || Upnp_Handle >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: Handle %d is out of range\\n\",\n\t\t\tUpnp_Handle);\n\t} else if (HandleTable[Upnp_Handle] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"FreeHandle: HandleTable[%d] is NULL\\n\",\n\t\t\tUpnp_Handle);\n\t} else {\n\t\tfree( HandleTable[Upnp_Handle] );\n\t\tHandleTable[Upnp_Handle] = NULL;\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"FreeHandle: exiting, ret = %d.\\n\", ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "GetFreeHandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "759-770",
    "snippet": "static int GetFreeHandle()\n{\n\t/* Handle 0 is not used as NULL translates to 0 when passed as a handle */\n\tint i = 1;\n\n\twhile (i < NUM_HANDLE && HandleTable[i] != NULL)\n\t\t++i;\n\tif (i == NUM_HANDLE)\n\t\treturn UPNP_E_OUTOF_HANDLE;\n\telse\n\t\treturn i;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_HANDLE 200"
    ],
    "globals_used": [
      "static void *HandleTable[NUM_HANDLE];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int GetFreeHandle()\n{\n\t/* Handle 0 is not used as NULL translates to 0 when passed as a handle */\n\tint i = 1;\n\n\twhile (i < NUM_HANDLE && HandleTable[i] != NULL)\n\t\t++i;\n\tif (i == NUM_HANDLE)\n\t\treturn UPNP_E_OUTOF_HANDLE;\n\telse\n\t\treturn i;\n}"
  },
  {
    "function_name": "UpnpGetServerUlaGuaIp6Address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "745-751",
    "snippet": "char *UpnpGetServerUlaGuaIp6Address(void)\n{\n\tif (UpnpSdkInit != 1)\n\t\treturn NULL;\n\n\treturn gIF_IPV6_ULA_GUA;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char gIF_IPV6_ULA_GUA[INET6_ADDRSTRLEN] = { '\\0' };",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nchar gIF_IPV6_ULA_GUA[INET6_ADDRSTRLEN] = { '\\0' };\nint UpnpSdkInit = 0;\n\nchar *UpnpGetServerUlaGuaIp6Address(void)\n{\n\tif (UpnpSdkInit != 1)\n\t\treturn NULL;\n\n\treturn gIF_IPV6_ULA_GUA;\n}"
  },
  {
    "function_name": "UpnpGetServerIp6Address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "737-743",
    "snippet": "char *UpnpGetServerIp6Address(void)\n{\n\tif (UpnpSdkInit != 1)\n\t\treturn NULL;\n\n\treturn gIF_IPV6;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char gIF_IPV6[INET6_ADDRSTRLEN] = { '\\0' };",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nchar gIF_IPV6[INET6_ADDRSTRLEN] = { '\\0' };\nint UpnpSdkInit = 0;\n\nchar *UpnpGetServerIp6Address(void)\n{\n\tif (UpnpSdkInit != 1)\n\t\treturn NULL;\n\n\treturn gIF_IPV6;\n}"
  },
  {
    "function_name": "UpnpGetServerIpAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "729-735",
    "snippet": "char *UpnpGetServerIpAddress(void)\n{\n\tif (UpnpSdkInit != 1)\n\t\treturn NULL;\n\n\treturn gIF_IPV4;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char gIF_IPV4[INET_ADDRSTRLEN] = { '\\0' };",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nchar gIF_IPV4[INET_ADDRSTRLEN] = { '\\0' };\nint UpnpSdkInit = 0;\n\nchar *UpnpGetServerIpAddress(void)\n{\n\tif (UpnpSdkInit != 1)\n\t\treturn NULL;\n\n\treturn gIF_IPV4;\n}"
  },
  {
    "function_name": "UpnpGetServerPort6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "720-726",
    "snippet": "unsigned short UpnpGetServerPort6(void)\n{\n\tif (UpnpSdkInit != 1)\n\t\treturn 0u;\n\n\treturn LOCAL_PORT_V6;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned short LOCAL_PORT_V6;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nunsigned short LOCAL_PORT_V6;\nint UpnpSdkInit = 0;\n\nunsigned short UpnpGetServerPort6(void)\n{\n\tif (UpnpSdkInit != 1)\n\t\treturn 0u;\n\n\treturn LOCAL_PORT_V6;\n}"
  },
  {
    "function_name": "UpnpGetServerPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "711-717",
    "snippet": "unsigned short UpnpGetServerPort(void)\n{\n\tif (UpnpSdkInit != 1)\n\t\treturn 0u;\n\n\treturn LOCAL_PORT_V4;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned short LOCAL_PORT_V4;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nunsigned short LOCAL_PORT_V4;\nint UpnpSdkInit = 0;\n\nunsigned short UpnpGetServerPort(void)\n{\n\tif (UpnpSdkInit != 1)\n\t\treturn 0u;\n\n\treturn LOCAL_PORT_V4;\n}"
  },
  {
    "function_name": "UpnpFinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "625-709",
    "snippet": "int UpnpFinish(void)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\tUpnpDevice_Handle device_handle;\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tUpnpClient_Handle client_handle;\n#endif\n\tstruct Handle_Info *temp;\n#ifdef UPNP_ENABLE_OPEN_SSL\n    if (gSslCtx) {\n        SSL_CTX_free(gSslCtx);\n        gSslCtx = NULL;\n    }\n#endif\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpFinish: UpnpSdkInit is %d\\n\", UpnpSdkInit);\n\tif (UpnpSdkInit == 1)\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"UpnpFinish: UpnpSdkInit is ONE\\n\");\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n#ifdef INCLUDE_DEVICE_APIS\n\tswitch (GetDeviceHandleInfo(AF_INET, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (GetDeviceHandleInfo(AF_INET6, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tswitch (GetClientHandleInfo(&client_handle, &temp)) {\n\tcase HND_CLIENT:\n\t\tUpnpUnRegisterClient(client_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\tTimerThreadShutdown(&gTimerThread);\n#if EXCLUDE_MINISERVER == 0\n\tStopMiniServer();\n#endif\n#if EXCLUDE_WEB_SERVER == 0\n\tweb_server_destroy();\n#endif\n\tThreadPoolShutdown(&gMiniServerThreadPool);\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n\tThreadPoolShutdown(&gRecvThreadPool);\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tThreadPoolShutdown(&gSendThreadPool);\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n#ifdef INCLUDE_CLIENT_APIS\n\tithread_mutex_destroy(&GlobalClientSubscribeMutex);\n#endif\n\tithread_rwlock_destroy(&GlobalHndRWLock);\n\tithread_mutex_destroy(&gUUIDMutex);\n\t/* remove all virtual dirs */\n\tUpnpRemoveAllVirtualDirs();\n\tUpnpSdkInit = 0;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpFinish: UpnpSdkInit is :%d:\\n\", UpnpSdkInit);\n\tUpnpCloseLog();\n\t/* Clean-up ithread library resources */\n\tithread_cleanup_library();\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ithread_rwlock_t GlobalHndRWLock;",
      "ithread_mutex_t gUUIDMutex;",
      "TimerThread gTimerThread;",
      "ThreadPool gSendThreadPool;",
      "ThreadPool gRecvThreadPool;",
      "ThreadPool gMiniServerThreadPool;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ithread_cleanup_library",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseLog",
          "args": [],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpCloseLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "87-96",
          "snippet": "void UpnpCloseLog(void)\n{\n\tif (DEBUG_TARGET == 1) {\n\t\tfflush(ErrFileHnd);\n\t\tfflush(InfoFileHnd);\n\t\tfclose(ErrFileHnd);\n\t\tfclose(InfoFileHnd);\n\t}\n\tithread_mutex_destroy(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpCloseLog(void)\n{\n\tif (DEBUG_TARGET == 1) {\n\t\tfflush(ErrFileHnd);\n\t\tfflush(InfoFileHnd);\n\t\tfclose(ErrFileHnd);\n\t\tfclose(InfoFileHnd);\n\t}\n\tithread_mutex_destroy(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpFinish: UpnpSdkInit is :%d:\\n\"",
            "UpnpSdkInit"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpRemoveAllVirtualDirs",
          "args": [],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpRemoveAllVirtualDirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "4233-4252",
          "snippet": "void UpnpRemoveAllVirtualDirs(void)\n{\n    virtualDirList *pCur;\n    virtualDirList *pNext;\n\n    if( UpnpSdkInit != 1 ) {\n        return;\n    }\n\n    pCur = pVirtualDirList;\n\n    while( pCur != NULL ) {\n        pNext = pCur->next;\n        free( pCur );\n\n        pCur = pNext;\n    }\n\n    pVirtualDirList = NULL;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "virtualDirList *pVirtualDirList;",
            "int UpnpSdkInit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nvirtualDirList *pVirtualDirList;\nint UpnpSdkInit = 0;\n\nvoid UpnpRemoveAllVirtualDirs(void)\n{\n    virtualDirList *pCur;\n    virtualDirList *pNext;\n\n    if( UpnpSdkInit != 1 ) {\n        return;\n    }\n\n    pCur = pVirtualDirList;\n\n    while( pCur != NULL ) {\n        pNext = pCur->next;\n        free( pCur );\n\n        pCur = pNext;\n    }\n\n    pVirtualDirList = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ithread_mutex_destroy",
          "args": [
            "&gUUIDMutex"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ithread_rwlock_destroy",
          "args": [
            "&GlobalHndRWLock"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ithread_mutex_destroy",
          "args": [
            "&GlobalClientSubscribeMutex"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintThreadPoolStats",
          "args": [
            "&gRecvThreadPool",
            "__FILE__",
            "__LINE__",
            "\"Recv Thread Pool\""
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "PrintThreadPoolStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "614-622",
          "snippet": "static UPNP_INLINE void PrintThreadPoolStats(ThreadPool *tp,\n\tconst char *DbgFileName, int DbgLineNo, const char *msg)\n{\n\treturn;\n\ttp = tp;\n\tDbgFileName = DbgFileName;\n\tDbgLineNo = DbgLineNo;\n\tmsg = msg;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void PrintThreadPoolStats(ThreadPool *tp,\n\tconst char *DbgFileName, int DbgLineNo, const char *msg)\n{\n\treturn;\n\ttp = tp;\n\tDbgFileName = DbgFileName;\n\tDbgLineNo = DbgLineNo;\n\tmsg = msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolShutdown",
          "args": [
            "&gSendThreadPool"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ThreadPoolShutdown",
          "args": [
            "&gRecvThreadPool"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ThreadPoolShutdown",
          "args": [
            "&gMiniServerThreadPool"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "web_server_destroy",
          "args": [],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "web_server_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "495-508",
          "snippet": "void web_server_destroy(void)\n{\n\tif (bWebServerState == WEB_SERVER_ENABLED) {\n\t\tmembuffer_destroy(&gDocumentRootDir);\n\t\talias_release(&gAliasDoc);\n\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tmemset(&gAliasDoc, 0, sizeof(struct xml_alias_t));\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\tithread_mutex_destroy(&gWebMutex);\n\t\tbWebServerState = WEB_SERVER_DISABLED;\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nvoid web_server_destroy(void)\n{\n\tif (bWebServerState == WEB_SERVER_ENABLED) {\n\t\tmembuffer_destroy(&gDocumentRootDir);\n\t\talias_release(&gAliasDoc);\n\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tmemset(&gAliasDoc, 0, sizeof(struct xml_alias_t));\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\tithread_mutex_destroy(&gWebMutex);\n\t\tbWebServerState = WEB_SERVER_DISABLED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "StopMiniServer",
          "args": [],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "StopMiniServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "962-1001",
          "snippet": "int StopMiniServer()\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tsocklen_t socklen = sizeof (struct sockaddr_in);\n\tSOCKET sock;\n\tstruct sockaddr_in ssdpAddr;\n\tchar buf[256] = \"ShutDown\";\n\tsize_t bufLen = strlen(buf);\n\n\tswitch(gMServState) {\n\tcase MSERV_RUNNING:\n\t\tgMServState = MSERV_STOPPING;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\"SSDP_SERVER: StopSSDPServer: Error in socket() %s\\n\",\n\t\t\terrorBuffer);\n\t\treturn 0;\n\t}\n\twhile(gMServState != (MiniServerState)MSERV_IDLE) {\n\t\tssdpAddr.sin_family = (sa_family_t)AF_INET;\n\t\tssdpAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\t\tssdpAddr.sin_port = htons(miniStopSockPort);\n\t\tsendto(sock, buf, bufLen, 0,\n\t\t\t(struct sockaddr *)&ssdpAddr, socklen);\n\t\tusleep(1000u);\n\t\tif (gMServState == (MiniServerState)MSERV_IDLE) {\n\t\t\tbreak;\n\t\t}\n\t\tisleep(1u);\n\t}\n\tsock_close(sock);\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nint StopMiniServer()\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tsocklen_t socklen = sizeof (struct sockaddr_in);\n\tSOCKET sock;\n\tstruct sockaddr_in ssdpAddr;\n\tchar buf[256] = \"ShutDown\";\n\tsize_t bufLen = strlen(buf);\n\n\tswitch(gMServState) {\n\tcase MSERV_RUNNING:\n\t\tgMServState = MSERV_STOPPING;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\"SSDP_SERVER: StopSSDPServer: Error in socket() %s\\n\",\n\t\t\terrorBuffer);\n\t\treturn 0;\n\t}\n\twhile(gMServState != (MiniServerState)MSERV_IDLE) {\n\t\tssdpAddr.sin_family = (sa_family_t)AF_INET;\n\t\tssdpAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\t\tssdpAddr.sin_port = htons(miniStopSockPort);\n\t\tsendto(sock, buf, bufLen, 0,\n\t\t\t(struct sockaddr *)&ssdpAddr, socklen);\n\t\tusleep(1000u);\n\t\tif (gMServState == (MiniServerState)MSERV_IDLE) {\n\t\t\tbreak;\n\t\t}\n\t\tisleep(1u);\n\t}\n\tsock_close(sock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimerThreadShutdown",
          "args": [
            "&gTimerThread"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpUnRegisterClient",
          "args": [
            "client_handle"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpUnRegisterClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "1424-1474",
          "snippet": "int UpnpUnRegisterClient(UpnpClient_Handle Hnd)\n{\n\tstruct Handle_Info *HInfo;\n\tListNode *node = NULL;\n\tSsdpSearchArg *searchArg = NULL;\n\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterClient \\n\");\n\n\tHandleLock();\n\tif (!UpnpSdkClientRegistered) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\t}\n\tHandleUnlock();\n\n#if EXCLUDE_GENA == 0\n\tif (genaUnregisterClient(Hnd) != UPNP_E_SUCCESS)\n\t\treturn UPNP_E_INVALID_HANDLE;\n#endif\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* clean up search list */\n\tnode = ListHead(&HInfo->SsdpSearchList);\n\twhile (node != NULL) {\n\t\tsearchArg = (SsdpSearchArg *) node->item;\n\t\tif (searchArg) {\n\t\t\tfree(searchArg->searchTarget);\n\t\t\tfree(searchArg);\n\t\t}\n\t\tListDelNode(&HInfo->SsdpSearchList, node, 0);\n\t\tnode = ListHead(&HInfo->SsdpSearchList);\n\t}\n\tListDestroy(&HInfo->SsdpSearchList, 0);\n\tFreeHandle(Hnd);\n\tUpnpSdkClientRegistered = 0;\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting UpnpUnRegisterClient \\n\");\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int UpnpSdkInit = 0;",
            "int UpnpSdkClientRegistered = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpSdkInit = 0;\nint UpnpSdkClientRegistered = 0;\n\nint UpnpUnRegisterClient(UpnpClient_Handle Hnd)\n{\n\tstruct Handle_Info *HInfo;\n\tListNode *node = NULL;\n\tSsdpSearchArg *searchArg = NULL;\n\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterClient \\n\");\n\n\tHandleLock();\n\tif (!UpnpSdkClientRegistered) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\t}\n\tHandleUnlock();\n\n#if EXCLUDE_GENA == 0\n\tif (genaUnregisterClient(Hnd) != UPNP_E_SUCCESS)\n\t\treturn UPNP_E_INVALID_HANDLE;\n#endif\n\tHandleLock();\n\tswitch (GetHandleInfo(Hnd, &HInfo)) {\n\tcase HND_INVALID:\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INVALID_HANDLE;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* clean up search list */\n\tnode = ListHead(&HInfo->SsdpSearchList);\n\twhile (node != NULL) {\n\t\tsearchArg = (SsdpSearchArg *) node->item;\n\t\tif (searchArg) {\n\t\t\tfree(searchArg->searchTarget);\n\t\t\tfree(searchArg);\n\t\t}\n\t\tListDelNode(&HInfo->SsdpSearchList, node, 0);\n\t\tnode = ListHead(&HInfo->SsdpSearchList);\n\t}\n\tListDestroy(&HInfo->SsdpSearchList, 0);\n\tFreeHandle(Hnd);\n\tUpnpSdkClientRegistered = 0;\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting UpnpUnRegisterClient \\n\");\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetClientHandleInfo",
          "args": [
            "&client_handle",
            "&temp"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "GetClientHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3822-3846",
          "snippet": "Upnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nUpnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpUnRegisterRootDevice",
          "args": [
            "device_handle"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpUnRegisterRootDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "1294-1299",
          "snippet": "int UpnpUnRegisterRootDevice(UpnpDevice_Handle Hnd)\n{\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterRootDevice\\n\");\n\treturn UpnpUnRegisterRootDeviceLowPower(Hnd, -1, -1, -1);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpUnRegisterRootDevice(UpnpDevice_Handle Hnd)\n{\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpUnRegisterRootDevice\\n\");\n\treturn UpnpUnRegisterRootDeviceLowPower(Hnd, -1, -1, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDeviceHandleInfo",
          "args": [
            "AF_INET6",
            "&device_handle",
            "&temp"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "GetDeviceHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3849-3878",
          "snippet": "Upnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "int UpnpSdkDeviceRegisteredV4 = 0;",
            "int UpnpSdkDeviceregisteredV6 = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nint UpnpSdkDeviceRegisteredV4 = 0;\nint UpnpSdkDeviceregisteredV6 = 0;\n\nUpnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSL_CTX_free",
          "args": [
            "gSslCtx"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nithread_rwlock_t GlobalHndRWLock;\nithread_mutex_t gUUIDMutex;\nTimerThread gTimerThread;\nThreadPool gSendThreadPool;\nThreadPool gRecvThreadPool;\nThreadPool gMiniServerThreadPool;\nint UpnpSdkInit = 0;\n\nint UpnpFinish(void)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\tUpnpDevice_Handle device_handle;\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tUpnpClient_Handle client_handle;\n#endif\n\tstruct Handle_Info *temp;\n#ifdef UPNP_ENABLE_OPEN_SSL\n    if (gSslCtx) {\n        SSL_CTX_free(gSslCtx);\n        gSslCtx = NULL;\n    }\n#endif\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpFinish: UpnpSdkInit is %d\\n\", UpnpSdkInit);\n\tif (UpnpSdkInit == 1)\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"UpnpFinish: UpnpSdkInit is ONE\\n\");\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n#ifdef INCLUDE_DEVICE_APIS\n\tswitch (GetDeviceHandleInfo(AF_INET, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (GetDeviceHandleInfo(AF_INET6, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tswitch (GetClientHandleInfo(&client_handle, &temp)) {\n\tcase HND_CLIENT:\n\t\tUpnpUnRegisterClient(client_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\tTimerThreadShutdown(&gTimerThread);\n#if EXCLUDE_MINISERVER == 0\n\tStopMiniServer();\n#endif\n#if EXCLUDE_WEB_SERVER == 0\n\tweb_server_destroy();\n#endif\n\tThreadPoolShutdown(&gMiniServerThreadPool);\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n\tThreadPoolShutdown(&gRecvThreadPool);\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tThreadPoolShutdown(&gSendThreadPool);\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n#ifdef INCLUDE_CLIENT_APIS\n\tithread_mutex_destroy(&GlobalClientSubscribeMutex);\n#endif\n\tithread_rwlock_destroy(&GlobalHndRWLock);\n\tithread_mutex_destroy(&gUUIDMutex);\n\t/* remove all virtual dirs */\n\tUpnpRemoveAllVirtualDirs();\n\tUpnpSdkInit = 0;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpFinish: UpnpSdkInit is :%d:\\n\", UpnpSdkInit);\n\tUpnpCloseLog();\n\t/* Clean-up ithread library resources */\n\tithread_cleanup_library();\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "PrintThreadPoolStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "614-622",
    "snippet": "static UPNP_INLINE void PrintThreadPoolStats(ThreadPool *tp,\n\tconst char *DbgFileName, int DbgLineNo, const char *msg)\n{\n\treturn;\n\ttp = tp;\n\tDbgFileName = DbgFileName;\n\tDbgLineNo = DbgLineNo;\n\tmsg = msg;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void PrintThreadPoolStats(ThreadPool *tp,\n\tconst char *DbgFileName, int DbgLineNo, const char *msg)\n{\n\treturn;\n\ttp = tp;\n\tDbgFileName = DbgFileName;\n\tDbgLineNo = DbgLineNo;\n\tmsg = msg;\n}"
  },
  {
    "function_name": "PrintThreadPoolStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "569-612",
    "snippet": "void PrintThreadPoolStats(\n\t/*! [in] The thread pool. */\n\tThreadPool *tp,\n\t/*! [in] The file name that called this function, use the macro\n\t * __FILE__. */\n\tconst char *DbgFileName,\n\t/*! [in] The line number that the function was called, use the macro\n\t * __LINE__. */\n\tint DbgLineNo,\n\t/*! [in] The message. */\n\tconst char *msg)\n{\n\tThreadPoolStats stats;\n\tThreadPoolGetStats(tp, &stats);\n\tUpnpPrintf(UPNP_INFO, API, DbgFileName, DbgLineNo,\n\t\t\"%s\\n\"\n\t\t\"High Jobs pending: %d\\n\"\n\t\t\"Med Jobs Pending: %d\\n\"\n\t\t\"Low Jobs Pending: %d\\n\"\n\t\t\"Average wait in High Q in milliseconds: %lf\\n\"\n\t\t\"Average wait in Med Q in milliseconds: %lf\\n\"\n\t\t\"Average wait in Low Q in milliseconds: %lf\\n\"\n\t\t\"Max Threads Used: %d\\n\"\n\t\t\"Worker Threads: %d\\n\"\n\t\t\"Persistent Threads: %d\\n\"\n\t\t\"Idle Threads: %d\\n\"\n\t\t\"Total Threads: %d\\n\"\n\t\t\"Total Work Time: %lf\\n\"\n\t\t\"Total Idle Time: %lf\\n\",\n\t\tmsg,\n\t\tstats.currentJobsHQ,\n\t\tstats.currentJobsMQ,\n\t\tstats.currentJobsLQ,\n\t\tstats.avgWaitHQ,\n\t\tstats.avgWaitMQ,\n\t\tstats.avgWaitLQ,\n\t\tstats.maxThreads,\n\t\tstats.workerThreads,\n\t\tstats.persistentThreads,\n\t\tstats.idleThreads,\n\t\tstats.totalThreads,\n\t\tstats.totalWorkTime,\n\t\tstats.totalIdleTime);\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "API",
            "DbgFileName",
            "DbgLineNo",
            "\"%s\\n\"\n\t\t\"High Jobs pending: %d\\n\"\n\t\t\"Med Jobs Pending: %d\\n\"\n\t\t\"Low Jobs Pending: %d\\n\"\n\t\t\"Average wait in High Q in milliseconds: %lf\\n\"\n\t\t\"Average wait in Med Q in milliseconds: %lf\\n\"\n\t\t\"Average wait in Low Q in milliseconds: %lf\\n\"\n\t\t\"Max Threads Used: %d\\n\"\n\t\t\"Worker Threads: %d\\n\"\n\t\t\"Persistent Threads: %d\\n\"\n\t\t\"Idle Threads: %d\\n\"\n\t\t\"Total Threads: %d\\n\"\n\t\t\"Total Work Time: %lf\\n\"\n\t\t\"Total Idle Time: %lf\\n\"",
            "msg",
            "stats.currentJobsHQ",
            "stats.currentJobsMQ",
            "stats.currentJobsLQ",
            "stats.avgWaitHQ",
            "stats.avgWaitMQ",
            "stats.avgWaitLQ",
            "stats.maxThreads",
            "stats.workerThreads",
            "stats.persistentThreads",
            "stats.idleThreads",
            "stats.totalThreads",
            "stats.totalWorkTime",
            "stats.totalIdleTime"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolGetStats",
          "args": [
            "tp",
            "&stats"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nvoid PrintThreadPoolStats(\n\t/*! [in] The thread pool. */\n\tThreadPool *tp,\n\t/*! [in] The file name that called this function, use the macro\n\t * __FILE__. */\n\tconst char *DbgFileName,\n\t/*! [in] The line number that the function was called, use the macro\n\t * __LINE__. */\n\tint DbgLineNo,\n\t/*! [in] The message. */\n\tconst char *msg)\n{\n\tThreadPoolStats stats;\n\tThreadPoolGetStats(tp, &stats);\n\tUpnpPrintf(UPNP_INFO, API, DbgFileName, DbgLineNo,\n\t\t\"%s\\n\"\n\t\t\"High Jobs pending: %d\\n\"\n\t\t\"Med Jobs Pending: %d\\n\"\n\t\t\"Low Jobs Pending: %d\\n\"\n\t\t\"Average wait in High Q in milliseconds: %lf\\n\"\n\t\t\"Average wait in Med Q in milliseconds: %lf\\n\"\n\t\t\"Average wait in Low Q in milliseconds: %lf\\n\"\n\t\t\"Max Threads Used: %d\\n\"\n\t\t\"Worker Threads: %d\\n\"\n\t\t\"Persistent Threads: %d\\n\"\n\t\t\"Idle Threads: %d\\n\"\n\t\t\"Total Threads: %d\\n\"\n\t\t\"Total Work Time: %lf\\n\"\n\t\t\"Total Idle Time: %lf\\n\",\n\t\tmsg,\n\t\tstats.currentJobsHQ,\n\t\tstats.currentJobsMQ,\n\t\tstats.currentJobsLQ,\n\t\tstats.avgWaitHQ,\n\t\tstats.avgWaitMQ,\n\t\tstats.avgWaitLQ,\n\t\tstats.maxThreads,\n\t\tstats.workerThreads,\n\t\tstats.persistentThreads,\n\t\tstats.idleThreads,\n\t\tstats.totalThreads,\n\t\tstats.totalWorkTime,\n\t\tstats.totalIdleTime);\n}"
  },
  {
    "function_name": "UpnpInitSslContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "548-562",
    "snippet": "int UpnpInitSslContext(int initOpenSslLib, const SSL_METHOD *sslMethod)\n{\n\tif (gSslCtx)\n\t\treturn UPNP_E_INIT;\n\tif (initOpenSslLib) {\n\t\tSSL_load_error_strings();\n\t\tSSL_library_init();\n\t\tOpenSSL_add_all_algorithms();\n\t}\n\tgSslCtx = SSL_CTX_new(sslMethod);\n\tif (!gSslCtx) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SSL_CTX_new",
          "args": [
            "sslMethod"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpenSSL_add_all_algorithms",
          "args": [],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_library_init",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_load_error_strings",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint UpnpInitSslContext(int initOpenSslLib, const SSL_METHOD *sslMethod)\n{\n\tif (gSslCtx)\n\t\treturn UPNP_E_INIT;\n\tif (initOpenSslLib) {\n\t\tSSL_load_error_strings();\n\t\tSSL_library_init();\n\t\tOpenSSL_add_all_algorithms();\n\t}\n\tgSslCtx = SSL_CTX_new(sslMethod);\n\tif (!gSslCtx) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpInit2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "499-544",
    "snippet": "int UpnpInit2(const char *IfName, unsigned short DestPort)\n{\n\tint retVal;\n\n\t/* Initializes the ithread library */\n\tithread_initialize_library();\n\n\tithread_mutex_lock(&gSDKInitMutex);\n\n\t/* Check if we're already initialized. */\n\tif (UpnpSdkInit == 1) {\n\t\tretVal = UPNP_E_INIT;\n\t\tgoto exit_function;\n\t}\n\n\t/* Perform initialization preamble. */\n\tretVal = UpnpInitPreamble();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"UpnpInit2 with IfName=%s, DestPort=%d.\\n\", \n\t\tIfName ? IfName : \"\", DestPort);\n\n\t/* Retrieve interface information (Addresses, index, etc). */\n\tretVal = UpnpGetIfInfo( IfName );\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tgoto exit_function;\n\t}\n\n\t/* Set the UpnpSdkInit flag to 1 to indicate we're successfully initialized. */\n\tUpnpSdkInit = 1;\n\n\t/* Finish initializing the SDK. */\n\tretVal = UpnpInitStartServers(DestPort);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpSdkInit = 0;\n\t\tgoto exit_function;\n\t}\n\nexit_function:\n\tithread_mutex_unlock(&gSDKInitMutex);\n\n\treturn retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ithread_mutex_t gSDKInitMutex = PTHREAD_MUTEX_INITIALIZER;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ithread_mutex_unlock",
          "args": [
            "&gSDKInitMutex"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpInitStartServers",
          "args": [
            "DestPort"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpInitStartServers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "403-439",
          "snippet": "static int UpnpInitStartServers(\n\t/*! [in] Local Port to listen for incoming connections. */\n\tunsigned short DestPort)\n{\n#if EXCLUDE_MINISERVER == 0 || EXCLUDE_WEB_SERVER == 0\n\tint retVal = 0;\n#endif\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Entering UpnpInitStartServers\\n\" );\n\n#if EXCLUDE_MINISERVER == 0\n\tLOCAL_PORT_V4 = DestPort;\n\tLOCAL_PORT_V6 = DestPort;\n\tretVal = StartMiniServer(&LOCAL_PORT_V4, &LOCAL_PORT_V6);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Miniserver failed to start\");\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmembuffer_init(&gDocumentRootDir);\n\tretVal = UpnpEnableWebserver(WEB_SERVER_ENABLED);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpInitStartServers\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned short LOCAL_PORT_V4;",
            "unsigned short LOCAL_PORT_V6;",
            "extern membuffer gDocumentRootDir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nunsigned short LOCAL_PORT_V4;\nunsigned short LOCAL_PORT_V6;\nextern membuffer gDocumentRootDir;\n\nstatic int UpnpInitStartServers(\n\t/*! [in] Local Port to listen for incoming connections. */\n\tunsigned short DestPort)\n{\n#if EXCLUDE_MINISERVER == 0 || EXCLUDE_WEB_SERVER == 0\n\tint retVal = 0;\n#endif\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Entering UpnpInitStartServers\\n\" );\n\n#if EXCLUDE_MINISERVER == 0\n\tLOCAL_PORT_V4 = DestPort;\n\tLOCAL_PORT_V6 = DestPort;\n\tretVal = StartMiniServer(&LOCAL_PORT_V4, &LOCAL_PORT_V6);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Miniserver failed to start\");\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmembuffer_init(&gDocumentRootDir);\n\tretVal = UpnpEnableWebserver(WEB_SERVER_ENABLED);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpInitStartServers\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpGetIfInfo",
          "args": [
            "IfName"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpGetIfInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3317-3701",
          "snippet": "int UpnpGetIfInfo(const char *IfName)\n{\n#ifdef WIN32\n\t/* ---------------------------------------------------- */\n\t/* WIN32 implementation will use the IpHlpAPI library. */\n\t/* ---------------------------------------------------- */\n\tPIP_ADAPTER_ADDRESSES adapts = NULL;\n\tPIP_ADAPTER_ADDRESSES adapts_item;\n\tPIP_ADAPTER_UNICAST_ADDRESS uni_addr;\n\tSOCKADDR *ip_addr;\n\tstruct in_addr v4_addr;\n\tstruct in6_addr v6_addr;\n\tULONG adapts_sz = 0;\n\tULONG ret;\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Get Adapters addresses required size. */\n\tret = GetAdaptersAddresses(AF_UNSPEC,\n\t\t\t\t   GAA_FLAG_SKIP_ANYCAST |\n\t\t\t\t   GAA_FLAG_SKIP_DNS_SERVER, NULL, adapts,\n\t\t\t\t   &adapts_sz);\n\tif (ret != ERROR_BUFFER_OVERFLOW) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"GetAdaptersAddresses failed to find list of adapters\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Allocate enough memory. */\n\tadapts = (PIP_ADAPTER_ADDRESSES) malloc(adapts_sz);\n\tif (adapts == NULL) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* Do the call that will actually return the info. */\n\tret = GetAdaptersAddresses(AF_UNSPEC,\n\t\t\t\t   GAA_FLAG_SKIP_ANYCAST |\n\t\t\t\t   GAA_FLAG_SKIP_DNS_SERVER, NULL, adapts,\n\t\t\t\t   &adapts_sz);\n\tif (ret != ERROR_SUCCESS) {\n\t\tfree(adapts);\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"GetAdaptersAddresses failed to find list of adapters\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\tadapts_item = adapts;\n\twhile (adapts_item != NULL) {\n\t\tif (adapts_item->Flags & IP_ADAPTER_NO_MULTICAST) {\n\t\t\tadapts_item = adapts_item->Next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n#ifdef UPNP_USE_MSVCPP\n\t\t\t/*\n\t\t\t * Partial fix for VC - friendly name is wchar string,\n\t\t\t * but currently gIF_NAME is char string. For now try\n\t\t\t * to convert it, which will work with many (but not\n\t\t\t * all) adapters. A full fix would require a lot of\n\t\t\t * big changes (gIF_NAME to wchar string?).\n\t\t\t */\n\t\t\twcstombs(gIF_NAME, adapts_item->FriendlyName,\n\t\t\t\tsizeof(gIF_NAME));\n#else\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, adapts_item->FriendlyName,\n\t\t\t\tsizeof(gIF_NAME) - 1);\n#endif\n\t\t\tifname_found = 1;\n\t\t} else {\n#ifdef UPNP_USE_MSVCPP\n\t\t\t/*\n\t\t\t * Partial fix for VC - friendly name is wchar string,\n\t\t\t * but currently gIF_NAME is char string. For now try\n\t\t\t * to convert it, which will work with many (but not\n\t\t\t * all) adapters. A full fix would require a lot of\n\t\t\t * big changes (gIF_NAME to wchar string?).\n\t\t\t */\n\t\t\tchar tmpIfName[LINE_SIZE] = { 0 };\n\t\t\twcstombs(tmpIfName, adapts_item->FriendlyName,\n\t\t\t\tsizeof(tmpIfName));\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, tmpIfName,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n#else\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, adapts_item->FriendlyName,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t}\n\t\t/* Loop thru this adapter's unicast IP addresses. */\n\t\tuni_addr = adapts_item->FirstUnicastAddress;\n\t\twhile (uni_addr) {\n\t\t\tip_addr = uni_addr->Address.lpSockaddr;\n\t\t\tswitch (ip_addr->sa_family) {\n\t\t\tcase AF_INET:\n\t\t\t\tmemcpy(&v4_addr,\n\t\t\t\t       &((struct sockaddr_in *)ip_addr)->\n\t\t\t\t       sin_addr, sizeof(v4_addr));\n\t\t\t\tvalid_addr_found = 1;\n\t\t\t\tbreak;\n\t\t\tcase AF_INET6:\n\t\t\t\t/* Only keep IPv6 link-local addresses. */\n\t\t\t\tif (IN6_IS_ADDR_LINKLOCAL\n\t\t\t\t    (&((struct sockaddr_in6 *)ip_addr)->\n\t\t\t\t     sin6_addr)) {\n\t\t\t\t\tmemcpy(&v6_addr,\n\t\t\t\t\t       &((struct sockaddr_in6 *)\n\t\t\t\t\t\t ip_addr)->sin6_addr,\n\t\t\t\t\t       sizeof(v6_addr));\n\t\t\t\t\tvalid_addr_found = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (valid_addr_found == 0) {\n\t\t\t\t\t/* Address is not IPv4 or IPv6 and no valid address has  */\n\t\t\t\t\t/* yet been found for this interface. Discard interface name. */\n\t\t\t\t\tifname_found = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Next address. */\n\t\t\tuni_addr = uni_addr->Next;\n\t\t}\n\t\tif (valid_addr_found == 1) {\n\t\t\tgIF_INDEX = adapts_item->IfIndex;\n\t\t\tbreak;\n\t\t}\n\t\t/* Next adapter. */\n\t\tadapts_item = adapts_item->Next;\n\t}\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\tinet_ntop(AF_INET, &v4_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\tinet_ntop(AF_INET6, &v6_addr, gIF_IPV6, sizeof(gIF_IPV6));\n#elif (defined(BSD) && BSD >= 199306) || defined(__FreeBSD_kernel__)\n\tstruct ifaddrs *ifap, *ifa;\n\tstruct in_addr v4_addr;\n\tstruct in6_addr v6_addr;\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\t/* Get system interface addresses. */\n\tif (getifaddrs(&ifap) != 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"getifaddrs failed to find list of addresses\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* cycle through available interfaces and their addresses. */\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t/* Skip LOOPBACK interfaces, DOWN interfaces and interfaces that  */\n\t\t/* don't support MULTICAST. */\n\t\tif ((ifa->ifa_flags & IFF_LOOPBACK)\n\t\t    || (!(ifa->ifa_flags & IFF_UP))\n\t\t    || (!(ifa->ifa_flags & IFF_MULTICAST))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, ifa->ifa_name, sizeof(gIF_NAME) - 1);\n\t\t\tifname_found = 1;\n\t\t} else {\n\t\t\tif (strncmp(gIF_NAME, ifa->ifa_name, sizeof(gIF_NAME))\n\t\t\t    != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* Keep interface addresses for later. */\n\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\tcase AF_INET:\n\t\t\tmemcpy(&v4_addr,\n\t\t\t       &((struct sockaddr_in *)(ifa->ifa_addr))->\n\t\t\t       sin_addr, sizeof(v4_addr));\n\t\t\tvalid_addr_found = 1;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t/* Only keep IPv6 link-local addresses. */\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL\n\t\t\t    (&((struct sockaddr_in6 *)(ifa->ifa_addr))->\n\t\t\t     sin6_addr)) {\n\t\t\t\tmemcpy(&v6_addr,\n\t\t\t\t       &((struct sockaddr_in6 *)(ifa->\n\t\t\t\t\t\t\t\t ifa_addr))->\n\t\t\t\t       sin6_addr, sizeof(v6_addr));\n\t\t\t\tvalid_addr_found = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (valid_addr_found == 0) {\n\t\t\t\t/* Address is not IPv4 or IPv6 and no valid address has  */\n\t\t\t\t/* yet been found for this interface. Discard interface name. */\n\t\t\t\tifname_found = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfreeifaddrs(ifap);\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\tinet_ntop(AF_INET, &v4_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\tinet_ntop(AF_INET6, &v6_addr, gIF_IPV6, sizeof(gIF_IPV6));\n\tgIF_INDEX = if_nametoindex(gIF_NAME);\n#else\n\tchar szBuffer[MAX_INTERFACES * sizeof(struct ifreq)];\n\tstruct ifconf ifConf;\n\tstruct ifreq ifReq;\n\tFILE *inet6_procfd;\n\tsize_t i;\n\tint LocalSock;\n\tstruct in6_addr v6_addr;\n\tunsigned if_idx;\n\tchar addr6[8][5];\n\tchar buf[INET6_ADDRSTRLEN];\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\t/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on.  */\n\tif ((LocalSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == INVALID_SOCKET) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t   \"Can't create addrlist socket\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Get the interface configuration information...  */\n\tifConf.ifc_len = (int)sizeof szBuffer;\n\tifConf.ifc_ifcu.ifcu_buf = (caddr_t) szBuffer;\n\n\tif (ioctl(LocalSock, SIOCGIFCONF, &ifConf) < 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t   \"DiscoverInterfaces: SIOCGIFCONF returned error\\n\");\n\t\tclose(LocalSock);\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Cycle through the list of interfaces looking for IP addresses.  */\n\tfor (i = (size_t)0; i < (size_t)ifConf.ifc_len;) {\n\t\tstruct ifreq *pifReq =\n\t\t    (struct ifreq *)((caddr_t) ifConf.ifc_req + i);\n\t\ti += sizeof *pifReq;\n\t\t/* See if this is the sort of interface we want to deal with. */\n\t\tmemset(ifReq.ifr_name, 0, sizeof(ifReq.ifr_name));\n\t\tstrncpy(ifReq.ifr_name, pifReq->ifr_name,\n\t\t\tsizeof(ifReq.ifr_name) - 1);\n\t\tif (ioctl(LocalSock, SIOCGIFFLAGS, &ifReq) < 0) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Can't get interface flags for %s:\\n\",\n\t\t\t\t   ifReq.ifr_name);\n\t\t}\n\t\t/* Skip LOOPBACK interfaces, DOWN interfaces and interfaces that  */\n\t\t/* don't support MULTICAST. */\n\t\tif ((ifReq.ifr_flags & IFF_LOOPBACK)\n\t\t    || (!(ifReq.ifr_flags & IFF_UP))\n\t\t    || (!(ifReq.ifr_flags & IFF_MULTICAST))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, pifReq->ifr_name, sizeof(gIF_NAME) - 1);\n\t\t\tifname_found = 1;\n\t\t} else {\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, pifReq->ifr_name,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* Check address family. */\n\t\tif (pifReq->ifr_addr.sa_family == AF_INET) {\n\t\t\t/* Copy interface name, IPv4 address and interface index. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, pifReq->ifr_name, sizeof(gIF_NAME) - 1);\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t  &((struct sockaddr_in *)&pifReq->ifr_addr)->\n\t\t\t\t  sin_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\t\t\tgIF_INDEX = if_nametoindex(gIF_NAME);\n\t\t\tvalid_addr_found = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Address is not IPv4 */\n\t\t\tifname_found = 0;\n\t\t}\n\t}\n\tclose(LocalSock);\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\t/* Try to get the IPv6 address for the same interface  */\n\t/* from \"/proc/net/if_inet6\", if possible. */\n\tinet6_procfd = fopen(\"/proc/net/if_inet6\", \"r\");\n\tif (inet6_procfd) {\n\t\twhile (fscanf(inet6_procfd,\n\t\t\t      \"%4s%4s%4s%4s%4s%4s%4s%4s %02x %*02x %*02x %*02x %*20s\\n\",\n\t\t\t      addr6[0], addr6[1], addr6[2], addr6[3],\n\t\t\t      addr6[4], addr6[5], addr6[6], addr6[7],\n\t\t\t      &if_idx) != EOF) {\n\t\t\t/* Get same interface as IPv4 address retrieved. */\n\t\t\tif (gIF_INDEX == if_idx) {\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"%s:%s:%s:%s:%s:%s:%s:%s\", addr6[0],\n\t\t\t\t\t addr6[1], addr6[2], addr6[3], addr6[4],\n\t\t\t\t\t addr6[5], addr6[6], addr6[7]);\n\t\t\t\t/* Validate formed address and check for link-local. */\n\t\t\t\tif (inet_pton(AF_INET6, buf, &v6_addr) > 0) {\n\t\t\t\t\tif (IN6_IS_ADDR_ULA(&v6_addr)) {\n\t\t\t\t\t\t/* Got valid IPv6 ula. */\n\t\t\t\t\t\tmemset(gIF_IPV6_ULA_GUA, 0,\n\t\t\t\t\t\t\tsizeof(gIF_IPV6_ULA_GUA));\n\t\t\t\t\t\tstrncpy(gIF_IPV6_ULA_GUA, buf,\n\t\t\t\t\t\t\tsizeof\n\t\t\t\t\t\t\t(gIF_IPV6_ULA_GUA) - 1);\n\t\t\t\t\t} else if (IN6_IS_ADDR_GLOBAL(&v6_addr)\n\t\t\t\t\t\t   && strlen(gIF_IPV6_ULA_GUA)\n\t\t\t\t\t\t   == (size_t)0) {\n\t\t\t\t\t\t/* got a GUA, should store it while no ULA is found */\n\t\t\t\t\t\tmemset(gIF_IPV6_ULA_GUA, 0,\n                                                        sizeof(gIF_IPV6_ULA_GUA));\n\t\t\t\t\t\tstrncpy(gIF_IPV6_ULA_GUA, buf,\n\t\t\t\t\t\t\tsizeof\n\t\t\t\t\t\t\t(gIF_IPV6_ULA_GUA) - 1);\n\t\t\t\t\t} else\n\t\t\t\t\t    if (IN6_IS_ADDR_LINKLOCAL(&v6_addr)\n\t\t\t\t\t\t&& strlen(gIF_IPV6) == (size_t)0) {\n\t\t\t\t\t\t/* got a Link local IPv6 address. */\n\t\t\t\t\t\tmemset(gIF_IPV6, 0,\n                                                        sizeof(gIF_IPV6));\n\t\t\t\t\t\tstrncpy(gIF_IPV6, buf,\n\t\t\t\t\t\t\tsizeof(gIF_IPV6) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfclose(inet6_procfd);\n\t}\n#endif\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Interface name=%s, index=%d, v4=%s, v6=%s, ULA or GUA v6=%s\\n\",\n\t\t   gIF_NAME, gIF_INDEX, gIF_IPV4, gIF_IPV6, gIF_IPV6_ULA_GUA);\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char gIF_NAME[LINE_SIZE] = { '\\0' };",
            "char gIF_IPV4[INET_ADDRSTRLEN] = { '\\0' };",
            "char gIF_IPV6[INET6_ADDRSTRLEN] = { '\\0' };",
            "char gIF_IPV6_ULA_GUA[INET6_ADDRSTRLEN] = { '\\0' };",
            "unsigned gIF_INDEX = (unsigned)-1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nchar gIF_NAME[LINE_SIZE] = { '\\0' };\nchar gIF_IPV4[INET_ADDRSTRLEN] = { '\\0' };\nchar gIF_IPV6[INET6_ADDRSTRLEN] = { '\\0' };\nchar gIF_IPV6_ULA_GUA[INET6_ADDRSTRLEN] = { '\\0' };\nunsigned gIF_INDEX = (unsigned)-1;\n\nint UpnpGetIfInfo(const char *IfName)\n{\n#ifdef WIN32\n\t/* ---------------------------------------------------- */\n\t/* WIN32 implementation will use the IpHlpAPI library. */\n\t/* ---------------------------------------------------- */\n\tPIP_ADAPTER_ADDRESSES adapts = NULL;\n\tPIP_ADAPTER_ADDRESSES adapts_item;\n\tPIP_ADAPTER_UNICAST_ADDRESS uni_addr;\n\tSOCKADDR *ip_addr;\n\tstruct in_addr v4_addr;\n\tstruct in6_addr v6_addr;\n\tULONG adapts_sz = 0;\n\tULONG ret;\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Get Adapters addresses required size. */\n\tret = GetAdaptersAddresses(AF_UNSPEC,\n\t\t\t\t   GAA_FLAG_SKIP_ANYCAST |\n\t\t\t\t   GAA_FLAG_SKIP_DNS_SERVER, NULL, adapts,\n\t\t\t\t   &adapts_sz);\n\tif (ret != ERROR_BUFFER_OVERFLOW) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"GetAdaptersAddresses failed to find list of adapters\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Allocate enough memory. */\n\tadapts = (PIP_ADAPTER_ADDRESSES) malloc(adapts_sz);\n\tif (adapts == NULL) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* Do the call that will actually return the info. */\n\tret = GetAdaptersAddresses(AF_UNSPEC,\n\t\t\t\t   GAA_FLAG_SKIP_ANYCAST |\n\t\t\t\t   GAA_FLAG_SKIP_DNS_SERVER, NULL, adapts,\n\t\t\t\t   &adapts_sz);\n\tif (ret != ERROR_SUCCESS) {\n\t\tfree(adapts);\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"GetAdaptersAddresses failed to find list of adapters\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\tadapts_item = adapts;\n\twhile (adapts_item != NULL) {\n\t\tif (adapts_item->Flags & IP_ADAPTER_NO_MULTICAST) {\n\t\t\tadapts_item = adapts_item->Next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n#ifdef UPNP_USE_MSVCPP\n\t\t\t/*\n\t\t\t * Partial fix for VC - friendly name is wchar string,\n\t\t\t * but currently gIF_NAME is char string. For now try\n\t\t\t * to convert it, which will work with many (but not\n\t\t\t * all) adapters. A full fix would require a lot of\n\t\t\t * big changes (gIF_NAME to wchar string?).\n\t\t\t */\n\t\t\twcstombs(gIF_NAME, adapts_item->FriendlyName,\n\t\t\t\tsizeof(gIF_NAME));\n#else\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, adapts_item->FriendlyName,\n\t\t\t\tsizeof(gIF_NAME) - 1);\n#endif\n\t\t\tifname_found = 1;\n\t\t} else {\n#ifdef UPNP_USE_MSVCPP\n\t\t\t/*\n\t\t\t * Partial fix for VC - friendly name is wchar string,\n\t\t\t * but currently gIF_NAME is char string. For now try\n\t\t\t * to convert it, which will work with many (but not\n\t\t\t * all) adapters. A full fix would require a lot of\n\t\t\t * big changes (gIF_NAME to wchar string?).\n\t\t\t */\n\t\t\tchar tmpIfName[LINE_SIZE] = { 0 };\n\t\t\twcstombs(tmpIfName, adapts_item->FriendlyName,\n\t\t\t\tsizeof(tmpIfName));\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, tmpIfName,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n#else\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, adapts_item->FriendlyName,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t}\n\t\t/* Loop thru this adapter's unicast IP addresses. */\n\t\tuni_addr = adapts_item->FirstUnicastAddress;\n\t\twhile (uni_addr) {\n\t\t\tip_addr = uni_addr->Address.lpSockaddr;\n\t\t\tswitch (ip_addr->sa_family) {\n\t\t\tcase AF_INET:\n\t\t\t\tmemcpy(&v4_addr,\n\t\t\t\t       &((struct sockaddr_in *)ip_addr)->\n\t\t\t\t       sin_addr, sizeof(v4_addr));\n\t\t\t\tvalid_addr_found = 1;\n\t\t\t\tbreak;\n\t\t\tcase AF_INET6:\n\t\t\t\t/* Only keep IPv6 link-local addresses. */\n\t\t\t\tif (IN6_IS_ADDR_LINKLOCAL\n\t\t\t\t    (&((struct sockaddr_in6 *)ip_addr)->\n\t\t\t\t     sin6_addr)) {\n\t\t\t\t\tmemcpy(&v6_addr,\n\t\t\t\t\t       &((struct sockaddr_in6 *)\n\t\t\t\t\t\t ip_addr)->sin6_addr,\n\t\t\t\t\t       sizeof(v6_addr));\n\t\t\t\t\tvalid_addr_found = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (valid_addr_found == 0) {\n\t\t\t\t\t/* Address is not IPv4 or IPv6 and no valid address has  */\n\t\t\t\t\t/* yet been found for this interface. Discard interface name. */\n\t\t\t\t\tifname_found = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Next address. */\n\t\t\tuni_addr = uni_addr->Next;\n\t\t}\n\t\tif (valid_addr_found == 1) {\n\t\t\tgIF_INDEX = adapts_item->IfIndex;\n\t\t\tbreak;\n\t\t}\n\t\t/* Next adapter. */\n\t\tadapts_item = adapts_item->Next;\n\t}\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\tinet_ntop(AF_INET, &v4_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\tinet_ntop(AF_INET6, &v6_addr, gIF_IPV6, sizeof(gIF_IPV6));\n#elif (defined(BSD) && BSD >= 199306) || defined(__FreeBSD_kernel__)\n\tstruct ifaddrs *ifap, *ifa;\n\tstruct in_addr v4_addr;\n\tstruct in6_addr v6_addr;\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\t/* Get system interface addresses. */\n\tif (getifaddrs(&ifap) != 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"getifaddrs failed to find list of addresses\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* cycle through available interfaces and their addresses. */\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t/* Skip LOOPBACK interfaces, DOWN interfaces and interfaces that  */\n\t\t/* don't support MULTICAST. */\n\t\tif ((ifa->ifa_flags & IFF_LOOPBACK)\n\t\t    || (!(ifa->ifa_flags & IFF_UP))\n\t\t    || (!(ifa->ifa_flags & IFF_MULTICAST))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, ifa->ifa_name, sizeof(gIF_NAME) - 1);\n\t\t\tifname_found = 1;\n\t\t} else {\n\t\t\tif (strncmp(gIF_NAME, ifa->ifa_name, sizeof(gIF_NAME))\n\t\t\t    != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* Keep interface addresses for later. */\n\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\tcase AF_INET:\n\t\t\tmemcpy(&v4_addr,\n\t\t\t       &((struct sockaddr_in *)(ifa->ifa_addr))->\n\t\t\t       sin_addr, sizeof(v4_addr));\n\t\t\tvalid_addr_found = 1;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t/* Only keep IPv6 link-local addresses. */\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL\n\t\t\t    (&((struct sockaddr_in6 *)(ifa->ifa_addr))->\n\t\t\t     sin6_addr)) {\n\t\t\t\tmemcpy(&v6_addr,\n\t\t\t\t       &((struct sockaddr_in6 *)(ifa->\n\t\t\t\t\t\t\t\t ifa_addr))->\n\t\t\t\t       sin6_addr, sizeof(v6_addr));\n\t\t\t\tvalid_addr_found = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (valid_addr_found == 0) {\n\t\t\t\t/* Address is not IPv4 or IPv6 and no valid address has  */\n\t\t\t\t/* yet been found for this interface. Discard interface name. */\n\t\t\t\tifname_found = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfreeifaddrs(ifap);\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\tinet_ntop(AF_INET, &v4_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\tinet_ntop(AF_INET6, &v6_addr, gIF_IPV6, sizeof(gIF_IPV6));\n\tgIF_INDEX = if_nametoindex(gIF_NAME);\n#else\n\tchar szBuffer[MAX_INTERFACES * sizeof(struct ifreq)];\n\tstruct ifconf ifConf;\n\tstruct ifreq ifReq;\n\tFILE *inet6_procfd;\n\tsize_t i;\n\tint LocalSock;\n\tstruct in6_addr v6_addr;\n\tunsigned if_idx;\n\tchar addr6[8][5];\n\tchar buf[INET6_ADDRSTRLEN];\n\tint ifname_found = 0;\n\tint valid_addr_found = 0;\n\n\t/* Copy interface name, if it was provided. */\n\tif (IfName != NULL) {\n\t\tif (strlen(IfName) > sizeof(gIF_NAME))\n\t\t\treturn UPNP_E_INVALID_INTERFACE;\n\n\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\tstrncpy(gIF_NAME, IfName, sizeof(gIF_NAME) - 1);\n\t\tifname_found = 1;\n\t}\n\t/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on.  */\n\tif ((LocalSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == INVALID_SOCKET) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t   \"Can't create addrlist socket\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Get the interface configuration information...  */\n\tifConf.ifc_len = (int)sizeof szBuffer;\n\tifConf.ifc_ifcu.ifcu_buf = (caddr_t) szBuffer;\n\n\tif (ioctl(LocalSock, SIOCGIFCONF, &ifConf) < 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t   \"DiscoverInterfaces: SIOCGIFCONF returned error\\n\");\n\t\tclose(LocalSock);\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Cycle through the list of interfaces looking for IP addresses.  */\n\tfor (i = (size_t)0; i < (size_t)ifConf.ifc_len;) {\n\t\tstruct ifreq *pifReq =\n\t\t    (struct ifreq *)((caddr_t) ifConf.ifc_req + i);\n\t\ti += sizeof *pifReq;\n\t\t/* See if this is the sort of interface we want to deal with. */\n\t\tmemset(ifReq.ifr_name, 0, sizeof(ifReq.ifr_name));\n\t\tstrncpy(ifReq.ifr_name, pifReq->ifr_name,\n\t\t\tsizeof(ifReq.ifr_name) - 1);\n\t\tif (ioctl(LocalSock, SIOCGIFFLAGS, &ifReq) < 0) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Can't get interface flags for %s:\\n\",\n\t\t\t\t   ifReq.ifr_name);\n\t\t}\n\t\t/* Skip LOOPBACK interfaces, DOWN interfaces and interfaces that  */\n\t\t/* don't support MULTICAST. */\n\t\tif ((ifReq.ifr_flags & IFF_LOOPBACK)\n\t\t    || (!(ifReq.ifr_flags & IFF_UP))\n\t\t    || (!(ifReq.ifr_flags & IFF_MULTICAST))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifname_found == 0) {\n\t\t\t/* We have found a valid interface name. Keep it. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, pifReq->ifr_name, sizeof(gIF_NAME) - 1);\n\t\t\tifname_found = 1;\n\t\t} else {\n\t\t\tif (strncmp\n\t\t\t    (gIF_NAME, pifReq->ifr_name,\n\t\t\t     sizeof(gIF_NAME)) != 0) {\n\t\t\t\t/* This is not the interface we're looking for. */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* Check address family. */\n\t\tif (pifReq->ifr_addr.sa_family == AF_INET) {\n\t\t\t/* Copy interface name, IPv4 address and interface index. */\n\t\t\tmemset(gIF_NAME, 0, sizeof(gIF_NAME));\n\t\t\tstrncpy(gIF_NAME, pifReq->ifr_name, sizeof(gIF_NAME) - 1);\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t  &((struct sockaddr_in *)&pifReq->ifr_addr)->\n\t\t\t\t  sin_addr, gIF_IPV4, sizeof(gIF_IPV4));\n\t\t\tgIF_INDEX = if_nametoindex(gIF_NAME);\n\t\t\tvalid_addr_found = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Address is not IPv4 */\n\t\t\tifname_found = 0;\n\t\t}\n\t}\n\tclose(LocalSock);\n\t/* Failed to find a valid interface, or valid address. */\n\tif (ifname_found == 0 || valid_addr_found == 0) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t   \"Failed to find an adapter with valid IP addresses for use.\\n\");\n\n\t\treturn UPNP_E_INVALID_INTERFACE;\n\t}\n\t/* Try to get the IPv6 address for the same interface  */\n\t/* from \"/proc/net/if_inet6\", if possible. */\n\tinet6_procfd = fopen(\"/proc/net/if_inet6\", \"r\");\n\tif (inet6_procfd) {\n\t\twhile (fscanf(inet6_procfd,\n\t\t\t      \"%4s%4s%4s%4s%4s%4s%4s%4s %02x %*02x %*02x %*02x %*20s\\n\",\n\t\t\t      addr6[0], addr6[1], addr6[2], addr6[3],\n\t\t\t      addr6[4], addr6[5], addr6[6], addr6[7],\n\t\t\t      &if_idx) != EOF) {\n\t\t\t/* Get same interface as IPv4 address retrieved. */\n\t\t\tif (gIF_INDEX == if_idx) {\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"%s:%s:%s:%s:%s:%s:%s:%s\", addr6[0],\n\t\t\t\t\t addr6[1], addr6[2], addr6[3], addr6[4],\n\t\t\t\t\t addr6[5], addr6[6], addr6[7]);\n\t\t\t\t/* Validate formed address and check for link-local. */\n\t\t\t\tif (inet_pton(AF_INET6, buf, &v6_addr) > 0) {\n\t\t\t\t\tif (IN6_IS_ADDR_ULA(&v6_addr)) {\n\t\t\t\t\t\t/* Got valid IPv6 ula. */\n\t\t\t\t\t\tmemset(gIF_IPV6_ULA_GUA, 0,\n\t\t\t\t\t\t\tsizeof(gIF_IPV6_ULA_GUA));\n\t\t\t\t\t\tstrncpy(gIF_IPV6_ULA_GUA, buf,\n\t\t\t\t\t\t\tsizeof\n\t\t\t\t\t\t\t(gIF_IPV6_ULA_GUA) - 1);\n\t\t\t\t\t} else if (IN6_IS_ADDR_GLOBAL(&v6_addr)\n\t\t\t\t\t\t   && strlen(gIF_IPV6_ULA_GUA)\n\t\t\t\t\t\t   == (size_t)0) {\n\t\t\t\t\t\t/* got a GUA, should store it while no ULA is found */\n\t\t\t\t\t\tmemset(gIF_IPV6_ULA_GUA, 0,\n                                                        sizeof(gIF_IPV6_ULA_GUA));\n\t\t\t\t\t\tstrncpy(gIF_IPV6_ULA_GUA, buf,\n\t\t\t\t\t\t\tsizeof\n\t\t\t\t\t\t\t(gIF_IPV6_ULA_GUA) - 1);\n\t\t\t\t\t} else\n\t\t\t\t\t    if (IN6_IS_ADDR_LINKLOCAL(&v6_addr)\n\t\t\t\t\t\t&& strlen(gIF_IPV6) == (size_t)0) {\n\t\t\t\t\t\t/* got a Link local IPv6 address. */\n\t\t\t\t\t\tmemset(gIF_IPV6, 0,\n                                                        sizeof(gIF_IPV6));\n\t\t\t\t\t\tstrncpy(gIF_IPV6, buf,\n\t\t\t\t\t\t\tsizeof(gIF_IPV6) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfclose(inet6_procfd);\n\t}\n#endif\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Interface name=%s, index=%d, v4=%s, v6=%s, ULA or GUA v6=%s\\n\",\n\t\t   gIF_NAME, gIF_INDEX, gIF_IPV4, gIF_IPV6, gIF_IPV6_ULA_GUA);\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "API",
            "__FILE__",
            "__LINE__",
            "\"UpnpInit2 with IfName=%s, DestPort=%d.\\n\"",
            "IfName ? IfName : \"\"",
            "DestPort"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpInitPreamble",
          "args": [],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpInitPreamble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "321-392",
          "snippet": "static int UpnpInitPreamble(void)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tint i;\n#ifdef UPNP_HAVE_OPTSSDP\n\tuuid_upnp nls_uuid;\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\tretVal = WinsockInit();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n\t/* needed by SSDP or other parts. */\n\tsrand((unsigned int)time(NULL));\n\n\t/* Initialize debug output. */\n\tretVal = UpnpInitLog();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\t/* UpnpInitLog does not return a valid UPNP_E_*. */\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__, \"Inside UpnpInitPreamble\\n\" );\n\n\t/* Initialize SDK global mutexes. */\n\tretVal = UpnpInitMutexes();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef UPNP_HAVE_OPTSSDP\n\t/* Create the NLS uuid. */\n\tuuid_create(&nls_uuid);\n\tuuid_unpack(&nls_uuid, gUpnpSdkNLSuuid);\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\t/* Initializes the handle list. */\n\tHandleLock();\n\tfor (i = 0; i < NUM_HANDLE; ++i) {\n\t\tHandleTable[i] = NULL;\n\t}\n\tHandleUnlock();\n\n\t/* Initialize SDK global thread pools. */\n\tretVal = UpnpInitThreadPools();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef INCLUDE_DEVICE_APIS\n#if EXCLUDE_SOAP == 0\n\tSetSoapCallback(soap_device_callback);\n#endif\n#endif /* INCLUDE_DEVICE_APIS */\n\n#ifdef INTERNAL_WEB_SERVER\n#if EXCLUDE_GENA == 0\n\tSetGenaCallback(genaCallback);\n#endif\n#endif /* INTERNAL_WEB_SERVER */\n\n\t/* Initialize the SDK timer thread. */\n\tretVal = TimerThreadInit( &gTimerThread, &gSendThreadPool );\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\n\t\treturn retVal;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "TimerThread gTimerThread;",
            "ThreadPool gSendThreadPool;",
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nTimerThread gTimerThread;\nThreadPool gSendThreadPool;\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int UpnpInitPreamble(void)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tint i;\n#ifdef UPNP_HAVE_OPTSSDP\n\tuuid_upnp nls_uuid;\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\tretVal = WinsockInit();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n\t/* needed by SSDP or other parts. */\n\tsrand((unsigned int)time(NULL));\n\n\t/* Initialize debug output. */\n\tretVal = UpnpInitLog();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\t/* UpnpInitLog does not return a valid UPNP_E_*. */\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__, \"Inside UpnpInitPreamble\\n\" );\n\n\t/* Initialize SDK global mutexes. */\n\tretVal = UpnpInitMutexes();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef UPNP_HAVE_OPTSSDP\n\t/* Create the NLS uuid. */\n\tuuid_create(&nls_uuid);\n\tuuid_unpack(&nls_uuid, gUpnpSdkNLSuuid);\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\t/* Initializes the handle list. */\n\tHandleLock();\n\tfor (i = 0; i < NUM_HANDLE; ++i) {\n\t\tHandleTable[i] = NULL;\n\t}\n\tHandleUnlock();\n\n\t/* Initialize SDK global thread pools. */\n\tretVal = UpnpInitThreadPools();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef INCLUDE_DEVICE_APIS\n#if EXCLUDE_SOAP == 0\n\tSetSoapCallback(soap_device_callback);\n#endif\n#endif /* INCLUDE_DEVICE_APIS */\n\n#ifdef INTERNAL_WEB_SERVER\n#if EXCLUDE_GENA == 0\n\tSetGenaCallback(genaCallback);\n#endif\n#endif /* INTERNAL_WEB_SERVER */\n\n\t/* Initialize the SDK timer thread. */\n\tretVal = TimerThreadInit( &gTimerThread, &gSendThreadPool );\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\n\t\treturn retVal;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ithread_mutex_lock",
          "args": [
            "&gSDKInitMutex"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ithread_initialize_library",
          "args": [],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nithread_mutex_t gSDKInitMutex = PTHREAD_MUTEX_INITIALIZER;\nint UpnpSdkInit = 0;\n\nint UpnpInit2(const char *IfName, unsigned short DestPort)\n{\n\tint retVal;\n\n\t/* Initializes the ithread library */\n\tithread_initialize_library();\n\n\tithread_mutex_lock(&gSDKInitMutex);\n\n\t/* Check if we're already initialized. */\n\tif (UpnpSdkInit == 1) {\n\t\tretVal = UPNP_E_INIT;\n\t\tgoto exit_function;\n\t}\n\n\t/* Perform initialization preamble. */\n\tretVal = UpnpInitPreamble();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"UpnpInit2 with IfName=%s, DestPort=%d.\\n\", \n\t\tIfName ? IfName : \"\", DestPort);\n\n\t/* Retrieve interface information (Addresses, index, etc). */\n\tretVal = UpnpGetIfInfo( IfName );\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tgoto exit_function;\n\t}\n\n\t/* Set the UpnpSdkInit flag to 1 to indicate we're successfully initialized. */\n\tUpnpSdkInit = 1;\n\n\t/* Finish initializing the SDK. */\n\tretVal = UpnpInitStartServers(DestPort);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpSdkInit = 0;\n\t\tgoto exit_function;\n\t}\n\nexit_function:\n\tithread_mutex_unlock(&gSDKInitMutex);\n\n\treturn retVal;\n}"
  },
  {
    "function_name": "UpnpInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "442-496",
    "snippet": "int UpnpInit(const char *HostIP, unsigned short DestPort)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\n\t/* Initializes the ithread library */\n\tithread_initialize_library();\n\n\tithread_mutex_lock(&gSDKInitMutex);\n\n\t/* Check if we're already initialized. */\n\tif (UpnpSdkInit == 1) {\n\t\tretVal = UPNP_E_INIT;\n\t\tgoto exit_function;\n\t}\n\n\t/* Perform initialization preamble. */\n\tretVal = UpnpInitPreamble();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"UpnpInit with HostIP=%s, DestPort=%d.\\n\", \n\t\tHostIP ? HostIP : \"\", (int)DestPort);\n\n\t/* Verify HostIP, if provided, or find it ourselves. */\n\tmemset(gIF_IPV4, 0, sizeof(gIF_IPV4));\n\tif (HostIP != NULL) {\n\t\tstrncpy(gIF_IPV4, HostIP, sizeof(gIF_IPV4) - 1);\n\t} else {\n\t\tif( getlocalhostname( gIF_IPV4, sizeof(gIF_IPV4) - 1 ) != UPNP_E_SUCCESS ) {\n\t\t\tretVal = UPNP_E_INIT_FAILED;\n\t\t\tgoto exit_function;\n\t\t}\n\t}\n\n\t/* Set the UpnpSdkInit flag to 1 to indicate we're successfully initialized. */\n\tUpnpSdkInit = 1;\n\n\t/* Finish initializing the SDK. */\n\tretVal = UpnpInitStartServers(DestPort);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpSdkInit = 0;\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Host Ip: %s Host Port: %d\\n\", gIF_IPV4,\n\t\t(int)LOCAL_PORT_V4);\n\nexit_function:\n\tithread_mutex_unlock(&gSDKInitMutex);\n\n\treturn retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ithread_mutex_t gSDKInitMutex = PTHREAD_MUTEX_INITIALIZER;",
      "char gIF_IPV4[INET_ADDRSTRLEN] = { '\\0' };",
      "unsigned short LOCAL_PORT_V4;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ithread_mutex_unlock",
          "args": [
            "&gSDKInitMutex"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Host Ip: %s Host Port: %d\\n\"",
            "gIF_IPV4",
            "(int)LOCAL_PORT_V4"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpInitStartServers",
          "args": [
            "DestPort"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpInitStartServers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "403-439",
          "snippet": "static int UpnpInitStartServers(\n\t/*! [in] Local Port to listen for incoming connections. */\n\tunsigned short DestPort)\n{\n#if EXCLUDE_MINISERVER == 0 || EXCLUDE_WEB_SERVER == 0\n\tint retVal = 0;\n#endif\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Entering UpnpInitStartServers\\n\" );\n\n#if EXCLUDE_MINISERVER == 0\n\tLOCAL_PORT_V4 = DestPort;\n\tLOCAL_PORT_V6 = DestPort;\n\tretVal = StartMiniServer(&LOCAL_PORT_V4, &LOCAL_PORT_V6);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Miniserver failed to start\");\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmembuffer_init(&gDocumentRootDir);\n\tretVal = UpnpEnableWebserver(WEB_SERVER_ENABLED);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpInitStartServers\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned short LOCAL_PORT_V4;",
            "unsigned short LOCAL_PORT_V6;",
            "extern membuffer gDocumentRootDir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nunsigned short LOCAL_PORT_V4;\nunsigned short LOCAL_PORT_V6;\nextern membuffer gDocumentRootDir;\n\nstatic int UpnpInitStartServers(\n\t/*! [in] Local Port to listen for incoming connections. */\n\tunsigned short DestPort)\n{\n#if EXCLUDE_MINISERVER == 0 || EXCLUDE_WEB_SERVER == 0\n\tint retVal = 0;\n#endif\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Entering UpnpInitStartServers\\n\" );\n\n#if EXCLUDE_MINISERVER == 0\n\tLOCAL_PORT_V4 = DestPort;\n\tLOCAL_PORT_V6 = DestPort;\n\tretVal = StartMiniServer(&LOCAL_PORT_V4, &LOCAL_PORT_V6);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Miniserver failed to start\");\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmembuffer_init(&gDocumentRootDir);\n\tretVal = UpnpEnableWebserver(WEB_SERVER_ENABLED);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpInitStartServers\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getlocalhostname",
          "args": [
            "gIF_IPV4",
            "sizeof(gIF_IPV4) - 1"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "getlocalhostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3934-4089",
          "snippet": "int getlocalhostname(char *out, size_t out_len)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar tempstr[INET_ADDRSTRLEN];\n\tconst char *p = NULL;\n\n#ifdef WIN32\n\tstruct hostent *h = NULL;\n\tstruct sockaddr_in LocalAddr;\n\n\tmemset(&LocalAddr, 0, sizeof(LocalAddr));\n\n\tgethostname(out, out_len);\n\th = gethostbyname(out);\n\tif (h != NULL) {\n\t\tmemcpy(&LocalAddr.sin_addr, h->h_addr_list[0], 4);\n\t\tp = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));\n\t\tif (p) {\n\t\t\tstrncpy(out, p, out_len);\n\t\t} else {\n\t\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"getlocalhostname: inet_ntop returned error\\n\" );\n\t\t\tret = UPNP_E_INIT;\n\t\t}\n\t} else {\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"getlocalhostname: gethostbyname returned error\\n\" );\n\t\tret = UPNP_E_INIT;\n\t}\n\n#elif (defined(BSD) && BSD >= 199306) || defined(__FreeBSD_kernel__)\n\tstruct ifaddrs *ifap, *ifa;\n\n\tif (getifaddrs(&ifap) != 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"DiscoverInterfaces: getifaddrs() returned error\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\n\t/* cycle through available interfaces */\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t/* Skip loopback, point-to-point and down interfaces, \n\t\t * except don't skip down interfaces\n\t\t * if we're trying to get a list of configurable interfaces. */\n\t\tif ((ifa->ifa_flags & IFF_LOOPBACK) ||\n\t\t    (!( ifa->ifa_flags & IFF_UP))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\t/* We don't want the loopback interface. */\n\t\t\tif (((struct sockaddr_in *)(ifa->ifa_addr))->sin_addr.s_addr ==\n\t\t\t    htonl(INADDR_LOOPBACK)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp = inet_ntop(AF_INET,\n\t\t\t\t&((struct sockaddr_in *)(ifa->ifa_addr))->sin_addr,\n\t\t\t\ttempstr, sizeof(tempstr));\n\t\t\tif (p) {\n\t\t\t\tstrncpy(out, p, out_len);\n\t\t\t} else {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t\"getlocalhostname: inet_ntop returned error\\n\");\n\t\t\t\tret = UPNP_E_INIT;\n\t\t\t}\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"Inside getlocalhostname: after strncpy %s\\n\", out);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfreeifaddrs(ifap);\n\n\tret = ifa ? UPNP_E_SUCCESS : UPNP_E_INIT;\n#else\n\tchar szBuffer[MAX_INTERFACES * sizeof (struct ifreq)];\n\tstruct ifconf ifConf;\n\tstruct ifreq ifReq;\n\tint nResult;\n\tlong unsigned int i;\n\tint LocalSock;\n\tstruct sockaddr_in LocalAddr;\n\tint j = 0;\n\n\t/* purify */\n\tmemset(&ifConf,  0, sizeof(ifConf));\n\tmemset(&ifReq,   0, sizeof(ifReq));\n\tmemset(szBuffer, 0, sizeof(szBuffer));\n\tmemset(&LocalAddr, 0, sizeof(LocalAddr));\n\n\t/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on.  */\n\tLocalSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (LocalSock == INVALID_SOCKET) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Can't create addrlist socket\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Get the interface configuration information... */\n\tifConf.ifc_len = (int)sizeof szBuffer;\n\tifConf.ifc_ifcu.ifcu_buf = (caddr_t) szBuffer;\n\tnResult = ioctl(LocalSock, SIOCGIFCONF, &ifConf);\n\tif (nResult < 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"DiscoverInterfaces: SIOCGIFCONF returned error\\n\");\n\t\tclose(LocalSock);\n\t\treturn UPNP_E_INIT;\n\t}\n\n\t/* Cycle through the list of interfaces looking for IP addresses. */\n\tfor (i = 0lu; i < (long unsigned int)ifConf.ifc_len && j < DEFAULT_INTERFACE; ) {\n\t\tstruct ifreq *pifReq =\n\t\t\t(struct ifreq *)((caddr_t)ifConf.ifc_req + i);\n\t\ti += sizeof *pifReq;\n\t\t/* See if this is the sort of interface we want to deal with. */\n\t\tmemset(ifReq.ifr_name, 0, sizeof(ifReq.ifr_name));\n\t\tstrncpy(ifReq.ifr_name, pifReq->ifr_name,\n\t\t\tsizeof(ifReq.ifr_name) - 1);\n\t\tif (ioctl(LocalSock, SIOCGIFFLAGS, &ifReq) < 0) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"Can't get interface flags for %s:\\n\",\n\t\t\t\tifReq.ifr_name);\n\t\t}\n\t\t/* Skip loopback, point-to-point and down interfaces,\n\t\t * except don't skip down interfaces\n\t\t * if we're trying to get a list of configurable interfaces. */\n\t\tif ((ifReq.ifr_flags & IFF_LOOPBACK) ||\n\t\t    (!(ifReq.ifr_flags & IFF_UP))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pifReq->ifr_addr.sa_family == AF_INET) {\n\t\t\t/* Get a pointer to the address...*/\n\t\t\tmemcpy(&LocalAddr, &pifReq->ifr_addr,\n\t\t\t\tsizeof pifReq->ifr_addr);\n\t\t\t/* We don't want the loopback interface. */\n\t\t\tif (LocalAddr.sin_addr.s_addr ==\n\t\t\t    htonl(INADDR_LOOPBACK)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* increment j if we found an address which is not loopback\n\t\t * and is up */\n\t\tj++;\n\t}\n\tclose(LocalSock);\n\n\tp = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));\n\tif (p) {\n\t\tstrncpy(out, p, out_len);\n\t} else {\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"getlocalhostname: inet_ntop returned error\\n\" );\n\t\tret = UPNP_E_INIT;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside getlocalhostname: after strncpy %s\\n\", out);\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nint getlocalhostname(char *out, size_t out_len)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar tempstr[INET_ADDRSTRLEN];\n\tconst char *p = NULL;\n\n#ifdef WIN32\n\tstruct hostent *h = NULL;\n\tstruct sockaddr_in LocalAddr;\n\n\tmemset(&LocalAddr, 0, sizeof(LocalAddr));\n\n\tgethostname(out, out_len);\n\th = gethostbyname(out);\n\tif (h != NULL) {\n\t\tmemcpy(&LocalAddr.sin_addr, h->h_addr_list[0], 4);\n\t\tp = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));\n\t\tif (p) {\n\t\t\tstrncpy(out, p, out_len);\n\t\t} else {\n\t\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"getlocalhostname: inet_ntop returned error\\n\" );\n\t\t\tret = UPNP_E_INIT;\n\t\t}\n\t} else {\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"getlocalhostname: gethostbyname returned error\\n\" );\n\t\tret = UPNP_E_INIT;\n\t}\n\n#elif (defined(BSD) && BSD >= 199306) || defined(__FreeBSD_kernel__)\n\tstruct ifaddrs *ifap, *ifa;\n\n\tif (getifaddrs(&ifap) != 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"DiscoverInterfaces: getifaddrs() returned error\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\n\t/* cycle through available interfaces */\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t/* Skip loopback, point-to-point and down interfaces, \n\t\t * except don't skip down interfaces\n\t\t * if we're trying to get a list of configurable interfaces. */\n\t\tif ((ifa->ifa_flags & IFF_LOOPBACK) ||\n\t\t    (!( ifa->ifa_flags & IFF_UP))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\t/* We don't want the loopback interface. */\n\t\t\tif (((struct sockaddr_in *)(ifa->ifa_addr))->sin_addr.s_addr ==\n\t\t\t    htonl(INADDR_LOOPBACK)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp = inet_ntop(AF_INET,\n\t\t\t\t&((struct sockaddr_in *)(ifa->ifa_addr))->sin_addr,\n\t\t\t\ttempstr, sizeof(tempstr));\n\t\t\tif (p) {\n\t\t\t\tstrncpy(out, p, out_len);\n\t\t\t} else {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t\"getlocalhostname: inet_ntop returned error\\n\");\n\t\t\t\tret = UPNP_E_INIT;\n\t\t\t}\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"Inside getlocalhostname: after strncpy %s\\n\", out);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfreeifaddrs(ifap);\n\n\tret = ifa ? UPNP_E_SUCCESS : UPNP_E_INIT;\n#else\n\tchar szBuffer[MAX_INTERFACES * sizeof (struct ifreq)];\n\tstruct ifconf ifConf;\n\tstruct ifreq ifReq;\n\tint nResult;\n\tlong unsigned int i;\n\tint LocalSock;\n\tstruct sockaddr_in LocalAddr;\n\tint j = 0;\n\n\t/* purify */\n\tmemset(&ifConf,  0, sizeof(ifConf));\n\tmemset(&ifReq,   0, sizeof(ifReq));\n\tmemset(szBuffer, 0, sizeof(szBuffer));\n\tmemset(&LocalAddr, 0, sizeof(LocalAddr));\n\n\t/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on.  */\n\tLocalSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (LocalSock == INVALID_SOCKET) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"Can't create addrlist socket\\n\");\n\t\treturn UPNP_E_INIT;\n\t}\n\t/* Get the interface configuration information... */\n\tifConf.ifc_len = (int)sizeof szBuffer;\n\tifConf.ifc_ifcu.ifcu_buf = (caddr_t) szBuffer;\n\tnResult = ioctl(LocalSock, SIOCGIFCONF, &ifConf);\n\tif (nResult < 0) {\n\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"DiscoverInterfaces: SIOCGIFCONF returned error\\n\");\n\t\tclose(LocalSock);\n\t\treturn UPNP_E_INIT;\n\t}\n\n\t/* Cycle through the list of interfaces looking for IP addresses. */\n\tfor (i = 0lu; i < (long unsigned int)ifConf.ifc_len && j < DEFAULT_INTERFACE; ) {\n\t\tstruct ifreq *pifReq =\n\t\t\t(struct ifreq *)((caddr_t)ifConf.ifc_req + i);\n\t\ti += sizeof *pifReq;\n\t\t/* See if this is the sort of interface we want to deal with. */\n\t\tmemset(ifReq.ifr_name, 0, sizeof(ifReq.ifr_name));\n\t\tstrncpy(ifReq.ifr_name, pifReq->ifr_name,\n\t\t\tsizeof(ifReq.ifr_name) - 1);\n\t\tif (ioctl(LocalSock, SIOCGIFFLAGS, &ifReq) < 0) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\"Can't get interface flags for %s:\\n\",\n\t\t\t\tifReq.ifr_name);\n\t\t}\n\t\t/* Skip loopback, point-to-point and down interfaces,\n\t\t * except don't skip down interfaces\n\t\t * if we're trying to get a list of configurable interfaces. */\n\t\tif ((ifReq.ifr_flags & IFF_LOOPBACK) ||\n\t\t    (!(ifReq.ifr_flags & IFF_UP))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pifReq->ifr_addr.sa_family == AF_INET) {\n\t\t\t/* Get a pointer to the address...*/\n\t\t\tmemcpy(&LocalAddr, &pifReq->ifr_addr,\n\t\t\t\tsizeof pifReq->ifr_addr);\n\t\t\t/* We don't want the loopback interface. */\n\t\t\tif (LocalAddr.sin_addr.s_addr ==\n\t\t\t    htonl(INADDR_LOOPBACK)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* increment j if we found an address which is not loopback\n\t\t * and is up */\n\t\tj++;\n\t}\n\tclose(LocalSock);\n\n\tp = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));\n\tif (p) {\n\t\tstrncpy(out, p, out_len);\n\t} else {\n\t\tUpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\"getlocalhostname: inet_ntop returned error\\n\" );\n\t\tret = UPNP_E_INIT;\n\t}\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\"Inside getlocalhostname: after strncpy %s\\n\", out);\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "gIF_IPV4",
            "HostIP",
            "sizeof(gIF_IPV4) - 1"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "gIF_IPV4",
            "0",
            "sizeof(gIF_IPV4)"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpInitPreamble",
          "args": [],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpInitPreamble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "321-392",
          "snippet": "static int UpnpInitPreamble(void)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tint i;\n#ifdef UPNP_HAVE_OPTSSDP\n\tuuid_upnp nls_uuid;\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\tretVal = WinsockInit();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n\t/* needed by SSDP or other parts. */\n\tsrand((unsigned int)time(NULL));\n\n\t/* Initialize debug output. */\n\tretVal = UpnpInitLog();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\t/* UpnpInitLog does not return a valid UPNP_E_*. */\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__, \"Inside UpnpInitPreamble\\n\" );\n\n\t/* Initialize SDK global mutexes. */\n\tretVal = UpnpInitMutexes();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef UPNP_HAVE_OPTSSDP\n\t/* Create the NLS uuid. */\n\tuuid_create(&nls_uuid);\n\tuuid_unpack(&nls_uuid, gUpnpSdkNLSuuid);\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\t/* Initializes the handle list. */\n\tHandleLock();\n\tfor (i = 0; i < NUM_HANDLE; ++i) {\n\t\tHandleTable[i] = NULL;\n\t}\n\tHandleUnlock();\n\n\t/* Initialize SDK global thread pools. */\n\tretVal = UpnpInitThreadPools();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef INCLUDE_DEVICE_APIS\n#if EXCLUDE_SOAP == 0\n\tSetSoapCallback(soap_device_callback);\n#endif\n#endif /* INCLUDE_DEVICE_APIS */\n\n#ifdef INTERNAL_WEB_SERVER\n#if EXCLUDE_GENA == 0\n\tSetGenaCallback(genaCallback);\n#endif\n#endif /* INTERNAL_WEB_SERVER */\n\n\t/* Initialize the SDK timer thread. */\n\tretVal = TimerThreadInit( &gTimerThread, &gSendThreadPool );\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\n\t\treturn retVal;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "TimerThread gTimerThread;",
            "ThreadPool gSendThreadPool;",
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nTimerThread gTimerThread;\nThreadPool gSendThreadPool;\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int UpnpInitPreamble(void)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tint i;\n#ifdef UPNP_HAVE_OPTSSDP\n\tuuid_upnp nls_uuid;\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\tretVal = WinsockInit();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n\t/* needed by SSDP or other parts. */\n\tsrand((unsigned int)time(NULL));\n\n\t/* Initialize debug output. */\n\tretVal = UpnpInitLog();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\t/* UpnpInitLog does not return a valid UPNP_E_*. */\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__, \"Inside UpnpInitPreamble\\n\" );\n\n\t/* Initialize SDK global mutexes. */\n\tretVal = UpnpInitMutexes();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef UPNP_HAVE_OPTSSDP\n\t/* Create the NLS uuid. */\n\tuuid_create(&nls_uuid);\n\tuuid_unpack(&nls_uuid, gUpnpSdkNLSuuid);\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\t/* Initializes the handle list. */\n\tHandleLock();\n\tfor (i = 0; i < NUM_HANDLE; ++i) {\n\t\tHandleTable[i] = NULL;\n\t}\n\tHandleUnlock();\n\n\t/* Initialize SDK global thread pools. */\n\tretVal = UpnpInitThreadPools();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef INCLUDE_DEVICE_APIS\n#if EXCLUDE_SOAP == 0\n\tSetSoapCallback(soap_device_callback);\n#endif\n#endif /* INCLUDE_DEVICE_APIS */\n\n#ifdef INTERNAL_WEB_SERVER\n#if EXCLUDE_GENA == 0\n\tSetGenaCallback(genaCallback);\n#endif\n#endif /* INTERNAL_WEB_SERVER */\n\n\t/* Initialize the SDK timer thread. */\n\tretVal = TimerThreadInit( &gTimerThread, &gSendThreadPool );\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\n\t\treturn retVal;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ithread_mutex_lock",
          "args": [
            "&gSDKInitMutex"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ithread_initialize_library",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nithread_mutex_t gSDKInitMutex = PTHREAD_MUTEX_INITIALIZER;\nchar gIF_IPV4[INET_ADDRSTRLEN] = { '\\0' };\nunsigned short LOCAL_PORT_V4;\nint UpnpSdkInit = 0;\n\nint UpnpInit(const char *HostIP, unsigned short DestPort)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\n\t/* Initializes the ithread library */\n\tithread_initialize_library();\n\n\tithread_mutex_lock(&gSDKInitMutex);\n\n\t/* Check if we're already initialized. */\n\tif (UpnpSdkInit == 1) {\n\t\tretVal = UPNP_E_INIT;\n\t\tgoto exit_function;\n\t}\n\n\t/* Perform initialization preamble. */\n\tretVal = UpnpInitPreamble();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"UpnpInit with HostIP=%s, DestPort=%d.\\n\", \n\t\tHostIP ? HostIP : \"\", (int)DestPort);\n\n\t/* Verify HostIP, if provided, or find it ourselves. */\n\tmemset(gIF_IPV4, 0, sizeof(gIF_IPV4));\n\tif (HostIP != NULL) {\n\t\tstrncpy(gIF_IPV4, HostIP, sizeof(gIF_IPV4) - 1);\n\t} else {\n\t\tif( getlocalhostname( gIF_IPV4, sizeof(gIF_IPV4) - 1 ) != UPNP_E_SUCCESS ) {\n\t\t\tretVal = UPNP_E_INIT_FAILED;\n\t\t\tgoto exit_function;\n\t\t}\n\t}\n\n\t/* Set the UpnpSdkInit flag to 1 to indicate we're successfully initialized. */\n\tUpnpSdkInit = 1;\n\n\t/* Finish initializing the SDK. */\n\tretVal = UpnpInitStartServers(DestPort);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpSdkInit = 0;\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Host Ip: %s Host Port: %d\\n\", gIF_IPV4,\n\t\t(int)LOCAL_PORT_V4);\n\nexit_function:\n\tithread_mutex_unlock(&gSDKInitMutex);\n\n\treturn retVal;\n}"
  },
  {
    "function_name": "UpnpInitStartServers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "403-439",
    "snippet": "static int UpnpInitStartServers(\n\t/*! [in] Local Port to listen for incoming connections. */\n\tunsigned short DestPort)\n{\n#if EXCLUDE_MINISERVER == 0 || EXCLUDE_WEB_SERVER == 0\n\tint retVal = 0;\n#endif\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Entering UpnpInitStartServers\\n\" );\n\n#if EXCLUDE_MINISERVER == 0\n\tLOCAL_PORT_V4 = DestPort;\n\tLOCAL_PORT_V6 = DestPort;\n\tretVal = StartMiniServer(&LOCAL_PORT_V4, &LOCAL_PORT_V6);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Miniserver failed to start\");\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmembuffer_init(&gDocumentRootDir);\n\tretVal = UpnpEnableWebserver(WEB_SERVER_ENABLED);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpInitStartServers\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned short LOCAL_PORT_V4;",
      "unsigned short LOCAL_PORT_V6;",
      "extern membuffer gDocumentRootDir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting UpnpInitStartServers\\n\""
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpFinish",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "625-709",
          "snippet": "int UpnpFinish(void)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\tUpnpDevice_Handle device_handle;\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tUpnpClient_Handle client_handle;\n#endif\n\tstruct Handle_Info *temp;\n#ifdef UPNP_ENABLE_OPEN_SSL\n    if (gSslCtx) {\n        SSL_CTX_free(gSslCtx);\n        gSslCtx = NULL;\n    }\n#endif\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpFinish: UpnpSdkInit is %d\\n\", UpnpSdkInit);\n\tif (UpnpSdkInit == 1)\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"UpnpFinish: UpnpSdkInit is ONE\\n\");\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n#ifdef INCLUDE_DEVICE_APIS\n\tswitch (GetDeviceHandleInfo(AF_INET, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (GetDeviceHandleInfo(AF_INET6, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tswitch (GetClientHandleInfo(&client_handle, &temp)) {\n\tcase HND_CLIENT:\n\t\tUpnpUnRegisterClient(client_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\tTimerThreadShutdown(&gTimerThread);\n#if EXCLUDE_MINISERVER == 0\n\tStopMiniServer();\n#endif\n#if EXCLUDE_WEB_SERVER == 0\n\tweb_server_destroy();\n#endif\n\tThreadPoolShutdown(&gMiniServerThreadPool);\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n\tThreadPoolShutdown(&gRecvThreadPool);\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tThreadPoolShutdown(&gSendThreadPool);\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n#ifdef INCLUDE_CLIENT_APIS\n\tithread_mutex_destroy(&GlobalClientSubscribeMutex);\n#endif\n\tithread_rwlock_destroy(&GlobalHndRWLock);\n\tithread_mutex_destroy(&gUUIDMutex);\n\t/* remove all virtual dirs */\n\tUpnpRemoveAllVirtualDirs();\n\tUpnpSdkInit = 0;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpFinish: UpnpSdkInit is :%d:\\n\", UpnpSdkInit);\n\tUpnpCloseLog();\n\t/* Clean-up ithread library resources */\n\tithread_cleanup_library();\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ithread_rwlock_t GlobalHndRWLock;",
            "ithread_mutex_t gUUIDMutex;",
            "TimerThread gTimerThread;",
            "ThreadPool gSendThreadPool;",
            "ThreadPool gRecvThreadPool;",
            "ThreadPool gMiniServerThreadPool;",
            "int UpnpSdkInit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nithread_rwlock_t GlobalHndRWLock;\nithread_mutex_t gUUIDMutex;\nTimerThread gTimerThread;\nThreadPool gSendThreadPool;\nThreadPool gRecvThreadPool;\nThreadPool gMiniServerThreadPool;\nint UpnpSdkInit = 0;\n\nint UpnpFinish(void)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\tUpnpDevice_Handle device_handle;\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tUpnpClient_Handle client_handle;\n#endif\n\tstruct Handle_Info *temp;\n#ifdef UPNP_ENABLE_OPEN_SSL\n    if (gSslCtx) {\n        SSL_CTX_free(gSslCtx);\n        gSslCtx = NULL;\n    }\n#endif\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpFinish: UpnpSdkInit is %d\\n\", UpnpSdkInit);\n\tif (UpnpSdkInit == 1)\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"UpnpFinish: UpnpSdkInit is ONE\\n\");\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n#ifdef INCLUDE_DEVICE_APIS\n\tswitch (GetDeviceHandleInfo(AF_INET, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (GetDeviceHandleInfo(AF_INET6, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tswitch (GetClientHandleInfo(&client_handle, &temp)) {\n\tcase HND_CLIENT:\n\t\tUpnpUnRegisterClient(client_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\tTimerThreadShutdown(&gTimerThread);\n#if EXCLUDE_MINISERVER == 0\n\tStopMiniServer();\n#endif\n#if EXCLUDE_WEB_SERVER == 0\n\tweb_server_destroy();\n#endif\n\tThreadPoolShutdown(&gMiniServerThreadPool);\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n\tThreadPoolShutdown(&gRecvThreadPool);\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tThreadPoolShutdown(&gSendThreadPool);\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n#ifdef INCLUDE_CLIENT_APIS\n\tithread_mutex_destroy(&GlobalClientSubscribeMutex);\n#endif\n\tithread_rwlock_destroy(&GlobalHndRWLock);\n\tithread_mutex_destroy(&gUUIDMutex);\n\t/* remove all virtual dirs */\n\tUpnpRemoveAllVirtualDirs();\n\tUpnpSdkInit = 0;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpFinish: UpnpSdkInit is :%d:\\n\", UpnpSdkInit);\n\tUpnpCloseLog();\n\t/* Clean-up ithread library resources */\n\tithread_cleanup_library();\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpEnableWebserver",
          "args": [
            "WEB_SERVER_ENABLED"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpEnableWebserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "4255-4284",
          "snippet": "int UpnpEnableWebserver(int enable)\n{\n    int retVal = UPNP_E_SUCCESS;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    switch ( enable ) {\n#ifdef INTERNAL_WEB_SERVER\n        case TRUE:\n            if( ( retVal = web_server_init() ) != UPNP_E_SUCCESS ) {\n                return retVal;\n            }\n            bWebServerState = WEB_SERVER_ENABLED;\n            SetHTTPGetCallback( web_server_callback );\n            break;\n\n        case FALSE:\n            web_server_destroy();\n            bWebServerState = WEB_SERVER_DISABLED;\n            SetHTTPGetCallback( NULL );\n            break;\n#endif /* INTERNAL_WEB_SERVER */\n        default:\n            retVal = UPNP_E_INVALID_PARAM;\n    }\n\n    return retVal;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "WebServerState bWebServerState = WEB_SERVER_DISABLED;",
            "int UpnpSdkInit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nWebServerState bWebServerState = WEB_SERVER_DISABLED;\nint UpnpSdkInit = 0;\n\nint UpnpEnableWebserver(int enable)\n{\n    int retVal = UPNP_E_SUCCESS;\n\n    if( UpnpSdkInit != 1 ) {\n        return UPNP_E_FINISH;\n    }\n\n    switch ( enable ) {\n#ifdef INTERNAL_WEB_SERVER\n        case TRUE:\n            if( ( retVal = web_server_init() ) != UPNP_E_SUCCESS ) {\n                return retVal;\n            }\n            bWebServerState = WEB_SERVER_ENABLED;\n            SetHTTPGetCallback( web_server_callback );\n            break;\n\n        case FALSE:\n            web_server_destroy();\n            bWebServerState = WEB_SERVER_DISABLED;\n            SetHTTPGetCallback( NULL );\n            break;\n#endif /* INTERNAL_WEB_SERVER */\n        default:\n            retVal = UPNP_E_INVALID_PARAM;\n    }\n\n    return retVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&gDocumentRootDir"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "StartMiniServer",
          "args": [
            "&LOCAL_PORT_V4",
            "&LOCAL_PORT_V6"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "StartMiniServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "856-960",
          "snippet": "int StartMiniServer(\n\t/*! [in,out] Port on which the server listens for incoming IPv4\n\t * connections. */\n\tuint16_t *listen_port4, \n\t/*! [in,out] Port on which the server listens for incoming IPv6\n\t * connections. */\n\tuint16_t *listen_port6)\n{\n\tint ret_code;\n\tint count;\n\tint max_count = 10000;\n\tMiniServerSockArray *miniSocket;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tswitch (gMServState) {\n\tcase MSERV_IDLE:\n\t\tbreak;\n\tdefault:\n\t\t/* miniserver running. */\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tminiSocket = (MiniServerSockArray *)malloc(\n\t\tsizeof (MiniServerSockArray));\n\tif (!miniSocket) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tInitMiniServerSockArray(miniSocket);\n#ifdef INTERNAL_WEB_SERVER\n\t/* V4 and V6 http listeners. */\n\tret_code = get_miniserver_sockets(\n\t\tminiSocket, *listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t\t, *listen_port6\n#endif\n\t\t);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n#endif\n\t/* Stop socket (To end miniserver processing). */\n\tret_code = get_miniserver_stopsock(miniSocket);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n\t/* SSDP socket for discovery/advertising. */\n\tret_code = get_ssdp_sockets(miniSocket);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n\tTPJobInit(&job, (start_routine)RunMiniServer, (void *)miniSocket);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tTPJobSetFreeFunction(&job, (free_routine)free);\n\tret_code = ThreadPoolAddPersistent(&gMiniServerThreadPool, &job, NULL);\n\tif (ret_code < 0) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tsock_close(miniSocket->ssdpSock4);\n\t\tsock_close(miniSocket->ssdpSock6);\n\t\tsock_close(miniSocket->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tsock_close(miniSocket->ssdpReqSock4);\n\t\tsock_close(miniSocket->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tfree(miniSocket);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* Wait for miniserver to start. */\n\tcount = 0;\n\twhile (gMServState != (MiniServerState)MSERV_RUNNING && count < max_count) {\n\t\t/* 0.05s */\n\t\tusleep(50u * 1000u);\n\t\tcount++;\n\t}\n\tif (count >= max_count) {\n\t\t/* Took it too long to start that thread. */\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tsock_close(miniSocket->ssdpSock4);\n\t\tsock_close(miniSocket->ssdpSock6);\n\t\tsock_close(miniSocket->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tsock_close(miniSocket->ssdpReqSock4);\n\t\tsock_close(miniSocket->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n#ifdef INTERNAL_WEB_SERVER\n\t*listen_port4 = miniSocket->miniServerPort4;\n\t*listen_port6 = miniSocket->miniServerPort6;\n#endif\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nint StartMiniServer(\n\t/*! [in,out] Port on which the server listens for incoming IPv4\n\t * connections. */\n\tuint16_t *listen_port4, \n\t/*! [in,out] Port on which the server listens for incoming IPv6\n\t * connections. */\n\tuint16_t *listen_port6)\n{\n\tint ret_code;\n\tint count;\n\tint max_count = 10000;\n\tMiniServerSockArray *miniSocket;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tswitch (gMServState) {\n\tcase MSERV_IDLE:\n\t\tbreak;\n\tdefault:\n\t\t/* miniserver running. */\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tminiSocket = (MiniServerSockArray *)malloc(\n\t\tsizeof (MiniServerSockArray));\n\tif (!miniSocket) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tInitMiniServerSockArray(miniSocket);\n#ifdef INTERNAL_WEB_SERVER\n\t/* V4 and V6 http listeners. */\n\tret_code = get_miniserver_sockets(\n\t\tminiSocket, *listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t\t, *listen_port6\n#endif\n\t\t);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n#endif\n\t/* Stop socket (To end miniserver processing). */\n\tret_code = get_miniserver_stopsock(miniSocket);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n\t/* SSDP socket for discovery/advertising. */\n\tret_code = get_ssdp_sockets(miniSocket);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n\tTPJobInit(&job, (start_routine)RunMiniServer, (void *)miniSocket);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tTPJobSetFreeFunction(&job, (free_routine)free);\n\tret_code = ThreadPoolAddPersistent(&gMiniServerThreadPool, &job, NULL);\n\tif (ret_code < 0) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tsock_close(miniSocket->ssdpSock4);\n\t\tsock_close(miniSocket->ssdpSock6);\n\t\tsock_close(miniSocket->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tsock_close(miniSocket->ssdpReqSock4);\n\t\tsock_close(miniSocket->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tfree(miniSocket);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* Wait for miniserver to start. */\n\tcount = 0;\n\twhile (gMServState != (MiniServerState)MSERV_RUNNING && count < max_count) {\n\t\t/* 0.05s */\n\t\tusleep(50u * 1000u);\n\t\tcount++;\n\t}\n\tif (count >= max_count) {\n\t\t/* Took it too long to start that thread. */\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tsock_close(miniSocket->ssdpSock4);\n\t\tsock_close(miniSocket->ssdpSock6);\n\t\tsock_close(miniSocket->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tsock_close(miniSocket->ssdpReqSock4);\n\t\tsock_close(miniSocket->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n#ifdef INTERNAL_WEB_SERVER\n\t*listen_port4 = miniSocket->miniServerPort4;\n\t*listen_port6 = miniSocket->miniServerPort6;\n#endif\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nunsigned short LOCAL_PORT_V4;\nunsigned short LOCAL_PORT_V6;\nextern membuffer gDocumentRootDir;\n\nstatic int UpnpInitStartServers(\n\t/*! [in] Local Port to listen for incoming connections. */\n\tunsigned short DestPort)\n{\n#if EXCLUDE_MINISERVER == 0 || EXCLUDE_WEB_SERVER == 0\n\tint retVal = 0;\n#endif\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Entering UpnpInitStartServers\\n\" );\n\n#if EXCLUDE_MINISERVER == 0\n\tLOCAL_PORT_V4 = DestPort;\n\tLOCAL_PORT_V6 = DestPort;\n\tretVal = StartMiniServer(&LOCAL_PORT_V4, &LOCAL_PORT_V6);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"Miniserver failed to start\");\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmembuffer_init(&gDocumentRootDir);\n\tretVal = UpnpEnableWebserver(WEB_SERVER_ENABLED);\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\t\treturn retVal;\n\t}\n#endif\n\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpInitStartServers\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpInitPreamble",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "321-392",
    "snippet": "static int UpnpInitPreamble(void)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tint i;\n#ifdef UPNP_HAVE_OPTSSDP\n\tuuid_upnp nls_uuid;\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\tretVal = WinsockInit();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n\t/* needed by SSDP or other parts. */\n\tsrand((unsigned int)time(NULL));\n\n\t/* Initialize debug output. */\n\tretVal = UpnpInitLog();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\t/* UpnpInitLog does not return a valid UPNP_E_*. */\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__, \"Inside UpnpInitPreamble\\n\" );\n\n\t/* Initialize SDK global mutexes. */\n\tretVal = UpnpInitMutexes();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef UPNP_HAVE_OPTSSDP\n\t/* Create the NLS uuid. */\n\tuuid_create(&nls_uuid);\n\tuuid_unpack(&nls_uuid, gUpnpSdkNLSuuid);\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\t/* Initializes the handle list. */\n\tHandleLock();\n\tfor (i = 0; i < NUM_HANDLE; ++i) {\n\t\tHandleTable[i] = NULL;\n\t}\n\tHandleUnlock();\n\n\t/* Initialize SDK global thread pools. */\n\tretVal = UpnpInitThreadPools();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef INCLUDE_DEVICE_APIS\n#if EXCLUDE_SOAP == 0\n\tSetSoapCallback(soap_device_callback);\n#endif\n#endif /* INCLUDE_DEVICE_APIS */\n\n#ifdef INTERNAL_WEB_SERVER\n#if EXCLUDE_GENA == 0\n\tSetGenaCallback(genaCallback);\n#endif\n#endif /* INTERNAL_WEB_SERVER */\n\n\t/* Initialize the SDK timer thread. */\n\tretVal = TimerThreadInit( &gTimerThread, &gSendThreadPool );\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\n\t\treturn retVal;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_HANDLE 200"
    ],
    "globals_used": [
      "TimerThread gTimerThread;",
      "ThreadPool gSendThreadPool;",
      "static void *HandleTable[NUM_HANDLE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpFinish",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "625-709",
          "snippet": "int UpnpFinish(void)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\tUpnpDevice_Handle device_handle;\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tUpnpClient_Handle client_handle;\n#endif\n\tstruct Handle_Info *temp;\n#ifdef UPNP_ENABLE_OPEN_SSL\n    if (gSslCtx) {\n        SSL_CTX_free(gSslCtx);\n        gSslCtx = NULL;\n    }\n#endif\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpFinish: UpnpSdkInit is %d\\n\", UpnpSdkInit);\n\tif (UpnpSdkInit == 1)\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"UpnpFinish: UpnpSdkInit is ONE\\n\");\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n#ifdef INCLUDE_DEVICE_APIS\n\tswitch (GetDeviceHandleInfo(AF_INET, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (GetDeviceHandleInfo(AF_INET6, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tswitch (GetClientHandleInfo(&client_handle, &temp)) {\n\tcase HND_CLIENT:\n\t\tUpnpUnRegisterClient(client_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\tTimerThreadShutdown(&gTimerThread);\n#if EXCLUDE_MINISERVER == 0\n\tStopMiniServer();\n#endif\n#if EXCLUDE_WEB_SERVER == 0\n\tweb_server_destroy();\n#endif\n\tThreadPoolShutdown(&gMiniServerThreadPool);\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n\tThreadPoolShutdown(&gRecvThreadPool);\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tThreadPoolShutdown(&gSendThreadPool);\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n#ifdef INCLUDE_CLIENT_APIS\n\tithread_mutex_destroy(&GlobalClientSubscribeMutex);\n#endif\n\tithread_rwlock_destroy(&GlobalHndRWLock);\n\tithread_mutex_destroy(&gUUIDMutex);\n\t/* remove all virtual dirs */\n\tUpnpRemoveAllVirtualDirs();\n\tUpnpSdkInit = 0;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpFinish: UpnpSdkInit is :%d:\\n\", UpnpSdkInit);\n\tUpnpCloseLog();\n\t/* Clean-up ithread library resources */\n\tithread_cleanup_library();\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ithread_rwlock_t GlobalHndRWLock;",
            "ithread_mutex_t gUUIDMutex;",
            "TimerThread gTimerThread;",
            "ThreadPool gSendThreadPool;",
            "ThreadPool gRecvThreadPool;",
            "ThreadPool gMiniServerThreadPool;",
            "int UpnpSdkInit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nithread_rwlock_t GlobalHndRWLock;\nithread_mutex_t gUUIDMutex;\nTimerThread gTimerThread;\nThreadPool gSendThreadPool;\nThreadPool gRecvThreadPool;\nThreadPool gMiniServerThreadPool;\nint UpnpSdkInit = 0;\n\nint UpnpFinish(void)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\tUpnpDevice_Handle device_handle;\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tUpnpClient_Handle client_handle;\n#endif\n\tstruct Handle_Info *temp;\n#ifdef UPNP_ENABLE_OPEN_SSL\n    if (gSslCtx) {\n        SSL_CTX_free(gSslCtx);\n        gSslCtx = NULL;\n    }\n#endif\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpFinish: UpnpSdkInit is %d\\n\", UpnpSdkInit);\n\tif (UpnpSdkInit == 1)\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"UpnpFinish: UpnpSdkInit is ONE\\n\");\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n#ifdef INCLUDE_DEVICE_APIS\n\tswitch (GetDeviceHandleInfo(AF_INET, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (GetDeviceHandleInfo(AF_INET6, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tswitch (GetClientHandleInfo(&client_handle, &temp)) {\n\tcase HND_CLIENT:\n\t\tUpnpUnRegisterClient(client_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\tTimerThreadShutdown(&gTimerThread);\n#if EXCLUDE_MINISERVER == 0\n\tStopMiniServer();\n#endif\n#if EXCLUDE_WEB_SERVER == 0\n\tweb_server_destroy();\n#endif\n\tThreadPoolShutdown(&gMiniServerThreadPool);\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n\tThreadPoolShutdown(&gRecvThreadPool);\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tThreadPoolShutdown(&gSendThreadPool);\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n#ifdef INCLUDE_CLIENT_APIS\n\tithread_mutex_destroy(&GlobalClientSubscribeMutex);\n#endif\n\tithread_rwlock_destroy(&GlobalHndRWLock);\n\tithread_mutex_destroy(&gUUIDMutex);\n\t/* remove all virtual dirs */\n\tUpnpRemoveAllVirtualDirs();\n\tUpnpSdkInit = 0;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpFinish: UpnpSdkInit is :%d:\\n\", UpnpSdkInit);\n\tUpnpCloseLog();\n\t/* Clean-up ithread library resources */\n\tithread_cleanup_library();\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimerThreadInit",
          "args": [
            "&gTimerThread",
            "&gSendThreadPool"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetGenaCallback",
          "args": [
            "genaCallback"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "SetGenaCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "112-115",
          "snippet": "void SetGenaCallback(MiniServerCallback callback)\n{\n\tgGenaCallback = callback;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nvoid SetGenaCallback(MiniServerCallback callback)\n{\n\tgGenaCallback = callback;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetSoapCallback",
          "args": [
            "soap_device_callback"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "SetSoapCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/miniserver.h",
          "lines": "102-102",
          "snippet": "static UPNP_INLINE void SetSoapCallback(MiniServerCallback callback) {}",
          "includes": [
            "#include \"UpnpStdInt.h\"",
            "#include \"httpparser.h\"",
            "#include \"sock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"UpnpStdInt.h\"\n#include \"httpparser.h\"\n#include \"sock.h\"\n\nstatic UPNP_INLINE void SetSoapCallback(MiniServerCallback callback) {}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpInitThreadPools",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpInitThreadPools",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "272-307",
          "snippet": "static int UpnpInitThreadPools(void)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tThreadPoolAttr attr;\n\n\tTPAttrInit(&attr);\n\tTPAttrSetMaxThreads(&attr, MAX_THREADS);\n\tTPAttrSetMinThreads(&attr, MIN_THREADS);\n\tTPAttrSetStackSize(&attr, THREAD_STACK_SIZE);\n\tTPAttrSetJobsPerThread(&attr, JOBS_PER_THREAD);\n\tTPAttrSetIdleTime(&attr, THREAD_IDLE_TIME);\n\tTPAttrSetMaxJobsTotal(&attr, MAX_JOBS_TOTAL);\n\n\tif (ThreadPoolInit(&gSendThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\n\tif (ThreadPoolInit(&gRecvThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\n\tif (ThreadPoolInit(&gMiniServerThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\nexit_function:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpSdkInit = 0;\n\t\tUpnpFinish();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ThreadPool gSendThreadPool;",
            "ThreadPool gRecvThreadPool;",
            "ThreadPool gMiniServerThreadPool;",
            "int UpnpSdkInit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nThreadPool gSendThreadPool;\nThreadPool gRecvThreadPool;\nThreadPool gMiniServerThreadPool;\nint UpnpSdkInit = 0;\n\nstatic int UpnpInitThreadPools(void)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tThreadPoolAttr attr;\n\n\tTPAttrInit(&attr);\n\tTPAttrSetMaxThreads(&attr, MAX_THREADS);\n\tTPAttrSetMinThreads(&attr, MIN_THREADS);\n\tTPAttrSetStackSize(&attr, THREAD_STACK_SIZE);\n\tTPAttrSetJobsPerThread(&attr, JOBS_PER_THREAD);\n\tTPAttrSetIdleTime(&attr, THREAD_IDLE_TIME);\n\tTPAttrSetMaxJobsTotal(&attr, MAX_JOBS_TOTAL);\n\n\tif (ThreadPoolInit(&gSendThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\n\tif (ThreadPoolInit(&gRecvThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\n\tif (ThreadPoolInit(&gMiniServerThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\nexit_function:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpSdkInit = 0;\n\t\tUpnpFinish();\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_unpack",
          "args": [
            "&nls_uuid",
            "gUpnpSdkNLSuuid"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "85-96",
          "snippet": "void uuid_unpack(uuid_upnp * u, char *out)\n{\n\tsprintf(out,\n\t\t\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\",\n\t\t(unsigned int)u->time_low,\n\t\tu->time_mid,\n\t\tu->time_hi_and_version,\n\t\tu->clock_seq_hi_and_reserved,\n\t\tu->clock_seq_low,\n\t\tu->node[0],\n\t\tu->node[1], u->node[2], u->node[3], u->node[4], u->node[5]);\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
            "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
            "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\n\nvoid uuid_unpack(uuid_upnp * u, char *out)\n{\n\tsprintf(out,\n\t\t\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\",\n\t\t(unsigned int)u->time_low,\n\t\tu->time_mid,\n\t\tu->time_hi_and_version,\n\t\tu->clock_seq_hi_and_reserved,\n\t\tu->clock_seq_low,\n\t\tu->node[0],\n\t\tu->node[1], u->node[2], u->node[3], u->node[4], u->node[5]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_create",
          "args": [
            "&nls_uuid"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "53-83",
          "snippet": "int uuid_create(uuid_upnp * uid)\n{\n\tuuid_time_t timestamp;\n\tuuid_time_t last_time;\n\tuint16_t clockseq;\n\tuuid_node_t node;\n\tuuid_node_t last_node;\n\tint f;\n\n\t/* acquire system wide lock so we're alone. */\n\tUUIDLock();\n\t/* get current time. */\n\tget_current_time(&timestamp);\n\t/* get node ID. */\n\tget_ieee_node_identifier(&node);\n\t/* get saved state from NV storage. */\n\tf = read_state(&clockseq, &last_time, &last_node);\n\t/* if no NV state, or if clock went backwards, or node ID changed\n\t * (e.g., net card swap) change clockseq. */\n\tif (!f || memcmp(&node, &last_node, sizeof(uuid_node_t)))\n\t\tclockseq = true_random();\n\telse if (timestamp < last_time)\n\t\tclockseq++;\n\t/* stuff fields into the UUID. */\n\tformat_uuid_v1(uid, clockseq, timestamp, node);\n\t/* save the state for next time. */\n\twrite_state(clockseq, timestamp, node);\n\tUUIDUnlock();\n\n\treturn 1;\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
            "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
            "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);",
            "static void get_current_time(uuid_time_t *timestamp);",
            "static uint16_t true_random(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\nstatic void get_current_time(uuid_time_t *timestamp);\nstatic uint16_t true_random(void);\n\nint uuid_create(uuid_upnp * uid)\n{\n\tuuid_time_t timestamp;\n\tuuid_time_t last_time;\n\tuint16_t clockseq;\n\tuuid_node_t node;\n\tuuid_node_t last_node;\n\tint f;\n\n\t/* acquire system wide lock so we're alone. */\n\tUUIDLock();\n\t/* get current time. */\n\tget_current_time(&timestamp);\n\t/* get node ID. */\n\tget_ieee_node_identifier(&node);\n\t/* get saved state from NV storage. */\n\tf = read_state(&clockseq, &last_time, &last_node);\n\t/* if no NV state, or if clock went backwards, or node ID changed\n\t * (e.g., net card swap) change clockseq. */\n\tif (!f || memcmp(&node, &last_node, sizeof(uuid_node_t)))\n\t\tclockseq = true_random();\n\telse if (timestamp < last_time)\n\t\tclockseq++;\n\t/* stuff fields into the UUID. */\n\tformat_uuid_v1(uid, clockseq, timestamp, node);\n\t/* save the state for next time. */\n\twrite_state(clockseq, timestamp, node);\n\tUUIDUnlock();\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpInitMutexes",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpInitMutexes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "242-263",
          "snippet": "static int UpnpInitMutexes(void)\n{\n#ifdef __CYGWIN__\n\t/* On Cygwin, pthread_mutex_init() fails without this memset. */\n\t/* TODO: Fix Cygwin so we don't need this memset(). */\n\tmemset(&GlobalHndRWLock, 0, sizeof(GlobalHndRWLock));\n#endif\n\tif (ithread_rwlock_init(&GlobalHndRWLock, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\n\tif (ithread_mutex_init(&gUUIDMutex, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\t/* initialize subscribe mutex. */\n#ifdef INCLUDE_CLIENT_APIS\n\tif (ithread_mutex_init(&GlobalClientSubscribeMutex, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ithread_rwlock_t GlobalHndRWLock;",
            "ithread_mutex_t gUUIDMutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nithread_rwlock_t GlobalHndRWLock;\nithread_mutex_t gUUIDMutex;\n\nstatic int UpnpInitMutexes(void)\n{\n#ifdef __CYGWIN__\n\t/* On Cygwin, pthread_mutex_init() fails without this memset. */\n\t/* TODO: Fix Cygwin so we don't need this memset(). */\n\tmemset(&GlobalHndRWLock, 0, sizeof(GlobalHndRWLock));\n#endif\n\tif (ithread_rwlock_init(&GlobalHndRWLock, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\n\tif (ithread_mutex_init(&gUUIDMutex, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\t/* initialize subscribe mutex. */\n#ifdef INCLUDE_CLIENT_APIS\n\tif (ithread_mutex_init(&GlobalClientSubscribeMutex, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Inside UpnpInitPreamble\\n\""
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpInitLog",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpInitLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "68-80",
          "snippet": "int UpnpInitLog(void)\n{\n\tithread_mutex_init(&GlobalDebugMutex, NULL);\n\tif (DEBUG_TARGET == 1) {\n\t\tif ((ErrFileHnd = fopen(errFileName, \"a\")) == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ((InfoFileHnd = fopen(infoFileName, \"a\")) == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nint UpnpInitLog(void)\n{\n\tithread_mutex_init(&GlobalDebugMutex, NULL);\n\tif (DEBUG_TARGET == 1) {\n\t\tif ((ErrFileHnd = fopen(errFileName, \"a\")) == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ((InfoFileHnd = fopen(infoFileName, \"a\")) == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srand",
          "args": [
            "(unsigned int)time(NULL)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "get_system_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/sysdep.c",
          "lines": "115-127",
          "snippet": "void get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpInet.h\"",
            "#include \"sysdep.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <string.h>\n#include \"UpnpInet.h\"\n#include \"sysdep.h\"\n#include \"config.h\"\n\nvoid get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WinsockInit",
          "args": [],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "WinsockInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "199-233",
          "snippet": "static int WinsockInit(void)\n{\n\tint retVal = UPNP_E_SUCCESS;\n#ifdef WIN32\n\tWORD wVersionRequested;\n\tWSADATA wsaData;\n\tint err;\n\n\twVersionRequested = MAKEWORD(2, 2);\n\terr = WSAStartup(wVersionRequested, &wsaData);\n\tif (err != 0) {\n\t\t/* Tell the user that we could not find a usable */\n\t\t/* WinSock DLL.                                  */\n\t\tretVal = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\t/* Confirm that the WinSock DLL supports 2.2.\n\t * Note that if the DLL supports versions greater\n\t * than 2.2 in addition to 2.2, it will still return\n\t * 2.2 in wVersion since that is the version we\n\t * requested. */\n\tif (LOBYTE(wsaData.wVersion) != 2 ||\n\t    HIBYTE(wsaData.wVersion) != 2) {\n\t\t/* Tell the user that we could not find a usable\n\t\t * WinSock DLL. */\n\t\tWSACleanup();\n\t\tretVal = UPNP_E_INIT_FAILED; \n\t\tgoto exit_function;\n\t}\n\t/* The WinSock DLL is acceptable. Proceed. */\nexit_function:\n#else\n#endif\n\treturn retVal;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic int WinsockInit(void)\n{\n\tint retVal = UPNP_E_SUCCESS;\n#ifdef WIN32\n\tWORD wVersionRequested;\n\tWSADATA wsaData;\n\tint err;\n\n\twVersionRequested = MAKEWORD(2, 2);\n\terr = WSAStartup(wVersionRequested, &wsaData);\n\tif (err != 0) {\n\t\t/* Tell the user that we could not find a usable */\n\t\t/* WinSock DLL.                                  */\n\t\tretVal = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\t/* Confirm that the WinSock DLL supports 2.2.\n\t * Note that if the DLL supports versions greater\n\t * than 2.2 in addition to 2.2, it will still return\n\t * 2.2 in wVersion since that is the version we\n\t * requested. */\n\tif (LOBYTE(wsaData.wVersion) != 2 ||\n\t    HIBYTE(wsaData.wVersion) != 2) {\n\t\t/* Tell the user that we could not find a usable\n\t\t * WinSock DLL. */\n\t\tWSACleanup();\n\t\tretVal = UPNP_E_INIT_FAILED; \n\t\tgoto exit_function;\n\t}\n\t/* The WinSock DLL is acceptable. Proceed. */\nexit_function:\n#else\n#endif\n\treturn retVal;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nTimerThread gTimerThread;\nThreadPool gSendThreadPool;\nstatic void *HandleTable[NUM_HANDLE];\n\nstatic int UpnpInitPreamble(void)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tint i;\n#ifdef UPNP_HAVE_OPTSSDP\n\tuuid_upnp nls_uuid;\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\tretVal = WinsockInit();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n\t/* needed by SSDP or other parts. */\n\tsrand((unsigned int)time(NULL));\n\n\t/* Initialize debug output. */\n\tretVal = UpnpInitLog();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\t/* UpnpInitLog does not return a valid UPNP_E_*. */\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__, \"Inside UpnpInitPreamble\\n\" );\n\n\t/* Initialize SDK global mutexes. */\n\tretVal = UpnpInitMutexes();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef UPNP_HAVE_OPTSSDP\n\t/* Create the NLS uuid. */\n\tuuid_create(&nls_uuid);\n\tuuid_unpack(&nls_uuid, gUpnpSdkNLSuuid);\n#endif /* UPNP_HAVE_OPTSSDP */\n\n\t/* Initializes the handle list. */\n\tHandleLock();\n\tfor (i = 0; i < NUM_HANDLE; ++i) {\n\t\tHandleTable[i] = NULL;\n\t}\n\tHandleUnlock();\n\n\t/* Initialize SDK global thread pools. */\n\tretVal = UpnpInitThreadPools();\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\treturn retVal;\n\t}\n\n#ifdef INCLUDE_DEVICE_APIS\n#if EXCLUDE_SOAP == 0\n\tSetSoapCallback(soap_device_callback);\n#endif\n#endif /* INCLUDE_DEVICE_APIS */\n\n#ifdef INTERNAL_WEB_SERVER\n#if EXCLUDE_GENA == 0\n\tSetGenaCallback(genaCallback);\n#endif\n#endif /* INTERNAL_WEB_SERVER */\n\n\t/* Initialize the SDK timer thread. */\n\tretVal = TimerThreadInit( &gTimerThread, &gSendThreadPool );\n\tif (retVal != UPNP_E_SUCCESS) {\n\t\tUpnpFinish();\n\n\t\treturn retVal;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpInitThreadPools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "272-307",
    "snippet": "static int UpnpInitThreadPools(void)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tThreadPoolAttr attr;\n\n\tTPAttrInit(&attr);\n\tTPAttrSetMaxThreads(&attr, MAX_THREADS);\n\tTPAttrSetMinThreads(&attr, MIN_THREADS);\n\tTPAttrSetStackSize(&attr, THREAD_STACK_SIZE);\n\tTPAttrSetJobsPerThread(&attr, JOBS_PER_THREAD);\n\tTPAttrSetIdleTime(&attr, THREAD_IDLE_TIME);\n\tTPAttrSetMaxJobsTotal(&attr, MAX_JOBS_TOTAL);\n\n\tif (ThreadPoolInit(&gSendThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\n\tif (ThreadPoolInit(&gRecvThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\n\tif (ThreadPoolInit(&gMiniServerThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\nexit_function:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpSdkInit = 0;\n\t\tUpnpFinish();\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ThreadPool gSendThreadPool;",
      "ThreadPool gRecvThreadPool;",
      "ThreadPool gMiniServerThreadPool;",
      "int UpnpSdkInit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpFinish",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "625-709",
          "snippet": "int UpnpFinish(void)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\tUpnpDevice_Handle device_handle;\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tUpnpClient_Handle client_handle;\n#endif\n\tstruct Handle_Info *temp;\n#ifdef UPNP_ENABLE_OPEN_SSL\n    if (gSslCtx) {\n        SSL_CTX_free(gSslCtx);\n        gSslCtx = NULL;\n    }\n#endif\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpFinish: UpnpSdkInit is %d\\n\", UpnpSdkInit);\n\tif (UpnpSdkInit == 1)\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"UpnpFinish: UpnpSdkInit is ONE\\n\");\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n#ifdef INCLUDE_DEVICE_APIS\n\tswitch (GetDeviceHandleInfo(AF_INET, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (GetDeviceHandleInfo(AF_INET6, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tswitch (GetClientHandleInfo(&client_handle, &temp)) {\n\tcase HND_CLIENT:\n\t\tUpnpUnRegisterClient(client_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\tTimerThreadShutdown(&gTimerThread);\n#if EXCLUDE_MINISERVER == 0\n\tStopMiniServer();\n#endif\n#if EXCLUDE_WEB_SERVER == 0\n\tweb_server_destroy();\n#endif\n\tThreadPoolShutdown(&gMiniServerThreadPool);\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n\tThreadPoolShutdown(&gRecvThreadPool);\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tThreadPoolShutdown(&gSendThreadPool);\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n#ifdef INCLUDE_CLIENT_APIS\n\tithread_mutex_destroy(&GlobalClientSubscribeMutex);\n#endif\n\tithread_rwlock_destroy(&GlobalHndRWLock);\n\tithread_mutex_destroy(&gUUIDMutex);\n\t/* remove all virtual dirs */\n\tUpnpRemoveAllVirtualDirs();\n\tUpnpSdkInit = 0;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpFinish: UpnpSdkInit is :%d:\\n\", UpnpSdkInit);\n\tUpnpCloseLog();\n\t/* Clean-up ithread library resources */\n\tithread_cleanup_library();\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ithread_rwlock_t GlobalHndRWLock;",
            "ithread_mutex_t gUUIDMutex;",
            "TimerThread gTimerThread;",
            "ThreadPool gSendThreadPool;",
            "ThreadPool gRecvThreadPool;",
            "ThreadPool gMiniServerThreadPool;",
            "int UpnpSdkInit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nithread_rwlock_t GlobalHndRWLock;\nithread_mutex_t gUUIDMutex;\nTimerThread gTimerThread;\nThreadPool gSendThreadPool;\nThreadPool gRecvThreadPool;\nThreadPool gMiniServerThreadPool;\nint UpnpSdkInit = 0;\n\nint UpnpFinish(void)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\tUpnpDevice_Handle device_handle;\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tUpnpClient_Handle client_handle;\n#endif\n\tstruct Handle_Info *temp;\n#ifdef UPNP_ENABLE_OPEN_SSL\n    if (gSslCtx) {\n        SSL_CTX_free(gSslCtx);\n        gSslCtx = NULL;\n    }\n#endif\n\tif (UpnpSdkInit != 1)\n\t\treturn UPNP_E_FINISH;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"Inside UpnpFinish: UpnpSdkInit is %d\\n\", UpnpSdkInit);\n\tif (UpnpSdkInit == 1)\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"UpnpFinish: UpnpSdkInit is ONE\\n\");\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n#ifdef INCLUDE_DEVICE_APIS\n\tswitch (GetDeviceHandleInfo(AF_INET, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (GetDeviceHandleInfo(AF_INET6, &device_handle, &temp)) {\n\tcase HND_DEVICE:\n\t\tUpnpUnRegisterRootDevice(device_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n#ifdef INCLUDE_CLIENT_APIS\n\tswitch (GetClientHandleInfo(&client_handle, &temp)) {\n\tcase HND_CLIENT:\n\t\tUpnpUnRegisterClient(client_handle);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\tTimerThreadShutdown(&gTimerThread);\n#if EXCLUDE_MINISERVER == 0\n\tStopMiniServer();\n#endif\n#if EXCLUDE_WEB_SERVER == 0\n\tweb_server_destroy();\n#endif\n\tThreadPoolShutdown(&gMiniServerThreadPool);\n\tPrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,\n\t\t\"MiniServer Thread Pool\");\n\tThreadPoolShutdown(&gRecvThreadPool);\n\tPrintThreadPoolStats(&gSendThreadPool, __FILE__, __LINE__,\n\t\t\"Send Thread Pool\");\n\tThreadPoolShutdown(&gSendThreadPool);\n\tPrintThreadPoolStats(&gRecvThreadPool, __FILE__, __LINE__,\n\t\t\"Recv Thread Pool\");\n#ifdef INCLUDE_CLIENT_APIS\n\tithread_mutex_destroy(&GlobalClientSubscribeMutex);\n#endif\n\tithread_rwlock_destroy(&GlobalHndRWLock);\n\tithread_mutex_destroy(&gUUIDMutex);\n\t/* remove all virtual dirs */\n\tUpnpRemoveAllVirtualDirs();\n\tUpnpSdkInit = 0;\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"Exiting UpnpFinish: UpnpSdkInit is :%d:\\n\", UpnpSdkInit);\n\tUpnpCloseLog();\n\t/* Clean-up ithread library resources */\n\tithread_cleanup_library();\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolInit",
          "args": [
            "&gMiniServerThreadPool",
            "&attr"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ThreadPoolInit",
          "args": [
            "&gRecvThreadPool",
            "&attr"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ThreadPoolInit",
          "args": [
            "&gSendThreadPool",
            "&attr"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPAttrSetMaxJobsTotal",
          "args": [
            "&attr",
            "MAX_JOBS_TOTAL"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPAttrSetIdleTime",
          "args": [
            "&attr",
            "THREAD_IDLE_TIME"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPAttrSetJobsPerThread",
          "args": [
            "&attr",
            "JOBS_PER_THREAD"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPAttrSetStackSize",
          "args": [
            "&attr",
            "THREAD_STACK_SIZE"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPAttrSetMinThreads",
          "args": [
            "&attr",
            "MIN_THREADS"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPAttrSetMaxThreads",
          "args": [
            "&attr",
            "MAX_THREADS"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPAttrInit",
          "args": [
            "&attr"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nThreadPool gSendThreadPool;\nThreadPool gRecvThreadPool;\nThreadPool gMiniServerThreadPool;\nint UpnpSdkInit = 0;\n\nstatic int UpnpInitThreadPools(void)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tThreadPoolAttr attr;\n\n\tTPAttrInit(&attr);\n\tTPAttrSetMaxThreads(&attr, MAX_THREADS);\n\tTPAttrSetMinThreads(&attr, MIN_THREADS);\n\tTPAttrSetStackSize(&attr, THREAD_STACK_SIZE);\n\tTPAttrSetJobsPerThread(&attr, JOBS_PER_THREAD);\n\tTPAttrSetIdleTime(&attr, THREAD_IDLE_TIME);\n\tTPAttrSetMaxJobsTotal(&attr, MAX_JOBS_TOTAL);\n\n\tif (ThreadPoolInit(&gSendThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\n\tif (ThreadPoolInit(&gRecvThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\n\tif (ThreadPoolInit(&gMiniServerThreadPool, &attr) != UPNP_E_SUCCESS) {\n\t\tret = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\nexit_function:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpSdkInit = 0;\n\t\tUpnpFinish();\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "UpnpInitMutexes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "242-263",
    "snippet": "static int UpnpInitMutexes(void)\n{\n#ifdef __CYGWIN__\n\t/* On Cygwin, pthread_mutex_init() fails without this memset. */\n\t/* TODO: Fix Cygwin so we don't need this memset(). */\n\tmemset(&GlobalHndRWLock, 0, sizeof(GlobalHndRWLock));\n#endif\n\tif (ithread_rwlock_init(&GlobalHndRWLock, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\n\tif (ithread_mutex_init(&gUUIDMutex, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\t/* initialize subscribe mutex. */\n#ifdef INCLUDE_CLIENT_APIS\n\tif (ithread_mutex_init(&GlobalClientSubscribeMutex, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ithread_rwlock_t GlobalHndRWLock;",
      "ithread_mutex_t gUUIDMutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ithread_mutex_init",
          "args": [
            "&GlobalClientSubscribeMutex",
            "NULL"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ithread_mutex_init",
          "args": [
            "&gUUIDMutex",
            "NULL"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ithread_rwlock_init",
          "args": [
            "&GlobalHndRWLock",
            "NULL"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&GlobalHndRWLock",
            "0",
            "sizeof(GlobalHndRWLock)"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nithread_rwlock_t GlobalHndRWLock;\nithread_mutex_t gUUIDMutex;\n\nstatic int UpnpInitMutexes(void)\n{\n#ifdef __CYGWIN__\n\t/* On Cygwin, pthread_mutex_init() fails without this memset. */\n\t/* TODO: Fix Cygwin so we don't need this memset(). */\n\tmemset(&GlobalHndRWLock, 0, sizeof(GlobalHndRWLock));\n#endif\n\tif (ithread_rwlock_init(&GlobalHndRWLock, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\n\tif (ithread_mutex_init(&gUUIDMutex, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n\t/* initialize subscribe mutex. */\n#ifdef INCLUDE_CLIENT_APIS\n\tif (ithread_mutex_init(&GlobalClientSubscribeMutex, NULL) != 0) {\n\t\treturn UPNP_E_INIT_FAILED;\n\t}\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "WinsockInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
    "lines": "199-233",
    "snippet": "static int WinsockInit(void)\n{\n\tint retVal = UPNP_E_SUCCESS;\n#ifdef WIN32\n\tWORD wVersionRequested;\n\tWSADATA wsaData;\n\tint err;\n\n\twVersionRequested = MAKEWORD(2, 2);\n\terr = WSAStartup(wVersionRequested, &wsaData);\n\tif (err != 0) {\n\t\t/* Tell the user that we could not find a usable */\n\t\t/* WinSock DLL.                                  */\n\t\tretVal = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\t/* Confirm that the WinSock DLL supports 2.2.\n\t * Note that if the DLL supports versions greater\n\t * than 2.2 in addition to 2.2, it will still return\n\t * 2.2 in wVersion since that is the version we\n\t * requested. */\n\tif (LOBYTE(wsaData.wVersion) != 2 ||\n\t    HIBYTE(wsaData.wVersion) != 2) {\n\t\t/* Tell the user that we could not find a usable\n\t\t * WinSock DLL. */\n\t\tWSACleanup();\n\t\tretVal = UPNP_E_INIT_FAILED; \n\t\tgoto exit_function;\n\t}\n\t/* The WinSock DLL is acceptable. Proceed. */\nexit_function:\n#else\n#endif\n\treturn retVal;\n}",
    "includes": [
      "#include <openssl/ssl.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <assert.h>",
      "#include <sys/stat.h>",
      "#include \"webserver.h\"",
      "#include \"VirtualDir.h\"",
      "#include \"urlconfig.h\"",
      "#include \"service_table.h\"",
      "#include \"miniserver.h\"",
      "#include \"gena.h\"",
      "#include \"uuid.h\"",
      "#include \"UpnpUniStd.h\" /* for close() */",
      "#include \"UpnpStdInt.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sysdep.h\"",
      "#include \"soaplib.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"upnpapi.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WSACleanup",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HIBYTE",
          "args": [
            "wsaData.wVersion"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOBYTE",
          "args": [
            "wsaData.wVersion"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAStartup",
          "args": [
            "wVersionRequested",
            "&wsaData"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKEWORD",
          "args": [
            "2",
            "2"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nstatic int WinsockInit(void)\n{\n\tint retVal = UPNP_E_SUCCESS;\n#ifdef WIN32\n\tWORD wVersionRequested;\n\tWSADATA wsaData;\n\tint err;\n\n\twVersionRequested = MAKEWORD(2, 2);\n\terr = WSAStartup(wVersionRequested, &wsaData);\n\tif (err != 0) {\n\t\t/* Tell the user that we could not find a usable */\n\t\t/* WinSock DLL.                                  */\n\t\tretVal = UPNP_E_INIT_FAILED;\n\t\tgoto exit_function;\n\t}\n\t/* Confirm that the WinSock DLL supports 2.2.\n\t * Note that if the DLL supports versions greater\n\t * than 2.2 in addition to 2.2, it will still return\n\t * 2.2 in wVersion since that is the version we\n\t * requested. */\n\tif (LOBYTE(wsaData.wVersion) != 2 ||\n\t    HIBYTE(wsaData.wVersion) != 2) {\n\t\t/* Tell the user that we could not find a usable\n\t\t * WinSock DLL. */\n\t\tWSACleanup();\n\t\tretVal = UPNP_E_INIT_FAILED; \n\t\tgoto exit_function;\n\t}\n\t/* The WinSock DLL is acceptable. Proceed. */\nexit_function:\n#else\n#endif\n\treturn retVal;\n}"
  }
]