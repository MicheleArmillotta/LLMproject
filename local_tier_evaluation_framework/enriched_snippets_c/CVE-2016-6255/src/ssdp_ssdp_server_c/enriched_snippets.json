[
  {
    "function_name": "get_ssdp_sockets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "1168-1240",
    "snippet": "int get_ssdp_sockets(MiniServerSockArray * out)\n{\n\tint retVal;\n\n#ifdef INCLUDE_CLIENT_APIS\n\tout->ssdpReqSock4 = INVALID_SOCKET;\n\tout->ssdpReqSock6 = INVALID_SOCKET;\n\t/* Create the IPv4 socket for SSDP REQUESTS */\n\tif (strlen(gIF_IPV4) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_reqv4(&out->ssdpReqSock4);\n\t\tif (retVal != UPNP_E_SUCCESS)\n\t\t\treturn retVal;\n\t\t/* For use by ssdp control point. */\n\t\tgSsdpReqSocket4 = out->ssdpReqSock4;\n\t} else\n\t\tout->ssdpReqSock4 = INVALID_SOCKET;\n\t/* Create the IPv6 socket for SSDP REQUESTS */\n#ifdef UPNP_ENABLE_IPV6\n\tif (strlen(gIF_IPV6) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_reqv6(&out->ssdpReqSock6);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\treturn retVal;\n\t\t}\n\t\t/* For use by ssdp control point. */\n\t\tgSsdpReqSocket6 = out->ssdpReqSock6;\n\t} else\n\t\tout->ssdpReqSock6 = INVALID_SOCKET;\n#endif /* IPv6 */\n#endif /* INCLUDE_CLIENT_APIS */\n\t/* Create the IPv4 socket for SSDP */\n\tif (strlen(gIF_IPV4) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v4(&out->ssdpSock4);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock4 = INVALID_SOCKET;\n\t/* Create the IPv6 socket for SSDP */\n#ifdef UPNP_ENABLE_IPV6\n\tif (strlen(gIF_IPV6) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v6(&out->ssdpSock6);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpSock4);\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock6 = INVALID_SOCKET;\n\tif (strlen(gIF_IPV6_ULA_GUA) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v6_ula_gua(&out->ssdpSock6UlaGua);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpSock4);\n\t\t\tUpnpCloseSocket(out->ssdpSock6);\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock6UlaGua = INVALID_SOCKET;\n#endif /* UPNP_ENABLE_IPV6 */\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "out->ssdpReqSock6"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "out->ssdpReqSock4"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "out->ssdpSock6"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "out->ssdpSock4"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_ssdp_sock_v6_ula_gua",
          "args": [
            "&out->ssdpSock6UlaGua"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "create_ssdp_sock_v6_ula_gua",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "1032-1134",
          "snippet": "static int create_ssdp_sock_v6_ula_gua(\n\t/*! [] SSDP IPv6 socket to be created. */\n\tSOCKET * ssdpSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct ipv6_mreq ssdpMcastAddr;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in6 *ssdpAddr6 = (struct sockaddr_in6 *)&__ss;\n\tint onOff;\n\tint ret = 0;\n\n\t*ssdpSock = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (*ssdpSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEADDR: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#if (defined(BSD) && !defined(__GNU__)) || defined(__OSX__) || defined(__APPLE__)\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEPORT: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#endif /* BSD, __OSX__, __APPLE__ */\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t(char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_V6ONLY: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tmemset(&__ss, 0, sizeof(__ss));\n\tssdpAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tssdpAddr6->sin6_addr = in6addr_any;\n\tssdpAddr6->sin6_scope_id = gIF_INDEX;\n\tssdpAddr6->sin6_port = htons(SSDP_PORT);\n\tret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr6, sizeof(*ssdpAddr6));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in bind(), addr=0x%032lX, port=%d: %s\\n\",\n\t\t\t   0lu, SSDP_PORT, errorBuffer);\n\t\tret = UPNP_E_SOCKET_BIND;\n\t\tgoto error_handler;\n\t}\n\tmemset((void *)&ssdpMcastAddr, 0, sizeof(ssdpMcastAddr));\n\tssdpMcastAddr.ipv6mr_interface = gIF_INDEX;\n\t/* SITE LOCAL */\n\tinet_pton(AF_INET6, SSDP_IPV6_SITELOCAL,\n\t\t  &ssdpMcastAddr.ipv6mr_multiaddr);\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_JOIN_GROUP,\n\t\t\t(char *)&ssdpMcastAddr, sizeof(ssdpMcastAddr));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_JOIN_GROUP (join multicast group): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_NETWORK_ERROR;\n\t\tgoto error_handler;\n\t}\n\tret = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpCloseSocket(*ssdpSock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic int create_ssdp_sock_v6_ula_gua(\n\t/*! [] SSDP IPv6 socket to be created. */\n\tSOCKET * ssdpSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct ipv6_mreq ssdpMcastAddr;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in6 *ssdpAddr6 = (struct sockaddr_in6 *)&__ss;\n\tint onOff;\n\tint ret = 0;\n\n\t*ssdpSock = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (*ssdpSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEADDR: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#if (defined(BSD) && !defined(__GNU__)) || defined(__OSX__) || defined(__APPLE__)\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEPORT: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#endif /* BSD, __OSX__, __APPLE__ */\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t(char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_V6ONLY: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tmemset(&__ss, 0, sizeof(__ss));\n\tssdpAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tssdpAddr6->sin6_addr = in6addr_any;\n\tssdpAddr6->sin6_scope_id = gIF_INDEX;\n\tssdpAddr6->sin6_port = htons(SSDP_PORT);\n\tret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr6, sizeof(*ssdpAddr6));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in bind(), addr=0x%032lX, port=%d: %s\\n\",\n\t\t\t   0lu, SSDP_PORT, errorBuffer);\n\t\tret = UPNP_E_SOCKET_BIND;\n\t\tgoto error_handler;\n\t}\n\tmemset((void *)&ssdpMcastAddr, 0, sizeof(ssdpMcastAddr));\n\tssdpMcastAddr.ipv6mr_interface = gIF_INDEX;\n\t/* SITE LOCAL */\n\tinet_pton(AF_INET6, SSDP_IPV6_SITELOCAL,\n\t\t  &ssdpMcastAddr.ipv6mr_multiaddr);\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_JOIN_GROUP,\n\t\t\t(char *)&ssdpMcastAddr, sizeof(ssdpMcastAddr));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_JOIN_GROUP (join multicast group): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_NETWORK_ERROR;\n\t\tgoto error_handler;\n\t}\n\tret = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpCloseSocket(*ssdpSock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gIF_IPV6_ULA_GUA"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "out->ssdpReqSock6"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "out->ssdpReqSock4"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "out->ssdpSock4"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gIF_IPV6"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "out->ssdpReqSock6"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "out->ssdpReqSock4"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_ssdp_sock_v4",
          "args": [
            "&out->ssdpSock4"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "create_ssdp_sock_v4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "785-890",
          "snippet": "static int create_ssdp_sock_v4(\n\t/*! [] SSDP IPv4 socket to be created. */\n\tSOCKET *ssdpSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tint onOff;\n\tu_char ttl = (u_char)4;\n\tstruct ip_mreq ssdpMcastAddr;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *ssdpAddr4 = (struct sockaddr_in *)&__ss;\n\tint ret = 0;\n\tstruct in_addr addr;\n\n\t*ssdpSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (*ssdpSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEADDR: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#if (defined(BSD) && !defined(__GNU__)) || defined(__OSX__) || defined(__APPLE__)\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEPORT: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#endif /* BSD, __OSX__, __APPLE__ */\n\tmemset(&__ss, 0, sizeof(__ss));\n\tssdpAddr4->sin_family = (sa_family_t)AF_INET;\n\tssdpAddr4->sin_addr.s_addr = htonl(INADDR_ANY);\n\tssdpAddr4->sin_port = htons(SSDP_PORT);\n\tret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr4, sizeof(*ssdpAddr4));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in bind(), addr=0x%08X, port=%d: %s\\n\",\n\t\t\t   INADDR_ANY, SSDP_PORT, errorBuffer);\n\t\tret = UPNP_E_SOCKET_BIND;\n\t\tgoto error_handler;\n\t}\n\tmemset((void *)&ssdpMcastAddr, 0, sizeof(struct ip_mreq));\n\tssdpMcastAddr.imr_interface.s_addr = inet_addr(gIF_IPV4);\n\tssdpMcastAddr.imr_multiaddr.s_addr = inet_addr(SSDP_IP);\n\tret = setsockopt(*ssdpSock, IPPROTO_IP, IP_ADD_MEMBERSHIP,\n\t\t\t (char *)&ssdpMcastAddr, sizeof(struct ip_mreq));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IP_ADD_MEMBERSHIP (join multicast group): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\t/* Set multicast interface. */\n\tmemset((void *)&addr, 0, sizeof(struct in_addr));\n\taddr.s_addr = inet_addr(gIF_IPV4);\n\tret = setsockopt(*ssdpSock, IPPROTO_IP, IP_MULTICAST_IF,\n\t\t\t (char *)&addr, sizeof addr);\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IP_MULTICAST_IF (set multicast interface): %s\\n\",\n\t\t\t   errorBuffer);\n\t\t/* This is probably not a critical error, so let's continue. */\n\t}\n\t/* result is not checked becuase it will fail in WinMe and Win9x. */\n\tsetsockopt(*ssdpSock, IPPROTO_IP,\n\t\tIP_MULTICAST_TTL, &ttl, sizeof(ttl));\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_NETWORK_ERROR;\n\t\tgoto error_handler;\n\t}\n\tret = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (ret != UPNP_E_SUCCESS) {\n                UpnpCloseSocket(*ssdpSock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic int create_ssdp_sock_v4(\n\t/*! [] SSDP IPv4 socket to be created. */\n\tSOCKET *ssdpSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tint onOff;\n\tu_char ttl = (u_char)4;\n\tstruct ip_mreq ssdpMcastAddr;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *ssdpAddr4 = (struct sockaddr_in *)&__ss;\n\tint ret = 0;\n\tstruct in_addr addr;\n\n\t*ssdpSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (*ssdpSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEADDR: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#if (defined(BSD) && !defined(__GNU__)) || defined(__OSX__) || defined(__APPLE__)\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEPORT: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#endif /* BSD, __OSX__, __APPLE__ */\n\tmemset(&__ss, 0, sizeof(__ss));\n\tssdpAddr4->sin_family = (sa_family_t)AF_INET;\n\tssdpAddr4->sin_addr.s_addr = htonl(INADDR_ANY);\n\tssdpAddr4->sin_port = htons(SSDP_PORT);\n\tret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr4, sizeof(*ssdpAddr4));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in bind(), addr=0x%08X, port=%d: %s\\n\",\n\t\t\t   INADDR_ANY, SSDP_PORT, errorBuffer);\n\t\tret = UPNP_E_SOCKET_BIND;\n\t\tgoto error_handler;\n\t}\n\tmemset((void *)&ssdpMcastAddr, 0, sizeof(struct ip_mreq));\n\tssdpMcastAddr.imr_interface.s_addr = inet_addr(gIF_IPV4);\n\tssdpMcastAddr.imr_multiaddr.s_addr = inet_addr(SSDP_IP);\n\tret = setsockopt(*ssdpSock, IPPROTO_IP, IP_ADD_MEMBERSHIP,\n\t\t\t (char *)&ssdpMcastAddr, sizeof(struct ip_mreq));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IP_ADD_MEMBERSHIP (join multicast group): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\t/* Set multicast interface. */\n\tmemset((void *)&addr, 0, sizeof(struct in_addr));\n\taddr.s_addr = inet_addr(gIF_IPV4);\n\tret = setsockopt(*ssdpSock, IPPROTO_IP, IP_MULTICAST_IF,\n\t\t\t (char *)&addr, sizeof addr);\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IP_MULTICAST_IF (set multicast interface): %s\\n\",\n\t\t\t   errorBuffer);\n\t\t/* This is probably not a critical error, so let's continue. */\n\t}\n\t/* result is not checked becuase it will fail in WinMe and Win9x. */\n\tsetsockopt(*ssdpSock, IPPROTO_IP,\n\t\tIP_MULTICAST_TTL, &ttl, sizeof(ttl));\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_NETWORK_ERROR;\n\t\tgoto error_handler;\n\t}\n\tret = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (ret != UPNP_E_SUCCESS) {\n                UpnpCloseSocket(*ssdpSock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gIF_IPV4"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "out->ssdpReqSock4"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_ssdp_sock_reqv6",
          "args": [
            "&out->ssdpReqSock6"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "create_ssdp_sock_reqv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "1141-1164",
          "snippet": "static int create_ssdp_sock_reqv6(\n\t/* [out] SSDP IPv6 request socket to be created. */\n\tSOCKET *ssdpReqSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tchar hops = 1;\n\n\t*ssdpReqSock = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (*ssdpReqSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* MUST use scoping of IPv6 addresses to control the propagation os SSDP\n\t * messages instead of relying on the Hop Limit (Equivalent to the TTL\n\t * limit in IPv4). */\n\tsetsockopt(*ssdpReqSock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n\t\t   &hops, sizeof(hops));\n\t/* just do it, regardless if fails or not. */\n\tsock_make_no_blocking(*ssdpReqSock);\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic int create_ssdp_sock_reqv6(\n\t/* [out] SSDP IPv6 request socket to be created. */\n\tSOCKET *ssdpReqSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tchar hops = 1;\n\n\t*ssdpReqSock = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (*ssdpReqSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* MUST use scoping of IPv6 addresses to control the propagation os SSDP\n\t * messages instead of relying on the Hop Limit (Equivalent to the TTL\n\t * limit in IPv4). */\n\tsetsockopt(*ssdpReqSock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n\t\t   &hops, sizeof(hops));\n\t/* just do it, regardless if fails or not. */\n\tsock_make_no_blocking(*ssdpReqSock);\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gIF_IPV6"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_ssdp_sock_reqv4",
          "args": [
            "&out->ssdpReqSock4"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "create_ssdp_sock_reqv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "898-918",
          "snippet": "static int create_ssdp_sock_reqv4(\n\t/*! [out] SSDP IPv4 request socket to be created. */\n\tSOCKET *ssdpReqSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tu_char ttl = 4;\n\n\t*ssdpReqSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (*ssdpReqSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tsetsockopt(*ssdpReqSock, IPPROTO_IP, IP_MULTICAST_TTL,\n\t\t   &ttl, sizeof(ttl));\n\t/* just do it, regardless if fails or not. */\n\tsock_make_no_blocking(*ssdpReqSock);\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic int create_ssdp_sock_reqv4(\n\t/*! [out] SSDP IPv4 request socket to be created. */\n\tSOCKET *ssdpReqSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tu_char ttl = 4;\n\n\t*ssdpReqSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (*ssdpReqSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tsetsockopt(*ssdpReqSock, IPPROTO_IP, IP_MULTICAST_TTL,\n\t\t   &ttl, sizeof(ttl));\n\t/* just do it, regardless if fails or not. */\n\tsock_make_no_blocking(*ssdpReqSock);\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gIF_IPV4"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nint get_ssdp_sockets(MiniServerSockArray * out)\n{\n\tint retVal;\n\n#ifdef INCLUDE_CLIENT_APIS\n\tout->ssdpReqSock4 = INVALID_SOCKET;\n\tout->ssdpReqSock6 = INVALID_SOCKET;\n\t/* Create the IPv4 socket for SSDP REQUESTS */\n\tif (strlen(gIF_IPV4) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_reqv4(&out->ssdpReqSock4);\n\t\tif (retVal != UPNP_E_SUCCESS)\n\t\t\treturn retVal;\n\t\t/* For use by ssdp control point. */\n\t\tgSsdpReqSocket4 = out->ssdpReqSock4;\n\t} else\n\t\tout->ssdpReqSock4 = INVALID_SOCKET;\n\t/* Create the IPv6 socket for SSDP REQUESTS */\n#ifdef UPNP_ENABLE_IPV6\n\tif (strlen(gIF_IPV6) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_reqv6(&out->ssdpReqSock6);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\treturn retVal;\n\t\t}\n\t\t/* For use by ssdp control point. */\n\t\tgSsdpReqSocket6 = out->ssdpReqSock6;\n\t} else\n\t\tout->ssdpReqSock6 = INVALID_SOCKET;\n#endif /* IPv6 */\n#endif /* INCLUDE_CLIENT_APIS */\n\t/* Create the IPv4 socket for SSDP */\n\tif (strlen(gIF_IPV4) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v4(&out->ssdpSock4);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock4 = INVALID_SOCKET;\n\t/* Create the IPv6 socket for SSDP */\n#ifdef UPNP_ENABLE_IPV6\n\tif (strlen(gIF_IPV6) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v6(&out->ssdpSock6);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpSock4);\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock6 = INVALID_SOCKET;\n\tif (strlen(gIF_IPV6_ULA_GUA) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v6_ula_gua(&out->ssdpSock6UlaGua);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpSock4);\n\t\t\tUpnpCloseSocket(out->ssdpSock6);\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock6UlaGua = INVALID_SOCKET;\n#endif /* UPNP_ENABLE_IPV6 */\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "create_ssdp_sock_reqv6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "1141-1164",
    "snippet": "static int create_ssdp_sock_reqv6(\n\t/* [out] SSDP IPv6 request socket to be created. */\n\tSOCKET *ssdpReqSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tchar hops = 1;\n\n\t*ssdpReqSock = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (*ssdpReqSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* MUST use scoping of IPv6 addresses to control the propagation os SSDP\n\t * messages instead of relying on the Hop Limit (Equivalent to the TTL\n\t * limit in IPv4). */\n\tsetsockopt(*ssdpReqSock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n\t\t   &hops, sizeof(hops));\n\t/* just do it, regardless if fails or not. */\n\tsock_make_no_blocking(*ssdpReqSock);\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_make_no_blocking",
          "args": [
            "*ssdpReqSock"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "sock_make_no_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "294-308",
          "snippet": "int sock_make_no_blocking(SOCKET sock)\n{\n#ifdef WIN32\n\tu_long val = 1;\n\treturn ioctlsocket(sock, FIONBIO, &val);\n#else /* WIN32 */\n\tint val;\n\n\tval = fcntl(sock, F_GETFL, 0);\n\tif (fcntl(sock, F_SETFL, val | O_NONBLOCK) == -1) {\n\t\treturn -1;\n\t}\n#endif /* WIN32 */\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_make_no_blocking(SOCKET sock)\n{\n#ifdef WIN32\n\tu_long val = 1;\n\treturn ioctlsocket(sock, FIONBIO, &val);\n#else /* WIN32 */\n\tint val;\n\n\tval = fcntl(sock, F_GETFL, 0);\n\tif (fcntl(sock, F_SETFL, val | O_NONBLOCK) == -1) {\n\t\treturn -1;\n\t}\n#endif /* WIN32 */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpReqSock",
            "IPPROTO_IPV6",
            "IPV6_MULTICAST_HOPS",
            "&hops",
            "sizeof(hops)"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_CRITICAL",
            "SSDP",
            "__FILE__",
            "__LINE__",
            "\"Error in socket(): %s\\n\"",
            "errorBuffer"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET6",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic int create_ssdp_sock_reqv6(\n\t/* [out] SSDP IPv6 request socket to be created. */\n\tSOCKET *ssdpReqSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tchar hops = 1;\n\n\t*ssdpReqSock = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (*ssdpReqSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* MUST use scoping of IPv6 addresses to control the propagation os SSDP\n\t * messages instead of relying on the Hop Limit (Equivalent to the TTL\n\t * limit in IPv4). */\n\tsetsockopt(*ssdpReqSock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n\t\t   &hops, sizeof(hops));\n\t/* just do it, regardless if fails or not. */\n\tsock_make_no_blocking(*ssdpReqSock);\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "create_ssdp_sock_v6_ula_gua",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "1032-1134",
    "snippet": "static int create_ssdp_sock_v6_ula_gua(\n\t/*! [] SSDP IPv6 socket to be created. */\n\tSOCKET * ssdpSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct ipv6_mreq ssdpMcastAddr;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in6 *ssdpAddr6 = (struct sockaddr_in6 *)&__ss;\n\tint onOff;\n\tint ret = 0;\n\n\t*ssdpSock = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (*ssdpSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEADDR: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#if (defined(BSD) && !defined(__GNU__)) || defined(__OSX__) || defined(__APPLE__)\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEPORT: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#endif /* BSD, __OSX__, __APPLE__ */\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t(char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_V6ONLY: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tmemset(&__ss, 0, sizeof(__ss));\n\tssdpAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tssdpAddr6->sin6_addr = in6addr_any;\n\tssdpAddr6->sin6_scope_id = gIF_INDEX;\n\tssdpAddr6->sin6_port = htons(SSDP_PORT);\n\tret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr6, sizeof(*ssdpAddr6));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in bind(), addr=0x%032lX, port=%d: %s\\n\",\n\t\t\t   0lu, SSDP_PORT, errorBuffer);\n\t\tret = UPNP_E_SOCKET_BIND;\n\t\tgoto error_handler;\n\t}\n\tmemset((void *)&ssdpMcastAddr, 0, sizeof(ssdpMcastAddr));\n\tssdpMcastAddr.ipv6mr_interface = gIF_INDEX;\n\t/* SITE LOCAL */\n\tinet_pton(AF_INET6, SSDP_IPV6_SITELOCAL,\n\t\t  &ssdpMcastAddr.ipv6mr_multiaddr);\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_JOIN_GROUP,\n\t\t\t(char *)&ssdpMcastAddr, sizeof(ssdpMcastAddr));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_JOIN_GROUP (join multicast group): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_NETWORK_ERROR;\n\t\tgoto error_handler;\n\t}\n\tret = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpCloseSocket(*ssdpSock);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "*ssdpSock"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_CRITICAL",
            "SSDP",
            "__FILE__",
            "__LINE__",
            "\"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\"",
            "errorBuffer"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "SOL_SOCKET",
            "SO_BROADCAST",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "IPPROTO_IPV6",
            "IPV6_JOIN_GROUP",
            "(char *)&ssdpMcastAddr",
            "sizeof(ssdpMcastAddr)"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET6",
            "SSDP_IPV6_SITELOCAL",
            "&ssdpMcastAddr.ipv6mr_multiaddr"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "inet_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "307-321",
          "snippet": "int inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nint inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)&ssdpMcastAddr",
            "0",
            "sizeof(ssdpMcastAddr)"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "*ssdpSock",
            "(struct sockaddr *)ssdpAddr6",
            "sizeof(*ssdpAddr6)"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "SSDP_PORT"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "IPPROTO_IPV6",
            "IPV6_V6ONLY",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "SOL_SOCKET",
            "SO_REUSEPORT",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET6",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic int create_ssdp_sock_v6_ula_gua(\n\t/*! [] SSDP IPv6 socket to be created. */\n\tSOCKET * ssdpSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct ipv6_mreq ssdpMcastAddr;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in6 *ssdpAddr6 = (struct sockaddr_in6 *)&__ss;\n\tint onOff;\n\tint ret = 0;\n\n\t*ssdpSock = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (*ssdpSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEADDR: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#if (defined(BSD) && !defined(__GNU__)) || defined(__OSX__) || defined(__APPLE__)\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEPORT: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#endif /* BSD, __OSX__, __APPLE__ */\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t(char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_V6ONLY: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tmemset(&__ss, 0, sizeof(__ss));\n\tssdpAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tssdpAddr6->sin6_addr = in6addr_any;\n\tssdpAddr6->sin6_scope_id = gIF_INDEX;\n\tssdpAddr6->sin6_port = htons(SSDP_PORT);\n\tret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr6, sizeof(*ssdpAddr6));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in bind(), addr=0x%032lX, port=%d: %s\\n\",\n\t\t\t   0lu, SSDP_PORT, errorBuffer);\n\t\tret = UPNP_E_SOCKET_BIND;\n\t\tgoto error_handler;\n\t}\n\tmemset((void *)&ssdpMcastAddr, 0, sizeof(ssdpMcastAddr));\n\tssdpMcastAddr.ipv6mr_interface = gIF_INDEX;\n\t/* SITE LOCAL */\n\tinet_pton(AF_INET6, SSDP_IPV6_SITELOCAL,\n\t\t  &ssdpMcastAddr.ipv6mr_multiaddr);\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_JOIN_GROUP,\n\t\t\t(char *)&ssdpMcastAddr, sizeof(ssdpMcastAddr));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_JOIN_GROUP (join multicast group): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_NETWORK_ERROR;\n\t\tgoto error_handler;\n\t}\n\tret = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpCloseSocket(*ssdpSock);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "create_ssdp_sock_v6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "924-1025",
    "snippet": "static int create_ssdp_sock_v6(\n\t/* [] SSDP IPv6 socket to be created. */\n\tSOCKET *ssdpSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct ipv6_mreq ssdpMcastAddr;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in6 *ssdpAddr6 = (struct sockaddr_in6 *)&__ss;\n\tint onOff;\n\tint ret = 0;\n\n\t*ssdpSock = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (*ssdpSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEADDR: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#if (defined(BSD) && !defined(__GNU__)) || defined(__OSX__) || defined(__APPLE__)\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEPORT: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#endif /* BSD, __OSX__, __APPLE__ */\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_V6ONLY: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tmemset(&__ss, 0, sizeof(__ss));\n\tssdpAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tssdpAddr6->sin6_addr = in6addr_any;\n\tssdpAddr6->sin6_scope_id = gIF_INDEX;\n\tssdpAddr6->sin6_port = htons(SSDP_PORT);\n\tret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr6, sizeof(*ssdpAddr6));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in bind(), addr=0x%032lX, port=%d: %s\\n\",\n\t\t\t   0lu, SSDP_PORT, errorBuffer);\n\t\tret = UPNP_E_SOCKET_BIND;\n\t\tgoto error_handler;\n\t}\n\tmemset((void *)&ssdpMcastAddr, 0, sizeof(ssdpMcastAddr));\n\tssdpMcastAddr.ipv6mr_interface = gIF_INDEX;\n\tinet_pton(AF_INET6, SSDP_IPV6_LINKLOCAL,\n\t\t  &ssdpMcastAddr.ipv6mr_multiaddr);\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_JOIN_GROUP,\n\t\t\t(char *)&ssdpMcastAddr, sizeof(ssdpMcastAddr));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_JOIN_GROUP (join multicast group): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_NETWORK_ERROR;\n\t\tgoto error_handler;\n\t}\n\tret = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpCloseSocket(*ssdpSock);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "*ssdpSock"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_CRITICAL",
            "SSDP",
            "__FILE__",
            "__LINE__",
            "\"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\"",
            "errorBuffer"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "SOL_SOCKET",
            "SO_BROADCAST",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "IPPROTO_IPV6",
            "IPV6_JOIN_GROUP",
            "(char *)&ssdpMcastAddr",
            "sizeof(ssdpMcastAddr)"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET6",
            "SSDP_IPV6_LINKLOCAL",
            "&ssdpMcastAddr.ipv6mr_multiaddr"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "inet_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "307-321",
          "snippet": "int inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nint inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)&ssdpMcastAddr",
            "0",
            "sizeof(ssdpMcastAddr)"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "*ssdpSock",
            "(struct sockaddr *)ssdpAddr6",
            "sizeof(*ssdpAddr6)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "SSDP_PORT"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "IPPROTO_IPV6",
            "IPV6_V6ONLY",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "SOL_SOCKET",
            "SO_REUSEPORT",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET6",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic int create_ssdp_sock_v6(\n\t/* [] SSDP IPv6 socket to be created. */\n\tSOCKET *ssdpSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct ipv6_mreq ssdpMcastAddr;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in6 *ssdpAddr6 = (struct sockaddr_in6 *)&__ss;\n\tint onOff;\n\tint ret = 0;\n\n\t*ssdpSock = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (*ssdpSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEADDR: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#if (defined(BSD) && !defined(__GNU__)) || defined(__OSX__) || defined(__APPLE__)\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEPORT: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#endif /* BSD, __OSX__, __APPLE__ */\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_V6ONLY: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tmemset(&__ss, 0, sizeof(__ss));\n\tssdpAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tssdpAddr6->sin6_addr = in6addr_any;\n\tssdpAddr6->sin6_scope_id = gIF_INDEX;\n\tssdpAddr6->sin6_port = htons(SSDP_PORT);\n\tret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr6, sizeof(*ssdpAddr6));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in bind(), addr=0x%032lX, port=%d: %s\\n\",\n\t\t\t   0lu, SSDP_PORT, errorBuffer);\n\t\tret = UPNP_E_SOCKET_BIND;\n\t\tgoto error_handler;\n\t}\n\tmemset((void *)&ssdpMcastAddr, 0, sizeof(ssdpMcastAddr));\n\tssdpMcastAddr.ipv6mr_interface = gIF_INDEX;\n\tinet_pton(AF_INET6, SSDP_IPV6_LINKLOCAL,\n\t\t  &ssdpMcastAddr.ipv6mr_multiaddr);\n\tret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_JOIN_GROUP,\n\t\t\t(char *)&ssdpMcastAddr, sizeof(ssdpMcastAddr));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IPV6_JOIN_GROUP (join multicast group): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_NETWORK_ERROR;\n\t\tgoto error_handler;\n\t}\n\tret = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpCloseSocket(*ssdpSock);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "create_ssdp_sock_reqv4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "898-918",
    "snippet": "static int create_ssdp_sock_reqv4(\n\t/*! [out] SSDP IPv4 request socket to be created. */\n\tSOCKET *ssdpReqSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tu_char ttl = 4;\n\n\t*ssdpReqSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (*ssdpReqSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tsetsockopt(*ssdpReqSock, IPPROTO_IP, IP_MULTICAST_TTL,\n\t\t   &ttl, sizeof(ttl));\n\t/* just do it, regardless if fails or not. */\n\tsock_make_no_blocking(*ssdpReqSock);\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_make_no_blocking",
          "args": [
            "*ssdpReqSock"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "sock_make_no_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "294-308",
          "snippet": "int sock_make_no_blocking(SOCKET sock)\n{\n#ifdef WIN32\n\tu_long val = 1;\n\treturn ioctlsocket(sock, FIONBIO, &val);\n#else /* WIN32 */\n\tint val;\n\n\tval = fcntl(sock, F_GETFL, 0);\n\tif (fcntl(sock, F_SETFL, val | O_NONBLOCK) == -1) {\n\t\treturn -1;\n\t}\n#endif /* WIN32 */\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_make_no_blocking(SOCKET sock)\n{\n#ifdef WIN32\n\tu_long val = 1;\n\treturn ioctlsocket(sock, FIONBIO, &val);\n#else /* WIN32 */\n\tint val;\n\n\tval = fcntl(sock, F_GETFL, 0);\n\tif (fcntl(sock, F_SETFL, val | O_NONBLOCK) == -1) {\n\t\treturn -1;\n\t}\n#endif /* WIN32 */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpReqSock",
            "IPPROTO_IP",
            "IP_MULTICAST_TTL",
            "&ttl",
            "sizeof(ttl)"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_CRITICAL",
            "SSDP",
            "__FILE__",
            "__LINE__",
            "\"Error in socket(): %s\\n\"",
            "errorBuffer"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic int create_ssdp_sock_reqv4(\n\t/*! [out] SSDP IPv4 request socket to be created. */\n\tSOCKET *ssdpReqSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tu_char ttl = 4;\n\n\t*ssdpReqSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (*ssdpReqSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tsetsockopt(*ssdpReqSock, IPPROTO_IP, IP_MULTICAST_TTL,\n\t\t   &ttl, sizeof(ttl));\n\t/* just do it, regardless if fails or not. */\n\tsock_make_no_blocking(*ssdpReqSock);\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "create_ssdp_sock_v4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "785-890",
    "snippet": "static int create_ssdp_sock_v4(\n\t/*! [] SSDP IPv4 socket to be created. */\n\tSOCKET *ssdpSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tint onOff;\n\tu_char ttl = (u_char)4;\n\tstruct ip_mreq ssdpMcastAddr;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *ssdpAddr4 = (struct sockaddr_in *)&__ss;\n\tint ret = 0;\n\tstruct in_addr addr;\n\n\t*ssdpSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (*ssdpSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEADDR: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#if (defined(BSD) && !defined(__GNU__)) || defined(__OSX__) || defined(__APPLE__)\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEPORT: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#endif /* BSD, __OSX__, __APPLE__ */\n\tmemset(&__ss, 0, sizeof(__ss));\n\tssdpAddr4->sin_family = (sa_family_t)AF_INET;\n\tssdpAddr4->sin_addr.s_addr = htonl(INADDR_ANY);\n\tssdpAddr4->sin_port = htons(SSDP_PORT);\n\tret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr4, sizeof(*ssdpAddr4));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in bind(), addr=0x%08X, port=%d: %s\\n\",\n\t\t\t   INADDR_ANY, SSDP_PORT, errorBuffer);\n\t\tret = UPNP_E_SOCKET_BIND;\n\t\tgoto error_handler;\n\t}\n\tmemset((void *)&ssdpMcastAddr, 0, sizeof(struct ip_mreq));\n\tssdpMcastAddr.imr_interface.s_addr = inet_addr(gIF_IPV4);\n\tssdpMcastAddr.imr_multiaddr.s_addr = inet_addr(SSDP_IP);\n\tret = setsockopt(*ssdpSock, IPPROTO_IP, IP_ADD_MEMBERSHIP,\n\t\t\t (char *)&ssdpMcastAddr, sizeof(struct ip_mreq));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IP_ADD_MEMBERSHIP (join multicast group): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\t/* Set multicast interface. */\n\tmemset((void *)&addr, 0, sizeof(struct in_addr));\n\taddr.s_addr = inet_addr(gIF_IPV4);\n\tret = setsockopt(*ssdpSock, IPPROTO_IP, IP_MULTICAST_IF,\n\t\t\t (char *)&addr, sizeof addr);\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IP_MULTICAST_IF (set multicast interface): %s\\n\",\n\t\t\t   errorBuffer);\n\t\t/* This is probably not a critical error, so let's continue. */\n\t}\n\t/* result is not checked becuase it will fail in WinMe and Win9x. */\n\tsetsockopt(*ssdpSock, IPPROTO_IP,\n\t\tIP_MULTICAST_TTL, &ttl, sizeof(ttl));\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_NETWORK_ERROR;\n\t\tgoto error_handler;\n\t}\n\tret = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (ret != UPNP_E_SUCCESS) {\n                UpnpCloseSocket(*ssdpSock);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "*ssdpSock"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_CRITICAL",
            "SSDP",
            "__FILE__",
            "__LINE__",
            "\"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\"",
            "errorBuffer"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "SOL_SOCKET",
            "SO_BROADCAST",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "IPPROTO_IP",
            "IP_MULTICAST_TTL",
            "&ttl",
            "sizeof(ttl)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "IPPROTO_IP",
            "IP_MULTICAST_IF",
            "(char *)&addr",
            "sizeof addr"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "gIF_IPV4"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)&addr",
            "0",
            "sizeof(struct in_addr)"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "IPPROTO_IP",
            "IP_ADD_MEMBERSHIP",
            "(char *)&ssdpMcastAddr",
            "sizeof(struct ip_mreq)"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "SSDP_IP"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "gIF_IPV4"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "*ssdpSock",
            "(struct sockaddr *)ssdpAddr4",
            "sizeof(*ssdpAddr4)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "SSDP_PORT"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "SOL_SOCKET",
            "SO_REUSEPORT",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "*ssdpSock",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic int create_ssdp_sock_v4(\n\t/*! [] SSDP IPv4 socket to be created. */\n\tSOCKET *ssdpSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tint onOff;\n\tu_char ttl = (u_char)4;\n\tstruct ip_mreq ssdpMcastAddr;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *ssdpAddr4 = (struct sockaddr_in *)&__ss;\n\tint ret = 0;\n\tstruct in_addr addr;\n\n\t*ssdpSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (*ssdpSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in socket(): %s\\n\", errorBuffer);\n\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEADDR: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#if (defined(BSD) && !defined(__GNU__)) || defined(__OSX__) || defined(__APPLE__)\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_REUSEPORT: %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n#endif /* BSD, __OSX__, __APPLE__ */\n\tmemset(&__ss, 0, sizeof(__ss));\n\tssdpAddr4->sin_family = (sa_family_t)AF_INET;\n\tssdpAddr4->sin_addr.s_addr = htonl(INADDR_ANY);\n\tssdpAddr4->sin_port = htons(SSDP_PORT);\n\tret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr4, sizeof(*ssdpAddr4));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in bind(), addr=0x%08X, port=%d: %s\\n\",\n\t\t\t   INADDR_ANY, SSDP_PORT, errorBuffer);\n\t\tret = UPNP_E_SOCKET_BIND;\n\t\tgoto error_handler;\n\t}\n\tmemset((void *)&ssdpMcastAddr, 0, sizeof(struct ip_mreq));\n\tssdpMcastAddr.imr_interface.s_addr = inet_addr(gIF_IPV4);\n\tssdpMcastAddr.imr_multiaddr.s_addr = inet_addr(SSDP_IP);\n\tret = setsockopt(*ssdpSock, IPPROTO_IP, IP_ADD_MEMBERSHIP,\n\t\t\t (char *)&ssdpMcastAddr, sizeof(struct ip_mreq));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IP_ADD_MEMBERSHIP (join multicast group): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_SOCKET_ERROR;\n\t\tgoto error_handler;\n\t}\n\t/* Set multicast interface. */\n\tmemset((void *)&addr, 0, sizeof(struct in_addr));\n\taddr.s_addr = inet_addr(gIF_IPV4);\n\tret = setsockopt(*ssdpSock, IPPROTO_IP, IP_MULTICAST_IF,\n\t\t\t (char *)&addr, sizeof addr);\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() IP_MULTICAST_IF (set multicast interface): %s\\n\",\n\t\t\t   errorBuffer);\n\t\t/* This is probably not a critical error, so let's continue. */\n\t}\n\t/* result is not checked becuase it will fail in WinMe and Win9x. */\n\tsetsockopt(*ssdpSock, IPPROTO_IP,\n\t\tIP_MULTICAST_TTL, &ttl, sizeof(ttl));\n\tonOff = 1;\n\tret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t (char *)&onOff, sizeof(onOff));\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Error in setsockopt() SO_BROADCAST (set broadcast): %s\\n\",\n\t\t\t   errorBuffer);\n\t\tret = UPNP_E_NETWORK_ERROR;\n\t\tgoto error_handler;\n\t}\n\tret = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (ret != UPNP_E_SUCCESS) {\n                UpnpCloseSocket(*ssdpSock);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "readFromSSDPSocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "697-780",
    "snippet": "void readFromSSDPSocket(SOCKET socket)\n{\n\tchar *requestBuf = NULL;\n\tchar staticBuf[BUFSIZE];\n\tstruct sockaddr_storage __ss;\n\tThreadPoolJob job;\n\tssdp_thread_data *data = NULL;\n\tsocklen_t socklen = sizeof(__ss);\n\tssize_t byteReceived = 0;\n\tchar ntop_buf[INET6_ADDRSTRLEN];\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequestBuf = staticBuf;\n\t/* in case memory can't be allocated, still drain the socket using a\n\t * static buffer. */\n\tdata = malloc(sizeof(ssdp_thread_data));\n\tif (data) {\n\t\t/* initialize parser */\n#ifdef INCLUDE_CLIENT_APIS\n\t\tif (socket == gSsdpReqSocket4\n\t#ifdef UPNP_ENABLE_IPV6\n\t\t    || socket == gSsdpReqSocket6\n\t#endif /* UPNP_ENABLE_IPV6 */\n\t\t    )\n\t\t\tparser_response_init(&data->parser, HTTPMETHOD_MSEARCH);\n\t\telse\n\t\t\tparser_request_init(&data->parser);\n#else /* INCLUDE_CLIENT_APIS */\n\t\tparser_request_init(&data->parser);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t/* set size of parser buffer */\n\t\tif (membuffer_set_size(&data->parser.msg.msg, BUFSIZE) == 0)\n\t\t\t/* use this as the buffer for recv */\n\t\t\trequestBuf = data->parser.msg.msg.buf;\n\t\telse {\n\t\t\tfree(data);\n\t\t\tdata = NULL;\n\t\t}\n\t}\n\tbyteReceived = recvfrom(socket, requestBuf, BUFSIZE - (size_t)1, 0,\n\t\t\t\t(struct sockaddr *)&__ss, &socklen);\n\tif (byteReceived > 0) {\n\t\trequestBuf[byteReceived] = '\\0';\n\t\tswitch (__ss.ss_family) {\n\t\tcase AF_INET:\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t  &((struct sockaddr_in *)&__ss)->sin_addr,\n\t\t\t\t  ntop_buf, sizeof(ntop_buf));\n\t\t\tbreak;\n#ifdef UPNP_ENABLE_IPV6\n\t\tcase AF_INET6:\n\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t  &((struct sockaddr_in6 *)&__ss)->sin6_addr,\n\t\t\t\t  ntop_buf, sizeof(ntop_buf));\n\t\t\tbreak;\n#endif /* UPNP_ENABLE_IPV6 */\n\t\tdefault:\n\t\t\tmemset(ntop_buf, 0, sizeof(ntop_buf));\n\t\t\tstrncpy(ntop_buf, \"<Invalid address family>\",\n\t\t\t\tsizeof(ntop_buf) - 1);\n\t\t}\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Start of received response ----------------------------------------------------\\n\"\n\t\t\t   \"%s\\n\"\n\t\t\t   \"End of received response ------------------------------------------------------\\n\"\n\t\t\t   \"From host %s\\n\", requestBuf, ntop_buf);\n\t\t/* add thread pool job to handle request */\n\t\tif (data != NULL) {\n\t\t\tdata->parser.msg.msg.length += (size_t) byteReceived;\n\t\t\t/* null-terminate */\n\t\t\tdata->parser.msg.msg.buf[byteReceived] = 0;\n\t\t\tmemcpy(&data->dest_addr, &__ss, sizeof(__ss));\n\t\t\tTPJobInit(&job, (start_routine)\n\t\t\t\t  ssdp_event_handler_thread, data);\n\t\t\tTPJobSetFreeFunction(&job,\n\t\t\t\t\t     free_ssdp_event_handler_data);\n\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\tif (ThreadPoolAdd(&gRecvThreadPool, &job, NULL) != 0)\n\t\t\t\tfree_ssdp_event_handler_data(data);\n\t\t}\n\t} else\n\t\tfree_ssdp_event_handler_data(data);\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ssdp_event_handler_data",
          "args": [
            "data"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "free_ssdp_event_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "565-578",
          "snippet": "static void free_ssdp_event_handler_data(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\n\tif (data != NULL) {\n\t\thttp_message_t *hmsg = &data->parser.msg;\n\t\t/* free data */\n\t\thttpmsg_destroy(hmsg);\n\t\tfree(data);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic void free_ssdp_event_handler_data(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\n\tif (data != NULL) {\n\t\thttp_message_t *hmsg = &data->parser.msg;\n\t\t/* free data */\n\t\thttpmsg_destroy(hmsg);\n\t\tfree(data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gRecvThreadPool",
            "&job",
            "NULL"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "free_ssdp_event_handler_data"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine)\n\t\t\t\t  ssdp_event_handler_thread",
            "data"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&data->dest_addr",
            "&__ss",
            "sizeof(__ss)"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "SSDP",
            "__FILE__",
            "__LINE__",
            "\"Start of received response ----------------------------------------------------\\n\"\n\t\t\t   \"%s\\n\"\n\t\t\t   \"End of received response ------------------------------------------------------\\n\"\n\t\t\t   \"From host %s\\n\"",
            "requestBuf",
            "ntop_buf"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ntop_buf",
            "\"<Invalid address family>\"",
            "sizeof(ntop_buf) - 1"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ntop_buf",
            "0",
            "sizeof(ntop_buf)"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "AF_INET6",
            "&((struct sockaddr_in6 *)&__ss)->sin6_addr",
            "ntop_buf",
            "sizeof(ntop_buf)"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "291-305",
          "snippet": "const char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nconst char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "recvfrom",
          "args": [
            "socket",
            "requestBuf",
            "BUFSIZE - (size_t)1",
            "0",
            "(struct sockaddr *)&__ss",
            "&socklen"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_set_size",
          "args": [
            "&data->parser.msg.msg",
            "BUFSIZE"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "104-150",
          "snippet": "int membuffer_set_size(membuffer *m, size_t new_length)\n{\n\tsize_t diff;\n\tsize_t alloc_len;\n\tchar *temp_buf;\n\n\tif (new_length >= m->length) {\t/* increase length */\n\t\t/* need more mem? */\n\t\tif (new_length <= m->capacity) {\n\t\t\treturn 0;\t/* have enough mem; done */\n\t\t}\n\n\t\tdiff = new_length - m->length;\n\t\talloc_len = MAXVAL(m->size_inc, diff) + m->capacity;\n\t} else {\t\t/* decrease length */\n\n\t\tassert(new_length <= m->length);\n\n\t\t/* if diff is 0..m->size_inc, don't free */\n\t\tif ((m->capacity - new_length) <= m->size_inc) {\n\t\t\treturn 0;\n\t\t}\n\n\t\talloc_len = new_length + m->size_inc;\n\t}\n\n\tassert(alloc_len >= new_length);\n\n\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\n\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\tif (temp_buf == NULL) {\n\t\t/* try smaller size */\n\t\talloc_len = new_length;\n\t\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\t\tif (temp_buf == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\t/* save */\n\tm->buf = temp_buf;\n\tm->capacity = alloc_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_set_size(membuffer *m, size_t new_length)\n{\n\tsize_t diff;\n\tsize_t alloc_len;\n\tchar *temp_buf;\n\n\tif (new_length >= m->length) {\t/* increase length */\n\t\t/* need more mem? */\n\t\tif (new_length <= m->capacity) {\n\t\t\treturn 0;\t/* have enough mem; done */\n\t\t}\n\n\t\tdiff = new_length - m->length;\n\t\talloc_len = MAXVAL(m->size_inc, diff) + m->capacity;\n\t} else {\t\t/* decrease length */\n\n\t\tassert(new_length <= m->length);\n\n\t\t/* if diff is 0..m->size_inc, don't free */\n\t\tif ((m->capacity - new_length) <= m->size_inc) {\n\t\t\treturn 0;\n\t\t}\n\n\t\talloc_len = new_length + m->size_inc;\n\t}\n\n\tassert(alloc_len >= new_length);\n\n\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\n\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\tif (temp_buf == NULL) {\n\t\t/* try smaller size */\n\t\talloc_len = new_length;\n\t\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\t\tif (temp_buf == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\t/* save */\n\tm->buf = temp_buf;\n\tm->capacity = alloc_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_request_init",
          "args": [
            "&data->parser"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "parser_request_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1965-1971",
          "snippet": "void\nparser_request_init( OUT http_parser_t * parser )\n{\n    parser_init( parser );\n    parser->msg.is_request = TRUE;\n    parser->position = POS_REQUEST_LINE;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid\nparser_request_init( OUT http_parser_t * parser )\n{\n    parser_init( parser );\n    parser->msg.is_request = TRUE;\n    parser->position = POS_REQUEST_LINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_response_init",
          "args": [
            "&data->parser",
            "HTTPMETHOD_MSEARCH"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "parser_response_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1985-1994",
          "snippet": "void\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(ssdp_thread_data)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nvoid readFromSSDPSocket(SOCKET socket)\n{\n\tchar *requestBuf = NULL;\n\tchar staticBuf[BUFSIZE];\n\tstruct sockaddr_storage __ss;\n\tThreadPoolJob job;\n\tssdp_thread_data *data = NULL;\n\tsocklen_t socklen = sizeof(__ss);\n\tssize_t byteReceived = 0;\n\tchar ntop_buf[INET6_ADDRSTRLEN];\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequestBuf = staticBuf;\n\t/* in case memory can't be allocated, still drain the socket using a\n\t * static buffer. */\n\tdata = malloc(sizeof(ssdp_thread_data));\n\tif (data) {\n\t\t/* initialize parser */\n#ifdef INCLUDE_CLIENT_APIS\n\t\tif (socket == gSsdpReqSocket4\n\t#ifdef UPNP_ENABLE_IPV6\n\t\t    || socket == gSsdpReqSocket6\n\t#endif /* UPNP_ENABLE_IPV6 */\n\t\t    )\n\t\t\tparser_response_init(&data->parser, HTTPMETHOD_MSEARCH);\n\t\telse\n\t\t\tparser_request_init(&data->parser);\n#else /* INCLUDE_CLIENT_APIS */\n\t\tparser_request_init(&data->parser);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t/* set size of parser buffer */\n\t\tif (membuffer_set_size(&data->parser.msg.msg, BUFSIZE) == 0)\n\t\t\t/* use this as the buffer for recv */\n\t\t\trequestBuf = data->parser.msg.msg.buf;\n\t\telse {\n\t\t\tfree(data);\n\t\t\tdata = NULL;\n\t\t}\n\t}\n\tbyteReceived = recvfrom(socket, requestBuf, BUFSIZE - (size_t)1, 0,\n\t\t\t\t(struct sockaddr *)&__ss, &socklen);\n\tif (byteReceived > 0) {\n\t\trequestBuf[byteReceived] = '\\0';\n\t\tswitch (__ss.ss_family) {\n\t\tcase AF_INET:\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t  &((struct sockaddr_in *)&__ss)->sin_addr,\n\t\t\t\t  ntop_buf, sizeof(ntop_buf));\n\t\t\tbreak;\n#ifdef UPNP_ENABLE_IPV6\n\t\tcase AF_INET6:\n\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t  &((struct sockaddr_in6 *)&__ss)->sin6_addr,\n\t\t\t\t  ntop_buf, sizeof(ntop_buf));\n\t\t\tbreak;\n#endif /* UPNP_ENABLE_IPV6 */\n\t\tdefault:\n\t\t\tmemset(ntop_buf, 0, sizeof(ntop_buf));\n\t\t\tstrncpy(ntop_buf, \"<Invalid address family>\",\n\t\t\t\tsizeof(ntop_buf) - 1);\n\t\t}\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Start of received response ----------------------------------------------------\\n\"\n\t\t\t   \"%s\\n\"\n\t\t\t   \"End of received response ------------------------------------------------------\\n\"\n\t\t\t   \"From host %s\\n\", requestBuf, ntop_buf);\n\t\t/* add thread pool job to handle request */\n\t\tif (data != NULL) {\n\t\t\tdata->parser.msg.msg.length += (size_t) byteReceived;\n\t\t\t/* null-terminate */\n\t\t\tdata->parser.msg.msg.buf[byteReceived] = 0;\n\t\t\tmemcpy(&data->dest_addr, &__ss, sizeof(__ss));\n\t\t\tTPJobInit(&job, (start_routine)\n\t\t\t\t  ssdp_event_handler_thread, data);\n\t\t\tTPJobSetFreeFunction(&job,\n\t\t\t\t\t     free_ssdp_event_handler_data);\n\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\tif (ThreadPoolAdd(&gRecvThreadPool, &job, NULL) != 0)\n\t\t\t\tfree_ssdp_event_handler_data(data);\n\t\t}\n\t} else\n\t\tfree_ssdp_event_handler_data(data);\n}"
  },
  {
    "function_name": "ssdp_event_handler_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "670-695",
    "snippet": "static void ssdp_event_handler_thread(\n\t/*! [] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\thttp_message_t *hmsg = &data->parser.msg;\n\n\tif (start_event_handler(the_data) != 0)\n\t\treturn;\n\t/* send msg to device or ctrlpt */\n\tif (hmsg->method == (http_method_t)HTTPMETHOD_NOTIFY ||\n\t    hmsg->request_method == (http_method_t)HTTPMETHOD_MSEARCH) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tssdp_handle_ctrlpt_msg(hmsg,\n\t\t\t\t       &data->dest_addr,\n\t\t\t\t       FALSE, NULL);\n#endif /* INCLUDE_CLIENT_APIS */\n\t} else {\n\t\tssdp_handle_device_request(hmsg,\n\t\t\t\t\t   &data->dest_addr);\n\t}\n\n\t/* free data */\n\tfree_ssdp_event_handler_data(data);\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ssdp_event_handler_data",
          "args": [
            "data"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "free_ssdp_event_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "565-578",
          "snippet": "static void free_ssdp_event_handler_data(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\n\tif (data != NULL) {\n\t\thttp_message_t *hmsg = &data->parser.msg;\n\t\t/* free data */\n\t\thttpmsg_destroy(hmsg);\n\t\tfree(data);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic void free_ssdp_event_handler_data(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\n\tif (data != NULL) {\n\t\thttp_message_t *hmsg = &data->parser.msg;\n\t\t/* free data */\n\t\thttpmsg_destroy(hmsg);\n\t\tfree(data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssdp_handle_device_request",
          "args": [
            "hmsg",
            "&data->dest_addr"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ssdp_handle_device_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_device.c",
          "lines": "82-165",
          "snippet": "void ssdp_handle_device_request(http_message_t *hmsg, struct sockaddr_storage *dest_addr)\n{\n#define MX_FUDGE_FACTOR 10\n\tint handle;\n\tstruct Handle_Info *dev_info = NULL;\n\tmemptr hdr_value;\n\tint mx;\n\tchar save_char;\n\tSsdpEvent event;\n\tint ret_code;\n\tSsdpSearchReply *threadArg = NULL;\n\tThreadPoolJob job;\n\tint replyTime;\n\tint maxAge;\n\n\tmemset(&job, 0, sizeof(job));\n\n\t/* check man hdr. */\n\tif (httpmsg_find_hdr(hmsg, HDR_MAN, &hdr_value) == NULL ||\n\t    memptr_cmp(&hdr_value, \"\\\"ssdp:discover\\\"\") != 0)\n\t\t/* bad or missing hdr. */\n\t\treturn;\n\t/* MX header. */\n\tif (httpmsg_find_hdr(hmsg, HDR_MX, &hdr_value) == NULL ||\n\t    (mx = raw_to_int(&hdr_value, 10)) < 0)\n\t\treturn;\n\t/* ST header. */\n\tif (httpmsg_find_hdr(hmsg, HDR_ST, &hdr_value) == NULL)\n\t\treturn;\n\tsave_char = hdr_value.buf[hdr_value.length];\n\thdr_value.buf[hdr_value.length] = '\\0';\n\tret_code = ssdp_request_type(hdr_value.buf, &event);\n\t/* restore. */\n\thdr_value.buf[hdr_value.length] = save_char;\n\tif (ret_code == -1)\n\t\t/* bad ST header. */\n\t\treturn;\n\n\tHandleLock();\n\t/* device info. */\n\tswitch (GetDeviceHandleInfo((int)dest_addr->ss_family,\n\t\t\t\t&handle, &dev_info)) {\n\tcase HND_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\t/* no info found. */\n\t\treturn;\n\t}\n\tmaxAge = dev_info->MaxAge;\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,\n\t\t   \"MAX-AGE     =  %d\\n\", maxAge);\n\tUpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,\n\t\t   \"MX     =  %d\\n\", event.Mx);\n\tUpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,\n\t\t   \"DeviceType   =  %s\\n\", event.DeviceType);\n\tUpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,\n\t\t   \"DeviceUuid   =  %s\\n\", event.UDN);\n\tUpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,\n\t\t   \"ServiceType =  %s\\n\", event.ServiceType);\n\tthreadArg = (SsdpSearchReply *)malloc(sizeof(SsdpSearchReply));\n\tif (threadArg == NULL)\n\t\treturn;\n\tthreadArg->handle = handle;\n\tmemcpy(&threadArg->dest_addr, dest_addr, sizeof(threadArg->dest_addr));\n\tthreadArg->event = event;\n\tthreadArg->MaxAge = maxAge;\n\n\tTPJobInit(&job, advertiseAndReplyThread, threadArg);\n\tTPJobSetFreeFunction(&job, (free_routine) free);\n\n\t/* Subtract a percentage from the mx to allow for network and processing\n\t * delays (i.e. if search is for 30 seconds, respond\n\t * within 0 - 27 seconds). */\n\tif (mx >= 2)\n\t\tmx -= MAXVAL(1, mx / MX_FUDGE_FACTOR);\n\tif (mx < 1)\n\t\tmx = 1;\n\treplyTime = rand() % mx;\n\tTimerThreadSchedule(&gTimerThread, replyTime, REL_SEC, &job,\n\t\t\t    SHORT_TERM, NULL);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"UpnpInet.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MX_FUDGE_FACTOR 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"config.h\"\n\n#define MX_FUDGE_FACTOR 10\n\nvoid ssdp_handle_device_request(http_message_t *hmsg, struct sockaddr_storage *dest_addr)\n{\n#define MX_FUDGE_FACTOR 10\n\tint handle;\n\tstruct Handle_Info *dev_info = NULL;\n\tmemptr hdr_value;\n\tint mx;\n\tchar save_char;\n\tSsdpEvent event;\n\tint ret_code;\n\tSsdpSearchReply *threadArg = NULL;\n\tThreadPoolJob job;\n\tint replyTime;\n\tint maxAge;\n\n\tmemset(&job, 0, sizeof(job));\n\n\t/* check man hdr. */\n\tif (httpmsg_find_hdr(hmsg, HDR_MAN, &hdr_value) == NULL ||\n\t    memptr_cmp(&hdr_value, \"\\\"ssdp:discover\\\"\") != 0)\n\t\t/* bad or missing hdr. */\n\t\treturn;\n\t/* MX header. */\n\tif (httpmsg_find_hdr(hmsg, HDR_MX, &hdr_value) == NULL ||\n\t    (mx = raw_to_int(&hdr_value, 10)) < 0)\n\t\treturn;\n\t/* ST header. */\n\tif (httpmsg_find_hdr(hmsg, HDR_ST, &hdr_value) == NULL)\n\t\treturn;\n\tsave_char = hdr_value.buf[hdr_value.length];\n\thdr_value.buf[hdr_value.length] = '\\0';\n\tret_code = ssdp_request_type(hdr_value.buf, &event);\n\t/* restore. */\n\thdr_value.buf[hdr_value.length] = save_char;\n\tif (ret_code == -1)\n\t\t/* bad ST header. */\n\t\treturn;\n\n\tHandleLock();\n\t/* device info. */\n\tswitch (GetDeviceHandleInfo((int)dest_addr->ss_family,\n\t\t\t\t&handle, &dev_info)) {\n\tcase HND_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tHandleUnlock();\n\t\t/* no info found. */\n\t\treturn;\n\t}\n\tmaxAge = dev_info->MaxAge;\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,\n\t\t   \"MAX-AGE     =  %d\\n\", maxAge);\n\tUpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,\n\t\t   \"MX     =  %d\\n\", event.Mx);\n\tUpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,\n\t\t   \"DeviceType   =  %s\\n\", event.DeviceType);\n\tUpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,\n\t\t   \"DeviceUuid   =  %s\\n\", event.UDN);\n\tUpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,\n\t\t   \"ServiceType =  %s\\n\", event.ServiceType);\n\tthreadArg = (SsdpSearchReply *)malloc(sizeof(SsdpSearchReply));\n\tif (threadArg == NULL)\n\t\treturn;\n\tthreadArg->handle = handle;\n\tmemcpy(&threadArg->dest_addr, dest_addr, sizeof(threadArg->dest_addr));\n\tthreadArg->event = event;\n\tthreadArg->MaxAge = maxAge;\n\n\tTPJobInit(&job, advertiseAndReplyThread, threadArg);\n\tTPJobSetFreeFunction(&job, (free_routine) free);\n\n\t/* Subtract a percentage from the mx to allow for network and processing\n\t * delays (i.e. if search is for 30 seconds, respond\n\t * within 0 - 27 seconds). */\n\tif (mx >= 2)\n\t\tmx -= MAXVAL(1, mx / MX_FUDGE_FACTOR);\n\tif (mx < 1)\n\t\tmx = 1;\n\treplyTime = rand() % mx;\n\tTimerThreadSchedule(&gTimerThread, replyTime, REL_SEC, &job,\n\t\t\t    SHORT_TERM, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssdp_handle_ctrlpt_msg",
          "args": [
            "hmsg",
            "&data->dest_addr",
            "FALSE",
            "NULL"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "ssdp_handle_ctrlpt_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_ctrlpt.c",
          "lines": "78-313",
          "snippet": "void ssdp_handle_ctrlpt_msg(http_message_t *hmsg, struct sockaddr_storage *dest_addr,\n\t\t\t    int timeout, void *cookie)\n{\n\tint handle;\n\tstruct Handle_Info *ctrlpt_info = NULL;\n\tmemptr hdr_value;\n\t/* byebye or alive */\n\tint is_byebye;\n\tUpnpDiscovery *param = UpnpDiscovery_new();\n\tint expires;\n\tint ret;\n\tSsdpEvent event;\n\tint nt_found;\n\tint usn_found;\n\tint st_found;\n\tchar save_char;\n\tUpnp_EventType event_type;\n\tUpnp_FunPtr ctrlpt_callback;\n\tvoid *ctrlpt_cookie;\n\tListNode *node = NULL;\n\tSsdpSearchArg *searchArg = NULL;\n\tint matched = 0;\n\tSSDPResultData *threadData = NULL;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\t/* we are assuming that there can be only one client supported at a time */\n\tHandleReadLock();\n\n\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\t/* copy */\n\tctrlpt_callback = ctrlpt_info->Callback;\n\tctrlpt_cookie = ctrlpt_info->Cookie;\n\tHandleUnlock();\n\t/* search timeout */\n\tif (timeout) {\n\t\tctrlpt_callback(UPNP_DISCOVERY_SEARCH_TIMEOUT, NULL, cookie);\n\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\n\tUpnpDiscovery_set_ErrCode(param, UPNP_E_SUCCESS);\n\t/* MAX-AGE, assume error */\n\texpires = -1;\n\tUpnpDiscovery_set_Expires(param, expires);\n\tif (httpmsg_find_hdr(hmsg, HDR_CACHE_CONTROL, &hdr_value) != NULL) {\n\t\tret = matchstr(hdr_value.buf, hdr_value.length,\n\t\t\t\"%imax-age = %d%0\", &expires);\n\t\tUpnpDiscovery_set_Expires(param, expires);\n\t\tif (ret != PARSE_OK)\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\t/* DATE */\n\tif (httpmsg_find_hdr(hmsg, HDR_DATE, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strcpy_Date(param, hdr_value.buf);\n\t}\n\t/* dest addr */\n\tUpnpDiscovery_set_DestAddr(param, dest_addr);\n\t/* EXT */\n\tif (httpmsg_find_hdr(hmsg, HDR_EXT, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Ext(param, hdr_value.buf,\n\t\t\t\t\t  hdr_value.length);\n\t}\n\t/* LOCATION */\n\tif (httpmsg_find_hdr(hmsg, HDR_LOCATION, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Location(param, hdr_value.buf,\n\t\t\t\t\t       hdr_value.length);\n\t}\n\t/* SERVER / USER-AGENT */\n\tif (httpmsg_find_hdr(hmsg, HDR_SERVER, &hdr_value) != NULL ||\n\t    httpmsg_find_hdr(hmsg, HDR_USER_AGENT, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Os(param, hdr_value.buf,\n\t\t\t\t\t hdr_value.length);\n\t}\n\t/* clear everything */\n\tevent.UDN[0] = '\\0';\n\tevent.DeviceType[0] = '\\0';\n\tevent.ServiceType[0] = '\\0';\n\tnt_found = FALSE;\n\tif (httpmsg_find_hdr(hmsg, HDR_NT, &hdr_value) != NULL) {\n\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\tnt_found = (ssdp_request_type(hdr_value.buf, &event) == 0);\n\t\thdr_value.buf[hdr_value.length] = save_char;\n\t}\n\tusn_found = FALSE;\n\tif (httpmsg_find_hdr(hmsg, HDR_USN, &hdr_value) != NULL) {\n\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\tusn_found = (unique_service_name(hdr_value.buf, &event) == 0);\n\t\thdr_value.buf[hdr_value.length] = save_char;\n\t}\n\tif (nt_found || usn_found) {\n\t\tUpnpDiscovery_strcpy_DeviceID(param, event.UDN);\n\t\tUpnpDiscovery_strcpy_DeviceType(param, event.DeviceType);\n\t\tUpnpDiscovery_strcpy_ServiceType(param, event.ServiceType);\n\t}\n\t/* ADVERT. OR BYEBYE */\n\tif (hmsg->is_request) {\n\t\t/* use NTS hdr to determine advert., or byebye */\n\t\tif (httpmsg_find_hdr(hmsg, HDR_NTS, &hdr_value) == NULL) {\n\t\t\t/* error; NTS header not found */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tif (memptr_cmp(&hdr_value, \"ssdp:alive\") == 0) {\n\t\t\tis_byebye = FALSE;\n\t\t} else if (memptr_cmp(&hdr_value, \"ssdp:byebye\") == 0) {\n\t\t\tis_byebye = TRUE;\n\t\t} else {\n\t\t\t/* bad value */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tif (is_byebye) {\n\t\t\t/* check device byebye */\n\t\t\tif (!nt_found || !usn_found) {\n\t\t\t\t/* bad byebye */\n\t\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t\t}\n\t\t\tevent_type = UPNP_DISCOVERY_ADVERTISEMENT_BYEBYE;\n\t\t} else {\n\t\t\t/* check advertisement.\n\t\t\t * Expires is valid if positive. This is for testing\n\t\t\t * only. Expires should be greater than 1800 (30 mins) */\n\t\t\tif (!nt_found ||\n\t\t\t    !usn_found ||\n\t\t\t    UpnpString_get_Length(UpnpDiscovery_get_Location(param)) == 0 ||\n\t\t\t    UpnpDiscovery_get_Expires(param) <= 0) {\n\t\t\t\t/* bad advertisement */\n\t\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t\t}\n\t\t\tevent_type = UPNP_DISCOVERY_ADVERTISEMENT_ALIVE;\n\t\t}\n\t\t/* call callback */\n\t\tctrlpt_callback(event_type, param, ctrlpt_cookie);\n\t} else {\n\t\t/* reply (to a SEARCH) */\n\t\t/* only checking to see if there is a valid ST header */\n\t\tst_found = FALSE;\n\t\tif (httpmsg_find_hdr(hmsg, HDR_ST, &hdr_value) != NULL) {\n\t\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\t\tst_found =\n\t\t\t    ssdp_request_type(hdr_value.buf, &event) == 0;\n\t\t\thdr_value.buf[hdr_value.length] = save_char;\n\t\t}\n\t\tif (hmsg->status_code != HTTP_OK ||\n\t\t    UpnpDiscovery_get_Expires(param) <= 0 ||\n\t\t    UpnpString_get_Length(UpnpDiscovery_get_Location(param)) == 0 ||\n\t\t    !usn_found || !st_found) {\n\t\t\t/* bad reply */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\t/* check each current search */\n\t\tHandleLock();\n\t\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\t\tHandleUnlock();\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tnode = ListHead(&ctrlpt_info->SsdpSearchList);\n\t\t/* temporary add null termination */\n\t\t/*save_char = hdr_value.buf[ hdr_value.length ]; */\n\t\t/*hdr_value.buf[ hdr_value.length ] = '\\0'; */\n\t\twhile (node != NULL) {\n\t\t\tsearchArg = node->item;\n\t\t\t/* check for match of ST header and search target */\n\t\t\tswitch (searchArg->requestType) {\n\t\t\tcase SSDP_ALL:\n\t\t\t\tmatched = 1;\n\t\t\t\tbreak;\n\t\t\tcase SSDP_ROOTDEVICE:\n\t\t\t\tmatched =\n\t\t\t\t    (event.RequestType == SSDP_ROOTDEVICE);\n\t\t\t\tbreak;\n\t\t\tcase SSDP_DEVICEUDN:\n\t\t\t\tmatched = !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t   hdr_value.buf,\n\t\t\t\t\t\t   hdr_value.length);\n\t\t\t\tbreak;\n\t\t\tcase SSDP_DEVICETYPE:{\n\t\t\t\t\tsize_t m = min(hdr_value.length,\n\t\t\t\t\t\t       strlen\n\t\t\t\t\t\t       (searchArg->searchTarget));\n\t\t\t\t\tmatched =\n\t\t\t\t\t    !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t     hdr_value.buf, m);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase SSDP_SERVICE:{\n\t\t\t\t\tsize_t m = min(hdr_value.length,\n\t\t\t\t\t\t       strlen\n\t\t\t\t\t\t       (searchArg->searchTarget));\n\t\t\t\t\tmatched =\n\t\t\t\t\t    !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t     hdr_value.buf, m);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tmatched = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (matched) {\n\t\t\t\t/* schedule call back */\n\t\t\t\tthreadData = SSDPResultData_new();\n\t\t\t\tif (threadData != NULL) {\n\t\t\t\t\tSSDPResultData_set_Param(threadData,\n\t\t\t\t\t\t\t\t param);\n\t\t\t\t\tSSDPResultData_set_Cookie(threadData,\n\t\t\t\t\t\t\t\t  searchArg->\n\t\t\t\t\t\t\t\t  cookie);\n\t\t\t\t\tSSDPResultData_set_CtrlptCallback\n\t\t\t\t\t    (threadData, ctrlpt_callback);\n\t\t\t\t\tTPJobInit(&job, (start_routine)\n\t\t\t\t\t\t  send_search_result,\n\t\t\t\t\t\t  threadData);\n\t\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\t\tTPJobSetFreeFunction(&job,\n\t\t\t\t\t\t\t     (free_routine)\n\t\t\t\t\t\t\t     free);\n\t\t\t\t\tif (ThreadPoolAdd(&gRecvThreadPool, &job, NULL) != 0) {\n\t\t\t\t\t\tSSDPResultData_delete(threadData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = ListNext(&ctrlpt_info->SsdpSearchList, node);\n\t\t}\n\n\t\tHandleUnlock();\n\t\t/*ctrlpt_callback( UPNP_DISCOVERY_SEARCH_RESULT, param, cookie ); */\n\t}\n\nend_ssdp_handle_ctrlpt_msg:\n\tUpnpDiscovery_delete(param);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"ThreadPool.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ssdp_ResultData.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"upnputil.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include \"ThreadPool.h\"\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ssdp_ResultData.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"upnputil.h\"\n#include \"config.h\"\n\nvoid ssdp_handle_ctrlpt_msg(http_message_t *hmsg, struct sockaddr_storage *dest_addr,\n\t\t\t    int timeout, void *cookie)\n{\n\tint handle;\n\tstruct Handle_Info *ctrlpt_info = NULL;\n\tmemptr hdr_value;\n\t/* byebye or alive */\n\tint is_byebye;\n\tUpnpDiscovery *param = UpnpDiscovery_new();\n\tint expires;\n\tint ret;\n\tSsdpEvent event;\n\tint nt_found;\n\tint usn_found;\n\tint st_found;\n\tchar save_char;\n\tUpnp_EventType event_type;\n\tUpnp_FunPtr ctrlpt_callback;\n\tvoid *ctrlpt_cookie;\n\tListNode *node = NULL;\n\tSsdpSearchArg *searchArg = NULL;\n\tint matched = 0;\n\tSSDPResultData *threadData = NULL;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\t/* we are assuming that there can be only one client supported at a time */\n\tHandleReadLock();\n\n\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\t/* copy */\n\tctrlpt_callback = ctrlpt_info->Callback;\n\tctrlpt_cookie = ctrlpt_info->Cookie;\n\tHandleUnlock();\n\t/* search timeout */\n\tif (timeout) {\n\t\tctrlpt_callback(UPNP_DISCOVERY_SEARCH_TIMEOUT, NULL, cookie);\n\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\n\tUpnpDiscovery_set_ErrCode(param, UPNP_E_SUCCESS);\n\t/* MAX-AGE, assume error */\n\texpires = -1;\n\tUpnpDiscovery_set_Expires(param, expires);\n\tif (httpmsg_find_hdr(hmsg, HDR_CACHE_CONTROL, &hdr_value) != NULL) {\n\t\tret = matchstr(hdr_value.buf, hdr_value.length,\n\t\t\t\"%imax-age = %d%0\", &expires);\n\t\tUpnpDiscovery_set_Expires(param, expires);\n\t\tif (ret != PARSE_OK)\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\t/* DATE */\n\tif (httpmsg_find_hdr(hmsg, HDR_DATE, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strcpy_Date(param, hdr_value.buf);\n\t}\n\t/* dest addr */\n\tUpnpDiscovery_set_DestAddr(param, dest_addr);\n\t/* EXT */\n\tif (httpmsg_find_hdr(hmsg, HDR_EXT, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Ext(param, hdr_value.buf,\n\t\t\t\t\t  hdr_value.length);\n\t}\n\t/* LOCATION */\n\tif (httpmsg_find_hdr(hmsg, HDR_LOCATION, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Location(param, hdr_value.buf,\n\t\t\t\t\t       hdr_value.length);\n\t}\n\t/* SERVER / USER-AGENT */\n\tif (httpmsg_find_hdr(hmsg, HDR_SERVER, &hdr_value) != NULL ||\n\t    httpmsg_find_hdr(hmsg, HDR_USER_AGENT, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Os(param, hdr_value.buf,\n\t\t\t\t\t hdr_value.length);\n\t}\n\t/* clear everything */\n\tevent.UDN[0] = '\\0';\n\tevent.DeviceType[0] = '\\0';\n\tevent.ServiceType[0] = '\\0';\n\tnt_found = FALSE;\n\tif (httpmsg_find_hdr(hmsg, HDR_NT, &hdr_value) != NULL) {\n\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\tnt_found = (ssdp_request_type(hdr_value.buf, &event) == 0);\n\t\thdr_value.buf[hdr_value.length] = save_char;\n\t}\n\tusn_found = FALSE;\n\tif (httpmsg_find_hdr(hmsg, HDR_USN, &hdr_value) != NULL) {\n\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\tusn_found = (unique_service_name(hdr_value.buf, &event) == 0);\n\t\thdr_value.buf[hdr_value.length] = save_char;\n\t}\n\tif (nt_found || usn_found) {\n\t\tUpnpDiscovery_strcpy_DeviceID(param, event.UDN);\n\t\tUpnpDiscovery_strcpy_DeviceType(param, event.DeviceType);\n\t\tUpnpDiscovery_strcpy_ServiceType(param, event.ServiceType);\n\t}\n\t/* ADVERT. OR BYEBYE */\n\tif (hmsg->is_request) {\n\t\t/* use NTS hdr to determine advert., or byebye */\n\t\tif (httpmsg_find_hdr(hmsg, HDR_NTS, &hdr_value) == NULL) {\n\t\t\t/* error; NTS header not found */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tif (memptr_cmp(&hdr_value, \"ssdp:alive\") == 0) {\n\t\t\tis_byebye = FALSE;\n\t\t} else if (memptr_cmp(&hdr_value, \"ssdp:byebye\") == 0) {\n\t\t\tis_byebye = TRUE;\n\t\t} else {\n\t\t\t/* bad value */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tif (is_byebye) {\n\t\t\t/* check device byebye */\n\t\t\tif (!nt_found || !usn_found) {\n\t\t\t\t/* bad byebye */\n\t\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t\t}\n\t\t\tevent_type = UPNP_DISCOVERY_ADVERTISEMENT_BYEBYE;\n\t\t} else {\n\t\t\t/* check advertisement.\n\t\t\t * Expires is valid if positive. This is for testing\n\t\t\t * only. Expires should be greater than 1800 (30 mins) */\n\t\t\tif (!nt_found ||\n\t\t\t    !usn_found ||\n\t\t\t    UpnpString_get_Length(UpnpDiscovery_get_Location(param)) == 0 ||\n\t\t\t    UpnpDiscovery_get_Expires(param) <= 0) {\n\t\t\t\t/* bad advertisement */\n\t\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t\t}\n\t\t\tevent_type = UPNP_DISCOVERY_ADVERTISEMENT_ALIVE;\n\t\t}\n\t\t/* call callback */\n\t\tctrlpt_callback(event_type, param, ctrlpt_cookie);\n\t} else {\n\t\t/* reply (to a SEARCH) */\n\t\t/* only checking to see if there is a valid ST header */\n\t\tst_found = FALSE;\n\t\tif (httpmsg_find_hdr(hmsg, HDR_ST, &hdr_value) != NULL) {\n\t\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\t\tst_found =\n\t\t\t    ssdp_request_type(hdr_value.buf, &event) == 0;\n\t\t\thdr_value.buf[hdr_value.length] = save_char;\n\t\t}\n\t\tif (hmsg->status_code != HTTP_OK ||\n\t\t    UpnpDiscovery_get_Expires(param) <= 0 ||\n\t\t    UpnpString_get_Length(UpnpDiscovery_get_Location(param)) == 0 ||\n\t\t    !usn_found || !st_found) {\n\t\t\t/* bad reply */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\t/* check each current search */\n\t\tHandleLock();\n\t\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\t\tHandleUnlock();\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tnode = ListHead(&ctrlpt_info->SsdpSearchList);\n\t\t/* temporary add null termination */\n\t\t/*save_char = hdr_value.buf[ hdr_value.length ]; */\n\t\t/*hdr_value.buf[ hdr_value.length ] = '\\0'; */\n\t\twhile (node != NULL) {\n\t\t\tsearchArg = node->item;\n\t\t\t/* check for match of ST header and search target */\n\t\t\tswitch (searchArg->requestType) {\n\t\t\tcase SSDP_ALL:\n\t\t\t\tmatched = 1;\n\t\t\t\tbreak;\n\t\t\tcase SSDP_ROOTDEVICE:\n\t\t\t\tmatched =\n\t\t\t\t    (event.RequestType == SSDP_ROOTDEVICE);\n\t\t\t\tbreak;\n\t\t\tcase SSDP_DEVICEUDN:\n\t\t\t\tmatched = !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t   hdr_value.buf,\n\t\t\t\t\t\t   hdr_value.length);\n\t\t\t\tbreak;\n\t\t\tcase SSDP_DEVICETYPE:{\n\t\t\t\t\tsize_t m = min(hdr_value.length,\n\t\t\t\t\t\t       strlen\n\t\t\t\t\t\t       (searchArg->searchTarget));\n\t\t\t\t\tmatched =\n\t\t\t\t\t    !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t     hdr_value.buf, m);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase SSDP_SERVICE:{\n\t\t\t\t\tsize_t m = min(hdr_value.length,\n\t\t\t\t\t\t       strlen\n\t\t\t\t\t\t       (searchArg->searchTarget));\n\t\t\t\t\tmatched =\n\t\t\t\t\t    !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t     hdr_value.buf, m);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tmatched = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (matched) {\n\t\t\t\t/* schedule call back */\n\t\t\t\tthreadData = SSDPResultData_new();\n\t\t\t\tif (threadData != NULL) {\n\t\t\t\t\tSSDPResultData_set_Param(threadData,\n\t\t\t\t\t\t\t\t param);\n\t\t\t\t\tSSDPResultData_set_Cookie(threadData,\n\t\t\t\t\t\t\t\t  searchArg->\n\t\t\t\t\t\t\t\t  cookie);\n\t\t\t\t\tSSDPResultData_set_CtrlptCallback\n\t\t\t\t\t    (threadData, ctrlpt_callback);\n\t\t\t\t\tTPJobInit(&job, (start_routine)\n\t\t\t\t\t\t  send_search_result,\n\t\t\t\t\t\t  threadData);\n\t\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\t\tTPJobSetFreeFunction(&job,\n\t\t\t\t\t\t\t     (free_routine)\n\t\t\t\t\t\t\t     free);\n\t\t\t\t\tif (ThreadPoolAdd(&gRecvThreadPool, &job, NULL) != 0) {\n\t\t\t\t\t\tSSDPResultData_delete(threadData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = ListNext(&ctrlpt_info->SsdpSearchList, node);\n\t\t}\n\n\t\tHandleUnlock();\n\t\t/*ctrlpt_callback( UPNP_DISCOVERY_SEARCH_RESULT, param, cookie ); */\n\t}\n\nend_ssdp_handle_ctrlpt_msg:\n\tUpnpDiscovery_delete(param);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_event_handler",
          "args": [
            "the_data"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "start_event_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "629-665",
          "snippet": "static UPNP_INLINE int start_event_handler(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *Data)\n{\n\thttp_parser_t *parser = NULL;\n\tparse_status_t status;\n\tssdp_thread_data *data = (ssdp_thread_data *) Data;\n\n\tparser = &data->parser;\n\tstatus = parser_parse(parser);\n\tif (status == (parse_status_t)PARSE_FAILURE) {\n\t\tif (parser->msg.method != (http_method_t)HTTPMETHOD_NOTIFY ||\n\t\t    !parser->valid_ssdp_notify_hack) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \"SSDP recvd bad msg code = %d\\n\", status);\n\t\t\t/* ignore bad msg, or not enuf mem */\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* valid notify msg */\n\t} else if (status != (parse_status_t)PARSE_SUCCESS) {\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"SSDP recvd bad msg code = %d\\n\", status);\n\n\t\tgoto error_handler;\n\t}\n\t/* check msg */\n\tif (valid_ssdp_msg(&parser->msg) != TRUE) {\n\t\tgoto error_handler;\n\t}\n\t/* done; thread will free 'data' */\n\treturn 0;\n\n error_handler:\n\tfree_ssdp_event_handler_data(data);\n\treturn -1;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic UPNP_INLINE int start_event_handler(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *Data)\n{\n\thttp_parser_t *parser = NULL;\n\tparse_status_t status;\n\tssdp_thread_data *data = (ssdp_thread_data *) Data;\n\n\tparser = &data->parser;\n\tstatus = parser_parse(parser);\n\tif (status == (parse_status_t)PARSE_FAILURE) {\n\t\tif (parser->msg.method != (http_method_t)HTTPMETHOD_NOTIFY ||\n\t\t    !parser->valid_ssdp_notify_hack) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \"SSDP recvd bad msg code = %d\\n\", status);\n\t\t\t/* ignore bad msg, or not enuf mem */\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* valid notify msg */\n\t} else if (status != (parse_status_t)PARSE_SUCCESS) {\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"SSDP recvd bad msg code = %d\\n\", status);\n\n\t\tgoto error_handler;\n\t}\n\t/* check msg */\n\tif (valid_ssdp_msg(&parser->msg) != TRUE) {\n\t\tgoto error_handler;\n\t}\n\t/* done; thread will free 'data' */\n\treturn 0;\n\n error_handler:\n\tfree_ssdp_event_handler_data(data);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic void ssdp_event_handler_thread(\n\t/*! [] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\thttp_message_t *hmsg = &data->parser.msg;\n\n\tif (start_event_handler(the_data) != 0)\n\t\treturn;\n\t/* send msg to device or ctrlpt */\n\tif (hmsg->method == (http_method_t)HTTPMETHOD_NOTIFY ||\n\t    hmsg->request_method == (http_method_t)HTTPMETHOD_MSEARCH) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\tssdp_handle_ctrlpt_msg(hmsg,\n\t\t\t\t       &data->dest_addr,\n\t\t\t\t       FALSE, NULL);\n#endif /* INCLUDE_CLIENT_APIS */\n\t} else {\n\t\tssdp_handle_device_request(hmsg,\n\t\t\t\t\t   &data->dest_addr);\n\t}\n\n\t/* free data */\n\tfree_ssdp_event_handler_data(data);\n}"
  },
  {
    "function_name": "start_event_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "629-665",
    "snippet": "static UPNP_INLINE int start_event_handler(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *Data)\n{\n\thttp_parser_t *parser = NULL;\n\tparse_status_t status;\n\tssdp_thread_data *data = (ssdp_thread_data *) Data;\n\n\tparser = &data->parser;\n\tstatus = parser_parse(parser);\n\tif (status == (parse_status_t)PARSE_FAILURE) {\n\t\tif (parser->msg.method != (http_method_t)HTTPMETHOD_NOTIFY ||\n\t\t    !parser->valid_ssdp_notify_hack) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \"SSDP recvd bad msg code = %d\\n\", status);\n\t\t\t/* ignore bad msg, or not enuf mem */\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* valid notify msg */\n\t} else if (status != (parse_status_t)PARSE_SUCCESS) {\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"SSDP recvd bad msg code = %d\\n\", status);\n\n\t\tgoto error_handler;\n\t}\n\t/* check msg */\n\tif (valid_ssdp_msg(&parser->msg) != TRUE) {\n\t\tgoto error_handler;\n\t}\n\t/* done; thread will free 'data' */\n\treturn 0;\n\n error_handler:\n\tfree_ssdp_event_handler_data(data);\n\treturn -1;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ssdp_event_handler_data",
          "args": [
            "data"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "free_ssdp_event_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "565-578",
          "snippet": "static void free_ssdp_event_handler_data(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\n\tif (data != NULL) {\n\t\thttp_message_t *hmsg = &data->parser.msg;\n\t\t/* free data */\n\t\thttpmsg_destroy(hmsg);\n\t\tfree(data);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic void free_ssdp_event_handler_data(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\n\tif (data != NULL) {\n\t\thttp_message_t *hmsg = &data->parser.msg;\n\t\t/* free data */\n\t\thttpmsg_destroy(hmsg);\n\t\tfree(data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_ssdp_msg",
          "args": [
            "&parser->msg"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "valid_ssdp_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "585-621",
          "snippet": "static UPNP_INLINE int valid_ssdp_msg(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\thttp_message_t * hmsg)\n{\n\tmemptr hdr_value;\n\n\t/* check for valid methods - NOTIFY or M-SEARCH */\n\tif (hmsg->method != (http_method_t)HTTPMETHOD_NOTIFY &&\n\t    hmsg->method != (http_method_t)HTTPMETHOD_MSEARCH &&\n\t    hmsg->request_method != (http_method_t)HTTPMETHOD_MSEARCH) {\n\t\treturn FALSE;\n\t}\n\tif (hmsg->request_method != (http_method_t)HTTPMETHOD_MSEARCH) {\n\t\t/* check PATH == \"*\" */\n\t\tif (hmsg->uri.type != (enum uriType)RELATIVE ||\n\t\t    strncmp(\"*\", hmsg->uri.pathquery.buff,\n\t\t\t    hmsg->uri.pathquery.size) != 0) {\n\t\t\treturn FALSE;\n\t\t}\n\t\t/* check HOST header */\n\t\tif (httpmsg_find_hdr(hmsg, HDR_HOST, &hdr_value) == NULL ||\n\t\t    (memptr_cmp(&hdr_value, \"239.255.255.250:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[FF02::C]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[ff02::c]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[FF05::C]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[ff05::c]:1900\") != 0)) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \"Invalid HOST header from SSDP message\\n\");\n\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* passed quick check */\n\treturn TRUE;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic UPNP_INLINE int valid_ssdp_msg(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\thttp_message_t * hmsg)\n{\n\tmemptr hdr_value;\n\n\t/* check for valid methods - NOTIFY or M-SEARCH */\n\tif (hmsg->method != (http_method_t)HTTPMETHOD_NOTIFY &&\n\t    hmsg->method != (http_method_t)HTTPMETHOD_MSEARCH &&\n\t    hmsg->request_method != (http_method_t)HTTPMETHOD_MSEARCH) {\n\t\treturn FALSE;\n\t}\n\tif (hmsg->request_method != (http_method_t)HTTPMETHOD_MSEARCH) {\n\t\t/* check PATH == \"*\" */\n\t\tif (hmsg->uri.type != (enum uriType)RELATIVE ||\n\t\t    strncmp(\"*\", hmsg->uri.pathquery.buff,\n\t\t\t    hmsg->uri.pathquery.size) != 0) {\n\t\t\treturn FALSE;\n\t\t}\n\t\t/* check HOST header */\n\t\tif (httpmsg_find_hdr(hmsg, HDR_HOST, &hdr_value) == NULL ||\n\t\t    (memptr_cmp(&hdr_value, \"239.255.255.250:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[FF02::C]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[ff02::c]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[FF05::C]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[ff05::c]:1900\") != 0)) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \"Invalid HOST header from SSDP message\\n\");\n\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* passed quick check */\n\treturn TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "SSDP",
            "__FILE__",
            "__LINE__",
            "\"SSDP recvd bad msg code = %d\\n\"",
            "status"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse",
          "args": [
            "parser"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "2012-2054",
          "snippet": "parse_status_t\nparser_parse( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    /*takes an http_parser_t with memory already allocated  */\n    /*in the message  */\n    assert( parser != NULL );\n\n    do {\n        switch ( parser->position ) {\n            case POS_ENTITY:\n                status = parser_parse_entity( parser );\n\n                break;\n\n            case POS_HEADERS:\n                status = parser_parse_headers( parser );\n\n                break;\n\n            case POS_REQUEST_LINE:\n                status = parser_parse_requestline( parser );\n\n                break;\n\n            case POS_RESPONSE_LINE:\n                status = parser_parse_responseline( parser );\n\n                break;\n\n            default:\n                {\n                    status = PARSE_FAILURE;\n                    assert( 0 );\n                }\n        }\n\n    } while( status == ( parse_status_t ) PARSE_OK );\n\n    return status;\n\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nparser_parse( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    /*takes an http_parser_t with memory already allocated  */\n    /*in the message  */\n    assert( parser != NULL );\n\n    do {\n        switch ( parser->position ) {\n            case POS_ENTITY:\n                status = parser_parse_entity( parser );\n\n                break;\n\n            case POS_HEADERS:\n                status = parser_parse_headers( parser );\n\n                break;\n\n            case POS_REQUEST_LINE:\n                status = parser_parse_requestline( parser );\n\n                break;\n\n            case POS_RESPONSE_LINE:\n                status = parser_parse_responseline( parser );\n\n                break;\n\n            default:\n                {\n                    status = PARSE_FAILURE;\n                    assert( 0 );\n                }\n        }\n\n    } while( status == ( parse_status_t ) PARSE_OK );\n\n    return status;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic UPNP_INLINE int start_event_handler(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *Data)\n{\n\thttp_parser_t *parser = NULL;\n\tparse_status_t status;\n\tssdp_thread_data *data = (ssdp_thread_data *) Data;\n\n\tparser = &data->parser;\n\tstatus = parser_parse(parser);\n\tif (status == (parse_status_t)PARSE_FAILURE) {\n\t\tif (parser->msg.method != (http_method_t)HTTPMETHOD_NOTIFY ||\n\t\t    !parser->valid_ssdp_notify_hack) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \"SSDP recvd bad msg code = %d\\n\", status);\n\t\t\t/* ignore bad msg, or not enuf mem */\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* valid notify msg */\n\t} else if (status != (parse_status_t)PARSE_SUCCESS) {\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"SSDP recvd bad msg code = %d\\n\", status);\n\n\t\tgoto error_handler;\n\t}\n\t/* check msg */\n\tif (valid_ssdp_msg(&parser->msg) != TRUE) {\n\t\tgoto error_handler;\n\t}\n\t/* done; thread will free 'data' */\n\treturn 0;\n\n error_handler:\n\tfree_ssdp_event_handler_data(data);\n\treturn -1;\n}"
  },
  {
    "function_name": "valid_ssdp_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "585-621",
    "snippet": "static UPNP_INLINE int valid_ssdp_msg(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\thttp_message_t * hmsg)\n{\n\tmemptr hdr_value;\n\n\t/* check for valid methods - NOTIFY or M-SEARCH */\n\tif (hmsg->method != (http_method_t)HTTPMETHOD_NOTIFY &&\n\t    hmsg->method != (http_method_t)HTTPMETHOD_MSEARCH &&\n\t    hmsg->request_method != (http_method_t)HTTPMETHOD_MSEARCH) {\n\t\treturn FALSE;\n\t}\n\tif (hmsg->request_method != (http_method_t)HTTPMETHOD_MSEARCH) {\n\t\t/* check PATH == \"*\" */\n\t\tif (hmsg->uri.type != (enum uriType)RELATIVE ||\n\t\t    strncmp(\"*\", hmsg->uri.pathquery.buff,\n\t\t\t    hmsg->uri.pathquery.size) != 0) {\n\t\t\treturn FALSE;\n\t\t}\n\t\t/* check HOST header */\n\t\tif (httpmsg_find_hdr(hmsg, HDR_HOST, &hdr_value) == NULL ||\n\t\t    (memptr_cmp(&hdr_value, \"239.255.255.250:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[FF02::C]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[ff02::c]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[FF05::C]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[ff05::c]:1900\") != 0)) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \"Invalid HOST header from SSDP message\\n\");\n\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* passed quick check */\n\treturn TRUE;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "SSDP",
            "__FILE__",
            "__LINE__",
            "\"Invalid HOST header from SSDP message\\n\""
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memptr_cmp",
          "args": [
            "&hdr_value",
            "\"[ff05::c]:1900\""
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "memptr_cmp_nocase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "78-90",
          "snippet": "int memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "hmsg",
            "HDR_HOST",
            "&hdr_value"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"*\"",
            "hmsg->uri.pathquery.buff",
            "hmsg->uri.pathquery.size"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic UPNP_INLINE int valid_ssdp_msg(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\thttp_message_t * hmsg)\n{\n\tmemptr hdr_value;\n\n\t/* check for valid methods - NOTIFY or M-SEARCH */\n\tif (hmsg->method != (http_method_t)HTTPMETHOD_NOTIFY &&\n\t    hmsg->method != (http_method_t)HTTPMETHOD_MSEARCH &&\n\t    hmsg->request_method != (http_method_t)HTTPMETHOD_MSEARCH) {\n\t\treturn FALSE;\n\t}\n\tif (hmsg->request_method != (http_method_t)HTTPMETHOD_MSEARCH) {\n\t\t/* check PATH == \"*\" */\n\t\tif (hmsg->uri.type != (enum uriType)RELATIVE ||\n\t\t    strncmp(\"*\", hmsg->uri.pathquery.buff,\n\t\t\t    hmsg->uri.pathquery.size) != 0) {\n\t\t\treturn FALSE;\n\t\t}\n\t\t/* check HOST header */\n\t\tif (httpmsg_find_hdr(hmsg, HDR_HOST, &hdr_value) == NULL ||\n\t\t    (memptr_cmp(&hdr_value, \"239.255.255.250:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[FF02::C]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[ff02::c]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[FF05::C]:1900\") != 0 &&\n\t\t     memptr_cmp(&hdr_value, \"[ff05::c]:1900\") != 0)) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \"Invalid HOST header from SSDP message\\n\");\n\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* passed quick check */\n\treturn TRUE;\n}"
  },
  {
    "function_name": "free_ssdp_event_handler_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "565-578",
    "snippet": "static void free_ssdp_event_handler_data(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\n\tif (data != NULL) {\n\t\thttp_message_t *hmsg = &data->parser.msg;\n\t\t/* free data */\n\t\thttpmsg_destroy(hmsg);\n\t\tfree(data);\n\t}\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "free_ssdp_event_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "565-578",
          "snippet": "static void free_ssdp_event_handler_data(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\n\tif (data != NULL) {\n\t\thttp_message_t *hmsg = &data->parser.msg;\n\t\t/* free data */\n\t\thttpmsg_destroy(hmsg);\n\t\tfree(data);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "hmsg"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic void free_ssdp_event_handler_data(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\n\tif (data != NULL) {\n\t\thttp_message_t *hmsg = &data->parser.msg;\n\t\t/* free data */\n\t\thttpmsg_destroy(hmsg);\n\t\tfree(data);\n\t}\n}"
  },
  {
    "function_name": "ssdp_request_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "549-560",
    "snippet": "int ssdp_request_type(char *cmd, SsdpEvent *Evt)\n{\n\t/* clear event */\n\tmemset(Evt, 0, sizeof(SsdpEvent));\n\tunique_service_name(cmd, Evt);\n\tEvt->ErrCode = NO_ERROR_FOUND;\n\tif ((Evt->RequestType = ssdp_request_type1(cmd)) == SSDP_SERROR) {\n\t\tEvt->ErrCode = E_HTTP_SYNTEX;\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssdp_request_type1",
          "args": [
            "cmd"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "ssdp_request_type1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "534-547",
          "snippet": "enum SsdpSearchType ssdp_request_type1(char *cmd)\n{\n\tif (strstr(cmd, \":all\"))\n\t\treturn SSDP_ALL;\n\tif (strstr(cmd, \":rootdevice\"))\n\t\treturn SSDP_ROOTDEVICE;\n\tif (strstr(cmd, \"uuid:\"))\n\t\treturn SSDP_DEVICEUDN;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":device:\"))\n\t\treturn SSDP_DEVICETYPE;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":service:\"))\n\t\treturn SSDP_SERVICE;\n\treturn SSDP_SERROR;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nenum SsdpSearchType ssdp_request_type1(char *cmd)\n{\n\tif (strstr(cmd, \":all\"))\n\t\treturn SSDP_ALL;\n\tif (strstr(cmd, \":rootdevice\"))\n\t\treturn SSDP_ROOTDEVICE;\n\tif (strstr(cmd, \"uuid:\"))\n\t\treturn SSDP_DEVICEUDN;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":device:\"))\n\t\treturn SSDP_DEVICETYPE;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":service:\"))\n\t\treturn SSDP_SERVICE;\n\treturn SSDP_SERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unique_service_name",
          "args": [
            "cmd",
            "Evt"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "unique_service_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "448-532",
          "snippet": "int unique_service_name(char *cmd, SsdpEvent *Evt)\n{\n\tchar TempBuf[COMMAND_LEN];\n\tchar *TempPtr = NULL;\n\tchar *Ptr = NULL;\n\tchar *ptr1 = NULL;\n\tchar *ptr2 = NULL;\n\tchar *ptr3 = NULL;\n\tint CommandFound = 0;\n\tsize_t n = (size_t)0;\n\n\tif (strstr(cmd, \"uuid:schemas\") != NULL) {\n\t\tptr1 = strstr(cmd, \":device\");\n\t\tif (ptr1 != NULL)\n\t\t\tptr2 = strstr(ptr1 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr2 != NULL)\n\t\t\tptr3 = strstr(ptr2 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr3 != NULL) {\n\t\t\tif (strlen(\"uuid:\") + strlen(ptr3 + 1) >= sizeof Evt->UDN)\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->UDN, sizeof Evt->UDN, \"uuid:%s\", ptr3 + 1);\n\t\t}\n\t\telse\n\t\t\treturn -1;\n\t\tptr1 = strstr(cmd, \":\");\n\t\tif (ptr1 != NULL) {\n\t\t\tn = (size_t)ptr3 - (size_t)ptr1;\n\t\t\tn = n >= sizeof TempBuf ? sizeof TempBuf - 1 : n;\n\t\t\tstrncpy(TempBuf, ptr1, n);\n\t\t\tTempBuf[n] = '\\0';\n\t\t\tif (strlen(\"urn\") + strlen(TempBuf) >= sizeof(Evt->DeviceType))\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->DeviceType, sizeof(Evt->DeviceType),\n\t\t\t\t\"urn%s\", TempBuf);\n\t\t} else\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tif ((TempPtr = strstr(cmd, \"uuid\")) != NULL) {\n\t\tif ((Ptr = strstr(cmd, \"::\")) != NULL) {\n\t\t\tn = (size_t)Ptr - (size_t)TempPtr;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, TempPtr, n);\n\t\t\tEvt->UDN[n] = '\\0';\n\t\t} else {\n\t\t\tmemset(Evt->UDN, 0, sizeof(Evt->UDN));\n\t\t\tstrncpy(Evt->UDN, TempPtr, sizeof Evt->UDN - 1);\n\t\t}\n\t\tCommandFound = 1;\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":service:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->ServiceType, 0, sizeof Evt->ServiceType);\n\t\t\tstrncpy(Evt->ServiceType, TempPtr,\n\t\t\t\tsizeof Evt->ServiceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":device:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->DeviceType, 0, sizeof Evt->DeviceType);\n\t\t\tstrncpy(Evt->DeviceType, TempPtr,\n\t\t\t\tsizeof Evt->DeviceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif ((TempPtr = strstr(cmd, \"::upnp:rootdevice\")) != NULL) {\n\t\t/* Everything before \"::upnp::rootdevice\" is the UDN. */\n\t\tif (TempPtr != cmd) {\n\t\t\tn = (size_t)TempPtr - (size_t)cmd;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, cmd, n);\n\t\t\tEvt->UDN[n] = 0;\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (CommandFound == 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\n#define snprintf _snprintf\n\nint unique_service_name(char *cmd, SsdpEvent *Evt)\n{\n\tchar TempBuf[COMMAND_LEN];\n\tchar *TempPtr = NULL;\n\tchar *Ptr = NULL;\n\tchar *ptr1 = NULL;\n\tchar *ptr2 = NULL;\n\tchar *ptr3 = NULL;\n\tint CommandFound = 0;\n\tsize_t n = (size_t)0;\n\n\tif (strstr(cmd, \"uuid:schemas\") != NULL) {\n\t\tptr1 = strstr(cmd, \":device\");\n\t\tif (ptr1 != NULL)\n\t\t\tptr2 = strstr(ptr1 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr2 != NULL)\n\t\t\tptr3 = strstr(ptr2 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr3 != NULL) {\n\t\t\tif (strlen(\"uuid:\") + strlen(ptr3 + 1) >= sizeof Evt->UDN)\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->UDN, sizeof Evt->UDN, \"uuid:%s\", ptr3 + 1);\n\t\t}\n\t\telse\n\t\t\treturn -1;\n\t\tptr1 = strstr(cmd, \":\");\n\t\tif (ptr1 != NULL) {\n\t\t\tn = (size_t)ptr3 - (size_t)ptr1;\n\t\t\tn = n >= sizeof TempBuf ? sizeof TempBuf - 1 : n;\n\t\t\tstrncpy(TempBuf, ptr1, n);\n\t\t\tTempBuf[n] = '\\0';\n\t\t\tif (strlen(\"urn\") + strlen(TempBuf) >= sizeof(Evt->DeviceType))\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->DeviceType, sizeof(Evt->DeviceType),\n\t\t\t\t\"urn%s\", TempBuf);\n\t\t} else\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tif ((TempPtr = strstr(cmd, \"uuid\")) != NULL) {\n\t\tif ((Ptr = strstr(cmd, \"::\")) != NULL) {\n\t\t\tn = (size_t)Ptr - (size_t)TempPtr;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, TempPtr, n);\n\t\t\tEvt->UDN[n] = '\\0';\n\t\t} else {\n\t\t\tmemset(Evt->UDN, 0, sizeof(Evt->UDN));\n\t\t\tstrncpy(Evt->UDN, TempPtr, sizeof Evt->UDN - 1);\n\t\t}\n\t\tCommandFound = 1;\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":service:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->ServiceType, 0, sizeof Evt->ServiceType);\n\t\t\tstrncpy(Evt->ServiceType, TempPtr,\n\t\t\t\tsizeof Evt->ServiceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":device:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->DeviceType, 0, sizeof Evt->DeviceType);\n\t\t\tstrncpy(Evt->DeviceType, TempPtr,\n\t\t\t\tsizeof Evt->DeviceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif ((TempPtr = strstr(cmd, \"::upnp:rootdevice\")) != NULL) {\n\t\t/* Everything before \"::upnp::rootdevice\" is the UDN. */\n\t\tif (TempPtr != cmd) {\n\t\t\tn = (size_t)TempPtr - (size_t)cmd;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, cmd, n);\n\t\t\tEvt->UDN[n] = 0;\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (CommandFound == 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Evt",
            "0",
            "sizeof(SsdpEvent)"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nint ssdp_request_type(char *cmd, SsdpEvent *Evt)\n{\n\t/* clear event */\n\tmemset(Evt, 0, sizeof(SsdpEvent));\n\tunique_service_name(cmd, Evt);\n\tEvt->ErrCode = NO_ERROR_FOUND;\n\tif ((Evt->RequestType = ssdp_request_type1(cmd)) == SSDP_SERROR) {\n\t\tEvt->ErrCode = E_HTTP_SYNTEX;\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ssdp_request_type1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "534-547",
    "snippet": "enum SsdpSearchType ssdp_request_type1(char *cmd)\n{\n\tif (strstr(cmd, \":all\"))\n\t\treturn SSDP_ALL;\n\tif (strstr(cmd, \":rootdevice\"))\n\t\treturn SSDP_ROOTDEVICE;\n\tif (strstr(cmd, \"uuid:\"))\n\t\treturn SSDP_DEVICEUDN;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":device:\"))\n\t\treturn SSDP_DEVICETYPE;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":service:\"))\n\t\treturn SSDP_SERVICE;\n\treturn SSDP_SERROR;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\":service:\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"urn:\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\":device:\""
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"urn:\""
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"uuid:\""
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\":rootdevice\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\":all\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nenum SsdpSearchType ssdp_request_type1(char *cmd)\n{\n\tif (strstr(cmd, \":all\"))\n\t\treturn SSDP_ALL;\n\tif (strstr(cmd, \":rootdevice\"))\n\t\treturn SSDP_ROOTDEVICE;\n\tif (strstr(cmd, \"uuid:\"))\n\t\treturn SSDP_DEVICEUDN;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":device:\"))\n\t\treturn SSDP_DEVICETYPE;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":service:\"))\n\t\treturn SSDP_SERVICE;\n\treturn SSDP_SERROR;\n}"
  },
  {
    "function_name": "unique_service_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "448-532",
    "snippet": "int unique_service_name(char *cmd, SsdpEvent *Evt)\n{\n\tchar TempBuf[COMMAND_LEN];\n\tchar *TempPtr = NULL;\n\tchar *Ptr = NULL;\n\tchar *ptr1 = NULL;\n\tchar *ptr2 = NULL;\n\tchar *ptr3 = NULL;\n\tint CommandFound = 0;\n\tsize_t n = (size_t)0;\n\n\tif (strstr(cmd, \"uuid:schemas\") != NULL) {\n\t\tptr1 = strstr(cmd, \":device\");\n\t\tif (ptr1 != NULL)\n\t\t\tptr2 = strstr(ptr1 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr2 != NULL)\n\t\t\tptr3 = strstr(ptr2 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr3 != NULL) {\n\t\t\tif (strlen(\"uuid:\") + strlen(ptr3 + 1) >= sizeof Evt->UDN)\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->UDN, sizeof Evt->UDN, \"uuid:%s\", ptr3 + 1);\n\t\t}\n\t\telse\n\t\t\treturn -1;\n\t\tptr1 = strstr(cmd, \":\");\n\t\tif (ptr1 != NULL) {\n\t\t\tn = (size_t)ptr3 - (size_t)ptr1;\n\t\t\tn = n >= sizeof TempBuf ? sizeof TempBuf - 1 : n;\n\t\t\tstrncpy(TempBuf, ptr1, n);\n\t\t\tTempBuf[n] = '\\0';\n\t\t\tif (strlen(\"urn\") + strlen(TempBuf) >= sizeof(Evt->DeviceType))\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->DeviceType, sizeof(Evt->DeviceType),\n\t\t\t\t\"urn%s\", TempBuf);\n\t\t} else\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tif ((TempPtr = strstr(cmd, \"uuid\")) != NULL) {\n\t\tif ((Ptr = strstr(cmd, \"::\")) != NULL) {\n\t\t\tn = (size_t)Ptr - (size_t)TempPtr;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, TempPtr, n);\n\t\t\tEvt->UDN[n] = '\\0';\n\t\t} else {\n\t\t\tmemset(Evt->UDN, 0, sizeof(Evt->UDN));\n\t\t\tstrncpy(Evt->UDN, TempPtr, sizeof Evt->UDN - 1);\n\t\t}\n\t\tCommandFound = 1;\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":service:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->ServiceType, 0, sizeof Evt->ServiceType);\n\t\t\tstrncpy(Evt->ServiceType, TempPtr,\n\t\t\t\tsizeof Evt->ServiceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":device:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->DeviceType, 0, sizeof Evt->DeviceType);\n\t\t\tstrncpy(Evt->DeviceType, TempPtr,\n\t\t\t\tsizeof Evt->DeviceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif ((TempPtr = strstr(cmd, \"::upnp:rootdevice\")) != NULL) {\n\t\t/* Everything before \"::upnp::rootdevice\" is the UDN. */\n\t\tif (TempPtr != cmd) {\n\t\t\tn = (size_t)TempPtr - (size_t)cmd;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, cmd, n);\n\t\t\tEvt->UDN[n] = 0;\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (CommandFound == 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Evt->UDN",
            "cmd",
            "n"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"::upnp:rootdevice\""
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Evt->DeviceType",
            "TempPtr",
            "sizeof Evt->DeviceType - 1"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Evt->DeviceType",
            "0",
            "sizeof Evt->DeviceType"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"urn\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\":device:\""
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"urn:\""
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Evt->ServiceType",
            "TempPtr",
            "sizeof Evt->ServiceType - 1"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"urn\""
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\":service:\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"urn:\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Evt->UDN",
            "TempPtr",
            "sizeof Evt->UDN - 1"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "Evt->UDN",
            "TempPtr",
            "n"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"::\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"uuid\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "Evt->DeviceType",
            "sizeof(Evt->DeviceType)",
            "\"urn%s\"",
            "TempBuf"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TempBuf"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"urn\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "TempBuf",
            "ptr1",
            "n"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\":\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "Evt->UDN",
            "sizeof Evt->UDN",
            "\"uuid:%s\"",
            "ptr3 + 1"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr3 + 1"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"uuid:\""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "ptr2 + 1",
            "\":\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "ptr1 + 1",
            "\":\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\":device\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"uuid:schemas\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\n#define snprintf _snprintf\n\nint unique_service_name(char *cmd, SsdpEvent *Evt)\n{\n\tchar TempBuf[COMMAND_LEN];\n\tchar *TempPtr = NULL;\n\tchar *Ptr = NULL;\n\tchar *ptr1 = NULL;\n\tchar *ptr2 = NULL;\n\tchar *ptr3 = NULL;\n\tint CommandFound = 0;\n\tsize_t n = (size_t)0;\n\n\tif (strstr(cmd, \"uuid:schemas\") != NULL) {\n\t\tptr1 = strstr(cmd, \":device\");\n\t\tif (ptr1 != NULL)\n\t\t\tptr2 = strstr(ptr1 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr2 != NULL)\n\t\t\tptr3 = strstr(ptr2 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr3 != NULL) {\n\t\t\tif (strlen(\"uuid:\") + strlen(ptr3 + 1) >= sizeof Evt->UDN)\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->UDN, sizeof Evt->UDN, \"uuid:%s\", ptr3 + 1);\n\t\t}\n\t\telse\n\t\t\treturn -1;\n\t\tptr1 = strstr(cmd, \":\");\n\t\tif (ptr1 != NULL) {\n\t\t\tn = (size_t)ptr3 - (size_t)ptr1;\n\t\t\tn = n >= sizeof TempBuf ? sizeof TempBuf - 1 : n;\n\t\t\tstrncpy(TempBuf, ptr1, n);\n\t\t\tTempBuf[n] = '\\0';\n\t\t\tif (strlen(\"urn\") + strlen(TempBuf) >= sizeof(Evt->DeviceType))\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->DeviceType, sizeof(Evt->DeviceType),\n\t\t\t\t\"urn%s\", TempBuf);\n\t\t} else\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tif ((TempPtr = strstr(cmd, \"uuid\")) != NULL) {\n\t\tif ((Ptr = strstr(cmd, \"::\")) != NULL) {\n\t\t\tn = (size_t)Ptr - (size_t)TempPtr;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, TempPtr, n);\n\t\t\tEvt->UDN[n] = '\\0';\n\t\t} else {\n\t\t\tmemset(Evt->UDN, 0, sizeof(Evt->UDN));\n\t\t\tstrncpy(Evt->UDN, TempPtr, sizeof Evt->UDN - 1);\n\t\t}\n\t\tCommandFound = 1;\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":service:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->ServiceType, 0, sizeof Evt->ServiceType);\n\t\t\tstrncpy(Evt->ServiceType, TempPtr,\n\t\t\t\tsizeof Evt->ServiceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":device:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->DeviceType, 0, sizeof Evt->DeviceType);\n\t\t\tstrncpy(Evt->DeviceType, TempPtr,\n\t\t\t\tsizeof Evt->DeviceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif ((TempPtr = strstr(cmd, \"::upnp:rootdevice\")) != NULL) {\n\t\t/* Everything before \"::upnp::rootdevice\" is the UDN. */\n\t\tif (TempPtr != cmd) {\n\t\t\tn = (size_t)TempPtr - (size_t)cmd;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, cmd, n);\n\t\t\tEvt->UDN[n] = 0;\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (CommandFound == 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "AdvertiseAndReply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
    "lines": "92-445",
    "snippet": "int AdvertiseAndReply(int AdFlag, UpnpDevice_Handle Hnd,\n\t\t      enum SsdpSearchType SearchType,\n\t\t      struct sockaddr *DestAddr, char *DeviceType,\n\t\t      char *DeviceUDN, char *ServiceType, int Exp)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tlong unsigned int i;\n\tlong unsigned int j;\n\tint defaultExp = DEFAULT_MAXAGE;\n\tstruct Handle_Info *SInfo = NULL;\n\tchar UDNstr[100];\n\tchar devType[100];\n\tchar servType[100];\n\tIXML_NodeList *nodeList = NULL;\n\tIXML_NodeList *tmpNodeList = NULL;\n\tIXML_Node *tmpNode = NULL;\n\tIXML_Node *tmpNode2 = NULL;\n\tIXML_Node *textNode = NULL;\n\tconst DOMString tmpStr;\n\tconst DOMString dbgStr;\n\tint NumCopy = 0;\n\n\tmemset(UDNstr, 0, sizeof(UDNstr));\n\tmemset(devType, 0, sizeof(devType));\n\tmemset(servType, 0, sizeof(servType));\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside AdvertiseAndReply with AdFlag = %d\\n\", AdFlag);\n\n\t/* Use a read lock */\n\tHandleReadLock();\n\tif (GetHandleInfo(Hnd, &SInfo) != HND_DEVICE) {\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto end_function;\n\t}\n\tdefaultExp = SInfo->MaxAge;\n\t/* parse the device list and send advertisements/replies */\n\twhile (NumCopy == 0 || (AdFlag && NumCopy < NUM_SSDP_COPY)) {\n\t\tif (NumCopy != 0)\n\t\t\timillisleep(SSDP_PAUSE);\n\t\tNumCopy++;\n\t\tfor (i = 0lu;; i++) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Entering new device list with i = %lu\\n\\n\",\n\t\t\t\t   i);\n\t\t\ttmpNode = ixmlNodeList_item(SInfo->DeviceList, i);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Exiting new device list with i = %lu\\n\\n\",\n\t\t\t\t\t   i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type once for %s\\n\",\n\t\t\t\t   dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"deviceType\");\n\t\t\tif (!nodeList)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type\\n\");\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2)\n\t\t\t\tcontinue;\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type \\n\");\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr)\n\t\t\t\tcontinue;\n\t\t\tstrncpy(devType, tmpStr, sizeof(devType) - 1);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type = %s\\n\", devType);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"TempNode is NULL\\n\");\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"UDN\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrncpy(UDNstr, tmpStr, sizeof(UDNstr) - 1);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending UDNStr = %s \\n\", UDNstr);\n\t\t\tif (AdFlag) {\n\t\t\t\t/* send the device advertisement */\n\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\tDeviceAdvertisement(devType, i == 0lu,\n\t\t\t\t\t\t\t    UDNstr,\n\t\t\t\t\t\t\t    SInfo->DescURL, Exp,\n\t\t\t\t\t\t\t    SInfo->DeviceAf,\n\t\t\t\t\t\t\t    SInfo->PowerState,\n\t                                                    SInfo->SleepPeriod,\n\t                                                    SInfo->RegistrationState);\n\t\t\t\t} else {\n\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\tDeviceShutdown(devType, i == 0lu, UDNstr,\n\t\t\t\t\t\t       SInfo->DescURL,\n\t\t\t\t\t\t       Exp, SInfo->DeviceAf,\n\t\t\t\t\t\t       SInfo->PowerState,\n\t\t\t\t\t\t       SInfo->SleepPeriod,\n\t\t\t\t\t\t       SInfo->RegistrationState);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (SearchType) {\n\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\tDeviceReply(DestAddr, devType, i == 0lu,\n\t\t\t\t\t\t    UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t    defaultExp, SInfo->PowerState,\n\t\t\t\t\t\t    SInfo->SleepPeriod,\n\t\t\t\t\t\t    SInfo->RegistrationState);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_ROOTDEVICE:\n\t\t\t\t\tif (i == 0lu) {\n\t\t\t\t\t\tSendReply(DestAddr, devType, 1,\n\t\t\t\t\t\t\t  UDNstr,\n\t\t\t\t\t\t\t  SInfo->DescURL,\n\t\t\t\t\t\t\t  defaultExp, 0,\n\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_DEVICEUDN: {\n\t\t\t\t\tif (DeviceUDN && strlen(DeviceUDN) != (size_t)0) {\n\t\t\t\t\t\tif (strcasecmp(DeviceUDN, UDNstr)) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s DID NOT match\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s MATCH\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tSendReply(DestAddr, devType, 0, UDNstr, SInfo->DescURL, defaultExp, 0,\n\t\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase SSDP_DEVICETYPE: {\n\t\t\t\t\tif (!strncasecmp(DeviceType, devType, strlen(DeviceType) - (size_t)2)) {\n\t\t\t\t\t\tif (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t    < atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\t/* the requested version is lower than the device version\n\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else if (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t\t   == atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* send service advertisements for services corresponding\n\t\t\t * to the same device */\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending service Advertisement\\n\");\n\t\t\t/* Correct service traversal such that each device's serviceList\n\t\t\t * is directly traversed as a child of its parent device. This\n\t\t\t * ensures that the service's alive message uses the UDN of\n\t\t\t * the parent device. */\n\t\t\ttmpNode = ixmlNode_getFirstChild(tmpNode);\n\t\t\twhile (tmpNode) {\n\t\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\t\tif (!strncmp\n\t\t\t\t    (dbgStr, SERVICELIST_STR,\n\t\t\t\t     sizeof SERVICELIST_STR)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmpNode = ixmlNode_getNextSibling(tmpNode);\n\t\t\t}\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tif (!tmpNode) {\n\t\t\t\tnodeList = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"service\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Service not found 3\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j = 0lu;; j++) {\n\t\t\t\ttmpNode = ixmlNodeList_item(nodeList, j);\n\t\t\t\tif (!tmpNode) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\t\ttmpNodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"serviceType\");\n\t\t\t\tif (!tmpNodeList) {\n\t\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t\t   __LINE__,\n\t\t\t\t\t\t   \"ServiceType not found \\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttmpNode2 = ixmlNodeList_item(tmpNodeList, 0lu);\n\t\t\t\tif (!tmpNode2)\n\t\t\t\t\tcontinue;\n\t\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\t\tif (!textNode)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* servType is of format Servicetype:ServiceVersion */\n\t\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\t\tif (!tmpStr)\n\t\t\t\t\tcontinue;\n\t\t\t\tstrncpy(servType, tmpStr, sizeof(servType) - 1);\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"ServiceType = %s\\n\", servType);\n\t\t\t\tif (AdFlag) {\n\t\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\t\tServiceAdvertisement(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\t\tServiceShutdown(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (SearchType) {\n\t\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\t\tServiceReply(DestAddr, servType,\n\t\t\t\t\t\t\t     UDNstr,\n\t\t\t\t\t\t\t     SInfo->DescURL,\n\t\t\t\t\t\t\t     defaultExp,\n\t\t\t\t\t\t\t     SInfo->PowerState,\n\t\t\t\t\t\t\t     SInfo->SleepPeriod,\n\t\t\t\t\t\t\t     SInfo->RegistrationState);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SSDP_SERVICE:\n\t\t\t\t\t\tif (ServiceType) {\n\t\t\t\t\t\t\tif (!strncasecmp(ServiceType, servType, strlen(ServiceType) - (size_t)2)) {\n\t\t\t\t\t\t\t\tif (atoi(strrchr(ServiceType, ':') + 1) <\n\t\t\t\t\t\t\t\t    atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\t/* the requested version is lower than the service version\n\t\t\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else if (atoi(strrchr (ServiceType, ':') + 1) ==\n\t\t\t\t\t\t\t\t\t   atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\ttmpNodeList = NULL;\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = NULL;\n\t\t}\n\t}\n\nend_function:\n\tixmlNodeList_free(tmpNodeList);\n\tixmlNodeList_free(nodeList);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting AdvertiseAndReply.\\n\");\n\tHandleUnlock();\n\n\treturn retVal;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include \"upnpapi.h\"",
      "#include \"ThreadPool.h\"",
      "#include \"sock.h\"",
      "#include \"miniserver.h\"",
      "#include \"membuffer.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ssdplib.h\"",
      "#include \"config.h\"",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "API",
            "__FILE__",
            "__LINE__",
            "\"Exiting AdvertiseAndReply.\\n\""
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_free",
          "args": [
            "nodeList"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_free",
          "args": [
            "tmpNodeList"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_free",
          "args": [
            "nodeList"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_free",
          "args": [
            "tmpNodeList"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReply",
          "args": [
            "DestAddr",
            "ServiceType",
            "0",
            "UDNstr",
            "SInfo->DescURL",
            "defaultExp",
            "1",
            "SInfo->PowerState",
            "SInfo->SleepPeriod",
            "SInfo->RegistrationState"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "SendReply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_device.c",
          "lines": "577-639",
          "snippet": "int SendReply(struct sockaddr *DestAddr, char *DevType, int RootDev,\n\t      char *Udn, char *Location, int Duration, int ByType,\n\t      int PowerState, int SleepPeriod, int RegistrationState)\n{\n\tint ret_code = UPNP_E_OUTOF_MEMORY;\n\tchar *msgs[2];\n\tint num_msgs;\n\tchar Mil_Usn[LINE_SIZE];\n\tint i;\n\tint rc = 0;\n\n\tmsgs[0] = NULL;\n\tmsgs[1] = NULL;\n\tif (RootDev) {\n\t\t/* one msg for root device */\n\t\tnum_msgs = 1;\n\n\t\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::upnp:rootdevice\",\n\t\t\tUdn);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\t\tgoto error_handler;\n\t\tCreateServicePacket(MSGTYPE_REPLY, \"upnp:rootdevice\",\n\t\t\t\t    Mil_Usn, Location, Duration, &msgs[0],\n\t\t\t\t    (int)DestAddr->sa_family, PowerState,\n\t\t\t\t    SleepPeriod, RegistrationState);\n\t} else {\n\t\t/* two msgs for embedded devices */\n\t\tnum_msgs = 1;\n\n\t\t/*NK: FIX for extra response when someone searches by udn */\n\t\tif (!ByType) {\n\t\t\tCreateServicePacket(MSGTYPE_REPLY, Udn, Udn, Location,\n\t\t\t\t\t    Duration, &msgs[0],\n\t\t\t\t\t    (int)DestAddr->sa_family, PowerState,\n\t\t\t\t\t    SleepPeriod, RegistrationState);\n\t\t} else {\n\t\t\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn,\n\t\t\t\tDevType);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\t\t\tgoto error_handler;\n\t\t\tCreateServicePacket(MSGTYPE_REPLY, DevType, Mil_Usn,\n\t\t\t\t\t    Location, Duration, &msgs[0],\n\t\t\t\t\t    (int)DestAddr->sa_family, PowerState,\n\t\t\t\t\t    SleepPeriod, RegistrationState);\n\t\t}\n\t}\n\t/* check error */\n\tfor (i = 0; i < num_msgs; i++) {\n\t\tif (msgs[i] == NULL) {\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\t/* send msgs */\n\tret_code = NewRequestHandler(DestAddr, num_msgs, msgs);\n\nerror_handler:\n\tfor (i = 0; i < num_msgs; i++) {\n\t\tif (msgs[i] != NULL)\n\t\t\tfree(msgs[i]);\n\t}\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"UpnpInet.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MSGTYPE_REPLY\t\t2",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"config.h\"\n\n#define MSGTYPE_REPLY\t\t2\n#define snprintf _snprintf\n\nint SendReply(struct sockaddr *DestAddr, char *DevType, int RootDev,\n\t      char *Udn, char *Location, int Duration, int ByType,\n\t      int PowerState, int SleepPeriod, int RegistrationState)\n{\n\tint ret_code = UPNP_E_OUTOF_MEMORY;\n\tchar *msgs[2];\n\tint num_msgs;\n\tchar Mil_Usn[LINE_SIZE];\n\tint i;\n\tint rc = 0;\n\n\tmsgs[0] = NULL;\n\tmsgs[1] = NULL;\n\tif (RootDev) {\n\t\t/* one msg for root device */\n\t\tnum_msgs = 1;\n\n\t\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::upnp:rootdevice\",\n\t\t\tUdn);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\t\tgoto error_handler;\n\t\tCreateServicePacket(MSGTYPE_REPLY, \"upnp:rootdevice\",\n\t\t\t\t    Mil_Usn, Location, Duration, &msgs[0],\n\t\t\t\t    (int)DestAddr->sa_family, PowerState,\n\t\t\t\t    SleepPeriod, RegistrationState);\n\t} else {\n\t\t/* two msgs for embedded devices */\n\t\tnum_msgs = 1;\n\n\t\t/*NK: FIX for extra response when someone searches by udn */\n\t\tif (!ByType) {\n\t\t\tCreateServicePacket(MSGTYPE_REPLY, Udn, Udn, Location,\n\t\t\t\t\t    Duration, &msgs[0],\n\t\t\t\t\t    (int)DestAddr->sa_family, PowerState,\n\t\t\t\t\t    SleepPeriod, RegistrationState);\n\t\t} else {\n\t\t\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn,\n\t\t\t\tDevType);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\t\t\tgoto error_handler;\n\t\t\tCreateServicePacket(MSGTYPE_REPLY, DevType, Mil_Usn,\n\t\t\t\t\t    Location, Duration, &msgs[0],\n\t\t\t\t\t    (int)DestAddr->sa_family, PowerState,\n\t\t\t\t\t    SleepPeriod, RegistrationState);\n\t\t}\n\t}\n\t/* check error */\n\tfor (i = 0; i < num_msgs; i++) {\n\t\tif (msgs[i] == NULL) {\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\t/* send msgs */\n\tret_code = NewRequestHandler(DestAddr, num_msgs, msgs);\n\nerror_handler:\n\tfor (i = 0; i < num_msgs; i++) {\n\t\tif (msgs[i] != NULL)\n\t\t\tfree(msgs[i]);\n\t}\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "&servType[strlen(servType) - (size_t)1]"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "servType"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "strrchr (ServiceType, ':') + 1"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "ServiceType",
            "':'"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "&servType[strlen(servType) - (size_t)1]"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "servType"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "strrchr(ServiceType, ':') + 1"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "ServiceType",
            "':'"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "ServiceType",
            "servType",
            "strlen(ServiceType) - (size_t)2"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ServiceType"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ServiceReply",
          "args": [
            "DestAddr",
            "servType",
            "UDNstr",
            "SInfo->DescURL",
            "defaultExp",
            "SInfo->PowerState",
            "SInfo->SleepPeriod",
            "SInfo->RegistrationState"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "ServiceReply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_device.c",
          "lines": "755-779",
          "snippet": "int ServiceReply(struct sockaddr *DestAddr, char *ServType, char *Udn,\n\t\t char *Location, int Duration, int PowerState, int SleepPeriod,\n\t\t int RegistrationState)\n{\n\tchar Mil_Usn[LINE_SIZE];\n\tchar *szReq[1];\n\tint RetVal = UPNP_E_OUTOF_MEMORY;\n\tint rc = 0;\n\n\tszReq[0] = NULL;\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, ServType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\tCreateServicePacket(MSGTYPE_REPLY, ServType, Mil_Usn,\n\t\t\t    Location, Duration, &szReq[0], (int)DestAddr->sa_family,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\tif (szReq[0] == NULL)\n\t\tgoto error_handler;\n\tRetVal = NewRequestHandler(DestAddr, 1, szReq);\n\nerror_handler:\n\tfree(szReq[0]);\n\n\treturn RetVal;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"UpnpInet.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MSGTYPE_REPLY\t\t2",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"config.h\"\n\n#define MSGTYPE_REPLY\t\t2\n#define snprintf _snprintf\n\nint ServiceReply(struct sockaddr *DestAddr, char *ServType, char *Udn,\n\t\t char *Location, int Duration, int PowerState, int SleepPeriod,\n\t\t int RegistrationState)\n{\n\tchar Mil_Usn[LINE_SIZE];\n\tchar *szReq[1];\n\tint RetVal = UPNP_E_OUTOF_MEMORY;\n\tint rc = 0;\n\n\tszReq[0] = NULL;\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, ServType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\tCreateServicePacket(MSGTYPE_REPLY, ServType, Mil_Usn,\n\t\t\t    Location, Duration, &szReq[0], (int)DestAddr->sa_family,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\tif (szReq[0] == NULL)\n\t\tgoto error_handler;\n\tRetVal = NewRequestHandler(DestAddr, 1, szReq);\n\nerror_handler:\n\tfree(szReq[0]);\n\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ServiceShutdown",
          "args": [
            "UDNstr",
            "servType",
            "SInfo->DescURL",
            "Exp",
            "SInfo->DeviceAf",
            "SInfo->PowerState",
            "SInfo->SleepPeriod",
            "SInfo->RegistrationState"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "ServiceShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_device.c",
          "lines": "781-830",
          "snippet": "int ServiceShutdown(char *Udn, char *ServType, char *Location, int Duration,\n\t\t    int AddressFamily, int PowerState,\n\t\t    int SleepPeriod, int RegistrationState)\n{\n\tchar Mil_Usn[LINE_SIZE];\n\tchar *szReq[1];\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *DestAddr4 = (struct sockaddr_in *)&__ss;\n\tstruct sockaddr_in6 *DestAddr6 = (struct sockaddr_in6 *)&__ss;\n\tint RetVal = UPNP_E_OUTOF_MEMORY;\n\tint rc = 0;\n\n\tmemset(&__ss, 0, sizeof(__ss));\n\tszReq[0] = NULL;\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tDestAddr4->sin_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET, SSDP_IP, &DestAddr4->sin_addr);\n\t\tDestAddr4->sin_port = htons(SSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tDestAddr6->sin6_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET6,\n\t\t\t  (isUrlV6UlaGua(Location)) ? SSDP_IPV6_SITELOCAL :\n\t\t\t  SSDP_IPV6_LINKLOCAL, &DestAddr6->sin6_addr);\n\t\tDestAddr6->sin6_port = htons(SSDP_PORT);\n\t\tDestAddr6->sin6_scope_id = gIF_INDEX;\n\t\tbreak;\n\tdefault:\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Invalid device address family.\\n\");\n\t}\n\t/* sprintf(Mil_Nt,\"%s\",ServType); */\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, ServType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\t/* CreateServiceRequestPacket(0,szReq[0],Mil_Nt,Mil_Usn,\n\t * Server,Location,Duration); */\n\tCreateServicePacket(MSGTYPE_SHUTDOWN, ServType, Mil_Usn,\n\t\t\t    Location, Duration, &szReq[0], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\tif (szReq[0] == NULL)\n\t\tgoto error_handler;\n\tRetVal = NewRequestHandler((struct sockaddr *)&__ss, 1, szReq);\n\nerror_handler:\n\tfree(szReq[0]);\n\n\treturn RetVal;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"UpnpInet.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MSGTYPE_SHUTDOWN\t0",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"config.h\"\n\n#define MSGTYPE_SHUTDOWN\t0\n#define snprintf _snprintf\n\nint ServiceShutdown(char *Udn, char *ServType, char *Location, int Duration,\n\t\t    int AddressFamily, int PowerState,\n\t\t    int SleepPeriod, int RegistrationState)\n{\n\tchar Mil_Usn[LINE_SIZE];\n\tchar *szReq[1];\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *DestAddr4 = (struct sockaddr_in *)&__ss;\n\tstruct sockaddr_in6 *DestAddr6 = (struct sockaddr_in6 *)&__ss;\n\tint RetVal = UPNP_E_OUTOF_MEMORY;\n\tint rc = 0;\n\n\tmemset(&__ss, 0, sizeof(__ss));\n\tszReq[0] = NULL;\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tDestAddr4->sin_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET, SSDP_IP, &DestAddr4->sin_addr);\n\t\tDestAddr4->sin_port = htons(SSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tDestAddr6->sin6_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET6,\n\t\t\t  (isUrlV6UlaGua(Location)) ? SSDP_IPV6_SITELOCAL :\n\t\t\t  SSDP_IPV6_LINKLOCAL, &DestAddr6->sin6_addr);\n\t\tDestAddr6->sin6_port = htons(SSDP_PORT);\n\t\tDestAddr6->sin6_scope_id = gIF_INDEX;\n\t\tbreak;\n\tdefault:\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Invalid device address family.\\n\");\n\t}\n\t/* sprintf(Mil_Nt,\"%s\",ServType); */\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, ServType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\t/* CreateServiceRequestPacket(0,szReq[0],Mil_Nt,Mil_Usn,\n\t * Server,Location,Duration); */\n\tCreateServicePacket(MSGTYPE_SHUTDOWN, ServType, Mil_Usn,\n\t\t\t    Location, Duration, &szReq[0], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\tif (szReq[0] == NULL)\n\t\tgoto error_handler;\n\tRetVal = NewRequestHandler((struct sockaddr *)&__ss, 1, szReq);\n\nerror_handler:\n\tfree(szReq[0]);\n\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ServiceAdvertisement",
          "args": [
            "UDNstr",
            "servType",
            "SInfo->DescURL",
            "Exp",
            "SInfo->DeviceAf",
            "SInfo->PowerState",
            "SInfo->SleepPeriod",
            "SInfo->RegistrationState"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ServiceAdvertisement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_device.c",
          "lines": "704-753",
          "snippet": "int ServiceAdvertisement(char *Udn, char *ServType, char *Location,\n\t\t\t int Duration, int AddressFamily,\n\t\t\t int PowerState, int SleepPeriod, int RegistrationState)\n{\n\tchar Mil_Usn[LINE_SIZE];\n\tchar *szReq[1];\n\tint RetVal = UPNP_E_OUTOF_MEMORY;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *DestAddr4 = (struct sockaddr_in *)&__ss;\n\tstruct sockaddr_in6 *DestAddr6 = (struct sockaddr_in6 *)&__ss;\n\tint rc = 0;\n\n\tmemset(&__ss, 0, sizeof(__ss));\n\tszReq[0] = NULL;\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tDestAddr4->sin_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET, SSDP_IP, &DestAddr4->sin_addr);\n\t\tDestAddr4->sin_port = htons(SSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tDestAddr6->sin6_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET6,\n\t\t\t  (isUrlV6UlaGua(Location)) ? SSDP_IPV6_SITELOCAL :\n\t\t\t  SSDP_IPV6_LINKLOCAL, &DestAddr6->sin6_addr);\n\t\tDestAddr6->sin6_port = htons(SSDP_PORT);\n\t\tDestAddr6->sin6_scope_id = gIF_INDEX;\n\t\tbreak;\n\tdefault:\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Invalid device address family.\\n\");\n\t}\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, ServType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\t/* CreateServiceRequestPacket(1,szReq[0],Mil_Nt,Mil_Usn,\n\t * Server,Location,Duration); */\n\tCreateServicePacket(MSGTYPE_ADVERTISEMENT, ServType, Mil_Usn,\n\t\t\t    Location, Duration, &szReq[0], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\tif (szReq[0] == NULL) {\n\t\tgoto error_handler;\n\t}\n\tRetVal = NewRequestHandler((struct sockaddr *)&__ss, 1, szReq);\n\nerror_handler:\n\tfree(szReq[0]);\n\n\treturn RetVal;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"UpnpInet.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MSGTYPE_ADVERTISEMENT\t1",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"config.h\"\n\n#define MSGTYPE_ADVERTISEMENT\t1\n#define snprintf _snprintf\n\nint ServiceAdvertisement(char *Udn, char *ServType, char *Location,\n\t\t\t int Duration, int AddressFamily,\n\t\t\t int PowerState, int SleepPeriod, int RegistrationState)\n{\n\tchar Mil_Usn[LINE_SIZE];\n\tchar *szReq[1];\n\tint RetVal = UPNP_E_OUTOF_MEMORY;\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *DestAddr4 = (struct sockaddr_in *)&__ss;\n\tstruct sockaddr_in6 *DestAddr6 = (struct sockaddr_in6 *)&__ss;\n\tint rc = 0;\n\n\tmemset(&__ss, 0, sizeof(__ss));\n\tszReq[0] = NULL;\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tDestAddr4->sin_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET, SSDP_IP, &DestAddr4->sin_addr);\n\t\tDestAddr4->sin_port = htons(SSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tDestAddr6->sin6_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET6,\n\t\t\t  (isUrlV6UlaGua(Location)) ? SSDP_IPV6_SITELOCAL :\n\t\t\t  SSDP_IPV6_LINKLOCAL, &DestAddr6->sin6_addr);\n\t\tDestAddr6->sin6_port = htons(SSDP_PORT);\n\t\tDestAddr6->sin6_scope_id = gIF_INDEX;\n\t\tbreak;\n\tdefault:\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Invalid device address family.\\n\");\n\t}\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, ServType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\t/* CreateServiceRequestPacket(1,szReq[0],Mil_Nt,Mil_Usn,\n\t * Server,Location,Duration); */\n\tCreateServicePacket(MSGTYPE_ADVERTISEMENT, ServType, Mil_Usn,\n\t\t\t    Location, Duration, &szReq[0], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\tif (szReq[0] == NULL) {\n\t\tgoto error_handler;\n\t}\n\tRetVal = NewRequestHandler((struct sockaddr *)&__ss, 1, szReq);\n\nerror_handler:\n\tfree(szReq[0]);\n\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "servType",
            "tmpStr",
            "sizeof(servType) - 1"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNodeValue",
          "args": [
            "textNode"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "tmpNode2"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_item",
          "args": [
            "tmpNodeList",
            "0lu"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlElement_getElementsByTagName",
          "args": [
            "(IXML_Element *) tmpNode",
            "\"serviceType\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_free",
          "args": [
            "tmpNodeList"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_item",
          "args": [
            "nodeList",
            "j"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlElement_getElementsByTagName",
          "args": [
            "(IXML_Element *) tmpNode",
            "\"service\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_free",
          "args": [
            "nodeList"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNextSibling",
          "args": [
            "tmpNode"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "dbgStr",
            "SERVICELIST_STR",
            "sizeof SERVICELIST_STR"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNodeName",
          "args": [
            "tmpNode"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "tmpNode"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "&devType[strlen(devType) - (size_t)1]"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "devType"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "strrchr(DeviceType, ':') + 1"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "DeviceType",
            "':'"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "&devType[strlen(devType) - (size_t)1]"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "devType"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "strrchr(DeviceType, ':') + 1"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "DeviceType",
            "':'"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "DeviceType",
            "devType",
            "strlen(DeviceType) - (size_t)2"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "DeviceType"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "DeviceUDN",
            "UDNstr"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "DeviceUDN"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeviceReply",
          "args": [
            "DestAddr",
            "devType",
            "i == 0lu",
            "UDNstr",
            "SInfo->DescURL",
            "defaultExp",
            "SInfo->PowerState",
            "SInfo->SleepPeriod",
            "SInfo->RegistrationState"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "DeviceReply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_device.c",
          "lines": "641-702",
          "snippet": "int DeviceReply(struct sockaddr *DestAddr, char *DevType, int RootDev,\n\t\tchar *Udn, char *Location, int Duration, int PowerState,\n\t\tint SleepPeriod, int RegistrationState)\n{\n\tchar *szReq[3], Mil_Nt[LINE_SIZE], Mil_Usn[LINE_SIZE];\n\tint RetVal = UPNP_E_OUTOF_MEMORY;\n\tint rc = 0;\n\n\tszReq[0] = NULL;\n\tszReq[1] = NULL;\n\tszReq[2] = NULL;\n\t/* create 2 or 3 msgs */\n\tif (RootDev) {\n\t\t/* 3 replies for root device */\n\t\tmemset(Mil_Nt, 0, sizeof(Mil_Nt));\n\t\tstrncpy(Mil_Nt, \"upnp:rootdevice\", sizeof(Mil_Nt) - 1);\n\t\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::upnp:rootdevice\", Udn);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\t\tgoto error_handler;\n\t\tCreateServicePacket(MSGTYPE_REPLY, Mil_Nt, Mil_Usn,\n\t\t\t\t    Location, Duration, &szReq[0],\n\t\t\t\t    (int)DestAddr->sa_family, PowerState,\n\t\t\t\t    SleepPeriod, RegistrationState);\n\t}\n\trc = snprintf(Mil_Nt, sizeof(Mil_Nt), \"%s\", Udn);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Nt))\n\t\tgoto error_handler;\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s\", Udn);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\tCreateServicePacket(MSGTYPE_REPLY, Mil_Nt, Mil_Usn,\n\t\t\t    Location, Duration, &szReq[1], (int)DestAddr->sa_family,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\trc = snprintf(Mil_Nt, sizeof(Mil_Nt), \"%s\", DevType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Nt))\n\t\tgoto error_handler;\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, DevType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\tCreateServicePacket(MSGTYPE_REPLY, Mil_Nt, Mil_Usn,\n\t\t\t    Location, Duration, &szReq[2], (int)DestAddr->sa_family,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\t/* check error */\n\tif ((RootDev && szReq[0] == NULL) ||\n\t    szReq[1] == NULL || szReq[2] == NULL) {\n\t\tgoto error_handler;\n\t}\n\t/* send replies */\n\tif (RootDev) {\n\t\tRetVal = NewRequestHandler(DestAddr, 3, szReq);\n\t} else {\n\t\tRetVal = NewRequestHandler(DestAddr, 2, &szReq[1]);\n\t}\n\nerror_handler:\n\t/* free */\n\tfree(szReq[0]);\n\tfree(szReq[1]);\n\tfree(szReq[2]);\n\n\treturn RetVal;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"UpnpInet.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MSGTYPE_REPLY\t\t2",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"config.h\"\n\n#define MSGTYPE_REPLY\t\t2\n#define snprintf _snprintf\n\nint DeviceReply(struct sockaddr *DestAddr, char *DevType, int RootDev,\n\t\tchar *Udn, char *Location, int Duration, int PowerState,\n\t\tint SleepPeriod, int RegistrationState)\n{\n\tchar *szReq[3], Mil_Nt[LINE_SIZE], Mil_Usn[LINE_SIZE];\n\tint RetVal = UPNP_E_OUTOF_MEMORY;\n\tint rc = 0;\n\n\tszReq[0] = NULL;\n\tszReq[1] = NULL;\n\tszReq[2] = NULL;\n\t/* create 2 or 3 msgs */\n\tif (RootDev) {\n\t\t/* 3 replies for root device */\n\t\tmemset(Mil_Nt, 0, sizeof(Mil_Nt));\n\t\tstrncpy(Mil_Nt, \"upnp:rootdevice\", sizeof(Mil_Nt) - 1);\n\t\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::upnp:rootdevice\", Udn);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\t\tgoto error_handler;\n\t\tCreateServicePacket(MSGTYPE_REPLY, Mil_Nt, Mil_Usn,\n\t\t\t\t    Location, Duration, &szReq[0],\n\t\t\t\t    (int)DestAddr->sa_family, PowerState,\n\t\t\t\t    SleepPeriod, RegistrationState);\n\t}\n\trc = snprintf(Mil_Nt, sizeof(Mil_Nt), \"%s\", Udn);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Nt))\n\t\tgoto error_handler;\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s\", Udn);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\tCreateServicePacket(MSGTYPE_REPLY, Mil_Nt, Mil_Usn,\n\t\t\t    Location, Duration, &szReq[1], (int)DestAddr->sa_family,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\trc = snprintf(Mil_Nt, sizeof(Mil_Nt), \"%s\", DevType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Nt))\n\t\tgoto error_handler;\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, DevType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\tCreateServicePacket(MSGTYPE_REPLY, Mil_Nt, Mil_Usn,\n\t\t\t    Location, Duration, &szReq[2], (int)DestAddr->sa_family,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\t/* check error */\n\tif ((RootDev && szReq[0] == NULL) ||\n\t    szReq[1] == NULL || szReq[2] == NULL) {\n\t\tgoto error_handler;\n\t}\n\t/* send replies */\n\tif (RootDev) {\n\t\tRetVal = NewRequestHandler(DestAddr, 3, szReq);\n\t} else {\n\t\tRetVal = NewRequestHandler(DestAddr, 2, &szReq[1]);\n\t}\n\nerror_handler:\n\t/* free */\n\tfree(szReq[0]);\n\tfree(szReq[1]);\n\tfree(szReq[2]);\n\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeviceShutdown",
          "args": [
            "devType",
            "i == 0lu",
            "UDNstr",
            "SInfo->DescURL",
            "Exp",
            "SInfo->DeviceAf",
            "SInfo->PowerState",
            "SInfo->SleepPeriod",
            "SInfo->RegistrationState"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "DeviceShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_device.c",
          "lines": "832-912",
          "snippet": "int DeviceShutdown(char *DevType, int RootDev, char *Udn,\n\t\t   char *Location, int Duration, int AddressFamily,\n\t\t   int PowerState, int SleepPeriod, int RegistrationState)\n{\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *DestAddr4 = (struct sockaddr_in *)&__ss;\n\tstruct sockaddr_in6 *DestAddr6 = (struct sockaddr_in6 *)&__ss;\n\tchar *msgs[3];\n\tchar Mil_Usn[LINE_SIZE];\n\tint ret_code = UPNP_E_OUTOF_MEMORY;\n\tint rc = 0;\n\n\tmsgs[0] = NULL;\n\tmsgs[1] = NULL;\n\tmsgs[2] = NULL;\n\tmemset(&__ss, 0, sizeof(__ss));\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tDestAddr4->sin_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET, SSDP_IP, &DestAddr4->sin_addr);\n\t\tDestAddr4->sin_port = htons(SSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tDestAddr6->sin6_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET6,\n\t\t\t  (isUrlV6UlaGua(Location)) ? SSDP_IPV6_SITELOCAL :\n\t\t\t  SSDP_IPV6_LINKLOCAL, &DestAddr6->sin6_addr);\n\t\tDestAddr6->sin6_port = htons(SSDP_PORT);\n\t\tDestAddr6->sin6_scope_id = gIF_INDEX;\n\t\tbreak;\n\tdefault:\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Invalid device address family.\\n\");\n\t}\n\t/* root device has one extra msg */\n\tif (RootDev) {\n\t\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::upnp:rootdevice\",\n\t\t\tUdn);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\t\tgoto error_handler;\n\t\tCreateServicePacket(MSGTYPE_SHUTDOWN, \"upnp:rootdevice\",\n\t\t\t\t    Mil_Usn, Location, Duration, &msgs[0],\n\t\t\t\t    AddressFamily, PowerState, SleepPeriod,\n\t\t\t\t    RegistrationState);\n\t}\n\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t   \"In function DeviceShutdown\\n\");\n\t/* both root and sub-devices need to send these two messages */\n\tCreateServicePacket(MSGTYPE_SHUTDOWN, Udn, Udn,\n\t\t\t    Location, Duration, &msgs[1], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, DevType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\tCreateServicePacket(MSGTYPE_SHUTDOWN, DevType, Mil_Usn,\n\t\t\t    Location, Duration, &msgs[2], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\t/* check error */\n\tif ((RootDev && msgs[0] == NULL) || msgs[1] == NULL || msgs[2] == NULL) {\n\t\tgoto error_handler;\n\t}\n\t/* send packets */\n\tif (RootDev) {\n\t\t/* send 3 msg types */\n\t\tret_code =\n\t\t    NewRequestHandler((struct sockaddr *)&__ss, 3, &msgs[0]);\n\t} else {\n\t\t/* sub-device */\n\t\t/* send 2 msg types */\n\t\tret_code =\n\t\t    NewRequestHandler((struct sockaddr *)&__ss, 2, &msgs[1]);\n\t}\n\nerror_handler:\n\t/* free msgs */\n\tfree(msgs[0]);\n\tfree(msgs[1]);\n\tfree(msgs[2]);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"UpnpInet.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MSGTYPE_SHUTDOWN\t0",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"config.h\"\n\n#define MSGTYPE_SHUTDOWN\t0\n#define snprintf _snprintf\n\nint DeviceShutdown(char *DevType, int RootDev, char *Udn,\n\t\t   char *Location, int Duration, int AddressFamily,\n\t\t   int PowerState, int SleepPeriod, int RegistrationState)\n{\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *DestAddr4 = (struct sockaddr_in *)&__ss;\n\tstruct sockaddr_in6 *DestAddr6 = (struct sockaddr_in6 *)&__ss;\n\tchar *msgs[3];\n\tchar Mil_Usn[LINE_SIZE];\n\tint ret_code = UPNP_E_OUTOF_MEMORY;\n\tint rc = 0;\n\n\tmsgs[0] = NULL;\n\tmsgs[1] = NULL;\n\tmsgs[2] = NULL;\n\tmemset(&__ss, 0, sizeof(__ss));\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tDestAddr4->sin_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET, SSDP_IP, &DestAddr4->sin_addr);\n\t\tDestAddr4->sin_port = htons(SSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tDestAddr6->sin6_family = (sa_family_t)AddressFamily;\n\t\tinet_pton(AF_INET6,\n\t\t\t  (isUrlV6UlaGua(Location)) ? SSDP_IPV6_SITELOCAL :\n\t\t\t  SSDP_IPV6_LINKLOCAL, &DestAddr6->sin6_addr);\n\t\tDestAddr6->sin6_port = htons(SSDP_PORT);\n\t\tDestAddr6->sin6_scope_id = gIF_INDEX;\n\t\tbreak;\n\tdefault:\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Invalid device address family.\\n\");\n\t}\n\t/* root device has one extra msg */\n\tif (RootDev) {\n\t\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::upnp:rootdevice\",\n\t\t\tUdn);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\t\tgoto error_handler;\n\t\tCreateServicePacket(MSGTYPE_SHUTDOWN, \"upnp:rootdevice\",\n\t\t\t\t    Mil_Usn, Location, Duration, &msgs[0],\n\t\t\t\t    AddressFamily, PowerState, SleepPeriod,\n\t\t\t\t    RegistrationState);\n\t}\n\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t   \"In function DeviceShutdown\\n\");\n\t/* both root and sub-devices need to send these two messages */\n\tCreateServicePacket(MSGTYPE_SHUTDOWN, Udn, Udn,\n\t\t\t    Location, Duration, &msgs[1], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, DevType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\tCreateServicePacket(MSGTYPE_SHUTDOWN, DevType, Mil_Usn,\n\t\t\t    Location, Duration, &msgs[2], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\t/* check error */\n\tif ((RootDev && msgs[0] == NULL) || msgs[1] == NULL || msgs[2] == NULL) {\n\t\tgoto error_handler;\n\t}\n\t/* send packets */\n\tif (RootDev) {\n\t\t/* send 3 msg types */\n\t\tret_code =\n\t\t    NewRequestHandler((struct sockaddr *)&__ss, 3, &msgs[0]);\n\t} else {\n\t\t/* sub-device */\n\t\t/* send 2 msg types */\n\t\tret_code =\n\t\t    NewRequestHandler((struct sockaddr *)&__ss, 2, &msgs[1]);\n\t}\n\nerror_handler:\n\t/* free msgs */\n\tfree(msgs[0]);\n\tfree(msgs[1]);\n\tfree(msgs[2]);\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeviceAdvertisement",
          "args": [
            "devType",
            "i == 0lu",
            "UDNstr",
            "SInfo->DescURL",
            "Exp",
            "SInfo->DeviceAf",
            "SInfo->PowerState",
            "SInfo->SleepPeriod",
            "SInfo->RegistrationState"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "DeviceAdvertisement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_device.c",
          "lines": "493-575",
          "snippet": "int DeviceAdvertisement(char *DevType, int RootDev, char *Udn, char *Location,\n\t\t\tint Duration, int AddressFamily, int PowerState,\n\t\t\tint SleepPeriod, int RegistrationState)\n{\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *DestAddr4 = (struct sockaddr_in *)&__ss;\n\tstruct sockaddr_in6 *DestAddr6 = (struct sockaddr_in6 *)&__ss;\n\t/* char Mil_Nt[LINE_SIZE] */\n\tchar Mil_Usn[LINE_SIZE];\n\tchar *msgs[3];\n\tint ret_code = UPNP_E_OUTOF_MEMORY;\n\tint rc = 0;\n\n\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t   \"In function DeviceAdvertisement\\n\");\n\tmemset(&__ss, 0, sizeof(__ss));\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tDestAddr4->sin_family = (sa_family_t)AF_INET;\n\t\tinet_pton(AF_INET, SSDP_IP, &DestAddr4->sin_addr);\n\t\tDestAddr4->sin_port = htons(SSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tDestAddr6->sin6_family = (sa_family_t)AF_INET6;\n\t\tinet_pton(AF_INET6,\n\t\t\t  (isUrlV6UlaGua(Location)) ? SSDP_IPV6_SITELOCAL :\n\t\t\t  SSDP_IPV6_LINKLOCAL, &DestAddr6->sin6_addr);\n\t\tDestAddr6->sin6_port = htons(SSDP_PORT);\n\t\tDestAddr6->sin6_scope_id = gIF_INDEX;\n\t\tbreak;\n\tdefault:\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Invalid device address family.\\n\");\n\t}\n\tmsgs[0] = NULL;\n\tmsgs[1] = NULL;\n\tmsgs[2] = NULL;\n\t/* If deviceis a root device , here we need to send 3 advertisement\n\t * or reply */\n\tif (RootDev) {\n\t\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::upnp:rootdevice\",\n\t\t\tUdn);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\t\tgoto error_handler;\n\t\tCreateServicePacket(MSGTYPE_ADVERTISEMENT, \"upnp:rootdevice\",\n\t\t\t\t    Mil_Usn, Location, Duration, &msgs[0],\n\t\t\t\t    AddressFamily, PowerState, SleepPeriod,\n\t\t\t\t    RegistrationState);\n\t}\n\t/* both root and sub-devices need to send these two messages */\n\tCreateServicePacket(MSGTYPE_ADVERTISEMENT, Udn, Udn,\n\t\t\t    Location, Duration, &msgs[1], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, DevType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\tCreateServicePacket(MSGTYPE_ADVERTISEMENT, DevType, Mil_Usn,\n\t\t\t    Location, Duration, &msgs[2], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\t/* check error */\n\tif ((RootDev && msgs[0] == NULL) || msgs[1] == NULL || msgs[2] == NULL) {\n\t\tgoto error_handler;\n\t}\n\t/* send packets */\n\tif (RootDev) {\n\t\t/* send 3 msg types */\n\t\tret_code =\n\t\t    NewRequestHandler((struct sockaddr *)&__ss, 3, &msgs[0]);\n\t} else {\t\t/* sub-device */\n\n\t\t/* send 2 msg types */\n\t\tret_code =\n\t\t    NewRequestHandler((struct sockaddr *)&__ss, 2, &msgs[1]);\n\t}\n\nerror_handler:\n\t/* free msgs */\n\tfree(msgs[0]);\n\tfree(msgs[1]);\n\tfree(msgs[2]);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"UpnpInet.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MSGTYPE_ADVERTISEMENT\t1",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"config.h\"\n\n#define MSGTYPE_ADVERTISEMENT\t1\n#define snprintf _snprintf\n\nint DeviceAdvertisement(char *DevType, int RootDev, char *Udn, char *Location,\n\t\t\tint Duration, int AddressFamily, int PowerState,\n\t\t\tint SleepPeriod, int RegistrationState)\n{\n\tstruct sockaddr_storage __ss;\n\tstruct sockaddr_in *DestAddr4 = (struct sockaddr_in *)&__ss;\n\tstruct sockaddr_in6 *DestAddr6 = (struct sockaddr_in6 *)&__ss;\n\t/* char Mil_Nt[LINE_SIZE] */\n\tchar Mil_Usn[LINE_SIZE];\n\tchar *msgs[3];\n\tint ret_code = UPNP_E_OUTOF_MEMORY;\n\tint rc = 0;\n\n\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t   \"In function DeviceAdvertisement\\n\");\n\tmemset(&__ss, 0, sizeof(__ss));\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\tDestAddr4->sin_family = (sa_family_t)AF_INET;\n\t\tinet_pton(AF_INET, SSDP_IP, &DestAddr4->sin_addr);\n\t\tDestAddr4->sin_port = htons(SSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tDestAddr6->sin6_family = (sa_family_t)AF_INET6;\n\t\tinet_pton(AF_INET6,\n\t\t\t  (isUrlV6UlaGua(Location)) ? SSDP_IPV6_SITELOCAL :\n\t\t\t  SSDP_IPV6_LINKLOCAL, &DestAddr6->sin6_addr);\n\t\tDestAddr6->sin6_port = htons(SSDP_PORT);\n\t\tDestAddr6->sin6_scope_id = gIF_INDEX;\n\t\tbreak;\n\tdefault:\n\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Invalid device address family.\\n\");\n\t}\n\tmsgs[0] = NULL;\n\tmsgs[1] = NULL;\n\tmsgs[2] = NULL;\n\t/* If deviceis a root device , here we need to send 3 advertisement\n\t * or reply */\n\tif (RootDev) {\n\t\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::upnp:rootdevice\",\n\t\t\tUdn);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\t\tgoto error_handler;\n\t\tCreateServicePacket(MSGTYPE_ADVERTISEMENT, \"upnp:rootdevice\",\n\t\t\t\t    Mil_Usn, Location, Duration, &msgs[0],\n\t\t\t\t    AddressFamily, PowerState, SleepPeriod,\n\t\t\t\t    RegistrationState);\n\t}\n\t/* both root and sub-devices need to send these two messages */\n\tCreateServicePacket(MSGTYPE_ADVERTISEMENT, Udn, Udn,\n\t\t\t    Location, Duration, &msgs[1], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\trc = snprintf(Mil_Usn, sizeof(Mil_Usn), \"%s::%s\", Udn, DevType);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(Mil_Usn))\n\t\tgoto error_handler;\n\tCreateServicePacket(MSGTYPE_ADVERTISEMENT, DevType, Mil_Usn,\n\t\t\t    Location, Duration, &msgs[2], AddressFamily,\n\t\t\t    PowerState, SleepPeriod, RegistrationState);\n\t/* check error */\n\tif ((RootDev && msgs[0] == NULL) || msgs[1] == NULL || msgs[2] == NULL) {\n\t\tgoto error_handler;\n\t}\n\t/* send packets */\n\tif (RootDev) {\n\t\t/* send 3 msg types */\n\t\tret_code =\n\t\t    NewRequestHandler((struct sockaddr *)&__ss, 3, &msgs[0]);\n\t} else {\t\t/* sub-device */\n\n\t\t/* send 2 msg types */\n\t\tret_code =\n\t\t    NewRequestHandler((struct sockaddr *)&__ss, 2, &msgs[1]);\n\t}\n\nerror_handler:\n\t/* free msgs */\n\tfree(msgs[0]);\n\tfree(msgs[1]);\n\tfree(msgs[2]);\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "UDNstr",
            "tmpStr",
            "sizeof(UDNstr) - 1"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNodeValue",
          "args": [
            "textNode"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "tmpNode2"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_item",
          "args": [
            "nodeList",
            "0lu"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlElement_getElementsByTagName",
          "args": [
            "(IXML_Element *) tmpNode",
            "\"UDN\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_free",
          "args": [
            "nodeList"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNodeName",
          "args": [
            "tmpNode"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "devType",
            "tmpStr",
            "sizeof(devType) - 1"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNodeValue",
          "args": [
            "textNode"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "tmpNode2"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_item",
          "args": [
            "nodeList",
            "0lu"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlElement_getElementsByTagName",
          "args": [
            "(IXML_Element *) tmpNode",
            "\"deviceType\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_free",
          "args": [
            "nodeList"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNodeName",
          "args": [
            "tmpNode"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_item",
          "args": [
            "SInfo->DeviceList",
            "i"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imillisleep",
          "args": [
            "SSDP_PAUSE"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "Hnd",
            "&SInfo"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "servType",
            "0",
            "sizeof(servType)"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nint AdvertiseAndReply(int AdFlag, UpnpDevice_Handle Hnd,\n\t\t      enum SsdpSearchType SearchType,\n\t\t      struct sockaddr *DestAddr, char *DeviceType,\n\t\t      char *DeviceUDN, char *ServiceType, int Exp)\n{\n\tint retVal = UPNP_E_SUCCESS;\n\tlong unsigned int i;\n\tlong unsigned int j;\n\tint defaultExp = DEFAULT_MAXAGE;\n\tstruct Handle_Info *SInfo = NULL;\n\tchar UDNstr[100];\n\tchar devType[100];\n\tchar servType[100];\n\tIXML_NodeList *nodeList = NULL;\n\tIXML_NodeList *tmpNodeList = NULL;\n\tIXML_Node *tmpNode = NULL;\n\tIXML_Node *tmpNode2 = NULL;\n\tIXML_Node *textNode = NULL;\n\tconst DOMString tmpStr;\n\tconst DOMString dbgStr;\n\tint NumCopy = 0;\n\n\tmemset(UDNstr, 0, sizeof(UDNstr));\n\tmemset(devType, 0, sizeof(devType));\n\tmemset(servType, 0, sizeof(servType));\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Inside AdvertiseAndReply with AdFlag = %d\\n\", AdFlag);\n\n\t/* Use a read lock */\n\tHandleReadLock();\n\tif (GetHandleInfo(Hnd, &SInfo) != HND_DEVICE) {\n\t\tretVal = UPNP_E_INVALID_HANDLE;\n\t\tgoto end_function;\n\t}\n\tdefaultExp = SInfo->MaxAge;\n\t/* parse the device list and send advertisements/replies */\n\twhile (NumCopy == 0 || (AdFlag && NumCopy < NUM_SSDP_COPY)) {\n\t\tif (NumCopy != 0)\n\t\t\timillisleep(SSDP_PAUSE);\n\t\tNumCopy++;\n\t\tfor (i = 0lu;; i++) {\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Entering new device list with i = %lu\\n\\n\",\n\t\t\t\t   i);\n\t\t\ttmpNode = ixmlNodeList_item(SInfo->DeviceList, i);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Exiting new device list with i = %lu\\n\\n\",\n\t\t\t\t\t   i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type once for %s\\n\",\n\t\t\t\t   dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"deviceType\");\n\t\t\tif (!nodeList)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type\\n\");\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2)\n\t\t\t\tcontinue;\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode)\n\t\t\t\tcontinue;\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type \\n\");\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr)\n\t\t\t\tcontinue;\n\t\t\tstrncpy(devType, tmpStr, sizeof(devType) - 1);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting device type = %s\\n\", devType);\n\t\t\tif (!tmpNode) {\n\t\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"TempNode is NULL\\n\");\n\t\t\t}\n\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t\t\t   \"Extracting UDN for %s\\n\", dbgStr);\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"UDN\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpNode2 = ixmlNodeList_item(nodeList, 0lu);\n\t\t\tif (!tmpNode2) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\tif (!textNode) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\tif (!tmpStr) {\n\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t   __LINE__, \"UDN not found!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstrncpy(UDNstr, tmpStr, sizeof(UDNstr) - 1);\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending UDNStr = %s \\n\", UDNstr);\n\t\t\tif (AdFlag) {\n\t\t\t\t/* send the device advertisement */\n\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\tDeviceAdvertisement(devType, i == 0lu,\n\t\t\t\t\t\t\t    UDNstr,\n\t\t\t\t\t\t\t    SInfo->DescURL, Exp,\n\t\t\t\t\t\t\t    SInfo->DeviceAf,\n\t\t\t\t\t\t\t    SInfo->PowerState,\n\t                                                    SInfo->SleepPeriod,\n\t                                                    SInfo->RegistrationState);\n\t\t\t\t} else {\n\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\tDeviceShutdown(devType, i == 0lu, UDNstr,\n\t\t\t\t\t\t       SInfo->DescURL,\n\t\t\t\t\t\t       Exp, SInfo->DeviceAf,\n\t\t\t\t\t\t       SInfo->PowerState,\n\t\t\t\t\t\t       SInfo->SleepPeriod,\n\t\t\t\t\t\t       SInfo->RegistrationState);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (SearchType) {\n\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\tDeviceReply(DestAddr, devType, i == 0lu,\n\t\t\t\t\t\t    UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t    defaultExp, SInfo->PowerState,\n\t\t\t\t\t\t    SInfo->SleepPeriod,\n\t\t\t\t\t\t    SInfo->RegistrationState);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_ROOTDEVICE:\n\t\t\t\t\tif (i == 0lu) {\n\t\t\t\t\t\tSendReply(DestAddr, devType, 1,\n\t\t\t\t\t\t\t  UDNstr,\n\t\t\t\t\t\t\t  SInfo->DescURL,\n\t\t\t\t\t\t\t  defaultExp, 0,\n\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SSDP_DEVICEUDN: {\n\t\t\t\t\tif (DeviceUDN && strlen(DeviceUDN) != (size_t)0) {\n\t\t\t\t\t\tif (strcasecmp(DeviceUDN, UDNstr)) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s DID NOT match\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\"DeviceUDN=%s and search UDN=%s MATCH\\n\",\n\t\t\t\t\t\t\t\tUDNstr, DeviceUDN);\n\t\t\t\t\t\t\tSendReply(DestAddr, devType, 0, UDNstr, SInfo->DescURL, defaultExp, 0,\n\t\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase SSDP_DEVICETYPE: {\n\t\t\t\t\tif (!strncasecmp(DeviceType, devType, strlen(DeviceType) - (size_t)2)) {\n\t\t\t\t\t\tif (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t    < atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\t/* the requested version is lower than the device version\n\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else if (atoi(strrchr(DeviceType, ':') + 1)\n\t\t\t\t\t\t\t   == atoi(&devType[strlen(devType) - (size_t)1])) {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t\tSendReply(DestAddr, DeviceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t   \"DeviceType=%s and search devType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t   devType, DeviceType);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* send service advertisements for services corresponding\n\t\t\t * to the same device */\n\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t   \"Sending service Advertisement\\n\");\n\t\t\t/* Correct service traversal such that each device's serviceList\n\t\t\t * is directly traversed as a child of its parent device. This\n\t\t\t * ensures that the service's alive message uses the UDN of\n\t\t\t * the parent device. */\n\t\t\ttmpNode = ixmlNode_getFirstChild(tmpNode);\n\t\t\twhile (tmpNode) {\n\t\t\t\tdbgStr = ixmlNode_getNodeName(tmpNode);\n\t\t\t\tif (!strncmp\n\t\t\t\t    (dbgStr, SERVICELIST_STR,\n\t\t\t\t     sizeof SERVICELIST_STR)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmpNode = ixmlNode_getNextSibling(tmpNode);\n\t\t\t}\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tif (!tmpNode) {\n\t\t\t\tnodeList = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"service\");\n\t\t\tif (!nodeList) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"Service not found 3\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j = 0lu;; j++) {\n\t\t\t\ttmpNode = ixmlNodeList_item(nodeList, j);\n\t\t\t\tif (!tmpNode) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\t\ttmpNodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, \"serviceType\");\n\t\t\t\tif (!tmpNodeList) {\n\t\t\t\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__,\n\t\t\t\t\t\t   __LINE__,\n\t\t\t\t\t\t   \"ServiceType not found \\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttmpNode2 = ixmlNodeList_item(tmpNodeList, 0lu);\n\t\t\t\tif (!tmpNode2)\n\t\t\t\t\tcontinue;\n\t\t\t\ttextNode = ixmlNode_getFirstChild(tmpNode2);\n\t\t\t\tif (!textNode)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* servType is of format Servicetype:ServiceVersion */\n\t\t\t\ttmpStr = ixmlNode_getNodeValue(textNode);\n\t\t\t\tif (!tmpStr)\n\t\t\t\t\tcontinue;\n\t\t\t\tstrncpy(servType, tmpStr, sizeof(servType) - 1);\n\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t   \"ServiceType = %s\\n\", servType);\n\t\t\t\tif (AdFlag) {\n\t\t\t\t\tif (AdFlag == 1) {\n\t\t\t\t\t\tServiceAdvertisement(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* AdFlag == -1 */\n\t\t\t\t\t\tServiceShutdown(UDNstr,\n\t\t\t\t\t\t\tservType, SInfo->DescURL,\n\t\t\t\t\t\t\tExp, SInfo->DeviceAf,\n\t\t\t\t\t\t\tSInfo->PowerState,\n\t\t\t\t\t\t\tSInfo->SleepPeriod,\n\t\t\t\t\t\t\tSInfo->RegistrationState);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (SearchType) {\n\t\t\t\t\tcase SSDP_ALL:\n\t\t\t\t\t\tServiceReply(DestAddr, servType,\n\t\t\t\t\t\t\t     UDNstr,\n\t\t\t\t\t\t\t     SInfo->DescURL,\n\t\t\t\t\t\t\t     defaultExp,\n\t\t\t\t\t\t\t     SInfo->PowerState,\n\t\t\t\t\t\t\t     SInfo->SleepPeriod,\n\t\t\t\t\t\t\t     SInfo->RegistrationState);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SSDP_SERVICE:\n\t\t\t\t\t\tif (ServiceType) {\n\t\t\t\t\t\t\tif (!strncasecmp(ServiceType, servType, strlen(ServiceType) - (size_t)2)) {\n\t\t\t\t\t\t\t\tif (atoi(strrchr(ServiceType, ':') + 1) <\n\t\t\t\t\t\t\t\t    atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\t/* the requested version is lower than the service version\n\t\t\t\t\t\t\t\t\t * must reply with the lower version number and the lower\n\t\t\t\t\t\t\t\t\t * description URL */\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->LowerDescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else if (atoi(strrchr (ServiceType, ':') + 1) ==\n\t\t\t\t\t\t\t\t\t   atoi(&servType[strlen(servType) - (size_t)1])) {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s MATCH\\n\",\n\t\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t\tSendReply(DestAddr, ServiceType, 0, UDNstr, SInfo->DescURL,\n\t\t\t\t\t\t\t\t\t\t  defaultExp, 1,\n\t\t\t\t\t\t\t\t\t\t  SInfo->PowerState,\n\t\t\t\t\t\t\t\t\t\t  SInfo->SleepPeriod,\n\t\t\t\t\t\t\t\t\t\t  SInfo->RegistrationState);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\t\t\t\t\t\t   \"ServiceType=%s and search servType=%s DID NOT MATCH\\n\",\n\t\t\t\t\t\t\t\t\t   ServiceType, servType);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tixmlNodeList_free(tmpNodeList);\n\t\t\ttmpNodeList = NULL;\n\t\t\tixmlNodeList_free(nodeList);\n\t\t\tnodeList = NULL;\n\t\t}\n\t}\n\nend_function:\n\tixmlNodeList_free(tmpNodeList);\n\tixmlNodeList_free(nodeList);\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,\n\t\t   \"Exiting AdvertiseAndReply.\\n\");\n\tHandleUnlock();\n\n\treturn retVal;\n}"
  }
]