[
  {
    "function_name": "print_http_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "2197-2227",
    "snippet": "void print_http_headers(http_message_t *hmsg)\n{\n    ListNode *node;\n    /* NNS:  dlist_node *node; */\n    http_header_t *header;\n\n    /* print start line */\n    if( hmsg->is_request ) {\n        printf( \"method = %d, version = %d.%d, url = %.*s\\n\", \n            hmsg->method, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->uri.pathquery.size, hmsg->uri.pathquery.buff);\n    } else {\n        printf( \"resp status = %d, version = %d.%d, status msg = %.*s\\n\",\n            hmsg->status_code, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->status_msg.length, hmsg->status_msg.buf);\n    }\n\n    /* print headers */\n    node = ListHead( &hmsg->headers );\n    /* NNS: node = dlist_first_node( &hmsg->headers ); */\n    while( node != NULL ) {\n        header = ( http_header_t * ) node->item;\n        /* NNS: header = (http_header_t *)node->data; */\n        printf( \"hdr name: %.*s, value: %.*s\\n\", \n            (int)header->name.length, header->name.buf,\n            (int)header->value.length, header->value.buf );\n\n        node = ListNext( &hmsg->headers, node );\n        /* NNS: node = dlist_next( &hmsg->headers, node ); */\n    }\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListNext",
          "args": [
            "&hmsg->headers",
            "node"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"hdr name: %.*s, value: %.*s\\n\"",
            "(int)header->name.length",
            "header->name.buf",
            "(int)header->value.length",
            "header->value.buf"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListHead",
          "args": [
            "&hmsg->headers"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"resp status = %d, version = %d.%d, status msg = %.*s\\n\"",
            "hmsg->status_code",
            "hmsg->major_version",
            "hmsg->minor_version",
            "(int)hmsg->status_msg.length",
            "hmsg->status_msg.buf"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"method = %d, version = %d.%d, url = %.*s\\n\"",
            "hmsg->method",
            "hmsg->major_version",
            "hmsg->minor_version",
            "(int)hmsg->uri.pathquery.size",
            "hmsg->uri.pathquery.buff"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid print_http_headers(http_message_t *hmsg)\n{\n    ListNode *node;\n    /* NNS:  dlist_node *node; */\n    http_header_t *header;\n\n    /* print start line */\n    if( hmsg->is_request ) {\n        printf( \"method = %d, version = %d.%d, url = %.*s\\n\", \n            hmsg->method, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->uri.pathquery.size, hmsg->uri.pathquery.buff);\n    } else {\n        printf( \"resp status = %d, version = %d.%d, status msg = %.*s\\n\",\n            hmsg->status_code, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->status_msg.length, hmsg->status_msg.buf);\n    }\n\n    /* print headers */\n    node = ListHead( &hmsg->headers );\n    /* NNS: node = dlist_first_node( &hmsg->headers ); */\n    while( node != NULL ) {\n        header = ( http_header_t * ) node->item;\n        /* NNS: header = (http_header_t *)node->data; */\n        printf( \"hdr name: %.*s, value: %.*s\\n\", \n            (int)header->name.length, header->name.buf,\n            (int)header->value.length, header->value.buf );\n\n        node = ListNext( &hmsg->headers, node );\n        /* NNS: node = dlist_next( &hmsg->headers, node ); */\n    }\n}"
  },
  {
    "function_name": "method_to_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "2184-2193",
    "snippet": "const char *method_to_str(IN http_method_t method)\n{\n    int index;\n\n    index = map_int_to_str( method, Http_Method_Table, NUM_HTTP_METHODS );\n\n    assert( index != -1 );\n\n    return index == -1 ? NULL : Http_Method_Table[index].name;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_HTTP_METHODS 11"
    ],
    "globals_used": [
      "static str_int_entry Http_Method_Table[NUM_HTTP_METHODS] = {\n\t{\"DELETE\", HTTPMETHOD_DELETE},\n\t{\"GET\", HTTPMETHOD_GET},\n\t{\"HEAD\", HTTPMETHOD_HEAD},\n\t{\"M-POST\", HTTPMETHOD_MPOST},\n\t{\"M-SEARCH\", HTTPMETHOD_MSEARCH},\n\t{\"NOTIFY\", HTTPMETHOD_NOTIFY},\n\t{\"POST\", HTTPMETHOD_POST},\n\t{\"SUBSCRIBE\", HTTPMETHOD_SUBSCRIBE},\n\t{\"UNSUBSCRIBE\", HTTPMETHOD_UNSUBSCRIBE},\n\t{\"POST\", SOAPMETHOD_POST},\n\t{\"PUT\", HTTPMETHOD_PUT}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index != -1"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_int_to_str",
          "args": [
            "method",
            "Http_Method_Table",
            "NUM_HTTP_METHODS"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "map_int_to_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/strintmap.c",
          "lines": "122-135",
          "snippet": "int\nmap_int_to_str( IN int id,\n                IN str_int_entry * table,\n                IN int num_entries )\n{\n    int i;\n\n    for( i = 0; i < num_entries; i++ ) {\n        if( table[i].id == id ) {\n            return i;\n        }\n    }\n    return -1;\n}",
          "includes": [
            "#include \"membuffer.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"membuffer.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nint\nmap_int_to_str( IN int id,\n                IN str_int_entry * table,\n                IN int num_entries )\n{\n    int i;\n\n    for( i = 0; i < num_entries; i++ ) {\n        if( table[i].id == id ) {\n            return i;\n        }\n    }\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define NUM_HTTP_METHODS 11\n\nstatic str_int_entry Http_Method_Table[NUM_HTTP_METHODS] = {\n\t{\"DELETE\", HTTPMETHOD_DELETE},\n\t{\"GET\", HTTPMETHOD_GET},\n\t{\"HEAD\", HTTPMETHOD_HEAD},\n\t{\"M-POST\", HTTPMETHOD_MPOST},\n\t{\"M-SEARCH\", HTTPMETHOD_MSEARCH},\n\t{\"NOTIFY\", HTTPMETHOD_NOTIFY},\n\t{\"POST\", HTTPMETHOD_POST},\n\t{\"SUBSCRIBE\", HTTPMETHOD_SUBSCRIBE},\n\t{\"UNSUBSCRIBE\", HTTPMETHOD_UNSUBSCRIBE},\n\t{\"POST\", SOAPMETHOD_POST},\n\t{\"PUT\", HTTPMETHOD_PUT}\n};\n\nconst char *method_to_str(IN http_method_t method)\n{\n    int index;\n\n    index = map_int_to_str( method, Http_Method_Table, NUM_HTTP_METHODS );\n\n    assert( index != -1 );\n\n    return index == -1 ? NULL : Http_Method_Table[index].name;\n}"
  },
  {
    "function_name": "raw_find_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "2141-2170",
    "snippet": "int raw_find_str(IN memptr *raw_value, IN const char *str)\n{\n    char c;\n    char *ptr;\n    int i = 0;\n\n    /* save */\n    c = raw_value->buf[raw_value->length];\n\n    /* Make it lowercase */\n    for (i = 0; raw_value->buf[i]; ++i) {\n        raw_value->buf[i] = (char)tolower(raw_value->buf[i]);\n    }\n\n    /* null-terminate */\n    raw_value->buf[raw_value->length] = 0;\n\n    /* Find the substring position */\n    ptr = strstr( raw_value->buf, str );\n\n    /* restore the \"length\" byte */\n    raw_value->buf[raw_value->length] = c;\n\n    if( ptr == 0 ) {\n        return -1;\n    }\n\n    /* return index */\n    return (int)(ptr - raw_value->buf);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "raw_value->buf",
            "str"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "raw_value->buf[i]"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nint raw_find_str(IN memptr *raw_value, IN const char *str)\n{\n    char c;\n    char *ptr;\n    int i = 0;\n\n    /* save */\n    c = raw_value->buf[raw_value->length];\n\n    /* Make it lowercase */\n    for (i = 0; raw_value->buf[i]; ++i) {\n        raw_value->buf[i] = (char)tolower(raw_value->buf[i]);\n    }\n\n    /* null-terminate */\n    raw_value->buf[raw_value->length] = 0;\n\n    /* Find the substring position */\n    ptr = strstr( raw_value->buf, str );\n\n    /* restore the \"length\" byte */\n    raw_value->buf[raw_value->length] = c;\n\n    if( ptr == 0 ) {\n        return -1;\n    }\n\n    /* return index */\n    return (int)(ptr - raw_value->buf);\n}"
  },
  {
    "function_name": "raw_to_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "2107-2125",
    "snippet": "int raw_to_int(IN memptr *raw_value, IN int base)\n{\n\tlong num;\n\tchar *end_ptr;\n\n\tif (raw_value->length == (size_t)0)\n\t\treturn -1;\n\terrno = 0;\n\tnum = strtol(raw_value->buf, &end_ptr, base);\n\tif ((num < 0)\n\t    /* all and only those chars in token should be used for num */\n\t    || (end_ptr != raw_value->buf + raw_value->length)\n\t    || ((num == LONG_MIN || num == LONG_MAX)\n\t\t&& (errno == ERANGE))\n\t    ) {\n\t\treturn -1;\n\t}\n\treturn (int)num;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "raw_value->buf",
            "&end_ptr",
            "base"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nint raw_to_int(IN memptr *raw_value, IN int base)\n{\n\tlong num;\n\tchar *end_ptr;\n\n\tif (raw_value->length == (size_t)0)\n\t\treturn -1;\n\terrno = 0;\n\tnum = strtol(raw_value->buf, &end_ptr, base);\n\tif ((num < 0)\n\t    /* all and only those chars in token should be used for num */\n\t    || (end_ptr != raw_value->buf + raw_value->length)\n\t    || ((num == LONG_MIN || num == LONG_MAX)\n\t\t&& (errno == ERANGE))\n\t    ) {\n\t\treturn -1;\n\t}\n\treturn (int)num;\n}"
  },
  {
    "function_name": "parser_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "2074-2093",
    "snippet": "parse_status_t\nparser_append( INOUT http_parser_t * parser,\n               IN const char *buf,\n               IN size_t buf_length )\n{\n    int ret_code;\n\n    assert( parser != NULL );\n    assert( buf != NULL );\n\n    /* append data to buffer */\n    ret_code = membuffer_append( &parser->msg.msg, buf, buf_length );\n    if( ret_code != 0 ) {\n        /* set failure status */\n        parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n        return PARSE_FAILURE;\n    }\n\n    return parser_parse( parser );\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parser_parse",
          "args": [
            "parser"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "2012-2054",
          "snippet": "parse_status_t\nparser_parse( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    /*takes an http_parser_t with memory already allocated  */\n    /*in the message  */\n    assert( parser != NULL );\n\n    do {\n        switch ( parser->position ) {\n            case POS_ENTITY:\n                status = parser_parse_entity( parser );\n\n                break;\n\n            case POS_HEADERS:\n                status = parser_parse_headers( parser );\n\n                break;\n\n            case POS_REQUEST_LINE:\n                status = parser_parse_requestline( parser );\n\n                break;\n\n            case POS_RESPONSE_LINE:\n                status = parser_parse_responseline( parser );\n\n                break;\n\n            default:\n                {\n                    status = PARSE_FAILURE;\n                    assert( 0 );\n                }\n        }\n\n    } while( status == ( parse_status_t ) PARSE_OK );\n\n    return status;\n\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nparser_parse( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    /*takes an http_parser_t with memory already allocated  */\n    /*in the message  */\n    assert( parser != NULL );\n\n    do {\n        switch ( parser->position ) {\n            case POS_ENTITY:\n                status = parser_parse_entity( parser );\n\n                break;\n\n            case POS_HEADERS:\n                status = parser_parse_headers( parser );\n\n                break;\n\n            case POS_REQUEST_LINE:\n                status = parser_parse_requestline( parser );\n\n                break;\n\n            case POS_RESPONSE_LINE:\n                status = parser_parse_responseline( parser );\n\n                break;\n\n            default:\n                {\n                    status = PARSE_FAILURE;\n                    assert( 0 );\n                }\n        }\n\n    } while( status == ( parse_status_t ) PARSE_OK );\n\n    return status;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append",
          "args": [
            "&parser->msg.msg",
            "buf",
            "buf_length"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "200-205",
          "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "buf != NULL"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parser != NULL"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nparser_append( INOUT http_parser_t * parser,\n               IN const char *buf,\n               IN size_t buf_length )\n{\n    int ret_code;\n\n    assert( parser != NULL );\n    assert( buf != NULL );\n\n    /* append data to buffer */\n    ret_code = membuffer_append( &parser->msg.msg, buf, buf_length );\n    if( ret_code != 0 ) {\n        /* set failure status */\n        parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n        return PARSE_FAILURE;\n    }\n\n    return parser_parse( parser );\n}"
  },
  {
    "function_name": "parser_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "2012-2054",
    "snippet": "parse_status_t\nparser_parse( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    /*takes an http_parser_t with memory already allocated  */\n    /*in the message  */\n    assert( parser != NULL );\n\n    do {\n        switch ( parser->position ) {\n            case POS_ENTITY:\n                status = parser_parse_entity( parser );\n\n                break;\n\n            case POS_HEADERS:\n                status = parser_parse_headers( parser );\n\n                break;\n\n            case POS_REQUEST_LINE:\n                status = parser_parse_requestline( parser );\n\n                break;\n\n            case POS_RESPONSE_LINE:\n                status = parser_parse_responseline( parser );\n\n                break;\n\n            default:\n                {\n                    status = PARSE_FAILURE;\n                    assert( 0 );\n                }\n        }\n\n    } while( status == ( parse_status_t ) PARSE_OK );\n\n    return status;\n\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser_parse_responseline",
          "args": [
            "parser"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_responseline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1367-1429",
          "snippet": "parse_status_t parser_parse_responseline(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\thttp_message_t *hmsg = &parser->msg;\n\tmemptr line;\n\tchar save_char;\n\tint num_scanned;\n\tint i;\n\tsize_t n;\n\tchar *p;\n\n\tassert(parser->position == POS_RESPONSE_LINE);\n\n\tstatus = skip_blank_lines(&parser->scanner);\n\tif (status != ( parse_status_t) PARSE_OK)\n\t\treturn status;\n\t/* response line */\n\t/*status = match( &parser->scanner, \"%ihttp%w/%w%d\\t.\\t%d\\t%d\\t%L%c\", */\n\t/*  &hmsg->major_version, &hmsg->minor_version, */\n\t/*  &hmsg->status_code, &hmsg->status_msg ); */\n\tstatus = match(&parser->scanner, \"%ihttp%w/%w%L%c\", &line);\n\tif (status != ( parse_status_t ) PARSE_OK)\n\t\treturn status;\n\tsave_char = line.buf[line.length];\n\tline.buf[line.length] = '\\0';\t/* null-terminate */\n\t/* scan http version and ret code */\n\tnum_scanned = sscanf(line.buf, \"%d . %d %d\",\n\t\t\t     &hmsg->major_version, &hmsg->minor_version,\n\t\t\t     &hmsg->status_code);\n\tline.buf[line.length] = save_char;\t/* restore */\n\tif (num_scanned != 3 ||\n\t    hmsg->major_version < 0 || hmsg->minor_version < 0 ||\n\t    hmsg->status_code < 0)\n\t\t/* bad response line */\n\t\treturn PARSE_FAILURE;\n\t/* point to status msg */\n\tp = line.buf;\n\t/* skip 3 ints */\n\tfor (i = 0; i < 3; i++) {\n\t\t/* go to start of num */\n\t\twhile (!isdigit(*p))\n\t\t\tp++;\n\t\t/* skip int */\n\t\twhile (isdigit(*p))\n\t\t\tp++;\n\t}\n\t/* whitespace must exist after status code */\n\tif (*p != ' ' && *p != '\\t')\n\t\treturn PARSE_FAILURE;\n\t/* skip whitespace */\n\twhile (*p == ' ' || *p == '\\t')\n\t\tp++;\n\t/* now, p is at start of status msg */\n\tn = line.length - ((size_t)p - (size_t)line.buf);\n\tif (membuffer_assign(&hmsg->status_msg, p, n) != 0) {\n\t\t/* out of mem */\n\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\treturn PARSE_FAILURE;\n\t}\n\tparser->position = POS_HEADERS;\t/* move to headers */\n\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t parser_parse_responseline(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\thttp_message_t *hmsg = &parser->msg;\n\tmemptr line;\n\tchar save_char;\n\tint num_scanned;\n\tint i;\n\tsize_t n;\n\tchar *p;\n\n\tassert(parser->position == POS_RESPONSE_LINE);\n\n\tstatus = skip_blank_lines(&parser->scanner);\n\tif (status != ( parse_status_t) PARSE_OK)\n\t\treturn status;\n\t/* response line */\n\t/*status = match( &parser->scanner, \"%ihttp%w/%w%d\\t.\\t%d\\t%d\\t%L%c\", */\n\t/*  &hmsg->major_version, &hmsg->minor_version, */\n\t/*  &hmsg->status_code, &hmsg->status_msg ); */\n\tstatus = match(&parser->scanner, \"%ihttp%w/%w%L%c\", &line);\n\tif (status != ( parse_status_t ) PARSE_OK)\n\t\treturn status;\n\tsave_char = line.buf[line.length];\n\tline.buf[line.length] = '\\0';\t/* null-terminate */\n\t/* scan http version and ret code */\n\tnum_scanned = sscanf(line.buf, \"%d . %d %d\",\n\t\t\t     &hmsg->major_version, &hmsg->minor_version,\n\t\t\t     &hmsg->status_code);\n\tline.buf[line.length] = save_char;\t/* restore */\n\tif (num_scanned != 3 ||\n\t    hmsg->major_version < 0 || hmsg->minor_version < 0 ||\n\t    hmsg->status_code < 0)\n\t\t/* bad response line */\n\t\treturn PARSE_FAILURE;\n\t/* point to status msg */\n\tp = line.buf;\n\t/* skip 3 ints */\n\tfor (i = 0; i < 3; i++) {\n\t\t/* go to start of num */\n\t\twhile (!isdigit(*p))\n\t\t\tp++;\n\t\t/* skip int */\n\t\twhile (isdigit(*p))\n\t\t\tp++;\n\t}\n\t/* whitespace must exist after status code */\n\tif (*p != ' ' && *p != '\\t')\n\t\treturn PARSE_FAILURE;\n\t/* skip whitespace */\n\twhile (*p == ' ' || *p == '\\t')\n\t\tp++;\n\t/* now, p is at start of status msg */\n\tn = line.length - ((size_t)p - (size_t)line.buf);\n\tif (membuffer_assign(&hmsg->status_msg, p, n) != 0) {\n\t\t/* out of mem */\n\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\treturn PARSE_FAILURE;\n\t}\n\tparser->position = POS_HEADERS;\t/* move to headers */\n\n\treturn PARSE_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_requestline",
          "args": [
            "parser"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_requestline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1244-1351",
          "snippet": "static parse_status_t\nparser_parse_requestline( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n    http_message_t *hmsg = &parser->msg;\n    memptr method_str;\n    memptr version_str;\n    int index;\n    char save_char;\n    int num_scanned;\n    memptr url_str;\n\n    assert( parser->position == POS_REQUEST_LINE );\n\n    status = skip_blank_lines( &parser->scanner );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        return status;\n    }\n    /*simple get http 0.9 as described in http 1.0 spec */\n\n    status =\n        match( &parser->scanner, \"%s\\t%S%w%c\", &method_str, &url_str );\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n\n        index =\n            map_str_to_int( method_str.buf, method_str.length,\n                            Http_Method_Table, NUM_HTTP_METHODS, TRUE );\n\n        if( index < 0 ) {\n            /* error; method not found */\n            parser->http_error_code = HTTP_NOT_IMPLEMENTED;\n            return PARSE_FAILURE;\n        }\n\n        if( Http_Method_Table[index].id != HTTPMETHOD_GET ) {\n            parser->http_error_code = HTTP_BAD_REQUEST;\n            return PARSE_FAILURE;\n        }\n\n        hmsg->method = HTTPMETHOD_SIMPLEGET;\n\n        /* store url */\n        hmsg->urlbuf = str_alloc( url_str.buf, url_str.length );\n        if( hmsg->urlbuf == NULL ) {\n            /* out of mem */\n            parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n            return PARSE_FAILURE;\n        }\n        if( parse_uri( hmsg->urlbuf, url_str.length, &hmsg->uri ) !=\n            HTTP_SUCCESS ) {\n            return PARSE_FAILURE;\n        }\n\n        parser->position = POS_COMPLETE;    /* move to headers */\n\n        return PARSE_SUCCESS;\n    }\n\n    status = match( &parser->scanner,\n                    \"%s\\t%S\\t%ihttp%w/%w%L%c\", &method_str, &url_str,\n                    &version_str );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        return status;\n    }\n    /* store url */\n    hmsg->urlbuf = str_alloc( url_str.buf, url_str.length );\n    if( hmsg->urlbuf == NULL ) {\n        /* out of mem */\n        parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n        return PARSE_FAILURE;\n    }\n    if( parse_uri( hmsg->urlbuf, url_str.length, &hmsg->uri ) !=\n        HTTP_SUCCESS ) {\n        return PARSE_FAILURE;\n    }\n\n    index =\n        map_str_to_int( method_str.buf, method_str.length,\n                        Http_Method_Table, NUM_HTTP_METHODS, TRUE );\n    if( index < 0 ) {\n        /* error; method not found */\n        parser->http_error_code = HTTP_NOT_IMPLEMENTED;\n        return PARSE_FAILURE;\n    }\n\n    /* scan version */\n    save_char = version_str.buf[version_str.length];\n    version_str.buf[version_str.length] = '\\0'; /* null-terminate */\n    num_scanned = sscanf( version_str.buf, \"%d . %d\",\n                          &hmsg->major_version, &hmsg->minor_version );\n    version_str.buf[version_str.length] = save_char;    /* restore */\n    if (num_scanned != 2 ||\n        /* HTTP version equals to 1.0 should fail for MSEARCH as required by the\n         * UPnP certification tool */\n        hmsg->major_version < 0 ||\n\t( hmsg->major_version == 1 && hmsg->minor_version < 1 &&\n\t  Http_Method_Table[index].id == HTTPMETHOD_MSEARCH )) {\n        parser->http_error_code = HTTP_HTTP_VERSION_NOT_SUPPORTED;\n        /* error; bad http version */\n        return PARSE_FAILURE;\n    }\n\n    hmsg->method = ( http_method_t ) Http_Method_Table[index].id;\n    parser->position = POS_HEADERS; /* move to headers */\n\n    return PARSE_OK;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HTTP_METHODS 11"
          ],
          "globals_used": [
            "static str_int_entry Http_Method_Table[NUM_HTTP_METHODS] = {\n\t{\"DELETE\", HTTPMETHOD_DELETE},\n\t{\"GET\", HTTPMETHOD_GET},\n\t{\"HEAD\", HTTPMETHOD_HEAD},\n\t{\"M-POST\", HTTPMETHOD_MPOST},\n\t{\"M-SEARCH\", HTTPMETHOD_MSEARCH},\n\t{\"NOTIFY\", HTTPMETHOD_NOTIFY},\n\t{\"POST\", HTTPMETHOD_POST},\n\t{\"SUBSCRIBE\", HTTPMETHOD_SUBSCRIBE},\n\t{\"UNSUBSCRIBE\", HTTPMETHOD_UNSUBSCRIBE},\n\t{\"POST\", SOAPMETHOD_POST},\n\t{\"PUT\", HTTPMETHOD_PUT}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define NUM_HTTP_METHODS 11\n\nstatic str_int_entry Http_Method_Table[NUM_HTTP_METHODS] = {\n\t{\"DELETE\", HTTPMETHOD_DELETE},\n\t{\"GET\", HTTPMETHOD_GET},\n\t{\"HEAD\", HTTPMETHOD_HEAD},\n\t{\"M-POST\", HTTPMETHOD_MPOST},\n\t{\"M-SEARCH\", HTTPMETHOD_MSEARCH},\n\t{\"NOTIFY\", HTTPMETHOD_NOTIFY},\n\t{\"POST\", HTTPMETHOD_POST},\n\t{\"SUBSCRIBE\", HTTPMETHOD_SUBSCRIBE},\n\t{\"UNSUBSCRIBE\", HTTPMETHOD_UNSUBSCRIBE},\n\t{\"POST\", SOAPMETHOD_POST},\n\t{\"PUT\", HTTPMETHOD_PUT}\n};\n\nstatic parse_status_t\nparser_parse_requestline( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n    http_message_t *hmsg = &parser->msg;\n    memptr method_str;\n    memptr version_str;\n    int index;\n    char save_char;\n    int num_scanned;\n    memptr url_str;\n\n    assert( parser->position == POS_REQUEST_LINE );\n\n    status = skip_blank_lines( &parser->scanner );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        return status;\n    }\n    /*simple get http 0.9 as described in http 1.0 spec */\n\n    status =\n        match( &parser->scanner, \"%s\\t%S%w%c\", &method_str, &url_str );\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n\n        index =\n            map_str_to_int( method_str.buf, method_str.length,\n                            Http_Method_Table, NUM_HTTP_METHODS, TRUE );\n\n        if( index < 0 ) {\n            /* error; method not found */\n            parser->http_error_code = HTTP_NOT_IMPLEMENTED;\n            return PARSE_FAILURE;\n        }\n\n        if( Http_Method_Table[index].id != HTTPMETHOD_GET ) {\n            parser->http_error_code = HTTP_BAD_REQUEST;\n            return PARSE_FAILURE;\n        }\n\n        hmsg->method = HTTPMETHOD_SIMPLEGET;\n\n        /* store url */\n        hmsg->urlbuf = str_alloc( url_str.buf, url_str.length );\n        if( hmsg->urlbuf == NULL ) {\n            /* out of mem */\n            parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n            return PARSE_FAILURE;\n        }\n        if( parse_uri( hmsg->urlbuf, url_str.length, &hmsg->uri ) !=\n            HTTP_SUCCESS ) {\n            return PARSE_FAILURE;\n        }\n\n        parser->position = POS_COMPLETE;    /* move to headers */\n\n        return PARSE_SUCCESS;\n    }\n\n    status = match( &parser->scanner,\n                    \"%s\\t%S\\t%ihttp%w/%w%L%c\", &method_str, &url_str,\n                    &version_str );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        return status;\n    }\n    /* store url */\n    hmsg->urlbuf = str_alloc( url_str.buf, url_str.length );\n    if( hmsg->urlbuf == NULL ) {\n        /* out of mem */\n        parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n        return PARSE_FAILURE;\n    }\n    if( parse_uri( hmsg->urlbuf, url_str.length, &hmsg->uri ) !=\n        HTTP_SUCCESS ) {\n        return PARSE_FAILURE;\n    }\n\n    index =\n        map_str_to_int( method_str.buf, method_str.length,\n                        Http_Method_Table, NUM_HTTP_METHODS, TRUE );\n    if( index < 0 ) {\n        /* error; method not found */\n        parser->http_error_code = HTTP_NOT_IMPLEMENTED;\n        return PARSE_FAILURE;\n    }\n\n    /* scan version */\n    save_char = version_str.buf[version_str.length];\n    version_str.buf[version_str.length] = '\\0'; /* null-terminate */\n    num_scanned = sscanf( version_str.buf, \"%d . %d\",\n                          &hmsg->major_version, &hmsg->minor_version );\n    version_str.buf[version_str.length] = save_char;    /* restore */\n    if (num_scanned != 2 ||\n        /* HTTP version equals to 1.0 should fail for MSEARCH as required by the\n         * UPnP certification tool */\n        hmsg->major_version < 0 ||\n\t( hmsg->major_version == 1 && hmsg->minor_version < 1 &&\n\t  Http_Method_Table[index].id == HTTPMETHOD_MSEARCH )) {\n        parser->http_error_code = HTTP_HTTP_VERSION_NOT_SUPPORTED;\n        /* error; bad http version */\n        return PARSE_FAILURE;\n    }\n\n    hmsg->method = ( http_method_t ) Http_Method_Table[index].id;\n    parser->position = POS_HEADERS; /* move to headers */\n\n    return PARSE_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_headers",
          "args": [
            "parser"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1446-1573",
          "snippet": "parse_status_t parser_parse_headers(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tmemptr token;\n\tmemptr hdr_value;\n\ttoken_type_t tok_type;\n\tscanner_t *scanner = &parser->scanner;\n\tsize_t save_pos;\n\thttp_header_t *header;\n\tint header_id;\n\tint ret = 0;\n\tint index;\n\thttp_header_t *orig_header;\n\tchar save_char;\n\tint ret2;\n\n\tassert(parser->position == (parser_pos_t)POS_HEADERS ||\n\t       parser->ent_position == ENTREAD_CHUNKY_HEADERS);\n\n\twhile (TRUE) {\n\t\tsave_pos = scanner->cursor;\n\t\t/* check end of headers */\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\tswitch (tok_type) {\n\t\tcase TT_CRLF:\n\t\t\t/* end of headers */\n\t\t\tif ((parser->msg.is_request)\n\t\t\t    && (parser->msg.method == (http_method_t)HTTPMETHOD_POST)) {\n\t\t\t\tparser->position = POS_COMPLETE;\t/*post entity parsing */\n\t\t\t\t/*is handled separately  */\n\t\t\t\treturn PARSE_SUCCESS;\n\t\t\t}\n\t\t\tparser->position = POS_ENTITY;\t/* read entity next */\n\t\t\treturn PARSE_OK;\n\t\tcase TT_IDENTIFIER:\n\t\t\t/* not end; read header */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn PARSE_FAILURE;\t/* didn't see header name */\n\t\t}\n\t\tstatus = match(scanner, \" : %R%c\", &hdr_value);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\t/* add header */\n\t\t/* find header */\n\t\tindex =\n\t\t    map_str_to_int(token.buf, token.length, Http_Header_Names,\n\t\t\t\t   NUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (index != -1) {\n\t\t\t/*Check if it is a soap header */\n\t\t\tif (Http_Header_Names[index].id == HDR_SOAPACTION) {\n\t\t\t\tparser->msg.method = SOAPMETHOD_POST;\n\t\t\t}\n\t\t\theader_id = Http_Header_Names[index].id;\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr(&parser->msg, header_id, NULL);\n\t\t} else {\n\t\t\theader_id = HDR_UNKNOWN;\n\t\t\tsave_char = token.buf[token.length];\n\t\t\ttoken.buf[token.length] = '\\0';\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr_str(&parser->msg, token.buf);\n\t\t\ttoken.buf[token.length] = save_char;\t/* restore */\n\t\t}\n\t\tif (orig_header == NULL) {\n\t\t\t/* add new header */\n\t\t\theader =\n\t\t\t    (http_header_t *) malloc(sizeof(http_header_t));\n\t\t\tif (header == NULL) {\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tmembuffer_init(&header->name_buf);\n\t\t\tmembuffer_init(&header->value);\n\t\t\t/* value can be 0 length */\n\t\t\tif (hdr_value.length == (size_t)0) {\n\t\t\t\t/* FIXME: Is this a bug? buf is not const. */\n\t\t\t\thdr_value.buf = \"\\0\";\n\t\t\t\thdr_value.length = (size_t)1;\n\t\t\t}\n\t\t\t/* save in header in buffers */\n\t\t\tif (membuffer_assign(&header->name_buf, token.buf, token.length) ||\n\t\t\t    membuffer_assign(&header->value, hdr_value.buf, hdr_value.length)) {\n\t\t\t\t/* not enough mem */\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\theader->name.buf = header->name_buf.buf;\n\t\t\theader->name.length = header->name_buf.length;\n\t\t\theader->name_id = header_id;\n\t\t\tif (!ListAddTail(&parser->msg.headers, header)) {\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t} else if (hdr_value.length > (size_t)0) {\n\t\t\t/* append value to existing header */\n\t\t\t/* append space */\n\t\t\tret = membuffer_append_str(&orig_header->value, \", \");\n\t\t\t/* append continuation of header value */\n\t\t\tret2 = membuffer_append(&orig_header->value,\n\t\t\t\t\t\thdr_value.buf,\n\t\t\t\t\t\thdr_value.length);\n\t\t\tif (ret == UPNP_E_OUTOF_MEMORY\n\t\t\t    || ret2 == UPNP_E_OUTOF_MEMORY) {\n\t\t\t\t/* not enuf mem */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* end while */\n\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HTTP_HEADER_NAMES 33"
          ],
          "globals_used": [
            "str_int_entry Http_Header_Names[NUM_HTTP_HEADER_NAMES] = {\n\t{\"ACCEPT\", HDR_ACCEPT},\n\t{\"ACCEPT-CHARSET\", HDR_ACCEPT_CHARSET},\n\t{\"ACCEPT-ENCODING\", HDR_ACCEPT_ENCODING},\n\t{\"ACCEPT-LANGUAGE\", HDR_ACCEPT_LANGUAGE},\n\t{\"ACCEPT-RANGES\", HDR_ACCEPT_RANGE},\n\t{\"CACHE-CONTROL\", HDR_CACHE_CONTROL},\n\t{\"CALLBACK\", HDR_CALLBACK},\n\t{\"CONTENT-ENCODING\", HDR_CONTENT_ENCODING},\n\t{\"CONTENT-LANGUAGE\", HDR_CONTENT_LANGUAGE},\n\t{\"CONTENT-LENGTH\", HDR_CONTENT_LENGTH},\n\t{\"CONTENT-LOCATION\", HDR_CONTENT_LOCATION},\n\t{\"CONTENT-RANGE\", HDR_CONTENT_RANGE},\n\t{\"CONTENT-TYPE\", HDR_CONTENT_TYPE},\n\t{\"DATE\", HDR_DATE},\n\t{\"EXT\", HDR_EXT},\n\t{\"HOST\", HDR_HOST},\n\t{\"IF-RANGE\", HDR_IF_RANGE},\n\t{\"LOCATION\", HDR_LOCATION},\n\t{\"MAN\", HDR_MAN},\n\t{\"MX\", HDR_MX},\n\t{\"NT\", HDR_NT},\n\t{\"NTS\", HDR_NTS},\n\t{\"RANGE\", HDR_RANGE},\n\t{\"SEQ\", HDR_SEQ},\n\t{\"SERVER\", HDR_SERVER},\n\t{\"SID\", HDR_SID},\n\t{\"SOAPACTION\", HDR_SOAPACTION},\n\t{\"ST\", HDR_ST},\n\t{\"TE\", HDR_TE},\n\t{\"TIMEOUT\", HDR_TIMEOUT},\n\t{\"TRANSFER-ENCODING\", HDR_TRANSFER_ENCODING},\n\t{\"USER-AGENT\", HDR_USER_AGENT},\n\t{\"USN\", HDR_USN},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define NUM_HTTP_HEADER_NAMES 33\n\nstr_int_entry Http_Header_Names[NUM_HTTP_HEADER_NAMES] = {\n\t{\"ACCEPT\", HDR_ACCEPT},\n\t{\"ACCEPT-CHARSET\", HDR_ACCEPT_CHARSET},\n\t{\"ACCEPT-ENCODING\", HDR_ACCEPT_ENCODING},\n\t{\"ACCEPT-LANGUAGE\", HDR_ACCEPT_LANGUAGE},\n\t{\"ACCEPT-RANGES\", HDR_ACCEPT_RANGE},\n\t{\"CACHE-CONTROL\", HDR_CACHE_CONTROL},\n\t{\"CALLBACK\", HDR_CALLBACK},\n\t{\"CONTENT-ENCODING\", HDR_CONTENT_ENCODING},\n\t{\"CONTENT-LANGUAGE\", HDR_CONTENT_LANGUAGE},\n\t{\"CONTENT-LENGTH\", HDR_CONTENT_LENGTH},\n\t{\"CONTENT-LOCATION\", HDR_CONTENT_LOCATION},\n\t{\"CONTENT-RANGE\", HDR_CONTENT_RANGE},\n\t{\"CONTENT-TYPE\", HDR_CONTENT_TYPE},\n\t{\"DATE\", HDR_DATE},\n\t{\"EXT\", HDR_EXT},\n\t{\"HOST\", HDR_HOST},\n\t{\"IF-RANGE\", HDR_IF_RANGE},\n\t{\"LOCATION\", HDR_LOCATION},\n\t{\"MAN\", HDR_MAN},\n\t{\"MX\", HDR_MX},\n\t{\"NT\", HDR_NT},\n\t{\"NTS\", HDR_NTS},\n\t{\"RANGE\", HDR_RANGE},\n\t{\"SEQ\", HDR_SEQ},\n\t{\"SERVER\", HDR_SERVER},\n\t{\"SID\", HDR_SID},\n\t{\"SOAPACTION\", HDR_SOAPACTION},\n\t{\"ST\", HDR_ST},\n\t{\"TE\", HDR_TE},\n\t{\"TIMEOUT\", HDR_TIMEOUT},\n\t{\"TRANSFER-ENCODING\", HDR_TRANSFER_ENCODING},\n\t{\"USER-AGENT\", HDR_USER_AGENT},\n\t{\"USN\", HDR_USN},\n};\n\nparse_status_t parser_parse_headers(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tmemptr token;\n\tmemptr hdr_value;\n\ttoken_type_t tok_type;\n\tscanner_t *scanner = &parser->scanner;\n\tsize_t save_pos;\n\thttp_header_t *header;\n\tint header_id;\n\tint ret = 0;\n\tint index;\n\thttp_header_t *orig_header;\n\tchar save_char;\n\tint ret2;\n\n\tassert(parser->position == (parser_pos_t)POS_HEADERS ||\n\t       parser->ent_position == ENTREAD_CHUNKY_HEADERS);\n\n\twhile (TRUE) {\n\t\tsave_pos = scanner->cursor;\n\t\t/* check end of headers */\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\tswitch (tok_type) {\n\t\tcase TT_CRLF:\n\t\t\t/* end of headers */\n\t\t\tif ((parser->msg.is_request)\n\t\t\t    && (parser->msg.method == (http_method_t)HTTPMETHOD_POST)) {\n\t\t\t\tparser->position = POS_COMPLETE;\t/*post entity parsing */\n\t\t\t\t/*is handled separately  */\n\t\t\t\treturn PARSE_SUCCESS;\n\t\t\t}\n\t\t\tparser->position = POS_ENTITY;\t/* read entity next */\n\t\t\treturn PARSE_OK;\n\t\tcase TT_IDENTIFIER:\n\t\t\t/* not end; read header */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn PARSE_FAILURE;\t/* didn't see header name */\n\t\t}\n\t\tstatus = match(scanner, \" : %R%c\", &hdr_value);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\t/* add header */\n\t\t/* find header */\n\t\tindex =\n\t\t    map_str_to_int(token.buf, token.length, Http_Header_Names,\n\t\t\t\t   NUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (index != -1) {\n\t\t\t/*Check if it is a soap header */\n\t\t\tif (Http_Header_Names[index].id == HDR_SOAPACTION) {\n\t\t\t\tparser->msg.method = SOAPMETHOD_POST;\n\t\t\t}\n\t\t\theader_id = Http_Header_Names[index].id;\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr(&parser->msg, header_id, NULL);\n\t\t} else {\n\t\t\theader_id = HDR_UNKNOWN;\n\t\t\tsave_char = token.buf[token.length];\n\t\t\ttoken.buf[token.length] = '\\0';\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr_str(&parser->msg, token.buf);\n\t\t\ttoken.buf[token.length] = save_char;\t/* restore */\n\t\t}\n\t\tif (orig_header == NULL) {\n\t\t\t/* add new header */\n\t\t\theader =\n\t\t\t    (http_header_t *) malloc(sizeof(http_header_t));\n\t\t\tif (header == NULL) {\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tmembuffer_init(&header->name_buf);\n\t\t\tmembuffer_init(&header->value);\n\t\t\t/* value can be 0 length */\n\t\t\tif (hdr_value.length == (size_t)0) {\n\t\t\t\t/* FIXME: Is this a bug? buf is not const. */\n\t\t\t\thdr_value.buf = \"\\0\";\n\t\t\t\thdr_value.length = (size_t)1;\n\t\t\t}\n\t\t\t/* save in header in buffers */\n\t\t\tif (membuffer_assign(&header->name_buf, token.buf, token.length) ||\n\t\t\t    membuffer_assign(&header->value, hdr_value.buf, hdr_value.length)) {\n\t\t\t\t/* not enough mem */\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\theader->name.buf = header->name_buf.buf;\n\t\t\theader->name.length = header->name_buf.length;\n\t\t\theader->name_id = header_id;\n\t\t\tif (!ListAddTail(&parser->msg.headers, header)) {\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t} else if (hdr_value.length > (size_t)0) {\n\t\t\t/* append value to existing header */\n\t\t\t/* append space */\n\t\t\tret = membuffer_append_str(&orig_header->value, \", \");\n\t\t\t/* append continuation of header value */\n\t\t\tret2 = membuffer_append(&orig_header->value,\n\t\t\t\t\t\thdr_value.buf,\n\t\t\t\t\t\thdr_value.length);\n\t\t\tif (ret == UPNP_E_OUTOF_MEMORY\n\t\t\t    || ret2 == UPNP_E_OUTOF_MEMORY) {\n\t\t\t\t/* not enuf mem */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* end while */\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_entity",
          "args": [
            "parser"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1911-1952",
          "snippet": "UPNP_INLINE parse_status_t\nparser_parse_entity( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    assert( parser->position == POS_ENTITY );\n\n    do {\n        switch ( parser->ent_position ) {\n            case ENTREAD_USING_CLEN:\n                status = parser_parse_entity_using_clen( parser );\n                break;\n\n            case ENTREAD_USING_CHUNKED:\n                status = parser_parse_chunky_entity( parser );\n                break;\n\n            case ENTREAD_CHUNKY_BODY:\n                status = parser_parse_chunky_body( parser );\n                break;\n\n            case ENTREAD_CHUNKY_HEADERS:\n                status = parser_parse_chunky_headers( parser );\n                break;\n\n            case ENTREAD_UNTIL_CLOSE:\n                status = parser_parse_entity_until_close( parser );\n                break;\n\n            case ENTREAD_DETERMINE_READ_METHOD:\n                status = parser_get_entity_read_method( parser );\n                break;\n\n            default:\n\t\tstatus = PARSE_FAILURE;\n                assert( 0 );\n        }\n\n    } while( status == ( parse_status_t ) PARSE_CONTINUE_1 );\n\n    return status;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nUPNP_INLINE parse_status_t\nparser_parse_entity( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    assert( parser->position == POS_ENTITY );\n\n    do {\n        switch ( parser->ent_position ) {\n            case ENTREAD_USING_CLEN:\n                status = parser_parse_entity_using_clen( parser );\n                break;\n\n            case ENTREAD_USING_CHUNKED:\n                status = parser_parse_chunky_entity( parser );\n                break;\n\n            case ENTREAD_CHUNKY_BODY:\n                status = parser_parse_chunky_body( parser );\n                break;\n\n            case ENTREAD_CHUNKY_HEADERS:\n                status = parser_parse_chunky_headers( parser );\n                break;\n\n            case ENTREAD_UNTIL_CLOSE:\n                status = parser_parse_entity_until_close( parser );\n                break;\n\n            case ENTREAD_DETERMINE_READ_METHOD:\n                status = parser_get_entity_read_method( parser );\n                break;\n\n            default:\n\t\tstatus = PARSE_FAILURE;\n                assert( 0 );\n        }\n\n    } while( status == ( parse_status_t ) PARSE_CONTINUE_1 );\n\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parser != NULL"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nparser_parse( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    /*takes an http_parser_t with memory already allocated  */\n    /*in the message  */\n    assert( parser != NULL );\n\n    do {\n        switch ( parser->position ) {\n            case POS_ENTITY:\n                status = parser_parse_entity( parser );\n\n                break;\n\n            case POS_HEADERS:\n                status = parser_parse_headers( parser );\n\n                break;\n\n            case POS_REQUEST_LINE:\n                status = parser_parse_requestline( parser );\n\n                break;\n\n            case POS_RESPONSE_LINE:\n                status = parser_parse_responseline( parser );\n\n                break;\n\n            default:\n                {\n                    status = PARSE_FAILURE;\n                    assert( 0 );\n                }\n        }\n\n    } while( status == ( parse_status_t ) PARSE_OK );\n\n    return status;\n\n}"
  },
  {
    "function_name": "parser_response_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1985-1994",
    "snippet": "void\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parser_init",
          "args": [
            "parser"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "parser_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1216-1227",
          "snippet": "static UPNP_INLINE void\nparser_init( OUT http_parser_t * parser )\n{\n    memset( parser, 0, sizeof( http_parser_t ) );\n\n    parser->http_error_code = HTTP_BAD_REQUEST; /* err msg by default */\n    parser->ent_position = ENTREAD_DETERMINE_READ_METHOD;\n    parser->valid_ssdp_notify_hack = FALSE;\n\n    httpmsg_init( &parser->msg );\n    scanner_init( &parser->scanner, &parser->msg.msg );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void\nparser_init( OUT http_parser_t * parser )\n{\n    memset( parser, 0, sizeof( http_parser_t ) );\n\n    parser->http_error_code = HTTP_BAD_REQUEST; /* err msg by default */\n    parser->ent_position = ENTREAD_DETERMINE_READ_METHOD;\n    parser->valid_ssdp_notify_hack = FALSE;\n\n    httpmsg_init( &parser->msg );\n    scanner_init( &parser->scanner, &parser->msg.msg );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}"
  },
  {
    "function_name": "parser_request_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1965-1971",
    "snippet": "void\nparser_request_init( OUT http_parser_t * parser )\n{\n    parser_init( parser );\n    parser->msg.is_request = TRUE;\n    parser->position = POS_REQUEST_LINE;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parser_init",
          "args": [
            "parser"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "parser_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1216-1227",
          "snippet": "static UPNP_INLINE void\nparser_init( OUT http_parser_t * parser )\n{\n    memset( parser, 0, sizeof( http_parser_t ) );\n\n    parser->http_error_code = HTTP_BAD_REQUEST; /* err msg by default */\n    parser->ent_position = ENTREAD_DETERMINE_READ_METHOD;\n    parser->valid_ssdp_notify_hack = FALSE;\n\n    httpmsg_init( &parser->msg );\n    scanner_init( &parser->scanner, &parser->msg.msg );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void\nparser_init( OUT http_parser_t * parser )\n{\n    memset( parser, 0, sizeof( http_parser_t ) );\n\n    parser->http_error_code = HTTP_BAD_REQUEST; /* err msg by default */\n    parser->ent_position = ENTREAD_DETERMINE_READ_METHOD;\n    parser->valid_ssdp_notify_hack = FALSE;\n\n    httpmsg_init( &parser->msg );\n    scanner_init( &parser->scanner, &parser->msg.msg );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid\nparser_request_init( OUT http_parser_t * parser )\n{\n    parser_init( parser );\n    parser->msg.is_request = TRUE;\n    parser->position = POS_REQUEST_LINE;\n}"
  },
  {
    "function_name": "parser_parse_entity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1911-1952",
    "snippet": "UPNP_INLINE parse_status_t\nparser_parse_entity( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    assert( parser->position == POS_ENTITY );\n\n    do {\n        switch ( parser->ent_position ) {\n            case ENTREAD_USING_CLEN:\n                status = parser_parse_entity_using_clen( parser );\n                break;\n\n            case ENTREAD_USING_CHUNKED:\n                status = parser_parse_chunky_entity( parser );\n                break;\n\n            case ENTREAD_CHUNKY_BODY:\n                status = parser_parse_chunky_body( parser );\n                break;\n\n            case ENTREAD_CHUNKY_HEADERS:\n                status = parser_parse_chunky_headers( parser );\n                break;\n\n            case ENTREAD_UNTIL_CLOSE:\n                status = parser_parse_entity_until_close( parser );\n                break;\n\n            case ENTREAD_DETERMINE_READ_METHOD:\n                status = parser_get_entity_read_method( parser );\n                break;\n\n            default:\n\t\tstatus = PARSE_FAILURE;\n                assert( 0 );\n        }\n\n    } while( status == ( parse_status_t ) PARSE_CONTINUE_1 );\n\n    return status;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser_get_entity_read_method",
          "args": [
            "parser"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "parser_get_entity_read_method",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1808-1894",
          "snippet": "UPNP_INLINE parse_status_t\nparser_get_entity_read_method( INOUT http_parser_t * parser )\n{\n    http_message_t *hmsg = &parser->msg;\n    int response_code;\n    memptr hdr_value;\n\n    assert( parser->ent_position == ENTREAD_DETERMINE_READ_METHOD );\n\n    /* entity points to start of msg body */\n    parser->msg.entity.buf = scanner_get_str( &parser->scanner );\n    parser->msg.entity.length = ( size_t ) 0;\n\n    /* remember start of body */\n    parser->entity_start_position = parser->scanner.cursor;\n\n    /* std http rules for determining content length */\n\n    /* * no body for 1xx, 204, 304 and HEAD, GET, */\n    /*      SUBSCRIBE, UNSUBSCRIBE */\n    if( hmsg->is_request ) {\n        switch ( hmsg->method ) {\n            case HTTPMETHOD_HEAD:\n            case HTTPMETHOD_GET:\n                /*case HTTPMETHOD_POST: */\n            case HTTPMETHOD_SUBSCRIBE:\n            case HTTPMETHOD_UNSUBSCRIBE:\n            case HTTPMETHOD_MSEARCH:\n                /* no body; mark as done */\n                parser->position = POS_COMPLETE;\n                return PARSE_SUCCESS;\n                break;\n\n            default:\n                ;               /* do nothing */\n        }\n    } else                      /* response */\n    {\n        response_code = hmsg->status_code;\n\n        if( response_code == 204 ||\n            response_code == 304 ||\n            ( response_code >= 100 && response_code <= 199 ) ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_HEAD ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_MSEARCH ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_SUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_UNSUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->position = POS_COMPLETE;\n            return PARSE_SUCCESS;\n        }\n    }\n\n    /* * transfer-encoding -- used to indicate chunked data */\n    if( httpmsg_find_hdr( hmsg, HDR_TRANSFER_ENCODING, &hdr_value ) ) {\n        if( raw_find_str( &hdr_value, \"chunked\" ) >= 0 ) {\n            /* read method to use chunked transfer encoding */\n            parser->ent_position = ENTREAD_USING_CHUNKED;\n            UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n                \"Found Chunked Encoding ....\\n\" );\n\n            return PARSE_CONTINUE_1;\n        }\n    }\n    /* * use content length */\n    if( httpmsg_find_hdr( hmsg, HDR_CONTENT_LENGTH, &hdr_value ) ) {\n        parser->content_length = (unsigned int)raw_to_int(&hdr_value, 10);\n        parser->ent_position = ENTREAD_USING_CLEN;\n        return PARSE_CONTINUE_1;\n    }\n    /* * multi-part/byteranges not supported (yet) */\n\n    /* * read until connection is closed */\n    if( hmsg->is_request ) {\n        /* set hack flag for NOTIFY methods; if set to true this is */\n        /*  a valid SSDP notify msg */\n        if( hmsg->method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->valid_ssdp_notify_hack = TRUE;\n        }\n\n        parser->http_error_code = HTTP_LENGTH_REQUIRED;\n        return PARSE_FAILURE;\n    }\n\n    parser->ent_position = ENTREAD_UNTIL_CLOSE;\n    return PARSE_CONTINUE_1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nUPNP_INLINE parse_status_t\nparser_get_entity_read_method( INOUT http_parser_t * parser )\n{\n    http_message_t *hmsg = &parser->msg;\n    int response_code;\n    memptr hdr_value;\n\n    assert( parser->ent_position == ENTREAD_DETERMINE_READ_METHOD );\n\n    /* entity points to start of msg body */\n    parser->msg.entity.buf = scanner_get_str( &parser->scanner );\n    parser->msg.entity.length = ( size_t ) 0;\n\n    /* remember start of body */\n    parser->entity_start_position = parser->scanner.cursor;\n\n    /* std http rules for determining content length */\n\n    /* * no body for 1xx, 204, 304 and HEAD, GET, */\n    /*      SUBSCRIBE, UNSUBSCRIBE */\n    if( hmsg->is_request ) {\n        switch ( hmsg->method ) {\n            case HTTPMETHOD_HEAD:\n            case HTTPMETHOD_GET:\n                /*case HTTPMETHOD_POST: */\n            case HTTPMETHOD_SUBSCRIBE:\n            case HTTPMETHOD_UNSUBSCRIBE:\n            case HTTPMETHOD_MSEARCH:\n                /* no body; mark as done */\n                parser->position = POS_COMPLETE;\n                return PARSE_SUCCESS;\n                break;\n\n            default:\n                ;               /* do nothing */\n        }\n    } else                      /* response */\n    {\n        response_code = hmsg->status_code;\n\n        if( response_code == 204 ||\n            response_code == 304 ||\n            ( response_code >= 100 && response_code <= 199 ) ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_HEAD ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_MSEARCH ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_SUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_UNSUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->position = POS_COMPLETE;\n            return PARSE_SUCCESS;\n        }\n    }\n\n    /* * transfer-encoding -- used to indicate chunked data */\n    if( httpmsg_find_hdr( hmsg, HDR_TRANSFER_ENCODING, &hdr_value ) ) {\n        if( raw_find_str( &hdr_value, \"chunked\" ) >= 0 ) {\n            /* read method to use chunked transfer encoding */\n            parser->ent_position = ENTREAD_USING_CHUNKED;\n            UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n                \"Found Chunked Encoding ....\\n\" );\n\n            return PARSE_CONTINUE_1;\n        }\n    }\n    /* * use content length */\n    if( httpmsg_find_hdr( hmsg, HDR_CONTENT_LENGTH, &hdr_value ) ) {\n        parser->content_length = (unsigned int)raw_to_int(&hdr_value, 10);\n        parser->ent_position = ENTREAD_USING_CLEN;\n        return PARSE_CONTINUE_1;\n    }\n    /* * multi-part/byteranges not supported (yet) */\n\n    /* * read until connection is closed */\n    if( hmsg->is_request ) {\n        /* set hack flag for NOTIFY methods; if set to true this is */\n        /*  a valid SSDP notify msg */\n        if( hmsg->method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->valid_ssdp_notify_hack = TRUE;\n        }\n\n        parser->http_error_code = HTTP_LENGTH_REQUIRED;\n        return PARSE_FAILURE;\n    }\n\n    parser->ent_position = ENTREAD_UNTIL_CLOSE;\n    return PARSE_CONTINUE_1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_entity_until_close",
          "args": [
            "parser"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_entity_until_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1772-1793",
          "snippet": "static UPNP_INLINE parse_status_t\nparser_parse_entity_until_close( INOUT http_parser_t * parser )\n{\n    size_t cursor;\n\n    assert( parser->ent_position == ENTREAD_UNTIL_CLOSE );\n\n    /* eat any and all data */\n    cursor = parser->msg.msg.length;\n\n    /* update entity length */\n    parser->msg.entity.length = cursor - parser->entity_start_position +\n                                parser->msg.amount_discarded;\n\n    /* update pointer */\n    parser->msg.entity.buf =\n        parser->msg.msg.buf + parser->entity_start_position;\n\n    parser->scanner.cursor = cursor;\n\n    return PARSE_INCOMPLETE_ENTITY; /* add anything */\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t\nparser_parse_entity_until_close( INOUT http_parser_t * parser )\n{\n    size_t cursor;\n\n    assert( parser->ent_position == ENTREAD_UNTIL_CLOSE );\n\n    /* eat any and all data */\n    cursor = parser->msg.msg.length;\n\n    /* update entity length */\n    parser->msg.entity.length = cursor - parser->entity_start_position +\n                                parser->msg.amount_discarded;\n\n    /* update pointer */\n    parser->msg.entity.buf =\n        parser->msg.msg.buf + parser->entity_start_position;\n\n    parser->scanner.cursor = cursor;\n\n    return PARSE_INCOMPLETE_ENTITY; /* add anything */\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_chunky_headers",
          "args": [
            "parser"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_chunky_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1681-1705",
          "snippet": "static UPNP_INLINE parse_status_t\nparser_parse_chunky_headers( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n    size_t save_pos;\n\n    save_pos = parser->scanner.cursor;\n    status = parser_parse_headers( parser );\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* finally, done with the whole msg */\n        parser->position = POS_COMPLETE;\n\n        membuffer_delete( &parser->msg.msg, save_pos,\n                          ( parser->scanner.cursor - save_pos ) );\n        parser->scanner.cursor = save_pos;\n\n        /* save entity start ptr as the very last thing to do */\n        parser->msg.entity.buf = parser->msg.msg.buf +\n            parser->entity_start_position;\n\n        return PARSE_SUCCESS;\n    } else {\n        return status;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t\nparser_parse_chunky_headers( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n    size_t save_pos;\n\n    save_pos = parser->scanner.cursor;\n    status = parser_parse_headers( parser );\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* finally, done with the whole msg */\n        parser->position = POS_COMPLETE;\n\n        membuffer_delete( &parser->msg.msg, save_pos,\n                          ( parser->scanner.cursor - save_pos ) );\n        parser->scanner.cursor = save_pos;\n\n        /* save entity start ptr as the very last thing to do */\n        parser->msg.entity.buf = parser->msg.msg.buf +\n            parser->entity_start_position;\n\n        return PARSE_SUCCESS;\n    } else {\n        return status;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_chunky_body",
          "args": [
            "parser"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_chunky_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1636-1665",
          "snippet": "static UPNP_INLINE parse_status_t parser_parse_chunky_body(\n\tINOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tsize_t save_pos;\n\n\t/* if 'chunk_size' of bytes have been read; read next chunk */\n\tif ((parser->msg.msg.length - parser->scanner.cursor) >= parser->chunk_size) {\n\t\t/* move to next chunk */\n\t\tparser->scanner.cursor += parser->chunk_size;\n\t\tsave_pos = parser->scanner.cursor;\n\t\t/* discard CRLF */\n\t\tstatus = match(&parser->scanner, \"%c\");\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/*move back */\n\t\t\tparser->scanner.cursor -= parser->chunk_size;\n\t\t\t/*parser->scanner.cursor = save_pos; */\n\t\t\treturn status;\n\t\t}\n\t\tmembuffer_delete(&parser->msg.msg, save_pos,\n\t\t\t\t (parser->scanner.cursor - save_pos));\n\t\tparser->scanner.cursor = save_pos;\n\t\t/*update temp  */\n\t\tparser->msg.entity.length += parser->chunk_size;\n\t\tparser->ent_position = ENTREAD_USING_CHUNKED;\n\t\treturn PARSE_CONTINUE_1;\n\t} else\n\t\t/* need more data for chunk */\n\t\treturn PARSE_INCOMPLETE;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t parser_parse_chunky_body(\n\tINOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tsize_t save_pos;\n\n\t/* if 'chunk_size' of bytes have been read; read next chunk */\n\tif ((parser->msg.msg.length - parser->scanner.cursor) >= parser->chunk_size) {\n\t\t/* move to next chunk */\n\t\tparser->scanner.cursor += parser->chunk_size;\n\t\tsave_pos = parser->scanner.cursor;\n\t\t/* discard CRLF */\n\t\tstatus = match(&parser->scanner, \"%c\");\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/*move back */\n\t\t\tparser->scanner.cursor -= parser->chunk_size;\n\t\t\t/*parser->scanner.cursor = save_pos; */\n\t\t\treturn status;\n\t\t}\n\t\tmembuffer_delete(&parser->msg.msg, save_pos,\n\t\t\t\t (parser->scanner.cursor - save_pos));\n\t\tparser->scanner.cursor = save_pos;\n\t\t/*update temp  */\n\t\tparser->msg.entity.length += parser->chunk_size;\n\t\tparser->ent_position = ENTREAD_USING_CHUNKED;\n\t\treturn PARSE_CONTINUE_1;\n\t} else\n\t\t/* need more data for chunk */\n\t\treturn PARSE_INCOMPLETE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_chunky_entity",
          "args": [
            "parser"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_chunky_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1721-1759",
          "snippet": "static UPNP_INLINE parse_status_t\nparser_parse_chunky_entity( INOUT http_parser_t * parser )\n{\n    scanner_t *scanner = &parser->scanner;\n    parse_status_t status;\n    size_t save_pos;\n    memptr dummy;\n\n    assert( parser->ent_position == ENTREAD_USING_CHUNKED );\n\n    save_pos = scanner->cursor;\n\n    /* get size of chunk, discard extension, discard CRLF */\n    status = match( scanner, \"%x%L%c\", &parser->chunk_size, &dummy );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        scanner->cursor = save_pos;\n        UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n            \"CHUNK COULD NOT BE PARSED\\n\" );\n        return status;\n    }\n    /* remove chunk info just matched; just retain data */\n    membuffer_delete( &parser->msg.msg, save_pos,\n                      ( scanner->cursor - save_pos ) );\n    scanner->cursor = save_pos; /* adjust scanner too */\n\n    if( parser->chunk_size == (size_t)0 ) {\n        /* done reading entity; determine length of entity */\n        parser->msg.entity.length = parser->scanner.cursor -\n            parser->entity_start_position + parser->msg.amount_discarded;\n\n        /* read entity headers */\n        parser->ent_position = ENTREAD_CHUNKY_HEADERS;\n    } else {\n        /* read chunk body */\n        parser->ent_position = ENTREAD_CHUNKY_BODY;\n    }\n\n    return PARSE_CONTINUE_1;    /* continue to reading body */\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t\nparser_parse_chunky_entity( INOUT http_parser_t * parser )\n{\n    scanner_t *scanner = &parser->scanner;\n    parse_status_t status;\n    size_t save_pos;\n    memptr dummy;\n\n    assert( parser->ent_position == ENTREAD_USING_CHUNKED );\n\n    save_pos = scanner->cursor;\n\n    /* get size of chunk, discard extension, discard CRLF */\n    status = match( scanner, \"%x%L%c\", &parser->chunk_size, &dummy );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        scanner->cursor = save_pos;\n        UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n            \"CHUNK COULD NOT BE PARSED\\n\" );\n        return status;\n    }\n    /* remove chunk info just matched; just retain data */\n    membuffer_delete( &parser->msg.msg, save_pos,\n                      ( scanner->cursor - save_pos ) );\n    scanner->cursor = save_pos; /* adjust scanner too */\n\n    if( parser->chunk_size == (size_t)0 ) {\n        /* done reading entity; determine length of entity */\n        parser->msg.entity.length = parser->scanner.cursor -\n            parser->entity_start_position + parser->msg.amount_discarded;\n\n        /* read entity headers */\n        parser->ent_position = ENTREAD_CHUNKY_HEADERS;\n    } else {\n        /* read chunk body */\n        parser->ent_position = ENTREAD_CHUNKY_BODY;\n    }\n\n    return PARSE_CONTINUE_1;    /* continue to reading body */\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_entity_using_clen",
          "args": [
            "parser"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_entity_using_clen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1587-1620",
          "snippet": "static UPNP_INLINE parse_status_t\nparser_parse_entity_using_clen( INOUT http_parser_t * parser )\n{\n    /*int entity_length; */\n\n    assert( parser->ent_position == ENTREAD_USING_CLEN );\n\n    /* determine entity (i.e. body) length so far */\n    parser->msg.entity.length =\n        parser->msg.msg.length - parser->entity_start_position + \n        parser->msg.amount_discarded;\n\n    if( parser->msg.entity.length < parser->content_length ) {\n        /* more data to be read */\n        return PARSE_INCOMPLETE;\n    } else {\n        if( parser->msg.entity.length > parser->content_length ) {\n            /* silently discard extra data */\n            parser->msg.msg.buf[parser->entity_start_position +\n                                parser->content_length -\n                                parser->msg.amount_discarded] = '\\0';\n        }\n        /* save entity length */\n        parser->msg.entity.length = parser->content_length;\n\n        /* save entity start ptr; (the very last thing to do) */\n        parser->msg.entity.buf = parser->msg.msg.buf +\n                                 parser->entity_start_position;\n\n        /* done reading entity */\n        parser->position = POS_COMPLETE;\n        return PARSE_SUCCESS;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t\nparser_parse_entity_using_clen( INOUT http_parser_t * parser )\n{\n    /*int entity_length; */\n\n    assert( parser->ent_position == ENTREAD_USING_CLEN );\n\n    /* determine entity (i.e. body) length so far */\n    parser->msg.entity.length =\n        parser->msg.msg.length - parser->entity_start_position + \n        parser->msg.amount_discarded;\n\n    if( parser->msg.entity.length < parser->content_length ) {\n        /* more data to be read */\n        return PARSE_INCOMPLETE;\n    } else {\n        if( parser->msg.entity.length > parser->content_length ) {\n            /* silently discard extra data */\n            parser->msg.msg.buf[parser->entity_start_position +\n                                parser->content_length -\n                                parser->msg.amount_discarded] = '\\0';\n        }\n        /* save entity length */\n        parser->msg.entity.length = parser->content_length;\n\n        /* save entity start ptr; (the very last thing to do) */\n        parser->msg.entity.buf = parser->msg.msg.buf +\n                                 parser->entity_start_position;\n\n        /* done reading entity */\n        parser->position = POS_COMPLETE;\n        return PARSE_SUCCESS;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parser->position == POS_ENTITY"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nUPNP_INLINE parse_status_t\nparser_parse_entity( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    assert( parser->position == POS_ENTITY );\n\n    do {\n        switch ( parser->ent_position ) {\n            case ENTREAD_USING_CLEN:\n                status = parser_parse_entity_using_clen( parser );\n                break;\n\n            case ENTREAD_USING_CHUNKED:\n                status = parser_parse_chunky_entity( parser );\n                break;\n\n            case ENTREAD_CHUNKY_BODY:\n                status = parser_parse_chunky_body( parser );\n                break;\n\n            case ENTREAD_CHUNKY_HEADERS:\n                status = parser_parse_chunky_headers( parser );\n                break;\n\n            case ENTREAD_UNTIL_CLOSE:\n                status = parser_parse_entity_until_close( parser );\n                break;\n\n            case ENTREAD_DETERMINE_READ_METHOD:\n                status = parser_get_entity_read_method( parser );\n                break;\n\n            default:\n\t\tstatus = PARSE_FAILURE;\n                assert( 0 );\n        }\n\n    } while( status == ( parse_status_t ) PARSE_CONTINUE_1 );\n\n    return status;\n}"
  },
  {
    "function_name": "parser_get_entity_read_method",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1808-1894",
    "snippet": "UPNP_INLINE parse_status_t\nparser_get_entity_read_method( INOUT http_parser_t * parser )\n{\n    http_message_t *hmsg = &parser->msg;\n    int response_code;\n    memptr hdr_value;\n\n    assert( parser->ent_position == ENTREAD_DETERMINE_READ_METHOD );\n\n    /* entity points to start of msg body */\n    parser->msg.entity.buf = scanner_get_str( &parser->scanner );\n    parser->msg.entity.length = ( size_t ) 0;\n\n    /* remember start of body */\n    parser->entity_start_position = parser->scanner.cursor;\n\n    /* std http rules for determining content length */\n\n    /* * no body for 1xx, 204, 304 and HEAD, GET, */\n    /*      SUBSCRIBE, UNSUBSCRIBE */\n    if( hmsg->is_request ) {\n        switch ( hmsg->method ) {\n            case HTTPMETHOD_HEAD:\n            case HTTPMETHOD_GET:\n                /*case HTTPMETHOD_POST: */\n            case HTTPMETHOD_SUBSCRIBE:\n            case HTTPMETHOD_UNSUBSCRIBE:\n            case HTTPMETHOD_MSEARCH:\n                /* no body; mark as done */\n                parser->position = POS_COMPLETE;\n                return PARSE_SUCCESS;\n                break;\n\n            default:\n                ;               /* do nothing */\n        }\n    } else                      /* response */\n    {\n        response_code = hmsg->status_code;\n\n        if( response_code == 204 ||\n            response_code == 304 ||\n            ( response_code >= 100 && response_code <= 199 ) ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_HEAD ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_MSEARCH ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_SUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_UNSUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->position = POS_COMPLETE;\n            return PARSE_SUCCESS;\n        }\n    }\n\n    /* * transfer-encoding -- used to indicate chunked data */\n    if( httpmsg_find_hdr( hmsg, HDR_TRANSFER_ENCODING, &hdr_value ) ) {\n        if( raw_find_str( &hdr_value, \"chunked\" ) >= 0 ) {\n            /* read method to use chunked transfer encoding */\n            parser->ent_position = ENTREAD_USING_CHUNKED;\n            UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n                \"Found Chunked Encoding ....\\n\" );\n\n            return PARSE_CONTINUE_1;\n        }\n    }\n    /* * use content length */\n    if( httpmsg_find_hdr( hmsg, HDR_CONTENT_LENGTH, &hdr_value ) ) {\n        parser->content_length = (unsigned int)raw_to_int(&hdr_value, 10);\n        parser->ent_position = ENTREAD_USING_CLEN;\n        return PARSE_CONTINUE_1;\n    }\n    /* * multi-part/byteranges not supported (yet) */\n\n    /* * read until connection is closed */\n    if( hmsg->is_request ) {\n        /* set hack flag for NOTIFY methods; if set to true this is */\n        /*  a valid SSDP notify msg */\n        if( hmsg->method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->valid_ssdp_notify_hack = TRUE;\n        }\n\n        parser->http_error_code = HTTP_LENGTH_REQUIRED;\n        return PARSE_FAILURE;\n    }\n\n    parser->ent_position = ENTREAD_UNTIL_CLOSE;\n    return PARSE_CONTINUE_1;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_to_int",
          "args": [
            "&hdr_value",
            "10"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "raw_to_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "2107-2125",
          "snippet": "int raw_to_int(IN memptr *raw_value, IN int base)\n{\n\tlong num;\n\tchar *end_ptr;\n\n\tif (raw_value->length == (size_t)0)\n\t\treturn -1;\n\terrno = 0;\n\tnum = strtol(raw_value->buf, &end_ptr, base);\n\tif ((num < 0)\n\t    /* all and only those chars in token should be used for num */\n\t    || (end_ptr != raw_value->buf + raw_value->length)\n\t    || ((num == LONG_MIN || num == LONG_MAX)\n\t\t&& (errno == ERANGE))\n\t    ) {\n\t\treturn -1;\n\t}\n\treturn (int)num;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nint raw_to_int(IN memptr *raw_value, IN int base)\n{\n\tlong num;\n\tchar *end_ptr;\n\n\tif (raw_value->length == (size_t)0)\n\t\treturn -1;\n\terrno = 0;\n\tnum = strtol(raw_value->buf, &end_ptr, base);\n\tif ((num < 0)\n\t    /* all and only those chars in token should be used for num */\n\t    || (end_ptr != raw_value->buf + raw_value->length)\n\t    || ((num == LONG_MIN || num == LONG_MAX)\n\t\t&& (errno == ERANGE))\n\t    ) {\n\t\treturn -1;\n\t}\n\treturn (int)num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "hmsg",
            "HDR_CONTENT_LENGTH",
            "&hdr_value"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\"Found Chunked Encoding ....\\n\""
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_find_str",
          "args": [
            "&hdr_value",
            "\"chunked\""
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "raw_find_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "2141-2170",
          "snippet": "int raw_find_str(IN memptr *raw_value, IN const char *str)\n{\n    char c;\n    char *ptr;\n    int i = 0;\n\n    /* save */\n    c = raw_value->buf[raw_value->length];\n\n    /* Make it lowercase */\n    for (i = 0; raw_value->buf[i]; ++i) {\n        raw_value->buf[i] = (char)tolower(raw_value->buf[i]);\n    }\n\n    /* null-terminate */\n    raw_value->buf[raw_value->length] = 0;\n\n    /* Find the substring position */\n    ptr = strstr( raw_value->buf, str );\n\n    /* restore the \"length\" byte */\n    raw_value->buf[raw_value->length] = c;\n\n    if( ptr == 0 ) {\n        return -1;\n    }\n\n    /* return index */\n    return (int)(ptr - raw_value->buf);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nint raw_find_str(IN memptr *raw_value, IN const char *str)\n{\n    char c;\n    char *ptr;\n    int i = 0;\n\n    /* save */\n    c = raw_value->buf[raw_value->length];\n\n    /* Make it lowercase */\n    for (i = 0; raw_value->buf[i]; ++i) {\n        raw_value->buf[i] = (char)tolower(raw_value->buf[i]);\n    }\n\n    /* null-terminate */\n    raw_value->buf[raw_value->length] = 0;\n\n    /* Find the substring position */\n    ptr = strstr( raw_value->buf, str );\n\n    /* restore the \"length\" byte */\n    raw_value->buf[raw_value->length] = c;\n\n    if( ptr == 0 ) {\n        return -1;\n    }\n\n    /* return index */\n    return (int)(ptr - raw_value->buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_get_str",
          "args": [
            "&parser->scanner"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "340-343",
          "snippet": "static UPNP_INLINE char *scanner_get_str(IN scanner_t * scanner)\n{\n\treturn scanner->msg->buf + scanner->cursor;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE char *scanner_get_str(IN scanner_t * scanner)\n{\n\treturn scanner->msg->buf + scanner->cursor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parser->ent_position == ENTREAD_DETERMINE_READ_METHOD"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nUPNP_INLINE parse_status_t\nparser_get_entity_read_method( INOUT http_parser_t * parser )\n{\n    http_message_t *hmsg = &parser->msg;\n    int response_code;\n    memptr hdr_value;\n\n    assert( parser->ent_position == ENTREAD_DETERMINE_READ_METHOD );\n\n    /* entity points to start of msg body */\n    parser->msg.entity.buf = scanner_get_str( &parser->scanner );\n    parser->msg.entity.length = ( size_t ) 0;\n\n    /* remember start of body */\n    parser->entity_start_position = parser->scanner.cursor;\n\n    /* std http rules for determining content length */\n\n    /* * no body for 1xx, 204, 304 and HEAD, GET, */\n    /*      SUBSCRIBE, UNSUBSCRIBE */\n    if( hmsg->is_request ) {\n        switch ( hmsg->method ) {\n            case HTTPMETHOD_HEAD:\n            case HTTPMETHOD_GET:\n                /*case HTTPMETHOD_POST: */\n            case HTTPMETHOD_SUBSCRIBE:\n            case HTTPMETHOD_UNSUBSCRIBE:\n            case HTTPMETHOD_MSEARCH:\n                /* no body; mark as done */\n                parser->position = POS_COMPLETE;\n                return PARSE_SUCCESS;\n                break;\n\n            default:\n                ;               /* do nothing */\n        }\n    } else                      /* response */\n    {\n        response_code = hmsg->status_code;\n\n        if( response_code == 204 ||\n            response_code == 304 ||\n            ( response_code >= 100 && response_code <= 199 ) ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_HEAD ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_MSEARCH ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_SUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_UNSUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->position = POS_COMPLETE;\n            return PARSE_SUCCESS;\n        }\n    }\n\n    /* * transfer-encoding -- used to indicate chunked data */\n    if( httpmsg_find_hdr( hmsg, HDR_TRANSFER_ENCODING, &hdr_value ) ) {\n        if( raw_find_str( &hdr_value, \"chunked\" ) >= 0 ) {\n            /* read method to use chunked transfer encoding */\n            parser->ent_position = ENTREAD_USING_CHUNKED;\n            UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n                \"Found Chunked Encoding ....\\n\" );\n\n            return PARSE_CONTINUE_1;\n        }\n    }\n    /* * use content length */\n    if( httpmsg_find_hdr( hmsg, HDR_CONTENT_LENGTH, &hdr_value ) ) {\n        parser->content_length = (unsigned int)raw_to_int(&hdr_value, 10);\n        parser->ent_position = ENTREAD_USING_CLEN;\n        return PARSE_CONTINUE_1;\n    }\n    /* * multi-part/byteranges not supported (yet) */\n\n    /* * read until connection is closed */\n    if( hmsg->is_request ) {\n        /* set hack flag for NOTIFY methods; if set to true this is */\n        /*  a valid SSDP notify msg */\n        if( hmsg->method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->valid_ssdp_notify_hack = TRUE;\n        }\n\n        parser->http_error_code = HTTP_LENGTH_REQUIRED;\n        return PARSE_FAILURE;\n    }\n\n    parser->ent_position = ENTREAD_UNTIL_CLOSE;\n    return PARSE_CONTINUE_1;\n}"
  },
  {
    "function_name": "parser_parse_entity_until_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1772-1793",
    "snippet": "static UPNP_INLINE parse_status_t\nparser_parse_entity_until_close( INOUT http_parser_t * parser )\n{\n    size_t cursor;\n\n    assert( parser->ent_position == ENTREAD_UNTIL_CLOSE );\n\n    /* eat any and all data */\n    cursor = parser->msg.msg.length;\n\n    /* update entity length */\n    parser->msg.entity.length = cursor - parser->entity_start_position +\n                                parser->msg.amount_discarded;\n\n    /* update pointer */\n    parser->msg.entity.buf =\n        parser->msg.msg.buf + parser->entity_start_position;\n\n    parser->scanner.cursor = cursor;\n\n    return PARSE_INCOMPLETE_ENTITY; /* add anything */\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parser->ent_position == ENTREAD_UNTIL_CLOSE"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t\nparser_parse_entity_until_close( INOUT http_parser_t * parser )\n{\n    size_t cursor;\n\n    assert( parser->ent_position == ENTREAD_UNTIL_CLOSE );\n\n    /* eat any and all data */\n    cursor = parser->msg.msg.length;\n\n    /* update entity length */\n    parser->msg.entity.length = cursor - parser->entity_start_position +\n                                parser->msg.amount_discarded;\n\n    /* update pointer */\n    parser->msg.entity.buf =\n        parser->msg.msg.buf + parser->entity_start_position;\n\n    parser->scanner.cursor = cursor;\n\n    return PARSE_INCOMPLETE_ENTITY; /* add anything */\n}"
  },
  {
    "function_name": "parser_parse_chunky_entity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1721-1759",
    "snippet": "static UPNP_INLINE parse_status_t\nparser_parse_chunky_entity( INOUT http_parser_t * parser )\n{\n    scanner_t *scanner = &parser->scanner;\n    parse_status_t status;\n    size_t save_pos;\n    memptr dummy;\n\n    assert( parser->ent_position == ENTREAD_USING_CHUNKED );\n\n    save_pos = scanner->cursor;\n\n    /* get size of chunk, discard extension, discard CRLF */\n    status = match( scanner, \"%x%L%c\", &parser->chunk_size, &dummy );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        scanner->cursor = save_pos;\n        UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n            \"CHUNK COULD NOT BE PARSED\\n\" );\n        return status;\n    }\n    /* remove chunk info just matched; just retain data */\n    membuffer_delete( &parser->msg.msg, save_pos,\n                      ( scanner->cursor - save_pos ) );\n    scanner->cursor = save_pos; /* adjust scanner too */\n\n    if( parser->chunk_size == (size_t)0 ) {\n        /* done reading entity; determine length of entity */\n        parser->msg.entity.length = parser->scanner.cursor -\n            parser->entity_start_position + parser->msg.amount_discarded;\n\n        /* read entity headers */\n        parser->ent_position = ENTREAD_CHUNKY_HEADERS;\n    } else {\n        /* read chunk body */\n        parser->ent_position = ENTREAD_CHUNKY_BODY;\n    }\n\n    return PARSE_CONTINUE_1;    /* continue to reading body */\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_delete",
          "args": [
            "&parser->msg.msg",
            "save_pos",
            "( scanner->cursor - save_pos )"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "240-271",
          "snippet": "void membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\"CHUNK COULD NOT BE PARSED\\n\""
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "scanner",
            "\"%x%L%c\"",
            "&parser->chunk_size",
            "&dummy"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1135-1148",
          "snippet": "static parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parser->ent_position == ENTREAD_USING_CHUNKED"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t\nparser_parse_chunky_entity( INOUT http_parser_t * parser )\n{\n    scanner_t *scanner = &parser->scanner;\n    parse_status_t status;\n    size_t save_pos;\n    memptr dummy;\n\n    assert( parser->ent_position == ENTREAD_USING_CHUNKED );\n\n    save_pos = scanner->cursor;\n\n    /* get size of chunk, discard extension, discard CRLF */\n    status = match( scanner, \"%x%L%c\", &parser->chunk_size, &dummy );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        scanner->cursor = save_pos;\n        UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n            \"CHUNK COULD NOT BE PARSED\\n\" );\n        return status;\n    }\n    /* remove chunk info just matched; just retain data */\n    membuffer_delete( &parser->msg.msg, save_pos,\n                      ( scanner->cursor - save_pos ) );\n    scanner->cursor = save_pos; /* adjust scanner too */\n\n    if( parser->chunk_size == (size_t)0 ) {\n        /* done reading entity; determine length of entity */\n        parser->msg.entity.length = parser->scanner.cursor -\n            parser->entity_start_position + parser->msg.amount_discarded;\n\n        /* read entity headers */\n        parser->ent_position = ENTREAD_CHUNKY_HEADERS;\n    } else {\n        /* read chunk body */\n        parser->ent_position = ENTREAD_CHUNKY_BODY;\n    }\n\n    return PARSE_CONTINUE_1;    /* continue to reading body */\n}"
  },
  {
    "function_name": "parser_parse_chunky_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1681-1705",
    "snippet": "static UPNP_INLINE parse_status_t\nparser_parse_chunky_headers( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n    size_t save_pos;\n\n    save_pos = parser->scanner.cursor;\n    status = parser_parse_headers( parser );\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* finally, done with the whole msg */\n        parser->position = POS_COMPLETE;\n\n        membuffer_delete( &parser->msg.msg, save_pos,\n                          ( parser->scanner.cursor - save_pos ) );\n        parser->scanner.cursor = save_pos;\n\n        /* save entity start ptr as the very last thing to do */\n        parser->msg.entity.buf = parser->msg.msg.buf +\n            parser->entity_start_position;\n\n        return PARSE_SUCCESS;\n    } else {\n        return status;\n    }\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_delete",
          "args": [
            "&parser->msg.msg",
            "save_pos",
            "( parser->scanner.cursor - save_pos )"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "240-271",
          "snippet": "void membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_headers",
          "args": [
            "parser"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1446-1573",
          "snippet": "parse_status_t parser_parse_headers(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tmemptr token;\n\tmemptr hdr_value;\n\ttoken_type_t tok_type;\n\tscanner_t *scanner = &parser->scanner;\n\tsize_t save_pos;\n\thttp_header_t *header;\n\tint header_id;\n\tint ret = 0;\n\tint index;\n\thttp_header_t *orig_header;\n\tchar save_char;\n\tint ret2;\n\n\tassert(parser->position == (parser_pos_t)POS_HEADERS ||\n\t       parser->ent_position == ENTREAD_CHUNKY_HEADERS);\n\n\twhile (TRUE) {\n\t\tsave_pos = scanner->cursor;\n\t\t/* check end of headers */\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\tswitch (tok_type) {\n\t\tcase TT_CRLF:\n\t\t\t/* end of headers */\n\t\t\tif ((parser->msg.is_request)\n\t\t\t    && (parser->msg.method == (http_method_t)HTTPMETHOD_POST)) {\n\t\t\t\tparser->position = POS_COMPLETE;\t/*post entity parsing */\n\t\t\t\t/*is handled separately  */\n\t\t\t\treturn PARSE_SUCCESS;\n\t\t\t}\n\t\t\tparser->position = POS_ENTITY;\t/* read entity next */\n\t\t\treturn PARSE_OK;\n\t\tcase TT_IDENTIFIER:\n\t\t\t/* not end; read header */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn PARSE_FAILURE;\t/* didn't see header name */\n\t\t}\n\t\tstatus = match(scanner, \" : %R%c\", &hdr_value);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\t/* add header */\n\t\t/* find header */\n\t\tindex =\n\t\t    map_str_to_int(token.buf, token.length, Http_Header_Names,\n\t\t\t\t   NUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (index != -1) {\n\t\t\t/*Check if it is a soap header */\n\t\t\tif (Http_Header_Names[index].id == HDR_SOAPACTION) {\n\t\t\t\tparser->msg.method = SOAPMETHOD_POST;\n\t\t\t}\n\t\t\theader_id = Http_Header_Names[index].id;\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr(&parser->msg, header_id, NULL);\n\t\t} else {\n\t\t\theader_id = HDR_UNKNOWN;\n\t\t\tsave_char = token.buf[token.length];\n\t\t\ttoken.buf[token.length] = '\\0';\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr_str(&parser->msg, token.buf);\n\t\t\ttoken.buf[token.length] = save_char;\t/* restore */\n\t\t}\n\t\tif (orig_header == NULL) {\n\t\t\t/* add new header */\n\t\t\theader =\n\t\t\t    (http_header_t *) malloc(sizeof(http_header_t));\n\t\t\tif (header == NULL) {\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tmembuffer_init(&header->name_buf);\n\t\t\tmembuffer_init(&header->value);\n\t\t\t/* value can be 0 length */\n\t\t\tif (hdr_value.length == (size_t)0) {\n\t\t\t\t/* FIXME: Is this a bug? buf is not const. */\n\t\t\t\thdr_value.buf = \"\\0\";\n\t\t\t\thdr_value.length = (size_t)1;\n\t\t\t}\n\t\t\t/* save in header in buffers */\n\t\t\tif (membuffer_assign(&header->name_buf, token.buf, token.length) ||\n\t\t\t    membuffer_assign(&header->value, hdr_value.buf, hdr_value.length)) {\n\t\t\t\t/* not enough mem */\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\theader->name.buf = header->name_buf.buf;\n\t\t\theader->name.length = header->name_buf.length;\n\t\t\theader->name_id = header_id;\n\t\t\tif (!ListAddTail(&parser->msg.headers, header)) {\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t} else if (hdr_value.length > (size_t)0) {\n\t\t\t/* append value to existing header */\n\t\t\t/* append space */\n\t\t\tret = membuffer_append_str(&orig_header->value, \", \");\n\t\t\t/* append continuation of header value */\n\t\t\tret2 = membuffer_append(&orig_header->value,\n\t\t\t\t\t\thdr_value.buf,\n\t\t\t\t\t\thdr_value.length);\n\t\t\tif (ret == UPNP_E_OUTOF_MEMORY\n\t\t\t    || ret2 == UPNP_E_OUTOF_MEMORY) {\n\t\t\t\t/* not enuf mem */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* end while */\n\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HTTP_HEADER_NAMES 33"
          ],
          "globals_used": [
            "str_int_entry Http_Header_Names[NUM_HTTP_HEADER_NAMES] = {\n\t{\"ACCEPT\", HDR_ACCEPT},\n\t{\"ACCEPT-CHARSET\", HDR_ACCEPT_CHARSET},\n\t{\"ACCEPT-ENCODING\", HDR_ACCEPT_ENCODING},\n\t{\"ACCEPT-LANGUAGE\", HDR_ACCEPT_LANGUAGE},\n\t{\"ACCEPT-RANGES\", HDR_ACCEPT_RANGE},\n\t{\"CACHE-CONTROL\", HDR_CACHE_CONTROL},\n\t{\"CALLBACK\", HDR_CALLBACK},\n\t{\"CONTENT-ENCODING\", HDR_CONTENT_ENCODING},\n\t{\"CONTENT-LANGUAGE\", HDR_CONTENT_LANGUAGE},\n\t{\"CONTENT-LENGTH\", HDR_CONTENT_LENGTH},\n\t{\"CONTENT-LOCATION\", HDR_CONTENT_LOCATION},\n\t{\"CONTENT-RANGE\", HDR_CONTENT_RANGE},\n\t{\"CONTENT-TYPE\", HDR_CONTENT_TYPE},\n\t{\"DATE\", HDR_DATE},\n\t{\"EXT\", HDR_EXT},\n\t{\"HOST\", HDR_HOST},\n\t{\"IF-RANGE\", HDR_IF_RANGE},\n\t{\"LOCATION\", HDR_LOCATION},\n\t{\"MAN\", HDR_MAN},\n\t{\"MX\", HDR_MX},\n\t{\"NT\", HDR_NT},\n\t{\"NTS\", HDR_NTS},\n\t{\"RANGE\", HDR_RANGE},\n\t{\"SEQ\", HDR_SEQ},\n\t{\"SERVER\", HDR_SERVER},\n\t{\"SID\", HDR_SID},\n\t{\"SOAPACTION\", HDR_SOAPACTION},\n\t{\"ST\", HDR_ST},\n\t{\"TE\", HDR_TE},\n\t{\"TIMEOUT\", HDR_TIMEOUT},\n\t{\"TRANSFER-ENCODING\", HDR_TRANSFER_ENCODING},\n\t{\"USER-AGENT\", HDR_USER_AGENT},\n\t{\"USN\", HDR_USN},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define NUM_HTTP_HEADER_NAMES 33\n\nstr_int_entry Http_Header_Names[NUM_HTTP_HEADER_NAMES] = {\n\t{\"ACCEPT\", HDR_ACCEPT},\n\t{\"ACCEPT-CHARSET\", HDR_ACCEPT_CHARSET},\n\t{\"ACCEPT-ENCODING\", HDR_ACCEPT_ENCODING},\n\t{\"ACCEPT-LANGUAGE\", HDR_ACCEPT_LANGUAGE},\n\t{\"ACCEPT-RANGES\", HDR_ACCEPT_RANGE},\n\t{\"CACHE-CONTROL\", HDR_CACHE_CONTROL},\n\t{\"CALLBACK\", HDR_CALLBACK},\n\t{\"CONTENT-ENCODING\", HDR_CONTENT_ENCODING},\n\t{\"CONTENT-LANGUAGE\", HDR_CONTENT_LANGUAGE},\n\t{\"CONTENT-LENGTH\", HDR_CONTENT_LENGTH},\n\t{\"CONTENT-LOCATION\", HDR_CONTENT_LOCATION},\n\t{\"CONTENT-RANGE\", HDR_CONTENT_RANGE},\n\t{\"CONTENT-TYPE\", HDR_CONTENT_TYPE},\n\t{\"DATE\", HDR_DATE},\n\t{\"EXT\", HDR_EXT},\n\t{\"HOST\", HDR_HOST},\n\t{\"IF-RANGE\", HDR_IF_RANGE},\n\t{\"LOCATION\", HDR_LOCATION},\n\t{\"MAN\", HDR_MAN},\n\t{\"MX\", HDR_MX},\n\t{\"NT\", HDR_NT},\n\t{\"NTS\", HDR_NTS},\n\t{\"RANGE\", HDR_RANGE},\n\t{\"SEQ\", HDR_SEQ},\n\t{\"SERVER\", HDR_SERVER},\n\t{\"SID\", HDR_SID},\n\t{\"SOAPACTION\", HDR_SOAPACTION},\n\t{\"ST\", HDR_ST},\n\t{\"TE\", HDR_TE},\n\t{\"TIMEOUT\", HDR_TIMEOUT},\n\t{\"TRANSFER-ENCODING\", HDR_TRANSFER_ENCODING},\n\t{\"USER-AGENT\", HDR_USER_AGENT},\n\t{\"USN\", HDR_USN},\n};\n\nparse_status_t parser_parse_headers(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tmemptr token;\n\tmemptr hdr_value;\n\ttoken_type_t tok_type;\n\tscanner_t *scanner = &parser->scanner;\n\tsize_t save_pos;\n\thttp_header_t *header;\n\tint header_id;\n\tint ret = 0;\n\tint index;\n\thttp_header_t *orig_header;\n\tchar save_char;\n\tint ret2;\n\n\tassert(parser->position == (parser_pos_t)POS_HEADERS ||\n\t       parser->ent_position == ENTREAD_CHUNKY_HEADERS);\n\n\twhile (TRUE) {\n\t\tsave_pos = scanner->cursor;\n\t\t/* check end of headers */\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\tswitch (tok_type) {\n\t\tcase TT_CRLF:\n\t\t\t/* end of headers */\n\t\t\tif ((parser->msg.is_request)\n\t\t\t    && (parser->msg.method == (http_method_t)HTTPMETHOD_POST)) {\n\t\t\t\tparser->position = POS_COMPLETE;\t/*post entity parsing */\n\t\t\t\t/*is handled separately  */\n\t\t\t\treturn PARSE_SUCCESS;\n\t\t\t}\n\t\t\tparser->position = POS_ENTITY;\t/* read entity next */\n\t\t\treturn PARSE_OK;\n\t\tcase TT_IDENTIFIER:\n\t\t\t/* not end; read header */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn PARSE_FAILURE;\t/* didn't see header name */\n\t\t}\n\t\tstatus = match(scanner, \" : %R%c\", &hdr_value);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\t/* add header */\n\t\t/* find header */\n\t\tindex =\n\t\t    map_str_to_int(token.buf, token.length, Http_Header_Names,\n\t\t\t\t   NUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (index != -1) {\n\t\t\t/*Check if it is a soap header */\n\t\t\tif (Http_Header_Names[index].id == HDR_SOAPACTION) {\n\t\t\t\tparser->msg.method = SOAPMETHOD_POST;\n\t\t\t}\n\t\t\theader_id = Http_Header_Names[index].id;\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr(&parser->msg, header_id, NULL);\n\t\t} else {\n\t\t\theader_id = HDR_UNKNOWN;\n\t\t\tsave_char = token.buf[token.length];\n\t\t\ttoken.buf[token.length] = '\\0';\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr_str(&parser->msg, token.buf);\n\t\t\ttoken.buf[token.length] = save_char;\t/* restore */\n\t\t}\n\t\tif (orig_header == NULL) {\n\t\t\t/* add new header */\n\t\t\theader =\n\t\t\t    (http_header_t *) malloc(sizeof(http_header_t));\n\t\t\tif (header == NULL) {\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tmembuffer_init(&header->name_buf);\n\t\t\tmembuffer_init(&header->value);\n\t\t\t/* value can be 0 length */\n\t\t\tif (hdr_value.length == (size_t)0) {\n\t\t\t\t/* FIXME: Is this a bug? buf is not const. */\n\t\t\t\thdr_value.buf = \"\\0\";\n\t\t\t\thdr_value.length = (size_t)1;\n\t\t\t}\n\t\t\t/* save in header in buffers */\n\t\t\tif (membuffer_assign(&header->name_buf, token.buf, token.length) ||\n\t\t\t    membuffer_assign(&header->value, hdr_value.buf, hdr_value.length)) {\n\t\t\t\t/* not enough mem */\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\theader->name.buf = header->name_buf.buf;\n\t\t\theader->name.length = header->name_buf.length;\n\t\t\theader->name_id = header_id;\n\t\t\tif (!ListAddTail(&parser->msg.headers, header)) {\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t} else if (hdr_value.length > (size_t)0) {\n\t\t\t/* append value to existing header */\n\t\t\t/* append space */\n\t\t\tret = membuffer_append_str(&orig_header->value, \", \");\n\t\t\t/* append continuation of header value */\n\t\t\tret2 = membuffer_append(&orig_header->value,\n\t\t\t\t\t\thdr_value.buf,\n\t\t\t\t\t\thdr_value.length);\n\t\t\tif (ret == UPNP_E_OUTOF_MEMORY\n\t\t\t    || ret2 == UPNP_E_OUTOF_MEMORY) {\n\t\t\t\t/* not enuf mem */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* end while */\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t\nparser_parse_chunky_headers( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n    size_t save_pos;\n\n    save_pos = parser->scanner.cursor;\n    status = parser_parse_headers( parser );\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* finally, done with the whole msg */\n        parser->position = POS_COMPLETE;\n\n        membuffer_delete( &parser->msg.msg, save_pos,\n                          ( parser->scanner.cursor - save_pos ) );\n        parser->scanner.cursor = save_pos;\n\n        /* save entity start ptr as the very last thing to do */\n        parser->msg.entity.buf = parser->msg.msg.buf +\n            parser->entity_start_position;\n\n        return PARSE_SUCCESS;\n    } else {\n        return status;\n    }\n}"
  },
  {
    "function_name": "parser_parse_chunky_body",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1636-1665",
    "snippet": "static UPNP_INLINE parse_status_t parser_parse_chunky_body(\n\tINOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tsize_t save_pos;\n\n\t/* if 'chunk_size' of bytes have been read; read next chunk */\n\tif ((parser->msg.msg.length - parser->scanner.cursor) >= parser->chunk_size) {\n\t\t/* move to next chunk */\n\t\tparser->scanner.cursor += parser->chunk_size;\n\t\tsave_pos = parser->scanner.cursor;\n\t\t/* discard CRLF */\n\t\tstatus = match(&parser->scanner, \"%c\");\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/*move back */\n\t\t\tparser->scanner.cursor -= parser->chunk_size;\n\t\t\t/*parser->scanner.cursor = save_pos; */\n\t\t\treturn status;\n\t\t}\n\t\tmembuffer_delete(&parser->msg.msg, save_pos,\n\t\t\t\t (parser->scanner.cursor - save_pos));\n\t\tparser->scanner.cursor = save_pos;\n\t\t/*update temp  */\n\t\tparser->msg.entity.length += parser->chunk_size;\n\t\tparser->ent_position = ENTREAD_USING_CHUNKED;\n\t\treturn PARSE_CONTINUE_1;\n\t} else\n\t\t/* need more data for chunk */\n\t\treturn PARSE_INCOMPLETE;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_delete",
          "args": [
            "&parser->msg.msg",
            "save_pos",
            "(parser->scanner.cursor - save_pos)"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "240-271",
          "snippet": "void membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "&parser->scanner",
            "\"%c\""
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1135-1148",
          "snippet": "static parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t parser_parse_chunky_body(\n\tINOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tsize_t save_pos;\n\n\t/* if 'chunk_size' of bytes have been read; read next chunk */\n\tif ((parser->msg.msg.length - parser->scanner.cursor) >= parser->chunk_size) {\n\t\t/* move to next chunk */\n\t\tparser->scanner.cursor += parser->chunk_size;\n\t\tsave_pos = parser->scanner.cursor;\n\t\t/* discard CRLF */\n\t\tstatus = match(&parser->scanner, \"%c\");\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/*move back */\n\t\t\tparser->scanner.cursor -= parser->chunk_size;\n\t\t\t/*parser->scanner.cursor = save_pos; */\n\t\t\treturn status;\n\t\t}\n\t\tmembuffer_delete(&parser->msg.msg, save_pos,\n\t\t\t\t (parser->scanner.cursor - save_pos));\n\t\tparser->scanner.cursor = save_pos;\n\t\t/*update temp  */\n\t\tparser->msg.entity.length += parser->chunk_size;\n\t\tparser->ent_position = ENTREAD_USING_CHUNKED;\n\t\treturn PARSE_CONTINUE_1;\n\t} else\n\t\t/* need more data for chunk */\n\t\treturn PARSE_INCOMPLETE;\n}"
  },
  {
    "function_name": "parser_parse_entity_using_clen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1587-1620",
    "snippet": "static UPNP_INLINE parse_status_t\nparser_parse_entity_using_clen( INOUT http_parser_t * parser )\n{\n    /*int entity_length; */\n\n    assert( parser->ent_position == ENTREAD_USING_CLEN );\n\n    /* determine entity (i.e. body) length so far */\n    parser->msg.entity.length =\n        parser->msg.msg.length - parser->entity_start_position + \n        parser->msg.amount_discarded;\n\n    if( parser->msg.entity.length < parser->content_length ) {\n        /* more data to be read */\n        return PARSE_INCOMPLETE;\n    } else {\n        if( parser->msg.entity.length > parser->content_length ) {\n            /* silently discard extra data */\n            parser->msg.msg.buf[parser->entity_start_position +\n                                parser->content_length -\n                                parser->msg.amount_discarded] = '\\0';\n        }\n        /* save entity length */\n        parser->msg.entity.length = parser->content_length;\n\n        /* save entity start ptr; (the very last thing to do) */\n        parser->msg.entity.buf = parser->msg.msg.buf +\n                                 parser->entity_start_position;\n\n        /* done reading entity */\n        parser->position = POS_COMPLETE;\n        return PARSE_SUCCESS;\n    }\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parser->ent_position == ENTREAD_USING_CLEN"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t\nparser_parse_entity_using_clen( INOUT http_parser_t * parser )\n{\n    /*int entity_length; */\n\n    assert( parser->ent_position == ENTREAD_USING_CLEN );\n\n    /* determine entity (i.e. body) length so far */\n    parser->msg.entity.length =\n        parser->msg.msg.length - parser->entity_start_position + \n        parser->msg.amount_discarded;\n\n    if( parser->msg.entity.length < parser->content_length ) {\n        /* more data to be read */\n        return PARSE_INCOMPLETE;\n    } else {\n        if( parser->msg.entity.length > parser->content_length ) {\n            /* silently discard extra data */\n            parser->msg.msg.buf[parser->entity_start_position +\n                                parser->content_length -\n                                parser->msg.amount_discarded] = '\\0';\n        }\n        /* save entity length */\n        parser->msg.entity.length = parser->content_length;\n\n        /* save entity start ptr; (the very last thing to do) */\n        parser->msg.entity.buf = parser->msg.msg.buf +\n                                 parser->entity_start_position;\n\n        /* done reading entity */\n        parser->position = POS_COMPLETE;\n        return PARSE_SUCCESS;\n    }\n}"
  },
  {
    "function_name": "parser_parse_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1446-1573",
    "snippet": "parse_status_t parser_parse_headers(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tmemptr token;\n\tmemptr hdr_value;\n\ttoken_type_t tok_type;\n\tscanner_t *scanner = &parser->scanner;\n\tsize_t save_pos;\n\thttp_header_t *header;\n\tint header_id;\n\tint ret = 0;\n\tint index;\n\thttp_header_t *orig_header;\n\tchar save_char;\n\tint ret2;\n\n\tassert(parser->position == (parser_pos_t)POS_HEADERS ||\n\t       parser->ent_position == ENTREAD_CHUNKY_HEADERS);\n\n\twhile (TRUE) {\n\t\tsave_pos = scanner->cursor;\n\t\t/* check end of headers */\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\tswitch (tok_type) {\n\t\tcase TT_CRLF:\n\t\t\t/* end of headers */\n\t\t\tif ((parser->msg.is_request)\n\t\t\t    && (parser->msg.method == (http_method_t)HTTPMETHOD_POST)) {\n\t\t\t\tparser->position = POS_COMPLETE;\t/*post entity parsing */\n\t\t\t\t/*is handled separately  */\n\t\t\t\treturn PARSE_SUCCESS;\n\t\t\t}\n\t\t\tparser->position = POS_ENTITY;\t/* read entity next */\n\t\t\treturn PARSE_OK;\n\t\tcase TT_IDENTIFIER:\n\t\t\t/* not end; read header */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn PARSE_FAILURE;\t/* didn't see header name */\n\t\t}\n\t\tstatus = match(scanner, \" : %R%c\", &hdr_value);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\t/* add header */\n\t\t/* find header */\n\t\tindex =\n\t\t    map_str_to_int(token.buf, token.length, Http_Header_Names,\n\t\t\t\t   NUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (index != -1) {\n\t\t\t/*Check if it is a soap header */\n\t\t\tif (Http_Header_Names[index].id == HDR_SOAPACTION) {\n\t\t\t\tparser->msg.method = SOAPMETHOD_POST;\n\t\t\t}\n\t\t\theader_id = Http_Header_Names[index].id;\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr(&parser->msg, header_id, NULL);\n\t\t} else {\n\t\t\theader_id = HDR_UNKNOWN;\n\t\t\tsave_char = token.buf[token.length];\n\t\t\ttoken.buf[token.length] = '\\0';\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr_str(&parser->msg, token.buf);\n\t\t\ttoken.buf[token.length] = save_char;\t/* restore */\n\t\t}\n\t\tif (orig_header == NULL) {\n\t\t\t/* add new header */\n\t\t\theader =\n\t\t\t    (http_header_t *) malloc(sizeof(http_header_t));\n\t\t\tif (header == NULL) {\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tmembuffer_init(&header->name_buf);\n\t\t\tmembuffer_init(&header->value);\n\t\t\t/* value can be 0 length */\n\t\t\tif (hdr_value.length == (size_t)0) {\n\t\t\t\t/* FIXME: Is this a bug? buf is not const. */\n\t\t\t\thdr_value.buf = \"\\0\";\n\t\t\t\thdr_value.length = (size_t)1;\n\t\t\t}\n\t\t\t/* save in header in buffers */\n\t\t\tif (membuffer_assign(&header->name_buf, token.buf, token.length) ||\n\t\t\t    membuffer_assign(&header->value, hdr_value.buf, hdr_value.length)) {\n\t\t\t\t/* not enough mem */\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\theader->name.buf = header->name_buf.buf;\n\t\t\theader->name.length = header->name_buf.length;\n\t\t\theader->name_id = header_id;\n\t\t\tif (!ListAddTail(&parser->msg.headers, header)) {\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t} else if (hdr_value.length > (size_t)0) {\n\t\t\t/* append value to existing header */\n\t\t\t/* append space */\n\t\t\tret = membuffer_append_str(&orig_header->value, \", \");\n\t\t\t/* append continuation of header value */\n\t\t\tret2 = membuffer_append(&orig_header->value,\n\t\t\t\t\t\thdr_value.buf,\n\t\t\t\t\t\thdr_value.length);\n\t\t\tif (ret == UPNP_E_OUTOF_MEMORY\n\t\t\t    || ret2 == UPNP_E_OUTOF_MEMORY) {\n\t\t\t\t/* not enuf mem */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* end while */\n\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_HTTP_HEADER_NAMES 33"
    ],
    "globals_used": [
      "str_int_entry Http_Header_Names[NUM_HTTP_HEADER_NAMES] = {\n\t{\"ACCEPT\", HDR_ACCEPT},\n\t{\"ACCEPT-CHARSET\", HDR_ACCEPT_CHARSET},\n\t{\"ACCEPT-ENCODING\", HDR_ACCEPT_ENCODING},\n\t{\"ACCEPT-LANGUAGE\", HDR_ACCEPT_LANGUAGE},\n\t{\"ACCEPT-RANGES\", HDR_ACCEPT_RANGE},\n\t{\"CACHE-CONTROL\", HDR_CACHE_CONTROL},\n\t{\"CALLBACK\", HDR_CALLBACK},\n\t{\"CONTENT-ENCODING\", HDR_CONTENT_ENCODING},\n\t{\"CONTENT-LANGUAGE\", HDR_CONTENT_LANGUAGE},\n\t{\"CONTENT-LENGTH\", HDR_CONTENT_LENGTH},\n\t{\"CONTENT-LOCATION\", HDR_CONTENT_LOCATION},\n\t{\"CONTENT-RANGE\", HDR_CONTENT_RANGE},\n\t{\"CONTENT-TYPE\", HDR_CONTENT_TYPE},\n\t{\"DATE\", HDR_DATE},\n\t{\"EXT\", HDR_EXT},\n\t{\"HOST\", HDR_HOST},\n\t{\"IF-RANGE\", HDR_IF_RANGE},\n\t{\"LOCATION\", HDR_LOCATION},\n\t{\"MAN\", HDR_MAN},\n\t{\"MX\", HDR_MX},\n\t{\"NT\", HDR_NT},\n\t{\"NTS\", HDR_NTS},\n\t{\"RANGE\", HDR_RANGE},\n\t{\"SEQ\", HDR_SEQ},\n\t{\"SERVER\", HDR_SERVER},\n\t{\"SID\", HDR_SID},\n\t{\"SOAPACTION\", HDR_SOAPACTION},\n\t{\"ST\", HDR_ST},\n\t{\"TE\", HDR_TE},\n\t{\"TIMEOUT\", HDR_TIMEOUT},\n\t{\"TRANSFER-ENCODING\", HDR_TRANSFER_ENCODING},\n\t{\"USER-AGENT\", HDR_USER_AGENT},\n\t{\"USN\", HDR_USN},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_append",
          "args": [
            "&orig_header->value",
            "hdr_value.buf",
            "hdr_value.length"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "200-205",
          "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append_str",
          "args": [
            "&orig_header->value",
            "\", \""
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "207-210",
          "snippet": "int membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "header"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&header->name_buf"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListAddTail",
          "args": [
            "&parser->msg.headers",
            "header"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_assign",
          "args": [
            "&header->value",
            "hdr_value.buf",
            "hdr_value.length"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "170-193",
          "snippet": "int membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&header->value"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(http_header_t)"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr_str",
          "args": [
            "&parser->msg",
            "token.buf"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "452-472",
          "snippet": "http_header_t *httpmsg_find_hdr_str(\n\tIN http_message_t *msg,\n\tIN const char *header_name)\n{\n    http_header_t *header;\n\n    ListNode *node;\n\n    node = ListHead( &msg->headers );\n    while( node != NULL ) {\n\n        header = ( http_header_t * ) node->item;\n\n        if( memptr_cmp_nocase( &header->name, header_name ) == 0 ) {\n            return header;\n        }\n\n        node = ListNext( &msg->headers, node );\n    }\n    return NULL;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr_str(\n\tIN http_message_t *msg,\n\tIN const char *header_name)\n{\n    http_header_t *header;\n\n    ListNode *node;\n\n    node = ListHead( &msg->headers );\n    while( node != NULL ) {\n\n        header = ( http_header_t * ) node->item;\n\n        if( memptr_cmp_nocase( &header->name, header_name ) == 0 ) {\n            return header;\n        }\n\n        node = ListNext( &msg->headers, node );\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "&parser->msg",
            "header_id",
            "NULL"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_str_to_int",
          "args": [
            "token.buf",
            "token.length",
            "Http_Header_Names",
            "NUM_HTTP_HEADER_NAMES",
            "FALSE"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "map_str_to_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/strintmap.c",
          "lines": "63-103",
          "snippet": "int\nmap_str_to_int( IN const char *name,\n                IN size_t name_len,\n                IN str_int_entry * table,\n                IN int num_entries,\n                IN int case_sensitive )\n{\n    int top,\n      mid,\n      bot;\n    int cmp;\n    memptr name_ptr;\n\n    name_ptr.buf = ( char * )name;\n    name_ptr.length = name_len;\n\n    top = 0;\n    bot = num_entries - 1;\n\n    while( top <= bot ) {\n        mid = ( top + bot ) / 2;\n        if( case_sensitive ) {\n            /*cmp = strcmp( name, table[mid].name ); */\n            cmp = memptr_cmp( &name_ptr, table[mid].name );\n        } else {\n            /*cmp = strcasecmp( name, table[mid].name ); */\n            cmp = memptr_cmp_nocase( &name_ptr, table[mid].name );\n        }\n\n        if( cmp > 0 ) {\n            top = mid + 1;      /* look below mid */\n        } else if( cmp < 0 ) {\n            bot = mid - 1;      /* look above mid */\n        } else                  /* cmp == 0 */\n        {\n            return mid;         /* match; return table index */\n        }\n    }\n\n    return -1;                  /* header name not found */\n}",
          "includes": [
            "#include \"membuffer.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"membuffer.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nint\nmap_str_to_int( IN const char *name,\n                IN size_t name_len,\n                IN str_int_entry * table,\n                IN int num_entries,\n                IN int case_sensitive )\n{\n    int top,\n      mid,\n      bot;\n    int cmp;\n    memptr name_ptr;\n\n    name_ptr.buf = ( char * )name;\n    name_ptr.length = name_len;\n\n    top = 0;\n    bot = num_entries - 1;\n\n    while( top <= bot ) {\n        mid = ( top + bot ) / 2;\n        if( case_sensitive ) {\n            /*cmp = strcmp( name, table[mid].name ); */\n            cmp = memptr_cmp( &name_ptr, table[mid].name );\n        } else {\n            /*cmp = strcasecmp( name, table[mid].name ); */\n            cmp = memptr_cmp_nocase( &name_ptr, table[mid].name );\n        }\n\n        if( cmp > 0 ) {\n            top = mid + 1;      /* look below mid */\n        } else if( cmp < 0 ) {\n            bot = mid - 1;      /* look above mid */\n        } else                  /* cmp == 0 */\n        {\n            return mid;         /* match; return table index */\n        }\n    }\n\n    return -1;                  /* header name not found */\n}"
        }
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "scanner",
            "\" : %R%c\"",
            "&hdr_value"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1135-1148",
          "snippet": "static parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_get_token",
          "args": [
            "scanner",
            "&token",
            "&tok_type"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "219-326",
          "snippet": "static parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TOKCHAR_LF\t\t0xA",
            "#define TOKCHAR_CR\t\t0xD"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parser->position == (parser_pos_t)POS_HEADERS ||\n\t       parser->ent_position == ENTREAD_CHUNKY_HEADERS"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define NUM_HTTP_HEADER_NAMES 33\n\nstr_int_entry Http_Header_Names[NUM_HTTP_HEADER_NAMES] = {\n\t{\"ACCEPT\", HDR_ACCEPT},\n\t{\"ACCEPT-CHARSET\", HDR_ACCEPT_CHARSET},\n\t{\"ACCEPT-ENCODING\", HDR_ACCEPT_ENCODING},\n\t{\"ACCEPT-LANGUAGE\", HDR_ACCEPT_LANGUAGE},\n\t{\"ACCEPT-RANGES\", HDR_ACCEPT_RANGE},\n\t{\"CACHE-CONTROL\", HDR_CACHE_CONTROL},\n\t{\"CALLBACK\", HDR_CALLBACK},\n\t{\"CONTENT-ENCODING\", HDR_CONTENT_ENCODING},\n\t{\"CONTENT-LANGUAGE\", HDR_CONTENT_LANGUAGE},\n\t{\"CONTENT-LENGTH\", HDR_CONTENT_LENGTH},\n\t{\"CONTENT-LOCATION\", HDR_CONTENT_LOCATION},\n\t{\"CONTENT-RANGE\", HDR_CONTENT_RANGE},\n\t{\"CONTENT-TYPE\", HDR_CONTENT_TYPE},\n\t{\"DATE\", HDR_DATE},\n\t{\"EXT\", HDR_EXT},\n\t{\"HOST\", HDR_HOST},\n\t{\"IF-RANGE\", HDR_IF_RANGE},\n\t{\"LOCATION\", HDR_LOCATION},\n\t{\"MAN\", HDR_MAN},\n\t{\"MX\", HDR_MX},\n\t{\"NT\", HDR_NT},\n\t{\"NTS\", HDR_NTS},\n\t{\"RANGE\", HDR_RANGE},\n\t{\"SEQ\", HDR_SEQ},\n\t{\"SERVER\", HDR_SERVER},\n\t{\"SID\", HDR_SID},\n\t{\"SOAPACTION\", HDR_SOAPACTION},\n\t{\"ST\", HDR_ST},\n\t{\"TE\", HDR_TE},\n\t{\"TIMEOUT\", HDR_TIMEOUT},\n\t{\"TRANSFER-ENCODING\", HDR_TRANSFER_ENCODING},\n\t{\"USER-AGENT\", HDR_USER_AGENT},\n\t{\"USN\", HDR_USN},\n};\n\nparse_status_t parser_parse_headers(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tmemptr token;\n\tmemptr hdr_value;\n\ttoken_type_t tok_type;\n\tscanner_t *scanner = &parser->scanner;\n\tsize_t save_pos;\n\thttp_header_t *header;\n\tint header_id;\n\tint ret = 0;\n\tint index;\n\thttp_header_t *orig_header;\n\tchar save_char;\n\tint ret2;\n\n\tassert(parser->position == (parser_pos_t)POS_HEADERS ||\n\t       parser->ent_position == ENTREAD_CHUNKY_HEADERS);\n\n\twhile (TRUE) {\n\t\tsave_pos = scanner->cursor;\n\t\t/* check end of headers */\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\tswitch (tok_type) {\n\t\tcase TT_CRLF:\n\t\t\t/* end of headers */\n\t\t\tif ((parser->msg.is_request)\n\t\t\t    && (parser->msg.method == (http_method_t)HTTPMETHOD_POST)) {\n\t\t\t\tparser->position = POS_COMPLETE;\t/*post entity parsing */\n\t\t\t\t/*is handled separately  */\n\t\t\t\treturn PARSE_SUCCESS;\n\t\t\t}\n\t\t\tparser->position = POS_ENTITY;\t/* read entity next */\n\t\t\treturn PARSE_OK;\n\t\tcase TT_IDENTIFIER:\n\t\t\t/* not end; read header */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn PARSE_FAILURE;\t/* didn't see header name */\n\t\t}\n\t\tstatus = match(scanner, \" : %R%c\", &hdr_value);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\t/* add header */\n\t\t/* find header */\n\t\tindex =\n\t\t    map_str_to_int(token.buf, token.length, Http_Header_Names,\n\t\t\t\t   NUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (index != -1) {\n\t\t\t/*Check if it is a soap header */\n\t\t\tif (Http_Header_Names[index].id == HDR_SOAPACTION) {\n\t\t\t\tparser->msg.method = SOAPMETHOD_POST;\n\t\t\t}\n\t\t\theader_id = Http_Header_Names[index].id;\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr(&parser->msg, header_id, NULL);\n\t\t} else {\n\t\t\theader_id = HDR_UNKNOWN;\n\t\t\tsave_char = token.buf[token.length];\n\t\t\ttoken.buf[token.length] = '\\0';\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr_str(&parser->msg, token.buf);\n\t\t\ttoken.buf[token.length] = save_char;\t/* restore */\n\t\t}\n\t\tif (orig_header == NULL) {\n\t\t\t/* add new header */\n\t\t\theader =\n\t\t\t    (http_header_t *) malloc(sizeof(http_header_t));\n\t\t\tif (header == NULL) {\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tmembuffer_init(&header->name_buf);\n\t\t\tmembuffer_init(&header->value);\n\t\t\t/* value can be 0 length */\n\t\t\tif (hdr_value.length == (size_t)0) {\n\t\t\t\t/* FIXME: Is this a bug? buf is not const. */\n\t\t\t\thdr_value.buf = \"\\0\";\n\t\t\t\thdr_value.length = (size_t)1;\n\t\t\t}\n\t\t\t/* save in header in buffers */\n\t\t\tif (membuffer_assign(&header->name_buf, token.buf, token.length) ||\n\t\t\t    membuffer_assign(&header->value, hdr_value.buf, hdr_value.length)) {\n\t\t\t\t/* not enough mem */\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\theader->name.buf = header->name_buf.buf;\n\t\t\theader->name.length = header->name_buf.length;\n\t\t\theader->name_id = header_id;\n\t\t\tif (!ListAddTail(&parser->msg.headers, header)) {\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t} else if (hdr_value.length > (size_t)0) {\n\t\t\t/* append value to existing header */\n\t\t\t/* append space */\n\t\t\tret = membuffer_append_str(&orig_header->value, \", \");\n\t\t\t/* append continuation of header value */\n\t\t\tret2 = membuffer_append(&orig_header->value,\n\t\t\t\t\t\thdr_value.buf,\n\t\t\t\t\t\thdr_value.length);\n\t\t\tif (ret == UPNP_E_OUTOF_MEMORY\n\t\t\t    || ret2 == UPNP_E_OUTOF_MEMORY) {\n\t\t\t\t/* not enuf mem */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* end while */\n\n}"
  },
  {
    "function_name": "parser_parse_responseline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1367-1429",
    "snippet": "parse_status_t parser_parse_responseline(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\thttp_message_t *hmsg = &parser->msg;\n\tmemptr line;\n\tchar save_char;\n\tint num_scanned;\n\tint i;\n\tsize_t n;\n\tchar *p;\n\n\tassert(parser->position == POS_RESPONSE_LINE);\n\n\tstatus = skip_blank_lines(&parser->scanner);\n\tif (status != ( parse_status_t) PARSE_OK)\n\t\treturn status;\n\t/* response line */\n\t/*status = match( &parser->scanner, \"%ihttp%w/%w%d\\t.\\t%d\\t%d\\t%L%c\", */\n\t/*  &hmsg->major_version, &hmsg->minor_version, */\n\t/*  &hmsg->status_code, &hmsg->status_msg ); */\n\tstatus = match(&parser->scanner, \"%ihttp%w/%w%L%c\", &line);\n\tif (status != ( parse_status_t ) PARSE_OK)\n\t\treturn status;\n\tsave_char = line.buf[line.length];\n\tline.buf[line.length] = '\\0';\t/* null-terminate */\n\t/* scan http version and ret code */\n\tnum_scanned = sscanf(line.buf, \"%d . %d %d\",\n\t\t\t     &hmsg->major_version, &hmsg->minor_version,\n\t\t\t     &hmsg->status_code);\n\tline.buf[line.length] = save_char;\t/* restore */\n\tif (num_scanned != 3 ||\n\t    hmsg->major_version < 0 || hmsg->minor_version < 0 ||\n\t    hmsg->status_code < 0)\n\t\t/* bad response line */\n\t\treturn PARSE_FAILURE;\n\t/* point to status msg */\n\tp = line.buf;\n\t/* skip 3 ints */\n\tfor (i = 0; i < 3; i++) {\n\t\t/* go to start of num */\n\t\twhile (!isdigit(*p))\n\t\t\tp++;\n\t\t/* skip int */\n\t\twhile (isdigit(*p))\n\t\t\tp++;\n\t}\n\t/* whitespace must exist after status code */\n\tif (*p != ' ' && *p != '\\t')\n\t\treturn PARSE_FAILURE;\n\t/* skip whitespace */\n\twhile (*p == ' ' || *p == '\\t')\n\t\tp++;\n\t/* now, p is at start of status msg */\n\tn = line.length - ((size_t)p - (size_t)line.buf);\n\tif (membuffer_assign(&hmsg->status_msg, p, n) != 0) {\n\t\t/* out of mem */\n\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\treturn PARSE_FAILURE;\n\t}\n\tparser->position = POS_HEADERS;\t/* move to headers */\n\n\treturn PARSE_OK;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_assign",
          "args": [
            "&hmsg->status_msg",
            "p",
            "n"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "170-193",
          "snippet": "int membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*p"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*p"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line.buf",
            "\"%d . %d %d\"",
            "&hmsg->major_version",
            "&hmsg->minor_version",
            "&hmsg->status_code"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "&parser->scanner",
            "\"%ihttp%w/%w%L%c\"",
            "&line"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1135-1148",
          "snippet": "static parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_blank_lines",
          "args": [
            "&parser->scanner"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "skip_blank_lines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "525-543",
          "snippet": "static UPNP_INLINE parse_status_t skip_blank_lines(INOUT scanner_t *scanner)\n{\n\tmemptr token;\n\ttoken_type_t tok_type;\n\tparse_status_t status;\n\n\t/* skip ws, crlf */\n\tdo {\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t} while (status == (parse_status_t)PARSE_OK &&\n\t\t (tok_type == (token_type_t)TT_WHITESPACE ||\n\t\t tok_type == (token_type_t)TT_CRLF));\n\tif (status == (parse_status_t)PARSE_OK) {\n\t\t/* pushback a non-whitespace token */\n\t\tscanner->cursor -= token.length;\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t skip_blank_lines(INOUT scanner_t *scanner)\n{\n\tmemptr token;\n\ttoken_type_t tok_type;\n\tparse_status_t status;\n\n\t/* skip ws, crlf */\n\tdo {\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t} while (status == (parse_status_t)PARSE_OK &&\n\t\t (tok_type == (token_type_t)TT_WHITESPACE ||\n\t\t tok_type == (token_type_t)TT_CRLF));\n\tif (status == (parse_status_t)PARSE_OK) {\n\t\t/* pushback a non-whitespace token */\n\t\tscanner->cursor -= token.length;\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parser->position == POS_RESPONSE_LINE"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t parser_parse_responseline(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\thttp_message_t *hmsg = &parser->msg;\n\tmemptr line;\n\tchar save_char;\n\tint num_scanned;\n\tint i;\n\tsize_t n;\n\tchar *p;\n\n\tassert(parser->position == POS_RESPONSE_LINE);\n\n\tstatus = skip_blank_lines(&parser->scanner);\n\tif (status != ( parse_status_t) PARSE_OK)\n\t\treturn status;\n\t/* response line */\n\t/*status = match( &parser->scanner, \"%ihttp%w/%w%d\\t.\\t%d\\t%d\\t%L%c\", */\n\t/*  &hmsg->major_version, &hmsg->minor_version, */\n\t/*  &hmsg->status_code, &hmsg->status_msg ); */\n\tstatus = match(&parser->scanner, \"%ihttp%w/%w%L%c\", &line);\n\tif (status != ( parse_status_t ) PARSE_OK)\n\t\treturn status;\n\tsave_char = line.buf[line.length];\n\tline.buf[line.length] = '\\0';\t/* null-terminate */\n\t/* scan http version and ret code */\n\tnum_scanned = sscanf(line.buf, \"%d . %d %d\",\n\t\t\t     &hmsg->major_version, &hmsg->minor_version,\n\t\t\t     &hmsg->status_code);\n\tline.buf[line.length] = save_char;\t/* restore */\n\tif (num_scanned != 3 ||\n\t    hmsg->major_version < 0 || hmsg->minor_version < 0 ||\n\t    hmsg->status_code < 0)\n\t\t/* bad response line */\n\t\treturn PARSE_FAILURE;\n\t/* point to status msg */\n\tp = line.buf;\n\t/* skip 3 ints */\n\tfor (i = 0; i < 3; i++) {\n\t\t/* go to start of num */\n\t\twhile (!isdigit(*p))\n\t\t\tp++;\n\t\t/* skip int */\n\t\twhile (isdigit(*p))\n\t\t\tp++;\n\t}\n\t/* whitespace must exist after status code */\n\tif (*p != ' ' && *p != '\\t')\n\t\treturn PARSE_FAILURE;\n\t/* skip whitespace */\n\twhile (*p == ' ' || *p == '\\t')\n\t\tp++;\n\t/* now, p is at start of status msg */\n\tn = line.length - ((size_t)p - (size_t)line.buf);\n\tif (membuffer_assign(&hmsg->status_msg, p, n) != 0) {\n\t\t/* out of mem */\n\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\treturn PARSE_FAILURE;\n\t}\n\tparser->position = POS_HEADERS;\t/* move to headers */\n\n\treturn PARSE_OK;\n}"
  },
  {
    "function_name": "parser_parse_requestline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1244-1351",
    "snippet": "static parse_status_t\nparser_parse_requestline( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n    http_message_t *hmsg = &parser->msg;\n    memptr method_str;\n    memptr version_str;\n    int index;\n    char save_char;\n    int num_scanned;\n    memptr url_str;\n\n    assert( parser->position == POS_REQUEST_LINE );\n\n    status = skip_blank_lines( &parser->scanner );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        return status;\n    }\n    /*simple get http 0.9 as described in http 1.0 spec */\n\n    status =\n        match( &parser->scanner, \"%s\\t%S%w%c\", &method_str, &url_str );\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n\n        index =\n            map_str_to_int( method_str.buf, method_str.length,\n                            Http_Method_Table, NUM_HTTP_METHODS, TRUE );\n\n        if( index < 0 ) {\n            /* error; method not found */\n            parser->http_error_code = HTTP_NOT_IMPLEMENTED;\n            return PARSE_FAILURE;\n        }\n\n        if( Http_Method_Table[index].id != HTTPMETHOD_GET ) {\n            parser->http_error_code = HTTP_BAD_REQUEST;\n            return PARSE_FAILURE;\n        }\n\n        hmsg->method = HTTPMETHOD_SIMPLEGET;\n\n        /* store url */\n        hmsg->urlbuf = str_alloc( url_str.buf, url_str.length );\n        if( hmsg->urlbuf == NULL ) {\n            /* out of mem */\n            parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n            return PARSE_FAILURE;\n        }\n        if( parse_uri( hmsg->urlbuf, url_str.length, &hmsg->uri ) !=\n            HTTP_SUCCESS ) {\n            return PARSE_FAILURE;\n        }\n\n        parser->position = POS_COMPLETE;    /* move to headers */\n\n        return PARSE_SUCCESS;\n    }\n\n    status = match( &parser->scanner,\n                    \"%s\\t%S\\t%ihttp%w/%w%L%c\", &method_str, &url_str,\n                    &version_str );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        return status;\n    }\n    /* store url */\n    hmsg->urlbuf = str_alloc( url_str.buf, url_str.length );\n    if( hmsg->urlbuf == NULL ) {\n        /* out of mem */\n        parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n        return PARSE_FAILURE;\n    }\n    if( parse_uri( hmsg->urlbuf, url_str.length, &hmsg->uri ) !=\n        HTTP_SUCCESS ) {\n        return PARSE_FAILURE;\n    }\n\n    index =\n        map_str_to_int( method_str.buf, method_str.length,\n                        Http_Method_Table, NUM_HTTP_METHODS, TRUE );\n    if( index < 0 ) {\n        /* error; method not found */\n        parser->http_error_code = HTTP_NOT_IMPLEMENTED;\n        return PARSE_FAILURE;\n    }\n\n    /* scan version */\n    save_char = version_str.buf[version_str.length];\n    version_str.buf[version_str.length] = '\\0'; /* null-terminate */\n    num_scanned = sscanf( version_str.buf, \"%d . %d\",\n                          &hmsg->major_version, &hmsg->minor_version );\n    version_str.buf[version_str.length] = save_char;    /* restore */\n    if (num_scanned != 2 ||\n        /* HTTP version equals to 1.0 should fail for MSEARCH as required by the\n         * UPnP certification tool */\n        hmsg->major_version < 0 ||\n\t( hmsg->major_version == 1 && hmsg->minor_version < 1 &&\n\t  Http_Method_Table[index].id == HTTPMETHOD_MSEARCH )) {\n        parser->http_error_code = HTTP_HTTP_VERSION_NOT_SUPPORTED;\n        /* error; bad http version */\n        return PARSE_FAILURE;\n    }\n\n    hmsg->method = ( http_method_t ) Http_Method_Table[index].id;\n    parser->position = POS_HEADERS; /* move to headers */\n\n    return PARSE_OK;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_HTTP_METHODS 11"
    ],
    "globals_used": [
      "static str_int_entry Http_Method_Table[NUM_HTTP_METHODS] = {\n\t{\"DELETE\", HTTPMETHOD_DELETE},\n\t{\"GET\", HTTPMETHOD_GET},\n\t{\"HEAD\", HTTPMETHOD_HEAD},\n\t{\"M-POST\", HTTPMETHOD_MPOST},\n\t{\"M-SEARCH\", HTTPMETHOD_MSEARCH},\n\t{\"NOTIFY\", HTTPMETHOD_NOTIFY},\n\t{\"POST\", HTTPMETHOD_POST},\n\t{\"SUBSCRIBE\", HTTPMETHOD_SUBSCRIBE},\n\t{\"UNSUBSCRIBE\", HTTPMETHOD_UNSUBSCRIBE},\n\t{\"POST\", SOAPMETHOD_POST},\n\t{\"PUT\", HTTPMETHOD_PUT}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "version_str.buf",
            "\"%d . %d\"",
            "&hmsg->major_version",
            "&hmsg->minor_version"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_str_to_int",
          "args": [
            "method_str.buf",
            "method_str.length",
            "Http_Method_Table",
            "NUM_HTTP_METHODS",
            "TRUE"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "map_str_to_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/strintmap.c",
          "lines": "63-103",
          "snippet": "int\nmap_str_to_int( IN const char *name,\n                IN size_t name_len,\n                IN str_int_entry * table,\n                IN int num_entries,\n                IN int case_sensitive )\n{\n    int top,\n      mid,\n      bot;\n    int cmp;\n    memptr name_ptr;\n\n    name_ptr.buf = ( char * )name;\n    name_ptr.length = name_len;\n\n    top = 0;\n    bot = num_entries - 1;\n\n    while( top <= bot ) {\n        mid = ( top + bot ) / 2;\n        if( case_sensitive ) {\n            /*cmp = strcmp( name, table[mid].name ); */\n            cmp = memptr_cmp( &name_ptr, table[mid].name );\n        } else {\n            /*cmp = strcasecmp( name, table[mid].name ); */\n            cmp = memptr_cmp_nocase( &name_ptr, table[mid].name );\n        }\n\n        if( cmp > 0 ) {\n            top = mid + 1;      /* look below mid */\n        } else if( cmp < 0 ) {\n            bot = mid - 1;      /* look above mid */\n        } else                  /* cmp == 0 */\n        {\n            return mid;         /* match; return table index */\n        }\n    }\n\n    return -1;                  /* header name not found */\n}",
          "includes": [
            "#include \"membuffer.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"membuffer.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nint\nmap_str_to_int( IN const char *name,\n                IN size_t name_len,\n                IN str_int_entry * table,\n                IN int num_entries,\n                IN int case_sensitive )\n{\n    int top,\n      mid,\n      bot;\n    int cmp;\n    memptr name_ptr;\n\n    name_ptr.buf = ( char * )name;\n    name_ptr.length = name_len;\n\n    top = 0;\n    bot = num_entries - 1;\n\n    while( top <= bot ) {\n        mid = ( top + bot ) / 2;\n        if( case_sensitive ) {\n            /*cmp = strcmp( name, table[mid].name ); */\n            cmp = memptr_cmp( &name_ptr, table[mid].name );\n        } else {\n            /*cmp = strcasecmp( name, table[mid].name ); */\n            cmp = memptr_cmp_nocase( &name_ptr, table[mid].name );\n        }\n\n        if( cmp > 0 ) {\n            top = mid + 1;      /* look below mid */\n        } else if( cmp < 0 ) {\n            bot = mid - 1;      /* look above mid */\n        } else                  /* cmp == 0 */\n        {\n            return mid;         /* match; return table index */\n        }\n    }\n\n    return -1;                  /* header name not found */\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_uri",
          "args": [
            "hmsg->urlbuf",
            "url_str.length",
            "&hmsg->uri"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uri_and_unescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "759-775",
          "snippet": "int parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_alloc",
          "args": [
            "url_str.buf",
            "url_str.length"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "str_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "48-61",
          "snippet": "char *str_alloc(const char *str, size_t str_len)\n{\n\tchar *s;\n\n\ts = (char *)malloc(str_len + (size_t)1);\n\tif (s == NULL) {\n\t\treturn NULL;\t/* no mem */\n\t}\n\n\tmemcpy(s, str, str_len);\n\ts[str_len] = '\\0';\n\n\treturn s;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nchar *str_alloc(const char *str, size_t str_len)\n{\n\tchar *s;\n\n\ts = (char *)malloc(str_len + (size_t)1);\n\tif (s == NULL) {\n\t\treturn NULL;\t/* no mem */\n\t}\n\n\tmemcpy(s, str, str_len);\n\ts[str_len] = '\\0';\n\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "&parser->scanner",
            "\"%s\\t%S\\t%ihttp%w/%w%L%c\"",
            "&method_str",
            "&url_str",
            "&version_str"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1135-1148",
          "snippet": "static parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_blank_lines",
          "args": [
            "&parser->scanner"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "skip_blank_lines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "525-543",
          "snippet": "static UPNP_INLINE parse_status_t skip_blank_lines(INOUT scanner_t *scanner)\n{\n\tmemptr token;\n\ttoken_type_t tok_type;\n\tparse_status_t status;\n\n\t/* skip ws, crlf */\n\tdo {\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t} while (status == (parse_status_t)PARSE_OK &&\n\t\t (tok_type == (token_type_t)TT_WHITESPACE ||\n\t\t tok_type == (token_type_t)TT_CRLF));\n\tif (status == (parse_status_t)PARSE_OK) {\n\t\t/* pushback a non-whitespace token */\n\t\tscanner->cursor -= token.length;\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t skip_blank_lines(INOUT scanner_t *scanner)\n{\n\tmemptr token;\n\ttoken_type_t tok_type;\n\tparse_status_t status;\n\n\t/* skip ws, crlf */\n\tdo {\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t} while (status == (parse_status_t)PARSE_OK &&\n\t\t (tok_type == (token_type_t)TT_WHITESPACE ||\n\t\t tok_type == (token_type_t)TT_CRLF));\n\tif (status == (parse_status_t)PARSE_OK) {\n\t\t/* pushback a non-whitespace token */\n\t\tscanner->cursor -= token.length;\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parser->position == POS_REQUEST_LINE"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define NUM_HTTP_METHODS 11\n\nstatic str_int_entry Http_Method_Table[NUM_HTTP_METHODS] = {\n\t{\"DELETE\", HTTPMETHOD_DELETE},\n\t{\"GET\", HTTPMETHOD_GET},\n\t{\"HEAD\", HTTPMETHOD_HEAD},\n\t{\"M-POST\", HTTPMETHOD_MPOST},\n\t{\"M-SEARCH\", HTTPMETHOD_MSEARCH},\n\t{\"NOTIFY\", HTTPMETHOD_NOTIFY},\n\t{\"POST\", HTTPMETHOD_POST},\n\t{\"SUBSCRIBE\", HTTPMETHOD_SUBSCRIBE},\n\t{\"UNSUBSCRIBE\", HTTPMETHOD_UNSUBSCRIBE},\n\t{\"POST\", SOAPMETHOD_POST},\n\t{\"PUT\", HTTPMETHOD_PUT}\n};\n\nstatic parse_status_t\nparser_parse_requestline( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n    http_message_t *hmsg = &parser->msg;\n    memptr method_str;\n    memptr version_str;\n    int index;\n    char save_char;\n    int num_scanned;\n    memptr url_str;\n\n    assert( parser->position == POS_REQUEST_LINE );\n\n    status = skip_blank_lines( &parser->scanner );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        return status;\n    }\n    /*simple get http 0.9 as described in http 1.0 spec */\n\n    status =\n        match( &parser->scanner, \"%s\\t%S%w%c\", &method_str, &url_str );\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n\n        index =\n            map_str_to_int( method_str.buf, method_str.length,\n                            Http_Method_Table, NUM_HTTP_METHODS, TRUE );\n\n        if( index < 0 ) {\n            /* error; method not found */\n            parser->http_error_code = HTTP_NOT_IMPLEMENTED;\n            return PARSE_FAILURE;\n        }\n\n        if( Http_Method_Table[index].id != HTTPMETHOD_GET ) {\n            parser->http_error_code = HTTP_BAD_REQUEST;\n            return PARSE_FAILURE;\n        }\n\n        hmsg->method = HTTPMETHOD_SIMPLEGET;\n\n        /* store url */\n        hmsg->urlbuf = str_alloc( url_str.buf, url_str.length );\n        if( hmsg->urlbuf == NULL ) {\n            /* out of mem */\n            parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n            return PARSE_FAILURE;\n        }\n        if( parse_uri( hmsg->urlbuf, url_str.length, &hmsg->uri ) !=\n            HTTP_SUCCESS ) {\n            return PARSE_FAILURE;\n        }\n\n        parser->position = POS_COMPLETE;    /* move to headers */\n\n        return PARSE_SUCCESS;\n    }\n\n    status = match( &parser->scanner,\n                    \"%s\\t%S\\t%ihttp%w/%w%L%c\", &method_str, &url_str,\n                    &version_str );\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        return status;\n    }\n    /* store url */\n    hmsg->urlbuf = str_alloc( url_str.buf, url_str.length );\n    if( hmsg->urlbuf == NULL ) {\n        /* out of mem */\n        parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n        return PARSE_FAILURE;\n    }\n    if( parse_uri( hmsg->urlbuf, url_str.length, &hmsg->uri ) !=\n        HTTP_SUCCESS ) {\n        return PARSE_FAILURE;\n    }\n\n    index =\n        map_str_to_int( method_str.buf, method_str.length,\n                        Http_Method_Table, NUM_HTTP_METHODS, TRUE );\n    if( index < 0 ) {\n        /* error; method not found */\n        parser->http_error_code = HTTP_NOT_IMPLEMENTED;\n        return PARSE_FAILURE;\n    }\n\n    /* scan version */\n    save_char = version_str.buf[version_str.length];\n    version_str.buf[version_str.length] = '\\0'; /* null-terminate */\n    num_scanned = sscanf( version_str.buf, \"%d . %d\",\n                          &hmsg->major_version, &hmsg->minor_version );\n    version_str.buf[version_str.length] = save_char;    /* restore */\n    if (num_scanned != 2 ||\n        /* HTTP version equals to 1.0 should fail for MSEARCH as required by the\n         * UPnP certification tool */\n        hmsg->major_version < 0 ||\n\t( hmsg->major_version == 1 && hmsg->minor_version < 1 &&\n\t  Http_Method_Table[index].id == HTTPMETHOD_MSEARCH )) {\n        parser->http_error_code = HTTP_HTTP_VERSION_NOT_SUPPORTED;\n        /* error; bad http version */\n        return PARSE_FAILURE;\n    }\n\n    hmsg->method = ( http_method_t ) Http_Method_Table[index].id;\n    parser->position = POS_HEADERS; /* move to headers */\n\n    return PARSE_OK;\n}"
  },
  {
    "function_name": "parser_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1216-1227",
    "snippet": "static UPNP_INLINE void\nparser_init( OUT http_parser_t * parser )\n{\n    memset( parser, 0, sizeof( http_parser_t ) );\n\n    parser->http_error_code = HTTP_BAD_REQUEST; /* err msg by default */\n    parser->ent_position = ENTREAD_DETERMINE_READ_METHOD;\n    parser->valid_ssdp_notify_hack = FALSE;\n\n    httpmsg_init( &parser->msg );\n    scanner_init( &parser->scanner, &parser->msg.msg );\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scanner_init",
          "args": [
            "&parser->scanner",
            "&parser->msg.msg"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "130-135",
          "snippet": "static UPNP_INLINE void scanner_init(OUT scanner_t *scanner, IN membuffer *bufptr)\n{\n\tscanner->cursor = (size_t)0;\n\tscanner->msg = bufptr;\n\tscanner->entire_msg_loaded = FALSE;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void scanner_init(OUT scanner_t *scanner, IN membuffer *bufptr)\n{\n\tscanner->cursor = (size_t)0;\n\tscanner->msg = bufptr;\n\tscanner->entire_msg_loaded = FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_init",
          "args": [
            "&parser->msg"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "402-410",
          "snippet": "void httpmsg_init(INOUT http_message_t *msg)\n{\n    msg->initialized = 1;\n    msg->entity.buf = NULL;\n    msg->entity.length = ( size_t ) 0;\n    ListInit( &msg->headers, httpmsg_compare, httpheader_free );\n    membuffer_init( &msg->msg );\n    membuffer_init( &msg->status_msg );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_init(INOUT http_message_t *msg)\n{\n    msg->initialized = 1;\n    msg->entity.buf = NULL;\n    msg->entity.length = ( size_t ) 0;\n    ListInit( &msg->headers, httpmsg_compare, httpheader_free );\n    membuffer_init( &msg->msg );\n    membuffer_init( &msg->status_msg );\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "parser",
            "0",
            "sizeof( http_parser_t )"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void\nparser_init( OUT http_parser_t * parser )\n{\n    memset( parser, 0, sizeof( http_parser_t ) );\n\n    parser->http_error_code = HTTP_BAD_REQUEST; /* err msg by default */\n    parser->ent_position = ENTREAD_DETERMINE_READ_METHOD;\n    parser->valid_ssdp_notify_hack = FALSE;\n\n    httpmsg_init( &parser->msg );\n    scanner_init( &parser->scanner, &parser->msg.msg );\n}"
  },
  {
    "function_name": "matchstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1168-1203",
    "snippet": "parse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "arg_list"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfmatch",
          "args": [
            "&scanner",
            "fmt",
            "arg_list"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "vfmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "952-1116",
          "snippet": "static parse_status_t vfmatch(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\tva_list argp)\n{\n    char c;\n    const char *fmt_ptr = fmt;\n    parse_status_t status;\n    memptr *str_ptr;\n    memptr temp_str;\n    int *int_ptr;\n    uri_type *uri_ptr;\n    size_t save_pos;\n    int stat;\n    int case_sensitive = TRUE;\n    memptr token;\n    token_type_t tok_type;\n    int base;\n\n    assert( scanner != NULL );\n    assert( fmt != NULL );\n\n    /* save scanner pos; to aid error recovery */\n    save_pos = scanner->cursor;\n\n    status = PARSE_OK;\n    while( ( c = *fmt_ptr++ ) &&\n\t ( status == ( parse_status_t ) PARSE_OK ) ) {\n        if( c == '%' ) {\n            c = *fmt_ptr++;\n            switch ( c ) {\n                case 'R':      /* raw value */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = match_raw_value( scanner, str_ptr );\n                    break;\n                case 's':      /* simple identifier */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = scanner_get_token( scanner, str_ptr,\n                                                &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_IDENTIFIER ) {\n                        /* not an identifier */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'c':      /* crlf */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_CRLF ) {\n                        /* not CRLF token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'd':      /* integer */\n                case 'x':      /* hex number */\n                    int_ptr = va_arg(argp, int *);\n                    assert(int_ptr != NULL);\n                    base = c == 'd' ? 10 : 16;\n                    status = match_int(scanner, base, int_ptr);\n                    break;\n                case 'S':      /* non-whitespace string */\n                case 'U':      /* uri */\n                    if( c == 'S' ) {\n                        str_ptr = va_arg( argp, memptr * );\n                    } else {\n                        str_ptr = &temp_str;\n                    }\n                    assert( str_ptr != NULL );\n                    status = match_non_ws_string( scanner, str_ptr );\n                    if( c == 'U' && status == ( parse_status_t ) PARSE_OK ) {\n                        uri_ptr = va_arg( argp, uri_type * );\n                        assert( uri_ptr != NULL );\n                        stat = parse_uri( str_ptr->buf, str_ptr->length,\n                                          uri_ptr );\n                        if( stat != HTTP_SUCCESS ) {\n                            status = PARSE_NO_MATCH;\n                        }\n                    }\n                    break;\n                case 'L':      /* string till eol */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = read_until_crlf( scanner, str_ptr );\n                    break;\n                case ' ':      /* match space */\n                case '%':      /* match percentage symbol */\n                    status = match_char( scanner, c, case_sensitive );\n                    break;\n                case 'n':      /* case-sensitive match */\n                    case_sensitive = TRUE;\n                    break;\n                case 'i':      /* ignore case */\n                    case_sensitive = FALSE;\n                    break;\n                case 'q':      /* quoted string */\n                    str_ptr = ( memptr * ) va_arg( argp, memptr * );\n                    status =\n                        scanner_get_token( scanner, str_ptr, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_QUOTEDSTRING ) {\n                        status = PARSE_NO_MATCH;    /* not a quoted string */\n                    }\n                    break;\n                case 'w':\n\t      \t    /* optional whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_WHITESPACE ) {\n                        /* restore non-whitespace token */\n                        scanner->cursor -= token.length;\n                    }\n                    break;\n                case 'P':\n\t      \t    /* current pos of scanner */\n                    int_ptr = va_arg( argp, int * );\n                    assert( int_ptr != NULL );\n                    *int_ptr = (int)scanner->cursor;\n                    break;\n                    /* valid only in matchstr() */\n                case '0':\n\t\t    /* end of msg? */\n                    /* check that we are 1 beyond last char */\n                    if( scanner->cursor == scanner->msg->length &&\n                        scanner->msg->buf[scanner->cursor] == '\\0' ) {\n                        status = PARSE_OK;\n                    } else {\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:\n\t\t    /* unknown option */\n                    assert( 0 );\n            }\n        } else {\n            switch ( c ) {\n                case ' ':      /* LWS* */\n                    status = skip_lws( scanner );\n                    break;\n                case '\\t':     /* Whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != (token_type_t) TT_WHITESPACE ) {\n                        /* not whitespace token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:       /* match characters */\n                    {\n                        status = match_char( scanner, c, case_sensitive );\n                    }\n            }\n        }\n    }\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        /* on error, restore original scanner pos */\n        scanner->cursor = save_pos;\n    }\n\n    return status;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic parse_status_t vfmatch(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\tva_list argp)\n{\n    char c;\n    const char *fmt_ptr = fmt;\n    parse_status_t status;\n    memptr *str_ptr;\n    memptr temp_str;\n    int *int_ptr;\n    uri_type *uri_ptr;\n    size_t save_pos;\n    int stat;\n    int case_sensitive = TRUE;\n    memptr token;\n    token_type_t tok_type;\n    int base;\n\n    assert( scanner != NULL );\n    assert( fmt != NULL );\n\n    /* save scanner pos; to aid error recovery */\n    save_pos = scanner->cursor;\n\n    status = PARSE_OK;\n    while( ( c = *fmt_ptr++ ) &&\n\t ( status == ( parse_status_t ) PARSE_OK ) ) {\n        if( c == '%' ) {\n            c = *fmt_ptr++;\n            switch ( c ) {\n                case 'R':      /* raw value */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = match_raw_value( scanner, str_ptr );\n                    break;\n                case 's':      /* simple identifier */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = scanner_get_token( scanner, str_ptr,\n                                                &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_IDENTIFIER ) {\n                        /* not an identifier */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'c':      /* crlf */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_CRLF ) {\n                        /* not CRLF token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'd':      /* integer */\n                case 'x':      /* hex number */\n                    int_ptr = va_arg(argp, int *);\n                    assert(int_ptr != NULL);\n                    base = c == 'd' ? 10 : 16;\n                    status = match_int(scanner, base, int_ptr);\n                    break;\n                case 'S':      /* non-whitespace string */\n                case 'U':      /* uri */\n                    if( c == 'S' ) {\n                        str_ptr = va_arg( argp, memptr * );\n                    } else {\n                        str_ptr = &temp_str;\n                    }\n                    assert( str_ptr != NULL );\n                    status = match_non_ws_string( scanner, str_ptr );\n                    if( c == 'U' && status == ( parse_status_t ) PARSE_OK ) {\n                        uri_ptr = va_arg( argp, uri_type * );\n                        assert( uri_ptr != NULL );\n                        stat = parse_uri( str_ptr->buf, str_ptr->length,\n                                          uri_ptr );\n                        if( stat != HTTP_SUCCESS ) {\n                            status = PARSE_NO_MATCH;\n                        }\n                    }\n                    break;\n                case 'L':      /* string till eol */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = read_until_crlf( scanner, str_ptr );\n                    break;\n                case ' ':      /* match space */\n                case '%':      /* match percentage symbol */\n                    status = match_char( scanner, c, case_sensitive );\n                    break;\n                case 'n':      /* case-sensitive match */\n                    case_sensitive = TRUE;\n                    break;\n                case 'i':      /* ignore case */\n                    case_sensitive = FALSE;\n                    break;\n                case 'q':      /* quoted string */\n                    str_ptr = ( memptr * ) va_arg( argp, memptr * );\n                    status =\n                        scanner_get_token( scanner, str_ptr, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_QUOTEDSTRING ) {\n                        status = PARSE_NO_MATCH;    /* not a quoted string */\n                    }\n                    break;\n                case 'w':\n\t      \t    /* optional whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_WHITESPACE ) {\n                        /* restore non-whitespace token */\n                        scanner->cursor -= token.length;\n                    }\n                    break;\n                case 'P':\n\t      \t    /* current pos of scanner */\n                    int_ptr = va_arg( argp, int * );\n                    assert( int_ptr != NULL );\n                    *int_ptr = (int)scanner->cursor;\n                    break;\n                    /* valid only in matchstr() */\n                case '0':\n\t\t    /* end of msg? */\n                    /* check that we are 1 beyond last char */\n                    if( scanner->cursor == scanner->msg->length &&\n                        scanner->msg->buf[scanner->cursor] == '\\0' ) {\n                        status = PARSE_OK;\n                    } else {\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:\n\t\t    /* unknown option */\n                    assert( 0 );\n            }\n        } else {\n            switch ( c ) {\n                case ' ':      /* LWS* */\n                    status = skip_lws( scanner );\n                    break;\n                case '\\t':     /* Whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != (token_type_t) TT_WHITESPACE ) {\n                        /* not whitespace token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:       /* match characters */\n                    {\n                        status = match_char( scanner, c, case_sensitive );\n                    }\n            }\n        }\n    }\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        /* on error, restore original scanner pos */\n        scanner->cursor = save_pos;\n    }\n\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "arg_list",
            "fmt"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_init",
          "args": [
            "&scanner",
            "&buf"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "130-135",
          "snippet": "static UPNP_INLINE void scanner_init(OUT scanner_t *scanner, IN membuffer *bufptr)\n{\n\tscanner->cursor = (size_t)0;\n\tscanner->msg = bufptr;\n\tscanner->entire_msg_loaded = FALSE;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void scanner_init(OUT scanner_t *scanner, IN membuffer *bufptr)\n{\n\tscanner->cursor = (size_t)0;\n\tscanner->msg = bufptr;\n\tscanner->entire_msg_loaded = FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_attach",
          "args": [
            "&buf",
            "str",
            "slen"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "287-295",
          "snippet": "void membuffer_attach(membuffer *m, char *new_buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\tmembuffer_destroy(m);\n\tm->buf = new_buf;\n\tm->length = buf_len;\n\tm->capacity = buf_len;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_attach(membuffer *m, char *new_buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\tmembuffer_destroy(m);\n\tm->buf = new_buf;\n\tm->length = buf_len;\n\tm->capacity = buf_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&buf"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}"
  },
  {
    "function_name": "match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "1135-1148",
    "snippet": "static parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfmatch",
          "args": [
            "scanner",
            "fmt",
            "args"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "vfmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "952-1116",
          "snippet": "static parse_status_t vfmatch(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\tva_list argp)\n{\n    char c;\n    const char *fmt_ptr = fmt;\n    parse_status_t status;\n    memptr *str_ptr;\n    memptr temp_str;\n    int *int_ptr;\n    uri_type *uri_ptr;\n    size_t save_pos;\n    int stat;\n    int case_sensitive = TRUE;\n    memptr token;\n    token_type_t tok_type;\n    int base;\n\n    assert( scanner != NULL );\n    assert( fmt != NULL );\n\n    /* save scanner pos; to aid error recovery */\n    save_pos = scanner->cursor;\n\n    status = PARSE_OK;\n    while( ( c = *fmt_ptr++ ) &&\n\t ( status == ( parse_status_t ) PARSE_OK ) ) {\n        if( c == '%' ) {\n            c = *fmt_ptr++;\n            switch ( c ) {\n                case 'R':      /* raw value */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = match_raw_value( scanner, str_ptr );\n                    break;\n                case 's':      /* simple identifier */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = scanner_get_token( scanner, str_ptr,\n                                                &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_IDENTIFIER ) {\n                        /* not an identifier */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'c':      /* crlf */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_CRLF ) {\n                        /* not CRLF token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'd':      /* integer */\n                case 'x':      /* hex number */\n                    int_ptr = va_arg(argp, int *);\n                    assert(int_ptr != NULL);\n                    base = c == 'd' ? 10 : 16;\n                    status = match_int(scanner, base, int_ptr);\n                    break;\n                case 'S':      /* non-whitespace string */\n                case 'U':      /* uri */\n                    if( c == 'S' ) {\n                        str_ptr = va_arg( argp, memptr * );\n                    } else {\n                        str_ptr = &temp_str;\n                    }\n                    assert( str_ptr != NULL );\n                    status = match_non_ws_string( scanner, str_ptr );\n                    if( c == 'U' && status == ( parse_status_t ) PARSE_OK ) {\n                        uri_ptr = va_arg( argp, uri_type * );\n                        assert( uri_ptr != NULL );\n                        stat = parse_uri( str_ptr->buf, str_ptr->length,\n                                          uri_ptr );\n                        if( stat != HTTP_SUCCESS ) {\n                            status = PARSE_NO_MATCH;\n                        }\n                    }\n                    break;\n                case 'L':      /* string till eol */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = read_until_crlf( scanner, str_ptr );\n                    break;\n                case ' ':      /* match space */\n                case '%':      /* match percentage symbol */\n                    status = match_char( scanner, c, case_sensitive );\n                    break;\n                case 'n':      /* case-sensitive match */\n                    case_sensitive = TRUE;\n                    break;\n                case 'i':      /* ignore case */\n                    case_sensitive = FALSE;\n                    break;\n                case 'q':      /* quoted string */\n                    str_ptr = ( memptr * ) va_arg( argp, memptr * );\n                    status =\n                        scanner_get_token( scanner, str_ptr, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_QUOTEDSTRING ) {\n                        status = PARSE_NO_MATCH;    /* not a quoted string */\n                    }\n                    break;\n                case 'w':\n\t      \t    /* optional whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_WHITESPACE ) {\n                        /* restore non-whitespace token */\n                        scanner->cursor -= token.length;\n                    }\n                    break;\n                case 'P':\n\t      \t    /* current pos of scanner */\n                    int_ptr = va_arg( argp, int * );\n                    assert( int_ptr != NULL );\n                    *int_ptr = (int)scanner->cursor;\n                    break;\n                    /* valid only in matchstr() */\n                case '0':\n\t\t    /* end of msg? */\n                    /* check that we are 1 beyond last char */\n                    if( scanner->cursor == scanner->msg->length &&\n                        scanner->msg->buf[scanner->cursor] == '\\0' ) {\n                        status = PARSE_OK;\n                    } else {\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:\n\t\t    /* unknown option */\n                    assert( 0 );\n            }\n        } else {\n            switch ( c ) {\n                case ' ':      /* LWS* */\n                    status = skip_lws( scanner );\n                    break;\n                case '\\t':     /* Whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != (token_type_t) TT_WHITESPACE ) {\n                        /* not whitespace token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:       /* match characters */\n                    {\n                        status = match_char( scanner, c, case_sensitive );\n                    }\n            }\n        }\n    }\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        /* on error, restore original scanner pos */\n        scanner->cursor = save_pos;\n    }\n\n    return status;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic parse_status_t vfmatch(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\tva_list argp)\n{\n    char c;\n    const char *fmt_ptr = fmt;\n    parse_status_t status;\n    memptr *str_ptr;\n    memptr temp_str;\n    int *int_ptr;\n    uri_type *uri_ptr;\n    size_t save_pos;\n    int stat;\n    int case_sensitive = TRUE;\n    memptr token;\n    token_type_t tok_type;\n    int base;\n\n    assert( scanner != NULL );\n    assert( fmt != NULL );\n\n    /* save scanner pos; to aid error recovery */\n    save_pos = scanner->cursor;\n\n    status = PARSE_OK;\n    while( ( c = *fmt_ptr++ ) &&\n\t ( status == ( parse_status_t ) PARSE_OK ) ) {\n        if( c == '%' ) {\n            c = *fmt_ptr++;\n            switch ( c ) {\n                case 'R':      /* raw value */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = match_raw_value( scanner, str_ptr );\n                    break;\n                case 's':      /* simple identifier */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = scanner_get_token( scanner, str_ptr,\n                                                &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_IDENTIFIER ) {\n                        /* not an identifier */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'c':      /* crlf */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_CRLF ) {\n                        /* not CRLF token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'd':      /* integer */\n                case 'x':      /* hex number */\n                    int_ptr = va_arg(argp, int *);\n                    assert(int_ptr != NULL);\n                    base = c == 'd' ? 10 : 16;\n                    status = match_int(scanner, base, int_ptr);\n                    break;\n                case 'S':      /* non-whitespace string */\n                case 'U':      /* uri */\n                    if( c == 'S' ) {\n                        str_ptr = va_arg( argp, memptr * );\n                    } else {\n                        str_ptr = &temp_str;\n                    }\n                    assert( str_ptr != NULL );\n                    status = match_non_ws_string( scanner, str_ptr );\n                    if( c == 'U' && status == ( parse_status_t ) PARSE_OK ) {\n                        uri_ptr = va_arg( argp, uri_type * );\n                        assert( uri_ptr != NULL );\n                        stat = parse_uri( str_ptr->buf, str_ptr->length,\n                                          uri_ptr );\n                        if( stat != HTTP_SUCCESS ) {\n                            status = PARSE_NO_MATCH;\n                        }\n                    }\n                    break;\n                case 'L':      /* string till eol */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = read_until_crlf( scanner, str_ptr );\n                    break;\n                case ' ':      /* match space */\n                case '%':      /* match percentage symbol */\n                    status = match_char( scanner, c, case_sensitive );\n                    break;\n                case 'n':      /* case-sensitive match */\n                    case_sensitive = TRUE;\n                    break;\n                case 'i':      /* ignore case */\n                    case_sensitive = FALSE;\n                    break;\n                case 'q':      /* quoted string */\n                    str_ptr = ( memptr * ) va_arg( argp, memptr * );\n                    status =\n                        scanner_get_token( scanner, str_ptr, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_QUOTEDSTRING ) {\n                        status = PARSE_NO_MATCH;    /* not a quoted string */\n                    }\n                    break;\n                case 'w':\n\t      \t    /* optional whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_WHITESPACE ) {\n                        /* restore non-whitespace token */\n                        scanner->cursor -= token.length;\n                    }\n                    break;\n                case 'P':\n\t      \t    /* current pos of scanner */\n                    int_ptr = va_arg( argp, int * );\n                    assert( int_ptr != NULL );\n                    *int_ptr = (int)scanner->cursor;\n                    break;\n                    /* valid only in matchstr() */\n                case '0':\n\t\t    /* end of msg? */\n                    /* check that we are 1 beyond last char */\n                    if( scanner->cursor == scanner->msg->length &&\n                        scanner->msg->buf[scanner->cursor] == '\\0' ) {\n                        status = PARSE_OK;\n                    } else {\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:\n\t\t    /* unknown option */\n                    assert( 0 );\n            }\n        } else {\n            switch ( c ) {\n                case ' ':      /* LWS* */\n                    status = skip_lws( scanner );\n                    break;\n                case '\\t':     /* Whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != (token_type_t) TT_WHITESPACE ) {\n                        /* not whitespace token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:       /* match characters */\n                    {\n                        status = match_char( scanner, c, case_sensitive );\n                    }\n            }\n        }\n    }\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        /* on error, restore original scanner pos */\n        scanner->cursor = save_pos;\n    }\n\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic parse_status_t match(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\t...)\n{\n\tparse_status_t ret_code;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tret_code = vfmatch(scanner, fmt, args);\n\tva_end(args);\n\n\treturn ret_code;\n}"
  },
  {
    "function_name": "vfmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "952-1116",
    "snippet": "static parse_status_t vfmatch(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\tva_list argp)\n{\n    char c;\n    const char *fmt_ptr = fmt;\n    parse_status_t status;\n    memptr *str_ptr;\n    memptr temp_str;\n    int *int_ptr;\n    uri_type *uri_ptr;\n    size_t save_pos;\n    int stat;\n    int case_sensitive = TRUE;\n    memptr token;\n    token_type_t tok_type;\n    int base;\n\n    assert( scanner != NULL );\n    assert( fmt != NULL );\n\n    /* save scanner pos; to aid error recovery */\n    save_pos = scanner->cursor;\n\n    status = PARSE_OK;\n    while( ( c = *fmt_ptr++ ) &&\n\t ( status == ( parse_status_t ) PARSE_OK ) ) {\n        if( c == '%' ) {\n            c = *fmt_ptr++;\n            switch ( c ) {\n                case 'R':      /* raw value */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = match_raw_value( scanner, str_ptr );\n                    break;\n                case 's':      /* simple identifier */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = scanner_get_token( scanner, str_ptr,\n                                                &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_IDENTIFIER ) {\n                        /* not an identifier */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'c':      /* crlf */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_CRLF ) {\n                        /* not CRLF token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'd':      /* integer */\n                case 'x':      /* hex number */\n                    int_ptr = va_arg(argp, int *);\n                    assert(int_ptr != NULL);\n                    base = c == 'd' ? 10 : 16;\n                    status = match_int(scanner, base, int_ptr);\n                    break;\n                case 'S':      /* non-whitespace string */\n                case 'U':      /* uri */\n                    if( c == 'S' ) {\n                        str_ptr = va_arg( argp, memptr * );\n                    } else {\n                        str_ptr = &temp_str;\n                    }\n                    assert( str_ptr != NULL );\n                    status = match_non_ws_string( scanner, str_ptr );\n                    if( c == 'U' && status == ( parse_status_t ) PARSE_OK ) {\n                        uri_ptr = va_arg( argp, uri_type * );\n                        assert( uri_ptr != NULL );\n                        stat = parse_uri( str_ptr->buf, str_ptr->length,\n                                          uri_ptr );\n                        if( stat != HTTP_SUCCESS ) {\n                            status = PARSE_NO_MATCH;\n                        }\n                    }\n                    break;\n                case 'L':      /* string till eol */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = read_until_crlf( scanner, str_ptr );\n                    break;\n                case ' ':      /* match space */\n                case '%':      /* match percentage symbol */\n                    status = match_char( scanner, c, case_sensitive );\n                    break;\n                case 'n':      /* case-sensitive match */\n                    case_sensitive = TRUE;\n                    break;\n                case 'i':      /* ignore case */\n                    case_sensitive = FALSE;\n                    break;\n                case 'q':      /* quoted string */\n                    str_ptr = ( memptr * ) va_arg( argp, memptr * );\n                    status =\n                        scanner_get_token( scanner, str_ptr, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_QUOTEDSTRING ) {\n                        status = PARSE_NO_MATCH;    /* not a quoted string */\n                    }\n                    break;\n                case 'w':\n\t      \t    /* optional whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_WHITESPACE ) {\n                        /* restore non-whitespace token */\n                        scanner->cursor -= token.length;\n                    }\n                    break;\n                case 'P':\n\t      \t    /* current pos of scanner */\n                    int_ptr = va_arg( argp, int * );\n                    assert( int_ptr != NULL );\n                    *int_ptr = (int)scanner->cursor;\n                    break;\n                    /* valid only in matchstr() */\n                case '0':\n\t\t    /* end of msg? */\n                    /* check that we are 1 beyond last char */\n                    if( scanner->cursor == scanner->msg->length &&\n                        scanner->msg->buf[scanner->cursor] == '\\0' ) {\n                        status = PARSE_OK;\n                    } else {\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:\n\t\t    /* unknown option */\n                    assert( 0 );\n            }\n        } else {\n            switch ( c ) {\n                case ' ':      /* LWS* */\n                    status = skip_lws( scanner );\n                    break;\n                case '\\t':     /* Whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != (token_type_t) TT_WHITESPACE ) {\n                        /* not whitespace token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:       /* match characters */\n                    {\n                        status = match_char( scanner, c, case_sensitive );\n                    }\n            }\n        }\n    }\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        /* on error, restore original scanner pos */\n        scanner->cursor = save_pos;\n    }\n\n    return status;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_char",
          "args": [
            "scanner",
            "c",
            "case_sensitive"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "match_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "875-894",
          "snippet": "static UPNP_INLINE parse_status_t\nmatch_char( INOUT scanner_t * scanner,\n            IN char c,\n            IN int case_sensitive )\n{\n    char scan_char;\n\n    if( scanner->cursor >= scanner->msg->length ) {\n        return PARSE_INCOMPLETE;\n    }\n    /* read next char from scanner */\n    scan_char = scanner->msg->buf[scanner->cursor++];\n\n    if( case_sensitive ) {\n        return c == scan_char ? PARSE_OK : PARSE_NO_MATCH;\n    } else {\n        return tolower( c ) == tolower( scan_char ) ?\n            PARSE_OK : PARSE_NO_MATCH;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t\nmatch_char( INOUT scanner_t * scanner,\n            IN char c,\n            IN int case_sensitive )\n{\n    char scan_char;\n\n    if( scanner->cursor >= scanner->msg->length ) {\n        return PARSE_INCOMPLETE;\n    }\n    /* read next char from scanner */\n    scan_char = scanner->msg->buf[scanner->cursor++];\n\n    if( case_sensitive ) {\n        return c == scan_char ? PARSE_OK : PARSE_NO_MATCH;\n    } else {\n        return tolower( c ) == tolower( scan_char ) ?\n            PARSE_OK : PARSE_NO_MATCH;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_get_token",
          "args": [
            "scanner",
            "&token",
            "&tok_type"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "219-326",
          "snippet": "static parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TOKCHAR_LF\t\t0xA",
            "#define TOKCHAR_CR\t\t0xD"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_lws",
          "args": [
            "scanner"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "skip_lws",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "560-597",
          "snippet": "static UPNP_INLINE parse_status_t skip_lws(INOUT scanner_t *scanner)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    size_t save_pos;\n    int matched;\n\n    do {\n        save_pos = scanner->cursor;\n        matched = FALSE;\n\n        /* get CRLF or WS */\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK ) {\n            if( tok_type == ( token_type_t ) TT_CRLF ) {\n                /* get WS */\n                status = scanner_get_token( scanner, &token, &tok_type );\n            }\n\n            if( status == ( parse_status_t ) PARSE_OK &&\n\t\ttok_type == ( token_type_t ) TT_WHITESPACE ) {\n                matched = TRUE;\n            } else {\n                /* did not match LWS; pushback token(s) */\n                scanner->cursor = save_pos;\n            }\n        }\n    } while( matched );\n\n    /* if entire msg is loaded, ignore an 'incomplete' warning */\n    if( status == ( parse_status_t ) PARSE_INCOMPLETE &&\n\tscanner->entire_msg_loaded ) {\n        status = PARSE_OK;\n    }\n\n    return status;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t skip_lws(INOUT scanner_t *scanner)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    size_t save_pos;\n    int matched;\n\n    do {\n        save_pos = scanner->cursor;\n        matched = FALSE;\n\n        /* get CRLF or WS */\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK ) {\n            if( tok_type == ( token_type_t ) TT_CRLF ) {\n                /* get WS */\n                status = scanner_get_token( scanner, &token, &tok_type );\n            }\n\n            if( status == ( parse_status_t ) PARSE_OK &&\n\t\ttok_type == ( token_type_t ) TT_WHITESPACE ) {\n                matched = TRUE;\n            } else {\n                /* did not match LWS; pushback token(s) */\n                scanner->cursor = save_pos;\n            }\n        }\n    } while( matched );\n\n    /* if entire msg is loaded, ignore an 'incomplete' warning */\n    if( status == ( parse_status_t ) PARSE_INCOMPLETE &&\n\tscanner->entire_msg_loaded ) {\n        status = PARSE_OK;\n    }\n\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "int_ptr != NULL"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "int*"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "memptr*"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_until_crlf",
          "args": [
            "scanner",
            "str_ptr"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "read_until_crlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "829-856",
          "snippet": "static UPNP_INLINE parse_status_t \nread_until_crlf( INOUT scanner_t * scanner,\n                 OUT memptr * str )\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    size_t start_pos;\n\n    start_pos = scanner->cursor;\n    str->buf = scanner_get_str( scanner );\n\n    /* read until we hit a crlf */\n    do {\n        status = scanner_get_token( scanner, &token, &tok_type );\n    } while( status == ( parse_status_t ) PARSE_OK &&\n\ttok_type != ( token_type_t ) TT_CRLF );\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* pushback crlf in stream */\n        scanner->cursor -= token.length;\n\n        /* str should include all strings except crlf at the end */\n        str->length = scanner->cursor - start_pos;\n    }\n\n    return status;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t \nread_until_crlf( INOUT scanner_t * scanner,\n                 OUT memptr * str )\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    size_t start_pos;\n\n    start_pos = scanner->cursor;\n    str->buf = scanner_get_str( scanner );\n\n    /* read until we hit a crlf */\n    do {\n        status = scanner_get_token( scanner, &token, &tok_type );\n    } while( status == ( parse_status_t ) PARSE_OK &&\n\ttok_type != ( token_type_t ) TT_CRLF );\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* pushback crlf in stream */\n        scanner->cursor -= token.length;\n\n        /* str should include all strings except crlf at the end */\n        str->length = scanner->cursor - start_pos;\n    }\n\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str_ptr != NULL"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "memptr*"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_uri",
          "args": [
            "str_ptr->buf",
            "str_ptr->length",
            "uri_ptr"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uri_and_unescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "759-775",
          "snippet": "int parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "uri_ptr != NULL"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "uri_type*"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_non_ws_string",
          "args": [
            "scanner",
            "str_ptr"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "match_non_ws_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "616-663",
          "snippet": "static UPNP_INLINE parse_status_t match_non_ws_string(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *str)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    int done = FALSE;\n    size_t save_cursor;\n\n    save_cursor = scanner->cursor;\n\n    str->length = ( size_t ) 0;\n    str->buf = scanner_get_str( scanner );  /* point to next char in input */\n\n    while( !done ) {\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK &&\n            tok_type != ( token_type_t ) TT_WHITESPACE &&\n            tok_type != ( token_type_t ) TT_CRLF ) {\n            /* append non-ws token */\n            str->length += token.length;\n        } else {\n            done = TRUE;\n        }\n    }\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* last token was WS; push it back in */\n        scanner->cursor -= token.length;\n    }\n    /* tolerate 'incomplete' msg */\n    if( status == ( parse_status_t ) PARSE_OK ||\n        ( status == ( parse_status_t ) PARSE_INCOMPLETE &&\n        scanner->entire_msg_loaded )\n         ) {\n        if( str->length == ( size_t ) 0 ) {\n            /* no strings found */\n            return PARSE_NO_MATCH;\n        } else {\n            return PARSE_OK;\n        }\n    } else {\n        /* error -- pushback tokens */\n        scanner->cursor = save_cursor;\n        return status;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t match_non_ws_string(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *str)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    int done = FALSE;\n    size_t save_cursor;\n\n    save_cursor = scanner->cursor;\n\n    str->length = ( size_t ) 0;\n    str->buf = scanner_get_str( scanner );  /* point to next char in input */\n\n    while( !done ) {\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK &&\n            tok_type != ( token_type_t ) TT_WHITESPACE &&\n            tok_type != ( token_type_t ) TT_CRLF ) {\n            /* append non-ws token */\n            str->length += token.length;\n        } else {\n            done = TRUE;\n        }\n    }\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* last token was WS; push it back in */\n        scanner->cursor -= token.length;\n    }\n    /* tolerate 'incomplete' msg */\n    if( status == ( parse_status_t ) PARSE_OK ||\n        ( status == ( parse_status_t ) PARSE_INCOMPLETE &&\n        scanner->entire_msg_loaded )\n         ) {\n        if( str->length == ( size_t ) 0 ) {\n            /* no strings found */\n            return PARSE_NO_MATCH;\n        } else {\n            return PARSE_OK;\n        }\n    } else {\n        /* error -- pushback tokens */\n        scanner->cursor = save_cursor;\n        return status;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str_ptr != NULL"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "memptr*"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "scanner",
            "base",
            "int_ptr"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "match_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "775-811",
          "snippet": "static UPNP_INLINE parse_status_t match_int(\n\tINOUT scanner_t *scanner,\n\tIN int base,\n\tOUT int *value)\n{\n\tmemptr token;\n\ttoken_type_t tok_type;\n\tparse_status_t status;\n\tlong num;\n\tchar *end_ptr;\n\tsize_t save_pos;\n\n\tsave_pos = scanner->cursor;\n\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\tif (status == (parse_status_t)PARSE_OK) {\n\t\tif (tok_type == (token_type_t)TT_IDENTIFIER) {\n\t\t\terrno = 0;\n\t\t\tnum = strtol(token.buf, &end_ptr, base);\n\t\t\t/* all and only those chars in token should be used for num */\n\t\t\tif (num < 0 || end_ptr != token.buf + token.length ||\n\t\t\t    ((num == LONG_MIN || num == LONG_MAX) && (errno == ERANGE))) {\n\t\t\t\tstatus = PARSE_NO_MATCH;\n\t\t\t}\n\t\t\t/* save result */\n\t\t\t*value = (int)num;\n\t\t} else {\n\t\t\t/* token must be an identifier */\n\t\t\tstatus = PARSE_NO_MATCH;\n\t\t}\n\t}\n\tif (status != (parse_status_t)PARSE_OK) {\n\t\t/* restore scanner position for bad values */\n\t\tscanner->cursor = save_pos;\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t match_int(\n\tINOUT scanner_t *scanner,\n\tIN int base,\n\tOUT int *value)\n{\n\tmemptr token;\n\ttoken_type_t tok_type;\n\tparse_status_t status;\n\tlong num;\n\tchar *end_ptr;\n\tsize_t save_pos;\n\n\tsave_pos = scanner->cursor;\n\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\tif (status == (parse_status_t)PARSE_OK) {\n\t\tif (tok_type == (token_type_t)TT_IDENTIFIER) {\n\t\t\terrno = 0;\n\t\t\tnum = strtol(token.buf, &end_ptr, base);\n\t\t\t/* all and only those chars in token should be used for num */\n\t\t\tif (num < 0 || end_ptr != token.buf + token.length ||\n\t\t\t    ((num == LONG_MIN || num == LONG_MAX) && (errno == ERANGE))) {\n\t\t\t\tstatus = PARSE_NO_MATCH;\n\t\t\t}\n\t\t\t/* save result */\n\t\t\t*value = (int)num;\n\t\t} else {\n\t\t\t/* token must be an identifier */\n\t\t\tstatus = PARSE_NO_MATCH;\n\t\t}\n\t}\n\tif (status != (parse_status_t)PARSE_OK) {\n\t\t/* restore scanner position for bad values */\n\t\tscanner->cursor = save_pos;\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "int_ptr != NULL"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "int*"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str_ptr != NULL"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "memptr*"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_raw_value",
          "args": [
            "scanner",
            "str_ptr"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "match_raw_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "684-754",
          "snippet": "static UPNP_INLINE parse_status_t match_raw_value(\n\tINOUT scanner_t * scanner,\n\tOUT memptr *raw_value)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    int done = FALSE;\n    int saw_crlf = FALSE;\n    size_t pos_at_crlf = ( size_t ) 0;\n    size_t save_pos;\n    char c;\n\n    save_pos = scanner->cursor;\n\n    /* value points to start of input */\n    raw_value->buf = scanner_get_str( scanner );\n    raw_value->length = ( size_t ) 0;\n\n    while( !done ) {\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK ) {\n            if( !saw_crlf ) {\n                if( tok_type == ( token_type_t ) TT_CRLF ) {\n                    /* CRLF could end value */\n                    saw_crlf = TRUE;\n\n                    /* save input position at start of CRLF */\n                    pos_at_crlf = scanner->cursor - token.length;\n                }\n                /* keep appending value */\n                raw_value->length += token.length;\n            } else              /* already seen CRLF */\n            {\n                if( tok_type == ( token_type_t ) TT_WHITESPACE ) {\n                    /* start again; forget CRLF */\n                    saw_crlf = FALSE;\n                    raw_value->length += token.length;\n                } else {\n                    /* non-ws means value ended just before CRLF */\n                    done = TRUE;\n\n                    /* point to the crlf which ended the value */\n                    scanner->cursor = pos_at_crlf;\n                }\n            }\n        } else {\n            /* some kind of error; restore scanner position */\n            scanner->cursor = save_pos;\n            done = TRUE;\n        }\n    }\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* trim whitespace on right side of value */\n        while( raw_value->length > ( size_t ) 0 ) {\n            /* get last char */\n            c = raw_value->buf[raw_value->length - ( size_t ) 1];\n\n            if( c != ' ' && c != '\\t' &&\n                c != TOKCHAR_CR && c != TOKCHAR_LF ) {\n                /* done; no more whitespace */\n                break;\n            }\n            /* remove whitespace */\n            raw_value->length--;\n        }\n    }\n\n    return status;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TOKCHAR_LF\t\t0xA",
            "#define TOKCHAR_CR\t\t0xD"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic UPNP_INLINE parse_status_t match_raw_value(\n\tINOUT scanner_t * scanner,\n\tOUT memptr *raw_value)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    int done = FALSE;\n    int saw_crlf = FALSE;\n    size_t pos_at_crlf = ( size_t ) 0;\n    size_t save_pos;\n    char c;\n\n    save_pos = scanner->cursor;\n\n    /* value points to start of input */\n    raw_value->buf = scanner_get_str( scanner );\n    raw_value->length = ( size_t ) 0;\n\n    while( !done ) {\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK ) {\n            if( !saw_crlf ) {\n                if( tok_type == ( token_type_t ) TT_CRLF ) {\n                    /* CRLF could end value */\n                    saw_crlf = TRUE;\n\n                    /* save input position at start of CRLF */\n                    pos_at_crlf = scanner->cursor - token.length;\n                }\n                /* keep appending value */\n                raw_value->length += token.length;\n            } else              /* already seen CRLF */\n            {\n                if( tok_type == ( token_type_t ) TT_WHITESPACE ) {\n                    /* start again; forget CRLF */\n                    saw_crlf = FALSE;\n                    raw_value->length += token.length;\n                } else {\n                    /* non-ws means value ended just before CRLF */\n                    done = TRUE;\n\n                    /* point to the crlf which ended the value */\n                    scanner->cursor = pos_at_crlf;\n                }\n            }\n        } else {\n            /* some kind of error; restore scanner position */\n            scanner->cursor = save_pos;\n            done = TRUE;\n        }\n    }\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* trim whitespace on right side of value */\n        while( raw_value->length > ( size_t ) 0 ) {\n            /* get last char */\n            c = raw_value->buf[raw_value->length - ( size_t ) 1];\n\n            if( c != ' ' && c != '\\t' &&\n                c != TOKCHAR_CR && c != TOKCHAR_LF ) {\n                /* done; no more whitespace */\n                break;\n            }\n            /* remove whitespace */\n            raw_value->length--;\n        }\n    }\n\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str_ptr != NULL"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "memptr*"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fmt != NULL"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "scanner != NULL"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic parse_status_t vfmatch(\n\tINOUT scanner_t *scanner,\n\tIN const char *fmt,\n\tva_list argp)\n{\n    char c;\n    const char *fmt_ptr = fmt;\n    parse_status_t status;\n    memptr *str_ptr;\n    memptr temp_str;\n    int *int_ptr;\n    uri_type *uri_ptr;\n    size_t save_pos;\n    int stat;\n    int case_sensitive = TRUE;\n    memptr token;\n    token_type_t tok_type;\n    int base;\n\n    assert( scanner != NULL );\n    assert( fmt != NULL );\n\n    /* save scanner pos; to aid error recovery */\n    save_pos = scanner->cursor;\n\n    status = PARSE_OK;\n    while( ( c = *fmt_ptr++ ) &&\n\t ( status == ( parse_status_t ) PARSE_OK ) ) {\n        if( c == '%' ) {\n            c = *fmt_ptr++;\n            switch ( c ) {\n                case 'R':      /* raw value */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = match_raw_value( scanner, str_ptr );\n                    break;\n                case 's':      /* simple identifier */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = scanner_get_token( scanner, str_ptr,\n                                                &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_IDENTIFIER ) {\n                        /* not an identifier */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'c':      /* crlf */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_CRLF ) {\n                        /* not CRLF token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                case 'd':      /* integer */\n                case 'x':      /* hex number */\n                    int_ptr = va_arg(argp, int *);\n                    assert(int_ptr != NULL);\n                    base = c == 'd' ? 10 : 16;\n                    status = match_int(scanner, base, int_ptr);\n                    break;\n                case 'S':      /* non-whitespace string */\n                case 'U':      /* uri */\n                    if( c == 'S' ) {\n                        str_ptr = va_arg( argp, memptr * );\n                    } else {\n                        str_ptr = &temp_str;\n                    }\n                    assert( str_ptr != NULL );\n                    status = match_non_ws_string( scanner, str_ptr );\n                    if( c == 'U' && status == ( parse_status_t ) PARSE_OK ) {\n                        uri_ptr = va_arg( argp, uri_type * );\n                        assert( uri_ptr != NULL );\n                        stat = parse_uri( str_ptr->buf, str_ptr->length,\n                                          uri_ptr );\n                        if( stat != HTTP_SUCCESS ) {\n                            status = PARSE_NO_MATCH;\n                        }\n                    }\n                    break;\n                case 'L':      /* string till eol */\n                    str_ptr = va_arg( argp, memptr * );\n                    assert( str_ptr != NULL );\n                    status = read_until_crlf( scanner, str_ptr );\n                    break;\n                case ' ':      /* match space */\n                case '%':      /* match percentage symbol */\n                    status = match_char( scanner, c, case_sensitive );\n                    break;\n                case 'n':      /* case-sensitive match */\n                    case_sensitive = TRUE;\n                    break;\n                case 'i':      /* ignore case */\n                    case_sensitive = FALSE;\n                    break;\n                case 'q':      /* quoted string */\n                    str_ptr = ( memptr * ) va_arg( argp, memptr * );\n                    status =\n                        scanner_get_token( scanner, str_ptr, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_QUOTEDSTRING ) {\n                        status = PARSE_NO_MATCH;    /* not a quoted string */\n                    }\n                    break;\n                case 'w':\n\t      \t    /* optional whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != ( token_type_t ) TT_WHITESPACE ) {\n                        /* restore non-whitespace token */\n                        scanner->cursor -= token.length;\n                    }\n                    break;\n                case 'P':\n\t      \t    /* current pos of scanner */\n                    int_ptr = va_arg( argp, int * );\n                    assert( int_ptr != NULL );\n                    *int_ptr = (int)scanner->cursor;\n                    break;\n                    /* valid only in matchstr() */\n                case '0':\n\t\t    /* end of msg? */\n                    /* check that we are 1 beyond last char */\n                    if( scanner->cursor == scanner->msg->length &&\n                        scanner->msg->buf[scanner->cursor] == '\\0' ) {\n                        status = PARSE_OK;\n                    } else {\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:\n\t\t    /* unknown option */\n                    assert( 0 );\n            }\n        } else {\n            switch ( c ) {\n                case ' ':      /* LWS* */\n                    status = skip_lws( scanner );\n                    break;\n                case '\\t':     /* Whitespace */\n                    status = scanner_get_token( scanner,\n                                                &token, &tok_type );\n                    if( status == ( parse_status_t ) PARSE_OK &&\n\t\t\ttok_type != (token_type_t) TT_WHITESPACE ) {\n                        /* not whitespace token */\n                        status = PARSE_NO_MATCH;\n                    }\n                    break;\n                default:       /* match characters */\n                    {\n                        status = match_char( scanner, c, case_sensitive );\n                    }\n            }\n        }\n    }\n    if( status != ( parse_status_t ) PARSE_OK ) {\n        /* on error, restore original scanner pos */\n        scanner->cursor = save_pos;\n    }\n\n    return status;\n}"
  },
  {
    "function_name": "match_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "875-894",
    "snippet": "static UPNP_INLINE parse_status_t\nmatch_char( INOUT scanner_t * scanner,\n            IN char c,\n            IN int case_sensitive )\n{\n    char scan_char;\n\n    if( scanner->cursor >= scanner->msg->length ) {\n        return PARSE_INCOMPLETE;\n    }\n    /* read next char from scanner */\n    scan_char = scanner->msg->buf[scanner->cursor++];\n\n    if( case_sensitive ) {\n        return c == scan_char ? PARSE_OK : PARSE_NO_MATCH;\n    } else {\n        return tolower( c ) == tolower( scan_char ) ?\n            PARSE_OK : PARSE_NO_MATCH;\n    }\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "scan_char"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "c"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t\nmatch_char( INOUT scanner_t * scanner,\n            IN char c,\n            IN int case_sensitive )\n{\n    char scan_char;\n\n    if( scanner->cursor >= scanner->msg->length ) {\n        return PARSE_INCOMPLETE;\n    }\n    /* read next char from scanner */\n    scan_char = scanner->msg->buf[scanner->cursor++];\n\n    if( case_sensitive ) {\n        return c == scan_char ? PARSE_OK : PARSE_NO_MATCH;\n    } else {\n        return tolower( c ) == tolower( scan_char ) ?\n            PARSE_OK : PARSE_NO_MATCH;\n    }\n}"
  },
  {
    "function_name": "read_until_crlf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "829-856",
    "snippet": "static UPNP_INLINE parse_status_t \nread_until_crlf( INOUT scanner_t * scanner,\n                 OUT memptr * str )\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    size_t start_pos;\n\n    start_pos = scanner->cursor;\n    str->buf = scanner_get_str( scanner );\n\n    /* read until we hit a crlf */\n    do {\n        status = scanner_get_token( scanner, &token, &tok_type );\n    } while( status == ( parse_status_t ) PARSE_OK &&\n\ttok_type != ( token_type_t ) TT_CRLF );\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* pushback crlf in stream */\n        scanner->cursor -= token.length;\n\n        /* str should include all strings except crlf at the end */\n        str->length = scanner->cursor - start_pos;\n    }\n\n    return status;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scanner_get_token",
          "args": [
            "scanner",
            "&token",
            "&tok_type"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "219-326",
          "snippet": "static parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TOKCHAR_LF\t\t0xA",
            "#define TOKCHAR_CR\t\t0xD"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_get_str",
          "args": [
            "scanner"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "340-343",
          "snippet": "static UPNP_INLINE char *scanner_get_str(IN scanner_t * scanner)\n{\n\treturn scanner->msg->buf + scanner->cursor;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE char *scanner_get_str(IN scanner_t * scanner)\n{\n\treturn scanner->msg->buf + scanner->cursor;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t \nread_until_crlf( INOUT scanner_t * scanner,\n                 OUT memptr * str )\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    size_t start_pos;\n\n    start_pos = scanner->cursor;\n    str->buf = scanner_get_str( scanner );\n\n    /* read until we hit a crlf */\n    do {\n        status = scanner_get_token( scanner, &token, &tok_type );\n    } while( status == ( parse_status_t ) PARSE_OK &&\n\ttok_type != ( token_type_t ) TT_CRLF );\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* pushback crlf in stream */\n        scanner->cursor -= token.length;\n\n        /* str should include all strings except crlf at the end */\n        str->length = scanner->cursor - start_pos;\n    }\n\n    return status;\n}"
  },
  {
    "function_name": "match_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "775-811",
    "snippet": "static UPNP_INLINE parse_status_t match_int(\n\tINOUT scanner_t *scanner,\n\tIN int base,\n\tOUT int *value)\n{\n\tmemptr token;\n\ttoken_type_t tok_type;\n\tparse_status_t status;\n\tlong num;\n\tchar *end_ptr;\n\tsize_t save_pos;\n\n\tsave_pos = scanner->cursor;\n\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\tif (status == (parse_status_t)PARSE_OK) {\n\t\tif (tok_type == (token_type_t)TT_IDENTIFIER) {\n\t\t\terrno = 0;\n\t\t\tnum = strtol(token.buf, &end_ptr, base);\n\t\t\t/* all and only those chars in token should be used for num */\n\t\t\tif (num < 0 || end_ptr != token.buf + token.length ||\n\t\t\t    ((num == LONG_MIN || num == LONG_MAX) && (errno == ERANGE))) {\n\t\t\t\tstatus = PARSE_NO_MATCH;\n\t\t\t}\n\t\t\t/* save result */\n\t\t\t*value = (int)num;\n\t\t} else {\n\t\t\t/* token must be an identifier */\n\t\t\tstatus = PARSE_NO_MATCH;\n\t\t}\n\t}\n\tif (status != (parse_status_t)PARSE_OK) {\n\t\t/* restore scanner position for bad values */\n\t\tscanner->cursor = save_pos;\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "token.buf",
            "&end_ptr",
            "base"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_get_token",
          "args": [
            "scanner",
            "&token",
            "&tok_type"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "219-326",
          "snippet": "static parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TOKCHAR_LF\t\t0xA",
            "#define TOKCHAR_CR\t\t0xD"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t match_int(\n\tINOUT scanner_t *scanner,\n\tIN int base,\n\tOUT int *value)\n{\n\tmemptr token;\n\ttoken_type_t tok_type;\n\tparse_status_t status;\n\tlong num;\n\tchar *end_ptr;\n\tsize_t save_pos;\n\n\tsave_pos = scanner->cursor;\n\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\tif (status == (parse_status_t)PARSE_OK) {\n\t\tif (tok_type == (token_type_t)TT_IDENTIFIER) {\n\t\t\terrno = 0;\n\t\t\tnum = strtol(token.buf, &end_ptr, base);\n\t\t\t/* all and only those chars in token should be used for num */\n\t\t\tif (num < 0 || end_ptr != token.buf + token.length ||\n\t\t\t    ((num == LONG_MIN || num == LONG_MAX) && (errno == ERANGE))) {\n\t\t\t\tstatus = PARSE_NO_MATCH;\n\t\t\t}\n\t\t\t/* save result */\n\t\t\t*value = (int)num;\n\t\t} else {\n\t\t\t/* token must be an identifier */\n\t\t\tstatus = PARSE_NO_MATCH;\n\t\t}\n\t}\n\tif (status != (parse_status_t)PARSE_OK) {\n\t\t/* restore scanner position for bad values */\n\t\tscanner->cursor = save_pos;\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "match_raw_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "684-754",
    "snippet": "static UPNP_INLINE parse_status_t match_raw_value(\n\tINOUT scanner_t * scanner,\n\tOUT memptr *raw_value)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    int done = FALSE;\n    int saw_crlf = FALSE;\n    size_t pos_at_crlf = ( size_t ) 0;\n    size_t save_pos;\n    char c;\n\n    save_pos = scanner->cursor;\n\n    /* value points to start of input */\n    raw_value->buf = scanner_get_str( scanner );\n    raw_value->length = ( size_t ) 0;\n\n    while( !done ) {\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK ) {\n            if( !saw_crlf ) {\n                if( tok_type == ( token_type_t ) TT_CRLF ) {\n                    /* CRLF could end value */\n                    saw_crlf = TRUE;\n\n                    /* save input position at start of CRLF */\n                    pos_at_crlf = scanner->cursor - token.length;\n                }\n                /* keep appending value */\n                raw_value->length += token.length;\n            } else              /* already seen CRLF */\n            {\n                if( tok_type == ( token_type_t ) TT_WHITESPACE ) {\n                    /* start again; forget CRLF */\n                    saw_crlf = FALSE;\n                    raw_value->length += token.length;\n                } else {\n                    /* non-ws means value ended just before CRLF */\n                    done = TRUE;\n\n                    /* point to the crlf which ended the value */\n                    scanner->cursor = pos_at_crlf;\n                }\n            }\n        } else {\n            /* some kind of error; restore scanner position */\n            scanner->cursor = save_pos;\n            done = TRUE;\n        }\n    }\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* trim whitespace on right side of value */\n        while( raw_value->length > ( size_t ) 0 ) {\n            /* get last char */\n            c = raw_value->buf[raw_value->length - ( size_t ) 1];\n\n            if( c != ' ' && c != '\\t' &&\n                c != TOKCHAR_CR && c != TOKCHAR_LF ) {\n                /* done; no more whitespace */\n                break;\n            }\n            /* remove whitespace */\n            raw_value->length--;\n        }\n    }\n\n    return status;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define TOKCHAR_LF\t\t0xA",
      "#define TOKCHAR_CR\t\t0xD"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scanner_get_token",
          "args": [
            "scanner",
            "&token",
            "&tok_type"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "219-326",
          "snippet": "static parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TOKCHAR_LF\t\t0xA",
            "#define TOKCHAR_CR\t\t0xD"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_get_str",
          "args": [
            "scanner"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "340-343",
          "snippet": "static UPNP_INLINE char *scanner_get_str(IN scanner_t * scanner)\n{\n\treturn scanner->msg->buf + scanner->cursor;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE char *scanner_get_str(IN scanner_t * scanner)\n{\n\treturn scanner->msg->buf + scanner->cursor;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic UPNP_INLINE parse_status_t match_raw_value(\n\tINOUT scanner_t * scanner,\n\tOUT memptr *raw_value)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    int done = FALSE;\n    int saw_crlf = FALSE;\n    size_t pos_at_crlf = ( size_t ) 0;\n    size_t save_pos;\n    char c;\n\n    save_pos = scanner->cursor;\n\n    /* value points to start of input */\n    raw_value->buf = scanner_get_str( scanner );\n    raw_value->length = ( size_t ) 0;\n\n    while( !done ) {\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK ) {\n            if( !saw_crlf ) {\n                if( tok_type == ( token_type_t ) TT_CRLF ) {\n                    /* CRLF could end value */\n                    saw_crlf = TRUE;\n\n                    /* save input position at start of CRLF */\n                    pos_at_crlf = scanner->cursor - token.length;\n                }\n                /* keep appending value */\n                raw_value->length += token.length;\n            } else              /* already seen CRLF */\n            {\n                if( tok_type == ( token_type_t ) TT_WHITESPACE ) {\n                    /* start again; forget CRLF */\n                    saw_crlf = FALSE;\n                    raw_value->length += token.length;\n                } else {\n                    /* non-ws means value ended just before CRLF */\n                    done = TRUE;\n\n                    /* point to the crlf which ended the value */\n                    scanner->cursor = pos_at_crlf;\n                }\n            }\n        } else {\n            /* some kind of error; restore scanner position */\n            scanner->cursor = save_pos;\n            done = TRUE;\n        }\n    }\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* trim whitespace on right side of value */\n        while( raw_value->length > ( size_t ) 0 ) {\n            /* get last char */\n            c = raw_value->buf[raw_value->length - ( size_t ) 1];\n\n            if( c != ' ' && c != '\\t' &&\n                c != TOKCHAR_CR && c != TOKCHAR_LF ) {\n                /* done; no more whitespace */\n                break;\n            }\n            /* remove whitespace */\n            raw_value->length--;\n        }\n    }\n\n    return status;\n}"
  },
  {
    "function_name": "match_non_ws_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "616-663",
    "snippet": "static UPNP_INLINE parse_status_t match_non_ws_string(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *str)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    int done = FALSE;\n    size_t save_cursor;\n\n    save_cursor = scanner->cursor;\n\n    str->length = ( size_t ) 0;\n    str->buf = scanner_get_str( scanner );  /* point to next char in input */\n\n    while( !done ) {\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK &&\n            tok_type != ( token_type_t ) TT_WHITESPACE &&\n            tok_type != ( token_type_t ) TT_CRLF ) {\n            /* append non-ws token */\n            str->length += token.length;\n        } else {\n            done = TRUE;\n        }\n    }\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* last token was WS; push it back in */\n        scanner->cursor -= token.length;\n    }\n    /* tolerate 'incomplete' msg */\n    if( status == ( parse_status_t ) PARSE_OK ||\n        ( status == ( parse_status_t ) PARSE_INCOMPLETE &&\n        scanner->entire_msg_loaded )\n         ) {\n        if( str->length == ( size_t ) 0 ) {\n            /* no strings found */\n            return PARSE_NO_MATCH;\n        } else {\n            return PARSE_OK;\n        }\n    } else {\n        /* error -- pushback tokens */\n        scanner->cursor = save_cursor;\n        return status;\n    }\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scanner_get_token",
          "args": [
            "scanner",
            "&token",
            "&tok_type"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "219-326",
          "snippet": "static parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TOKCHAR_LF\t\t0xA",
            "#define TOKCHAR_CR\t\t0xD"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_get_str",
          "args": [
            "scanner"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "340-343",
          "snippet": "static UPNP_INLINE char *scanner_get_str(IN scanner_t * scanner)\n{\n\treturn scanner->msg->buf + scanner->cursor;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE char *scanner_get_str(IN scanner_t * scanner)\n{\n\treturn scanner->msg->buf + scanner->cursor;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t match_non_ws_string(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *str)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    int done = FALSE;\n    size_t save_cursor;\n\n    save_cursor = scanner->cursor;\n\n    str->length = ( size_t ) 0;\n    str->buf = scanner_get_str( scanner );  /* point to next char in input */\n\n    while( !done ) {\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK &&\n            tok_type != ( token_type_t ) TT_WHITESPACE &&\n            tok_type != ( token_type_t ) TT_CRLF ) {\n            /* append non-ws token */\n            str->length += token.length;\n        } else {\n            done = TRUE;\n        }\n    }\n\n    if( status == ( parse_status_t ) PARSE_OK ) {\n        /* last token was WS; push it back in */\n        scanner->cursor -= token.length;\n    }\n    /* tolerate 'incomplete' msg */\n    if( status == ( parse_status_t ) PARSE_OK ||\n        ( status == ( parse_status_t ) PARSE_INCOMPLETE &&\n        scanner->entire_msg_loaded )\n         ) {\n        if( str->length == ( size_t ) 0 ) {\n            /* no strings found */\n            return PARSE_NO_MATCH;\n        } else {\n            return PARSE_OK;\n        }\n    } else {\n        /* error -- pushback tokens */\n        scanner->cursor = save_cursor;\n        return status;\n    }\n}"
  },
  {
    "function_name": "skip_lws",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "560-597",
    "snippet": "static UPNP_INLINE parse_status_t skip_lws(INOUT scanner_t *scanner)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    size_t save_pos;\n    int matched;\n\n    do {\n        save_pos = scanner->cursor;\n        matched = FALSE;\n\n        /* get CRLF or WS */\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK ) {\n            if( tok_type == ( token_type_t ) TT_CRLF ) {\n                /* get WS */\n                status = scanner_get_token( scanner, &token, &tok_type );\n            }\n\n            if( status == ( parse_status_t ) PARSE_OK &&\n\t\ttok_type == ( token_type_t ) TT_WHITESPACE ) {\n                matched = TRUE;\n            } else {\n                /* did not match LWS; pushback token(s) */\n                scanner->cursor = save_pos;\n            }\n        }\n    } while( matched );\n\n    /* if entire msg is loaded, ignore an 'incomplete' warning */\n    if( status == ( parse_status_t ) PARSE_INCOMPLETE &&\n\tscanner->entire_msg_loaded ) {\n        status = PARSE_OK;\n    }\n\n    return status;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scanner_get_token",
          "args": [
            "scanner",
            "&token",
            "&tok_type"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "219-326",
          "snippet": "static parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TOKCHAR_LF\t\t0xA",
            "#define TOKCHAR_CR\t\t0xD"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t skip_lws(INOUT scanner_t *scanner)\n{\n    memptr token;\n    token_type_t tok_type;\n    parse_status_t status;\n    size_t save_pos;\n    int matched;\n\n    do {\n        save_pos = scanner->cursor;\n        matched = FALSE;\n\n        /* get CRLF or WS */\n        status = scanner_get_token( scanner, &token, &tok_type );\n        if( status == ( parse_status_t ) PARSE_OK ) {\n            if( tok_type == ( token_type_t ) TT_CRLF ) {\n                /* get WS */\n                status = scanner_get_token( scanner, &token, &tok_type );\n            }\n\n            if( status == ( parse_status_t ) PARSE_OK &&\n\t\ttok_type == ( token_type_t ) TT_WHITESPACE ) {\n                matched = TRUE;\n            } else {\n                /* did not match LWS; pushback token(s) */\n                scanner->cursor = save_pos;\n            }\n        }\n    } while( matched );\n\n    /* if entire msg is loaded, ignore an 'incomplete' warning */\n    if( status == ( parse_status_t ) PARSE_INCOMPLETE &&\n\tscanner->entire_msg_loaded ) {\n        status = PARSE_OK;\n    }\n\n    return status;\n}"
  },
  {
    "function_name": "skip_blank_lines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "525-543",
    "snippet": "static UPNP_INLINE parse_status_t skip_blank_lines(INOUT scanner_t *scanner)\n{\n\tmemptr token;\n\ttoken_type_t tok_type;\n\tparse_status_t status;\n\n\t/* skip ws, crlf */\n\tdo {\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t} while (status == (parse_status_t)PARSE_OK &&\n\t\t (tok_type == (token_type_t)TT_WHITESPACE ||\n\t\t tok_type == (token_type_t)TT_CRLF));\n\tif (status == (parse_status_t)PARSE_OK) {\n\t\t/* pushback a non-whitespace token */\n\t\tscanner->cursor -= token.length;\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scanner_get_token",
          "args": [
            "scanner",
            "&token",
            "&tok_type"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "scanner_get_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "219-326",
          "snippet": "static parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TOKCHAR_LF\t\t0xA",
            "#define TOKCHAR_CR\t\t0xD"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE parse_status_t skip_blank_lines(INOUT scanner_t *scanner)\n{\n\tmemptr token;\n\ttoken_type_t tok_type;\n\tparse_status_t status;\n\n\t/* skip ws, crlf */\n\tdo {\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t} while (status == (parse_status_t)PARSE_OK &&\n\t\t (tok_type == (token_type_t)TT_WHITESPACE ||\n\t\t tok_type == (token_type_t)TT_CRLF));\n\tif (status == (parse_status_t)PARSE_OK) {\n\t\t/* pushback a non-whitespace token */\n\t\tscanner->cursor -= token.length;\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "httpmsg_find_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "489-510",
    "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListFind",
          "args": [
            "&msg->headers",
            "NULL",
            "&header"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
  },
  {
    "function_name": "httpmsg_find_hdr_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "452-472",
    "snippet": "http_header_t *httpmsg_find_hdr_str(\n\tIN http_message_t *msg,\n\tIN const char *header_name)\n{\n    http_header_t *header;\n\n    ListNode *node;\n\n    node = ListHead( &msg->headers );\n    while( node != NULL ) {\n\n        header = ( http_header_t * ) node->item;\n\n        if( memptr_cmp_nocase( &header->name, header_name ) == 0 ) {\n            return header;\n        }\n\n        node = ListNext( &msg->headers, node );\n    }\n    return NULL;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListNext",
          "args": [
            "&msg->headers",
            "node"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memptr_cmp_nocase",
          "args": [
            "&header->name",
            "header_name"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "memptr_cmp_nocase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "78-90",
          "snippet": "int memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListHead",
          "args": [
            "&msg->headers"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr_str(\n\tIN http_message_t *msg,\n\tIN const char *header_name)\n{\n    http_header_t *header;\n\n    ListNode *node;\n\n    node = ListHead( &msg->headers );\n    while( node != NULL ) {\n\n        header = ( http_header_t * ) node->item;\n\n        if( memptr_cmp_nocase( &header->name, header_name ) == 0 ) {\n            return header;\n        }\n\n        node = ListNext( &msg->headers, node );\n    }\n    return NULL;\n}"
  },
  {
    "function_name": "httpmsg_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "424-435",
    "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg->urlbuf"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&msg->status_msg"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListDestroy",
          "args": [
            "&msg->headers",
            "1"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "msg != NULL"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
  },
  {
    "function_name": "httpmsg_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "402-410",
    "snippet": "void httpmsg_init(INOUT http_message_t *msg)\n{\n    msg->initialized = 1;\n    msg->entity.buf = NULL;\n    msg->entity.length = ( size_t ) 0;\n    ListInit( &msg->headers, httpmsg_compare, httpheader_free );\n    membuffer_init( &msg->msg );\n    membuffer_init( &msg->status_msg );\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&msg->status_msg"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListInit",
          "args": [
            "&msg->headers",
            "httpmsg_compare",
            "httpheader_free"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_init(INOUT http_message_t *msg)\n{\n    msg->initialized = 1;\n    msg->entity.buf = NULL;\n    msg->entity.length = ( size_t ) 0;\n    ListInit( &msg->headers, httpmsg_compare, httpheader_free );\n    membuffer_init( &msg->msg );\n    membuffer_init( &msg->status_msg );\n}"
  },
  {
    "function_name": "httpheader_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "381-388",
    "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "hdr"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&hdr->value"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
  },
  {
    "function_name": "httpmsg_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "359-367",
    "snippet": "static int httpmsg_compare(void *param1, void *param2)\n{\n    assert( param1 != NULL );\n    assert( param2 != NULL );\n\n    return\n\t    ((http_header_t *)param1)->name_id ==\n\t    ((http_header_t *)param2)->name_id;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "param2 != NULL"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "param1 != NULL"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic int httpmsg_compare(void *param1, void *param2)\n{\n    assert( param1 != NULL );\n    assert( param2 != NULL );\n\n    return\n\t    ((http_header_t *)param1)->name_id ==\n\t    ((http_header_t *)param2)->name_id;\n}"
  },
  {
    "function_name": "scanner_get_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "340-343",
    "snippet": "static UPNP_INLINE char *scanner_get_str(IN scanner_t * scanner)\n{\n\treturn scanner->msg->buf + scanner->cursor;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE char *scanner_get_str(IN scanner_t * scanner)\n{\n\treturn scanner->msg->buf + scanner->cursor;\n}"
  },
  {
    "function_name": "scanner_get_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "219-326",
    "snippet": "static parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define TOKCHAR_LF\t\t0xA",
      "#define TOKCHAR_CR\t\t0xD"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_control_char",
          "args": [
            "c"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "is_control_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "174-177",
          "snippet": "static UPNP_INLINE int is_control_char(IN int c)\n{\n    return (c >= 0 && c <= 31) || c == 127;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int is_control_char(IN int c)\n{\n    return (c >= 0 && c <= 31) || c == 127;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_separator_char",
          "args": [
            "c"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "is_separator_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "146-149",
          "snippet": "static UPNP_INLINE int is_separator_char(IN int c)\n{\n\treturn strchr(\" \\t()<>@,;:\\\\\\\"/[]?={}\", c) != 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int is_separator_char(IN int c)\n{\n\treturn strchr(\" \\t()<>@,;:\\\\\\\"/[]?={}\", c) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cursor == null_terminator"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_qdtext_char",
          "args": [
            "c"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "is_qdtext_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "188-199",
          "snippet": "static UPNP_INLINE int is_qdtext_char(IN int c)\n{\n\t/* we don't check for this; it's checked in get_token() */\n\tassert( c != '\"' );\n\n\treturn\n\t\t(c >= 32 && c != 127) ||\n\t\tc < 0 ||\n\t\tc == TOKCHAR_CR ||\n\t\tc == TOKCHAR_LF ||\n\t\tc == '\\t';\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define TOKCHAR_LF\t\t0xA",
            "#define TOKCHAR_CR\t\t0xD"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic UPNP_INLINE int is_qdtext_char(IN int c)\n{\n\t/* we don't check for this; it's checked in get_token() */\n\tassert( c != '\"' );\n\n\treturn\n\t\t(c >= 32 && c != 127) ||\n\t\tc < 0 ||\n\t\tc == TOKCHAR_CR ||\n\t\tc == TOKCHAR_LF ||\n\t\tc == '\\t';\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_identifier_char",
          "args": [
            "*cursor"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "is_identifier_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "160-163",
          "snippet": "static UPNP_INLINE int is_identifier_char(IN int c)\n{\n    return c >= 32 && c <= 126 && !is_separator_char(c);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int is_identifier_char(IN int c)\n{\n    return c >= 32 && c <= 126 && !is_separator_char(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tok_type"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "token"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "scanner"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic parse_status_t scanner_get_token(\n\tINOUT scanner_t *scanner,\n\tOUT memptr *token,\n\tOUT token_type_t *tok_type)\n{\n\tchar *cursor;\n\tchar *null_terminator;\t/* point to null-terminator in buffer */\n\tint c;\n\ttoken_type_t token_type;\n\tint got_end_quote;\n\n\tassert(scanner);\n\tassert(token);\n\tassert(tok_type);\n\n\t/* point to next char in buffer */\n\tcursor = scanner->msg->buf + scanner->cursor;\n\tnull_terminator = scanner->msg->buf + scanner->msg->length;\n\t/* not enough chars in input to parse */\n\tif (cursor == null_terminator)\n\t\treturn PARSE_INCOMPLETE;\n\tc = *cursor;\n\tif (is_identifier_char(c)) {\n\t\t/* scan identifier */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_IDENTIFIER;\n\t\twhile (cursor < null_terminator && is_identifier_char(*cursor))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more valid chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t/* calc token length */\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == ' ' || c == '\\t') {\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_WHITESPACE;\n\t\twhile (cursor < null_terminator && (*cursor == ' ' || *cursor == '\\t'))\n\t\t\tcursor++;\n\t\tif (!scanner->entire_msg_loaded && cursor == null_terminator)\n\t\t\t/* possibly more chars */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t} else if (c == TOKCHAR_CR) {\n\t\t/* scan CRLF */\n\t\ttoken->buf = cursor++;\n\t\tif (cursor == null_terminator)\n\t\t\t/* not enuf info to determine CRLF */\n\t\t\treturn PARSE_INCOMPLETE;\n\t\tif (*cursor != TOKCHAR_LF) {\n\t\t\t/* couldn't match CRLF; match as CR */\n\t\t\ttoken_type = TT_CTRL;\t/* ctrl char */\n\t\t\ttoken->length = (size_t)1;\n\t\t} else {\n\t\t\t/* got CRLF */\n\t\t\ttoken->length = (size_t)2;\n\t\t\ttoken_type = TT_CRLF;\n\t\t\tcursor++;\n\t\t}\n\t} else if (c == TOKCHAR_LF) {\t/* accept \\n as CRLF */\n\t\ttoken->buf = cursor++;\n\t\ttoken->length = (size_t)1;\n\t\ttoken_type = TT_CRLF;\n\t} else if (c == '\"') {\n\t\t/* quoted text */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_QUOTEDSTRING;\n\t\tgot_end_quote = FALSE;\n\t\twhile (cursor < null_terminator) {\n\t\t\tc = *cursor++;\n\t\t\tif (c == '\"') {\n\t\t\t\tgot_end_quote = TRUE;\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tif (cursor < null_terminator) {\n\t\t\t\t\tc = *cursor++;\n\t\t\t\t\t/* the char after '\\\\' could be ANY octet */\n\t\t\t\t}\n\t\t\t\t/* else, while loop handles incomplete buf */\n\t\t\t} else if (is_qdtext_char(c)) {\n\t\t\t\t/* just accept char */\n\t\t\t} else\n\t\t\t\t/* bad quoted text */\n\t\t\t\treturn PARSE_FAILURE;\n\t\t}\n\t\tif (got_end_quote)\n\t\t\ttoken->length = (size_t)cursor - (size_t)token->buf;\n\t\telse {\t/* incomplete */\n\n\t\t\tassert(cursor == null_terminator);\n\t\t\treturn PARSE_INCOMPLETE;\n\t\t}\n\t} else if (is_separator_char(c)) {\n\t\t/* scan separator */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_SEPARATOR;\n\t\ttoken->length = (size_t)1;\n\t} else if (is_control_char(c)) {\n\t\t/* scan ctrl char */\n\t\ttoken->buf = cursor++;\n\t\ttoken_type = TT_CTRL;\n\t\ttoken->length = (size_t)1;\n\t} else\n\t\treturn PARSE_FAILURE;\n\n\tscanner->cursor += token->length;\t/* move to next token */\n\t*tok_type = token_type;\n\treturn PARSE_OK;\n}"
  },
  {
    "function_name": "is_qdtext_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "188-199",
    "snippet": "static UPNP_INLINE int is_qdtext_char(IN int c)\n{\n\t/* we don't check for this; it's checked in get_token() */\n\tassert( c != '\"' );\n\n\treturn\n\t\t(c >= 32 && c != 127) ||\n\t\tc < 0 ||\n\t\tc == TOKCHAR_CR ||\n\t\tc == TOKCHAR_LF ||\n\t\tc == '\\t';\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define TOKCHAR_LF\t\t0xA",
      "#define TOKCHAR_CR\t\t0xD"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "c != '\"'"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define TOKCHAR_LF\t\t0xA\n#define TOKCHAR_CR\t\t0xD\n\nstatic UPNP_INLINE int is_qdtext_char(IN int c)\n{\n\t/* we don't check for this; it's checked in get_token() */\n\tassert( c != '\"' );\n\n\treturn\n\t\t(c >= 32 && c != 127) ||\n\t\tc < 0 ||\n\t\tc == TOKCHAR_CR ||\n\t\tc == TOKCHAR_LF ||\n\t\tc == '\\t';\n}"
  },
  {
    "function_name": "is_control_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "174-177",
    "snippet": "static UPNP_INLINE int is_control_char(IN int c)\n{\n    return (c >= 0 && c <= 31) || c == 127;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int is_control_char(IN int c)\n{\n    return (c >= 0 && c <= 31) || c == 127;\n}"
  },
  {
    "function_name": "is_identifier_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "160-163",
    "snippet": "static UPNP_INLINE int is_identifier_char(IN int c)\n{\n    return c >= 32 && c <= 126 && !is_separator_char(c);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_separator_char",
          "args": [
            "c"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "is_separator_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "146-149",
          "snippet": "static UPNP_INLINE int is_separator_char(IN int c)\n{\n\treturn strchr(\" \\t()<>@,;:\\\\\\\"/[]?={}\", c) != 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int is_separator_char(IN int c)\n{\n\treturn strchr(\" \\t()<>@,;:\\\\\\\"/[]?={}\", c) != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int is_identifier_char(IN int c)\n{\n    return c >= 32 && c <= 126 && !is_separator_char(c);\n}"
  },
  {
    "function_name": "is_separator_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "146-149",
    "snippet": "static UPNP_INLINE int is_separator_char(IN int c)\n{\n\treturn strchr(\" \\t()<>@,;:\\\\\\\"/[]?={}\", c) != 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\" \\t()<>@,;:\\\\\\\"/[]?={}\"",
            "c"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int is_separator_char(IN int c)\n{\n\treturn strchr(\" \\t()<>@,;:\\\\\\\"/[]?={}\", c) != 0;\n}"
  },
  {
    "function_name": "scanner_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
    "lines": "130-135",
    "snippet": "static UPNP_INLINE void scanner_init(OUT scanner_t *scanner, IN membuffer *bufptr)\n{\n\tscanner->cursor = (size_t)0;\n\tscanner->msg = bufptr;\n\tscanner->entire_msg_loaded = FALSE;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include \"upnpdebug.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpparser.h\"",
      "#include \"strintmap.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void scanner_init(OUT scanner_t *scanner, IN membuffer *bufptr)\n{\n\tscanner->cursor = (size_t)0;\n\tscanner->msg = bufptr;\n\tscanner->entire_msg_loaded = FALSE;\n}"
  }
]