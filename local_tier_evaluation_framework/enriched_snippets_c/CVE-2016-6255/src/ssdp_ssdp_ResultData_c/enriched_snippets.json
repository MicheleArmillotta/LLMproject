[
  {
    "function_name": "SSDPResultData_Callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_ResultData.c",
    "lines": "15-21",
    "snippet": "void SSDPResultData_Callback(const SSDPResultData *p)\n{\n\tUpnp_FunPtr callback = SSDPResultData_get_CtrlptCallback(p);\n\tcallback(UPNP_DISCOVERY_SEARCH_RESULT,\n\t\tSSDPResultData_get_Param(p),\n\t\tSSDPResultData_get_Cookie(p));\n}",
    "includes": [
      "#include \"ssdp_ResultData.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "UPNP_DISCOVERY_SEARCH_RESULT",
            "SSDPResultData_get_Param(p)",
            "SSDPResultData_get_Cookie(p)"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "soap_device_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "701-780",
          "snippet": "void soap_device_callback(\n\t/*! [in] Parsed request received by the device. */\n\thttp_parser_t *parser,\n\t/*! [in] HTTP request. */\n\thttp_message_t *request,\n\t/*! [in,out] Socket info. */\n\tSOCKINFO *info)\n{\n\tint err_code;\n\tIXML_Document *xml_doc = NULL;\n\tsoap_devserv_t *soap_info = NULL;\n\tIXML_Node *req_node = NULL;\n\n\t/* get device/service identified by the request-URI */\n\tsoap_info = malloc(sizeof(soap_devserv_t));\n\tif (NULL == soap_info) {\n\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\tgoto error_handler;\n\t}\n\tif (get_dev_service(request,\n\t\t\tinfo->foreign_sockaddr.ss_family, soap_info) < 0) {\n\t\terr_code = HTTP_NOT_FOUND;\n\t\tgoto error_handler;\n\t}\n\t/* validate: content-type == text/xml */\n\tif (!has_xml_content_type(request)) {\n\t\terr_code = HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAPACTION HTTP header */\n\terr_code = check_soapaction_hdr(request, soap_info);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tswitch (err_code) {\n\t\tcase SREQ_NOT_EXTENDED:\n\t\t\terr_code = HTTP_NOT_EXTENDED;\n\t\t\tbreak;\n\t\tcase UPNP_E_OUTOF_MEMORY:\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\t\tbreak;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* parse XML */\n\terr_code = ixmlParseBufferEx(request->entity.buf, &xml_doc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code)\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\telse\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAP body */\n\tif (check_soap_request(soap_info, xml_doc, &req_node) < 0)\n\t{\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* process SOAP request */\n\tif (NULL == soap_info->action_name.buf)\n\t\t/* query var */\n\t\thandle_query_variable(info, request, soap_info, req_node);\n\telse\n\t\t/* invoke action */\n\t\thandle_invoke_action(info, request, soap_info, req_node);\n\n\terr_code = HTTP_OK;\n\nerror_handler:\n\tixmlDocument_free(xml_doc);\n\tfree(soap_info);\n\tif (err_code != HTTP_OK) {\n\t\thttp_SendStatusResponse(info, err_code, request->major_version,\n\t\t\t\trequest->minor_version);\n\t}\n\treturn;\n\tparser = parser;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SREQ_NOT_EXTENDED\t -3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SREQ_NOT_EXTENDED\t -3\n\nvoid soap_device_callback(\n\t/*! [in] Parsed request received by the device. */\n\thttp_parser_t *parser,\n\t/*! [in] HTTP request. */\n\thttp_message_t *request,\n\t/*! [in,out] Socket info. */\n\tSOCKINFO *info)\n{\n\tint err_code;\n\tIXML_Document *xml_doc = NULL;\n\tsoap_devserv_t *soap_info = NULL;\n\tIXML_Node *req_node = NULL;\n\n\t/* get device/service identified by the request-URI */\n\tsoap_info = malloc(sizeof(soap_devserv_t));\n\tif (NULL == soap_info) {\n\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\tgoto error_handler;\n\t}\n\tif (get_dev_service(request,\n\t\t\tinfo->foreign_sockaddr.ss_family, soap_info) < 0) {\n\t\terr_code = HTTP_NOT_FOUND;\n\t\tgoto error_handler;\n\t}\n\t/* validate: content-type == text/xml */\n\tif (!has_xml_content_type(request)) {\n\t\terr_code = HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAPACTION HTTP header */\n\terr_code = check_soapaction_hdr(request, soap_info);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tswitch (err_code) {\n\t\tcase SREQ_NOT_EXTENDED:\n\t\t\terr_code = HTTP_NOT_EXTENDED;\n\t\t\tbreak;\n\t\tcase UPNP_E_OUTOF_MEMORY:\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\t\tbreak;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* parse XML */\n\terr_code = ixmlParseBufferEx(request->entity.buf, &xml_doc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code)\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\telse\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAP body */\n\tif (check_soap_request(soap_info, xml_doc, &req_node) < 0)\n\t{\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* process SOAP request */\n\tif (NULL == soap_info->action_name.buf)\n\t\t/* query var */\n\t\thandle_query_variable(info, request, soap_info, req_node);\n\telse\n\t\t/* invoke action */\n\t\thandle_invoke_action(info, request, soap_info, req_node);\n\n\terr_code = HTTP_OK;\n\nerror_handler:\n\tixmlDocument_free(xml_doc);\n\tfree(soap_info);\n\tif (err_code != HTTP_OK) {\n\t\thttp_SendStatusResponse(info, err_code, request->major_version,\n\t\t\t\trequest->minor_version);\n\t}\n\treturn;\n\tparser = parser;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSDPResultData_get_Cookie",
          "args": [
            "p"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSDPResultData_get_Param",
          "args": [
            "p"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSDPResultData_get_CtrlptCallback",
          "args": [
            "p"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssdp_ResultData.h\"\n#include \"config.h\"\n\nvoid SSDPResultData_Callback(const SSDPResultData *p)\n{\n\tUpnp_FunPtr callback = SSDPResultData_get_CtrlptCallback(p);\n\tcallback(UPNP_DISCOVERY_SEARCH_RESULT,\n\t\tSSDPResultData_get_Param(p),\n\t\tSSDPResultData_get_Cookie(p));\n}"
  }
]