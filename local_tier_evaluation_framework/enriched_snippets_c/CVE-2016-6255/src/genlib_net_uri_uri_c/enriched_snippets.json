[
  {
    "function_name": "parse_uri_and_unescape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "759-775",
    "snippet": "int parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_escaped_chars",
          "args": [
            "(char *)out->fragment.buff",
            "&out->fragment.size"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "remove_escaped_chars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "502-511",
          "snippet": "int remove_escaped_chars(INOUT char *in, INOUT size_t *size)\n{\n\tsize_t i = (size_t)0;\n\n\tfor (i = (size_t)0; i < *size; i++) {\n\t\treplace_escaped(in, i, size);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint remove_escaped_chars(INOUT char *in, INOUT size_t *size)\n{\n\tsize_t i = (size_t)0;\n\n\tfor (i = (size_t)0; i < *size; i++) {\n\t\treplace_escaped(in, i, size);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_uri",
          "args": [
            "in",
            "max",
            "out"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uri_and_unescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "759-775",
          "snippet": "int parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}"
  },
  {
    "function_name": "parse_uri",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "707-757",
    "snippet": "int parse_uri(const char *in, size_t max, uri_type *out)\n{\n\tint begin_path = 0;\n\tsize_t begin_hostport = (size_t)0;\n\tsize_t begin_fragment = (size_t)0;\n\tunsigned short int defaultPort = 80;\n\n\tbegin_hostport = parse_scheme(in, max, &out->scheme);\n\tif (begin_hostport) {\n\t\tout->type = ABSOLUTE;\n\t\tout->path_type = OPAQUE_PART;\n\t\tbegin_hostport++;\n\t} else {\n\t\tout->type = RELATIVE;\n\t\tout->path_type = REL_PATH;\n\t}\n\tif (begin_hostport + (size_t)1 < max &&\n\t    in[begin_hostport] == '/' &&\n\t    in[begin_hostport + (size_t)1] == '/') {\n\t\tbegin_hostport += (size_t)2;\n\t\tif (token_string_casecmp(&out->scheme, \"https\") == 0) {\n\t\t\tdefaultPort = 443;\n\t\t}\n\t\tbegin_path = parse_hostport(&in[begin_hostport],\n\t\t\tdefaultPort,\n\t\t\t&out->hostport);\n\t\tif (begin_path >= 0) {\n\t\t\tbegin_path += (int)begin_hostport;\n\t\t} else\n\t\t\treturn begin_path;\n\t} else {\n\t\tmemset(&out->hostport, 0, sizeof(out->hostport));\n\t\tbegin_path = (int)begin_hostport;\n\t}\n\tbegin_fragment = parse_uric(&in[begin_path],\n\t\tmax - (size_t)begin_path,\n\t\t&out->pathquery) + (size_t)begin_path;\n\tif (out->pathquery.size && out->pathquery.buff[0] == '/') {\n\t\tout->path_type = ABS_PATH;\n\t}\n\tif (begin_fragment < max && in[begin_fragment] == '#') {\n\t\tbegin_fragment++;\n\t\tparse_uric(&in[begin_fragment], max - begin_fragment,\n\t\t\t   &out->fragment);\n\t} else {\n\t\tout->fragment.buff = NULL;\n\t\tout->fragment.size = (size_t)0;\n\t}\n\n\treturn HTTP_SUCCESS;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_uric",
          "args": [
            "&in[begin_fragment]",
            "max - begin_fragment",
            "&out->fragment"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uric",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "171-191",
          "snippet": "static size_t parse_uric(\n\t/*! [in] String of characters. */\n\tconst char *in,\n\t/*! [in] Maximum limit. */\n\tsize_t max,\n\t/*! [out] Token object where the string of characters is copied. */\n\ttoken *out)\n{\n\tsize_t i = (size_t)0;\n\n\twhile (i < max &&\n\t       (is_unreserved(in[i]) ||\n\t        is_reserved(in[i])   ||\n\t        ((i + (size_t)2 < max) && is_escaped(&in[i])))) {\n\t\ti++;\n\t}\n\n\tout->size = i;\n\tout->buff = in;\n\treturn i;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic size_t parse_uric(\n\t/*! [in] String of characters. */\n\tconst char *in,\n\t/*! [in] Maximum limit. */\n\tsize_t max,\n\t/*! [out] Token object where the string of characters is copied. */\n\ttoken *out)\n{\n\tsize_t i = (size_t)0;\n\n\twhile (i < max &&\n\t       (is_unreserved(in[i]) ||\n\t        is_reserved(in[i])   ||\n\t        ((i + (size_t)2 < max) && is_escaped(&in[i])))) {\n\t\ti++;\n\t}\n\n\tout->size = i;\n\tout->buff = in;\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&out->hostport",
            "0",
            "sizeof(out->hostport)"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_hostport",
          "args": [
            "&in[begin_hostport]",
            "defaultPort",
            "&out->hostport"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "parse_hostport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "323-457",
          "snippet": "static int parse_hostport(\n\t/*! [in] String of characters representing host and port. */\n\tconst char *in,\n\t/*! [out] Output parameter where the host and port are represented as\n\t * an internet address. */\n\tunsigned short int defaultPort,\n\thostport_type *out)\n{\n\tchar workbuf[256];\n\tchar *c;\n\tstruct sockaddr_in *sai4 = (struct sockaddr_in *)&out->IPaddress;\n\tstruct sockaddr_in6 *sai6 = (struct sockaddr_in6 *)&out->IPaddress;\n\tchar *srvname = NULL;\n\tchar *srvport = NULL;\n\tchar *last_dot = NULL;\n\tunsigned short int port;\n\tint af = AF_UNSPEC;\n\tsize_t hostport_size;\n\tint has_port = 0;\n\tint ret;\n\n\tmemset(out, 0, sizeof(hostport_type));\n\tmemset(workbuf, 0, sizeof(workbuf));\n\t/* Work on a copy of the input string. */\n\tstrncpy(workbuf, in, sizeof(workbuf) - 1);\n\tc = workbuf;\n\tif (*c == '[') {\n\t\t/* IPv6 addresses are enclosed in square brackets. */\n\t\tsrvname = ++c;\n\t\twhile (*c != '\\0' && *c != ']')\n\t\t\tc++;\n\t\tif (*c == '\\0')\n\t\t\t/* did not find closing bracket. */\n\t\t\treturn UPNP_E_INVALID_URL;\n\t\t/* NULL terminate the srvname and then increment c. */\n\t\t*c++ = '\\0';\t/* overwrite the ']' */\n\t\tif (*c == ':') {\n\t\t\thas_port = 1;\n\t\t\tc++;\n\t\t}\n\t\taf = AF_INET6;\n\t} else {\n\t\t/* IPv4 address -OR- host name. */\n\t\tsrvname = c;\n\t\twhile (*c != ':' && *c != '/' &&\n\t\t       (isalnum(*c) || *c == '.' || *c == '-')) {\n\t\t\tif (*c == '.')\n\t\t\t\tlast_dot = c;\n\t\t\tc++;\n\t\t}\n\t\thas_port = (*c == ':') ? 1 : 0;\n\t\t/* NULL terminate the srvname */\n\t\t*c = '\\0';\n\t\tif (has_port == 1)\n\t\t\tc++;\n\t\tif (last_dot != NULL && isdigit(*(last_dot + 1)))\n\t\t\t/* Must be an IPv4 address. */\n\t\t\taf = AF_INET;\n\t\telse {\n\t\t\t/* Must be a host name. */\n\t\t\tstruct addrinfo hints, *res, *res0;\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\thints.ai_family = AF_UNSPEC;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n\n\t\t\tret = getaddrinfo(srvname, NULL, &hints, &res0);\n\t\t\tif (ret == 0) {\n\t\t\t\tfor (res = res0; res; res = res->ai_next) {\n\t\t\t\t\tswitch (res->ai_family) {\n\t\t\t\t\tcase AF_INET:\n\t\t\t\t\tcase AF_INET6:\n\t\t\t\t\t\t/* Found a valid IPv4 or IPv6 address. */\n\t\t\t\t\t\tmemcpy(&out->IPaddress,\n\t\t\t\t\t\t       res->ai_addr,\n\t\t\t\t\t\t       res->ai_addrlen);\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\t\t\t\t}\nfound:\n\t\t\t\tfreeaddrinfo(res0);\n\t\t\t\tif (res == NULL)\n\t\t\t\t\t/* Didn't find an AF_INET or AF_INET6 address. */\n\t\t\t\t\treturn UPNP_E_INVALID_URL;\n\t\t\t} else\n\t\t\t\t/* getaddrinfo failed. */\n\t\t\t\treturn UPNP_E_INVALID_URL;\n\t\t}\n\t}\n\t/* Check if a port is specified. */\n\tif (has_port == 1) {\n\t\t/* Port is specified. */\n\t\tsrvport = c;\n\t\twhile (*c != '\\0' && isdigit(*c))\n\t\t\tc++;\n\t\tport = (unsigned short int)atoi(srvport);\n\t\tif (port == 0)\n\t\t\t/* Bad port number. */\n\t\t\treturn UPNP_E_INVALID_URL;\n\t} else\n\t\t/* Port was not specified, use default port. */\n\t\tport = defaultPort;\n\t/* The length of the host and port string can be calculated by */\n\t/* subtracting pointers. */\n\thostport_size = (size_t)c - (size_t)workbuf;\n\t/* Fill in the 'out' information. */\n\tswitch (af) {\n\tcase AF_INET:\n\t\tsai4->sin_family = (sa_family_t)af;\n\t\tsai4->sin_port = htons(port);\n\t\tret = inet_pton(AF_INET, srvname, &sai4->sin_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsai6->sin6_family = (sa_family_t)af;\n\t\tsai6->sin6_port = htons(port);\n\t\tsai6->sin6_scope_id = gIF_INDEX;\n\t\tret = inet_pton(AF_INET6, srvname, &sai6->sin6_addr);\n\t\tbreak;\n\tdefault:\n\t\t/* IP address was set by the hostname (getaddrinfo). */\n\t\t/* Override port: */\n\t\tif (out->IPaddress.ss_family == (sa_family_t)AF_INET)\n\t\t\tsai4->sin_port = htons(port);\n\t\telse\n\t\t\tsai6->sin6_port = htons(port);\n\t\tret = 1;\n\t}\n\t/* Check if address was converted successfully. */\n\tif (ret <= 0)\n\t\treturn UPNP_E_INVALID_URL;\n\tout->text.size = hostport_size;\n\tout->text.buff = in;\n\n\treturn (int)hostport_size;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic int parse_hostport(\n\t/*! [in] String of characters representing host and port. */\n\tconst char *in,\n\t/*! [out] Output parameter where the host and port are represented as\n\t * an internet address. */\n\tunsigned short int defaultPort,\n\thostport_type *out)\n{\n\tchar workbuf[256];\n\tchar *c;\n\tstruct sockaddr_in *sai4 = (struct sockaddr_in *)&out->IPaddress;\n\tstruct sockaddr_in6 *sai6 = (struct sockaddr_in6 *)&out->IPaddress;\n\tchar *srvname = NULL;\n\tchar *srvport = NULL;\n\tchar *last_dot = NULL;\n\tunsigned short int port;\n\tint af = AF_UNSPEC;\n\tsize_t hostport_size;\n\tint has_port = 0;\n\tint ret;\n\n\tmemset(out, 0, sizeof(hostport_type));\n\tmemset(workbuf, 0, sizeof(workbuf));\n\t/* Work on a copy of the input string. */\n\tstrncpy(workbuf, in, sizeof(workbuf) - 1);\n\tc = workbuf;\n\tif (*c == '[') {\n\t\t/* IPv6 addresses are enclosed in square brackets. */\n\t\tsrvname = ++c;\n\t\twhile (*c != '\\0' && *c != ']')\n\t\t\tc++;\n\t\tif (*c == '\\0')\n\t\t\t/* did not find closing bracket. */\n\t\t\treturn UPNP_E_INVALID_URL;\n\t\t/* NULL terminate the srvname and then increment c. */\n\t\t*c++ = '\\0';\t/* overwrite the ']' */\n\t\tif (*c == ':') {\n\t\t\thas_port = 1;\n\t\t\tc++;\n\t\t}\n\t\taf = AF_INET6;\n\t} else {\n\t\t/* IPv4 address -OR- host name. */\n\t\tsrvname = c;\n\t\twhile (*c != ':' && *c != '/' &&\n\t\t       (isalnum(*c) || *c == '.' || *c == '-')) {\n\t\t\tif (*c == '.')\n\t\t\t\tlast_dot = c;\n\t\t\tc++;\n\t\t}\n\t\thas_port = (*c == ':') ? 1 : 0;\n\t\t/* NULL terminate the srvname */\n\t\t*c = '\\0';\n\t\tif (has_port == 1)\n\t\t\tc++;\n\t\tif (last_dot != NULL && isdigit(*(last_dot + 1)))\n\t\t\t/* Must be an IPv4 address. */\n\t\t\taf = AF_INET;\n\t\telse {\n\t\t\t/* Must be a host name. */\n\t\t\tstruct addrinfo hints, *res, *res0;\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\thints.ai_family = AF_UNSPEC;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n\n\t\t\tret = getaddrinfo(srvname, NULL, &hints, &res0);\n\t\t\tif (ret == 0) {\n\t\t\t\tfor (res = res0; res; res = res->ai_next) {\n\t\t\t\t\tswitch (res->ai_family) {\n\t\t\t\t\tcase AF_INET:\n\t\t\t\t\tcase AF_INET6:\n\t\t\t\t\t\t/* Found a valid IPv4 or IPv6 address. */\n\t\t\t\t\t\tmemcpy(&out->IPaddress,\n\t\t\t\t\t\t       res->ai_addr,\n\t\t\t\t\t\t       res->ai_addrlen);\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\t\t\t\t}\nfound:\n\t\t\t\tfreeaddrinfo(res0);\n\t\t\t\tif (res == NULL)\n\t\t\t\t\t/* Didn't find an AF_INET or AF_INET6 address. */\n\t\t\t\t\treturn UPNP_E_INVALID_URL;\n\t\t\t} else\n\t\t\t\t/* getaddrinfo failed. */\n\t\t\t\treturn UPNP_E_INVALID_URL;\n\t\t}\n\t}\n\t/* Check if a port is specified. */\n\tif (has_port == 1) {\n\t\t/* Port is specified. */\n\t\tsrvport = c;\n\t\twhile (*c != '\\0' && isdigit(*c))\n\t\t\tc++;\n\t\tport = (unsigned short int)atoi(srvport);\n\t\tif (port == 0)\n\t\t\t/* Bad port number. */\n\t\t\treturn UPNP_E_INVALID_URL;\n\t} else\n\t\t/* Port was not specified, use default port. */\n\t\tport = defaultPort;\n\t/* The length of the host and port string can be calculated by */\n\t/* subtracting pointers. */\n\thostport_size = (size_t)c - (size_t)workbuf;\n\t/* Fill in the 'out' information. */\n\tswitch (af) {\n\tcase AF_INET:\n\t\tsai4->sin_family = (sa_family_t)af;\n\t\tsai4->sin_port = htons(port);\n\t\tret = inet_pton(AF_INET, srvname, &sai4->sin_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsai6->sin6_family = (sa_family_t)af;\n\t\tsai6->sin6_port = htons(port);\n\t\tsai6->sin6_scope_id = gIF_INDEX;\n\t\tret = inet_pton(AF_INET6, srvname, &sai6->sin6_addr);\n\t\tbreak;\n\tdefault:\n\t\t/* IP address was set by the hostname (getaddrinfo). */\n\t\t/* Override port: */\n\t\tif (out->IPaddress.ss_family == (sa_family_t)AF_INET)\n\t\t\tsai4->sin_port = htons(port);\n\t\telse\n\t\t\tsai6->sin6_port = htons(port);\n\t\tret = 1;\n\t}\n\t/* Check if address was converted successfully. */\n\tif (ret <= 0)\n\t\treturn UPNP_E_INVALID_URL;\n\tout->text.size = hostport_size;\n\tout->text.buff = in;\n\n\treturn (int)hostport_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "token_string_casecmp",
          "args": [
            "&out->scheme",
            "\"https\""
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "token_string_casecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "289-296",
          "snippet": "int token_string_casecmp(token *in1, const char *in2)\n{\n\tsize_t in2_length = strlen(in2);\n\tif (in1->size != in2_length)\n\t\treturn 1;\n\telse\n\t\treturn strncasecmp(in1->buff, in2, in1->size);\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint token_string_casecmp(token *in1, const char *in2)\n{\n\tsize_t in2_length = strlen(in2);\n\tif (in1->size != in2_length)\n\t\treturn 1;\n\telse\n\t\treturn strncasecmp(in1->buff, in2, in1->size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_scheme",
          "args": [
            "in",
            "max",
            "&out->scheme"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "parse_scheme",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "469-499",
          "snippet": "static size_t parse_scheme(\n\t/*! [in] String of characters representing a scheme. */\n\tconst char *in,\n\t/*! [in] Maximum number of characters. */\n\tsize_t max,\n\t/*! [out] Output parameter whose buffer is filled in with the scheme. */\n\ttoken *out)\n{\n    size_t i = (size_t)0;\n\n    out->size = (size_t)0;\n    out->buff = NULL;\n\n    if( ( max == (size_t)0 ) || ( !isalpha( in[0] ) ) )\n        return (size_t)0;\n\n    i++;\n    while( ( i < max ) && ( in[i] != ':' ) ) {\n        if( !( isalnum( in[i] ) || ( in[i] == '+' ) || ( in[i] == '-' )\n               || ( in[i] == '.' ) ) )\n            return (size_t)0;\n        i++;\n    }\n    if( i < max ) {\n        out->size = i;\n        out->buff = &in[0];\n        return i;\n    }\n\n    return (size_t)0;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic size_t parse_scheme(\n\t/*! [in] String of characters representing a scheme. */\n\tconst char *in,\n\t/*! [in] Maximum number of characters. */\n\tsize_t max,\n\t/*! [out] Output parameter whose buffer is filled in with the scheme. */\n\ttoken *out)\n{\n    size_t i = (size_t)0;\n\n    out->size = (size_t)0;\n    out->buff = NULL;\n\n    if( ( max == (size_t)0 ) || ( !isalpha( in[0] ) ) )\n        return (size_t)0;\n\n    i++;\n    while( ( i < max ) && ( in[i] != ':' ) ) {\n        if( !( isalnum( in[i] ) || ( in[i] == '+' ) || ( in[i] == '-' )\n               || ( in[i] == '.' ) ) )\n            return (size_t)0;\n        i++;\n    }\n    if( i < max ) {\n        out->size = i;\n        out->buff = &in[0];\n        return i;\n    }\n\n    return (size_t)0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint parse_uri(const char *in, size_t max, uri_type *out)\n{\n\tint begin_path = 0;\n\tsize_t begin_hostport = (size_t)0;\n\tsize_t begin_fragment = (size_t)0;\n\tunsigned short int defaultPort = 80;\n\n\tbegin_hostport = parse_scheme(in, max, &out->scheme);\n\tif (begin_hostport) {\n\t\tout->type = ABSOLUTE;\n\t\tout->path_type = OPAQUE_PART;\n\t\tbegin_hostport++;\n\t} else {\n\t\tout->type = RELATIVE;\n\t\tout->path_type = REL_PATH;\n\t}\n\tif (begin_hostport + (size_t)1 < max &&\n\t    in[begin_hostport] == '/' &&\n\t    in[begin_hostport + (size_t)1] == '/') {\n\t\tbegin_hostport += (size_t)2;\n\t\tif (token_string_casecmp(&out->scheme, \"https\") == 0) {\n\t\t\tdefaultPort = 443;\n\t\t}\n\t\tbegin_path = parse_hostport(&in[begin_hostport],\n\t\t\tdefaultPort,\n\t\t\t&out->hostport);\n\t\tif (begin_path >= 0) {\n\t\t\tbegin_path += (int)begin_hostport;\n\t\t} else\n\t\t\treturn begin_path;\n\t} else {\n\t\tmemset(&out->hostport, 0, sizeof(out->hostport));\n\t\tbegin_path = (int)begin_hostport;\n\t}\n\tbegin_fragment = parse_uric(&in[begin_path],\n\t\tmax - (size_t)begin_path,\n\t\t&out->pathquery) + (size_t)begin_path;\n\tif (out->pathquery.size && out->pathquery.buff[0] == '/') {\n\t\tout->path_type = ABS_PATH;\n\t}\n\tif (begin_fragment < max && in[begin_fragment] == '#') {\n\t\tbegin_fragment++;\n\t\tparse_uric(&in[begin_fragment], max - begin_fragment,\n\t\t\t   &out->fragment);\n\t} else {\n\t\tout->fragment.buff = NULL;\n\t\tout->fragment.size = (size_t)0;\n\t}\n\n\treturn HTTP_SUCCESS;\n}"
  },
  {
    "function_name": "resolve_rel_url",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "593-704",
    "snippet": "char *resolve_rel_url(char *base_url, char *rel_url)\n{\n    uri_type base;\n    uri_type rel;\n    int rv;\n\n    if (!base_url) {\n        if (!rel_url)\n            return NULL;\n        return strdup(rel_url);\n    }\n\n    size_t len_rel = strlen(rel_url);\n    if (parse_uri(rel_url, len_rel, &rel) != HTTP_SUCCESS)\n        return NULL;\n    if (rel.type == (enum uriType)ABSOLUTE)\n        return strdup(rel_url);\n\n    size_t len_base = strlen(base_url);\n    if ((parse_uri(base_url, len_base, &base) != HTTP_SUCCESS)\n            || (base.type != (enum uriType)ABSOLUTE))\n        return NULL;\n    if (len_rel == (size_t)0)\n        return strdup(base_url);\n\n    size_t len = len_base + len_rel + (size_t)2;\n    char *out = (char *)malloc(len);\n    if (out == NULL)\n        return NULL;\n    memset(out, 0, len);\n    char *out_finger = out;\n\n    /* scheme */\n    rv = snprintf(out_finger, len, \"%.*s:\", (int)base.scheme.size, base.scheme.buff);\n    if (rv < 0 || rv >= len)\n        goto error;\n    out_finger += rv;\n    len -= rv;\n\n    /* authority */\n    if (rel.hostport.text.size > (size_t)0) {\n        rv = snprintf(out_finger, len, \"%s\", rel_url);\n        if (rv < 0 || rv >= len)\n            goto error;\n        return out;\n    }\n    if (base.hostport.text.size > (size_t)0) {\n\trv = snprintf(out_finger, len, \"//%.*s\", (int)base.hostport.text.size, base.hostport.text.buff);\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n    }\n\n    /* path */\n    char *path = out_finger;\n    if (rel.path_type == (enum pathType)ABS_PATH) {\n\trv = snprintf(out_finger, len, \"%s\", rel_url);\n    } else if (base.pathquery.size == (size_t)0) {\n\trv = snprintf(out_finger, len, \"/%s\", rel_url);\n    } else {\n\tif (rel.pathquery.size == (size_t)0) {\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)base.pathquery.size, base.pathquery.buff);\n\t} else {\n\t    if (len < base.pathquery.size)\n\t\tgoto error;\n\t    size_t i = (size_t)0, prefix = (size_t)1;\n\t    while (i < base.pathquery.size) {\n\t\tout_finger[i] = base.pathquery.buff[i];\n\t\tswitch (base.pathquery.buff[i++]) {\n\t\t    case '/':\n\t\t\tprefix = i;\n\t\t\t/* fall-through */\n\t\t    default:\n\t\t\tcontinue;\n\t\t    case '?': /* query */\n\t\t\tif (rel.pathquery.buff[0] == '?')\n\t\t\t    prefix = --i;\n\t\t}\n\t\tbreak;\n\t    }\n\t    out_finger += prefix;\n\t    len -= prefix;\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)rel.pathquery.size, rel.pathquery.buff);\n\t}\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n\n\t/* fragment */\n\tif (rel.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)rel.fragment.size, rel.fragment.buff);\n\telse if (base.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)base.fragment.size, base.fragment.buff);\n\telse\n\t    rv = 0;\n    }\n    if (rv < 0 || rv >= len)\n\tgoto error;\n    out_finger += rv;\n    len -= rv;\n\n    if (remove_dots(path, out_finger - path) != UPNP_E_SUCCESS)\n\tgoto error;\n\n    return out;\n\nerror:\n    free(out);\n    return NULL;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "out"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "free_URL_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "252-261",
          "snippet": "void free_URL_list(URL_list *list)\n{\n\tif (list->URLs) {\n\t\tfree(list->URLs);\n\t}\n\tif (list->parsedURLs) {\n\t\tfree(list->parsedURLs);\n\t}\n\tlist->size = (size_t)0;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nvoid free_URL_list(URL_list *list)\n{\n\tif (list->URLs) {\n\t\tfree(list->URLs);\n\t}\n\tif (list->parsedURLs) {\n\t\tfree(list->parsedURLs);\n\t}\n\tlist->size = (size_t)0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_dots",
          "args": [
            "path",
            "out_finger - path"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "remove_dots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "527-590",
          "snippet": "int remove_dots(char *buf, size_t size)\n{\n    char *in = buf;\n    char *out = buf;\n    char *max = buf + size;\n\n    while (!is_end_path(in[0])) {\n\tassert (buf <= out);\n\tassert (out <= in);\n\tassert (in < max);\n\n        /* case 2.A: */\n        if (strncmp(in, \"./\", 2) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"../\", 3) == 0) {\n            in += 3;\n        /* case 2.B: */\n        } else if (strncmp(in, \"/./\", 3) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"/.\", 2) == 0 && is_end_path(in[2])) {\n            in += 1;\n\t    in[0] = '/';\n        /* case 2.C: */\n        } else if (strncmp(in, \"/../\", 4) == 0 || (strncmp(in, \"/..\", 3) == 0 && is_end_path(in[3]))) {\n            /* Make the next character in the input buffer a '/': */\n            if (is_end_path(in[3])) { /* terminating \"/..\" case */\n                in += 2;\n                in[0] = '/';\n            } else { /* \"/../\" prefix case */\n                in += 3;\n            }\n            /* Trim the last component from the output buffer, or empty it. */\n            while (buf < out)\n\t\tif (*--out == '/')\n\t\t    break;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        /* case 2.D: */\n        } else if (strncmp(in, \".\", 1) == 0 && is_end_path(in[1])) {\n            in += 1;\n\t} else if (strncmp(in, \"..\", 2) == 0 && is_end_path(in[2])) {\n            in += 2;\n        /* case 2.E */\n        } else {\n            /* move initial '/' character (if any) */\n            if (in[0] == '/')\n\t\t*out++ = *in++;\n\t    /* move first segment up to, but not including, the next '/' character */\n\t    while (in < max && in[0] != '/' && !is_end_path(in[0]))\n\t\t*out++ = *in++;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        }\n    }\n    while (in < max)\n\t*out++ = *in++;\n    if (out < max)\n\tout[0] = '\\0';\n    return UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint remove_dots(char *buf, size_t size)\n{\n    char *in = buf;\n    char *out = buf;\n    char *max = buf + size;\n\n    while (!is_end_path(in[0])) {\n\tassert (buf <= out);\n\tassert (out <= in);\n\tassert (in < max);\n\n        /* case 2.A: */\n        if (strncmp(in, \"./\", 2) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"../\", 3) == 0) {\n            in += 3;\n        /* case 2.B: */\n        } else if (strncmp(in, \"/./\", 3) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"/.\", 2) == 0 && is_end_path(in[2])) {\n            in += 1;\n\t    in[0] = '/';\n        /* case 2.C: */\n        } else if (strncmp(in, \"/../\", 4) == 0 || (strncmp(in, \"/..\", 3) == 0 && is_end_path(in[3]))) {\n            /* Make the next character in the input buffer a '/': */\n            if (is_end_path(in[3])) { /* terminating \"/..\" case */\n                in += 2;\n                in[0] = '/';\n            } else { /* \"/../\" prefix case */\n                in += 3;\n            }\n            /* Trim the last component from the output buffer, or empty it. */\n            while (buf < out)\n\t\tif (*--out == '/')\n\t\t    break;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        /* case 2.D: */\n        } else if (strncmp(in, \".\", 1) == 0 && is_end_path(in[1])) {\n            in += 1;\n\t} else if (strncmp(in, \"..\", 2) == 0 && is_end_path(in[2])) {\n            in += 2;\n        /* case 2.E */\n        } else {\n            /* move initial '/' character (if any) */\n            if (in[0] == '/')\n\t\t*out++ = *in++;\n\t    /* move first segment up to, but not including, the next '/' character */\n\t    while (in < max && in[0] != '/' && !is_end_path(in[0]))\n\t\t*out++ = *in++;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        }\n    }\n    while (in < max)\n\t*out++ = *in++;\n    if (out < max)\n\tout[0] = '\\0';\n    return UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "out_finger",
            "len",
            "\"#%.*s\"",
            "(int)base.fragment.size",
            "base.fragment.buff"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "out_finger",
            "len",
            "\"#%.*s\"",
            "(int)rel.fragment.size",
            "rel.fragment.buff"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "out_finger",
            "len",
            "\"%.*s\"",
            "(int)rel.pathquery.size",
            "rel.pathquery.buff"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "out_finger",
            "len",
            "\"%.*s\"",
            "(int)base.pathquery.size",
            "base.pathquery.buff"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "out_finger",
            "len",
            "\"/%s\"",
            "rel_url"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "out_finger",
            "len",
            "\"%s\"",
            "rel_url"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "out_finger",
            "len",
            "\"//%.*s\"",
            "(int)base.hostport.text.size",
            "base.hostport.text.buff"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "out_finger",
            "len",
            "\"%s\"",
            "rel_url"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "out_finger",
            "len",
            "\"%.*s:\"",
            "(int)base.scheme.size",
            "base.scheme.buff"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "out",
            "0",
            "len"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "base_url"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_uri",
          "args": [
            "base_url",
            "len_base",
            "&base"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uri_and_unescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "759-775",
          "snippet": "int parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "base_url"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "rel_url"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rel_url"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "rel_url"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\n#define snprintf _snprintf\n\nchar *resolve_rel_url(char *base_url, char *rel_url)\n{\n    uri_type base;\n    uri_type rel;\n    int rv;\n\n    if (!base_url) {\n        if (!rel_url)\n            return NULL;\n        return strdup(rel_url);\n    }\n\n    size_t len_rel = strlen(rel_url);\n    if (parse_uri(rel_url, len_rel, &rel) != HTTP_SUCCESS)\n        return NULL;\n    if (rel.type == (enum uriType)ABSOLUTE)\n        return strdup(rel_url);\n\n    size_t len_base = strlen(base_url);\n    if ((parse_uri(base_url, len_base, &base) != HTTP_SUCCESS)\n            || (base.type != (enum uriType)ABSOLUTE))\n        return NULL;\n    if (len_rel == (size_t)0)\n        return strdup(base_url);\n\n    size_t len = len_base + len_rel + (size_t)2;\n    char *out = (char *)malloc(len);\n    if (out == NULL)\n        return NULL;\n    memset(out, 0, len);\n    char *out_finger = out;\n\n    /* scheme */\n    rv = snprintf(out_finger, len, \"%.*s:\", (int)base.scheme.size, base.scheme.buff);\n    if (rv < 0 || rv >= len)\n        goto error;\n    out_finger += rv;\n    len -= rv;\n\n    /* authority */\n    if (rel.hostport.text.size > (size_t)0) {\n        rv = snprintf(out_finger, len, \"%s\", rel_url);\n        if (rv < 0 || rv >= len)\n            goto error;\n        return out;\n    }\n    if (base.hostport.text.size > (size_t)0) {\n\trv = snprintf(out_finger, len, \"//%.*s\", (int)base.hostport.text.size, base.hostport.text.buff);\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n    }\n\n    /* path */\n    char *path = out_finger;\n    if (rel.path_type == (enum pathType)ABS_PATH) {\n\trv = snprintf(out_finger, len, \"%s\", rel_url);\n    } else if (base.pathquery.size == (size_t)0) {\n\trv = snprintf(out_finger, len, \"/%s\", rel_url);\n    } else {\n\tif (rel.pathquery.size == (size_t)0) {\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)base.pathquery.size, base.pathquery.buff);\n\t} else {\n\t    if (len < base.pathquery.size)\n\t\tgoto error;\n\t    size_t i = (size_t)0, prefix = (size_t)1;\n\t    while (i < base.pathquery.size) {\n\t\tout_finger[i] = base.pathquery.buff[i];\n\t\tswitch (base.pathquery.buff[i++]) {\n\t\t    case '/':\n\t\t\tprefix = i;\n\t\t\t/* fall-through */\n\t\t    default:\n\t\t\tcontinue;\n\t\t    case '?': /* query */\n\t\t\tif (rel.pathquery.buff[0] == '?')\n\t\t\t    prefix = --i;\n\t\t}\n\t\tbreak;\n\t    }\n\t    out_finger += prefix;\n\t    len -= prefix;\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)rel.pathquery.size, rel.pathquery.buff);\n\t}\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n\n\t/* fragment */\n\tif (rel.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)rel.fragment.size, rel.fragment.buff);\n\telse if (base.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)base.fragment.size, base.fragment.buff);\n\telse\n\t    rv = 0;\n    }\n    if (rv < 0 || rv >= len)\n\tgoto error;\n    out_finger += rv;\n    len -= rv;\n\n    if (remove_dots(path, out_finger - path) != UPNP_E_SUCCESS)\n\tgoto error;\n\n    return out;\n\nerror:\n    free(out);\n    return NULL;\n}"
  },
  {
    "function_name": "remove_dots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "527-590",
    "snippet": "int remove_dots(char *buf, size_t size)\n{\n    char *in = buf;\n    char *out = buf;\n    char *max = buf + size;\n\n    while (!is_end_path(in[0])) {\n\tassert (buf <= out);\n\tassert (out <= in);\n\tassert (in < max);\n\n        /* case 2.A: */\n        if (strncmp(in, \"./\", 2) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"../\", 3) == 0) {\n            in += 3;\n        /* case 2.B: */\n        } else if (strncmp(in, \"/./\", 3) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"/.\", 2) == 0 && is_end_path(in[2])) {\n            in += 1;\n\t    in[0] = '/';\n        /* case 2.C: */\n        } else if (strncmp(in, \"/../\", 4) == 0 || (strncmp(in, \"/..\", 3) == 0 && is_end_path(in[3]))) {\n            /* Make the next character in the input buffer a '/': */\n            if (is_end_path(in[3])) { /* terminating \"/..\" case */\n                in += 2;\n                in[0] = '/';\n            } else { /* \"/../\" prefix case */\n                in += 3;\n            }\n            /* Trim the last component from the output buffer, or empty it. */\n            while (buf < out)\n\t\tif (*--out == '/')\n\t\t    break;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        /* case 2.D: */\n        } else if (strncmp(in, \".\", 1) == 0 && is_end_path(in[1])) {\n            in += 1;\n\t} else if (strncmp(in, \"..\", 2) == 0 && is_end_path(in[2])) {\n            in += 2;\n        /* case 2.E */\n        } else {\n            /* move initial '/' character (if any) */\n            if (in[0] == '/')\n\t\t*out++ = *in++;\n\t    /* move first segment up to, but not including, the next '/' character */\n\t    while (in < max && in[0] != '/' && !is_end_path(in[0]))\n\t\t*out++ = *in++;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        }\n    }\n    while (in < max)\n\t*out++ = *in++;\n    if (out < max)\n\tout[0] = '\\0';\n    return UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_end_path",
          "args": [
            "in[0]"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "is_end_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "514-522",
          "snippet": "static UPNP_INLINE int is_end_path(char c) {\n    switch (c) {\n\tcase '?':\n\tcase '#':\n\tcase '\\0':\n\t    return 1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic UPNP_INLINE int is_end_path(char c) {\n    switch (c) {\n\tcase '?':\n\tcase '#':\n\tcase '\\0':\n\t    return 1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "in",
            "\"..\"",
            "2"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "in",
            "\".\"",
            "1"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "in",
            "\"/..\"",
            "3"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "in",
            "\"/../\"",
            "4"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "in",
            "\"/.\"",
            "2"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "in",
            "\"/./\"",
            "3"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "in",
            "\"../\"",
            "3"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "in",
            "\"./\"",
            "2"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "in < max"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out <= in"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "buf <= out"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint remove_dots(char *buf, size_t size)\n{\n    char *in = buf;\n    char *out = buf;\n    char *max = buf + size;\n\n    while (!is_end_path(in[0])) {\n\tassert (buf <= out);\n\tassert (out <= in);\n\tassert (in < max);\n\n        /* case 2.A: */\n        if (strncmp(in, \"./\", 2) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"../\", 3) == 0) {\n            in += 3;\n        /* case 2.B: */\n        } else if (strncmp(in, \"/./\", 3) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"/.\", 2) == 0 && is_end_path(in[2])) {\n            in += 1;\n\t    in[0] = '/';\n        /* case 2.C: */\n        } else if (strncmp(in, \"/../\", 4) == 0 || (strncmp(in, \"/..\", 3) == 0 && is_end_path(in[3]))) {\n            /* Make the next character in the input buffer a '/': */\n            if (is_end_path(in[3])) { /* terminating \"/..\" case */\n                in += 2;\n                in[0] = '/';\n            } else { /* \"/../\" prefix case */\n                in += 3;\n            }\n            /* Trim the last component from the output buffer, or empty it. */\n            while (buf < out)\n\t\tif (*--out == '/')\n\t\t    break;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        /* case 2.D: */\n        } else if (strncmp(in, \".\", 1) == 0 && is_end_path(in[1])) {\n            in += 1;\n\t} else if (strncmp(in, \"..\", 2) == 0 && is_end_path(in[2])) {\n            in += 2;\n        /* case 2.E */\n        } else {\n            /* move initial '/' character (if any) */\n            if (in[0] == '/')\n\t\t*out++ = *in++;\n\t    /* move first segment up to, but not including, the next '/' character */\n\t    while (in < max && in[0] != '/' && !is_end_path(in[0]))\n\t\t*out++ = *in++;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        }\n    }\n    while (in < max)\n\t*out++ = *in++;\n    if (out < max)\n\tout[0] = '\\0';\n    return UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "is_end_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "514-522",
    "snippet": "static UPNP_INLINE int is_end_path(char c) {\n    switch (c) {\n\tcase '?':\n\tcase '#':\n\tcase '\\0':\n\t    return 1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic UPNP_INLINE int is_end_path(char c) {\n    switch (c) {\n\tcase '?':\n\tcase '#':\n\tcase '\\0':\n\t    return 1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "remove_escaped_chars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "502-511",
    "snippet": "int remove_escaped_chars(INOUT char *in, INOUT size_t *size)\n{\n\tsize_t i = (size_t)0;\n\n\tfor (i = (size_t)0; i < *size; i++) {\n\t\treplace_escaped(in, i, size);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "replace_escaped",
          "args": [
            "in",
            "i",
            "size"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "replace_escaped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "135-162",
          "snippet": "int replace_escaped(char *in, size_t index, size_t *max)\n{\n\tint tempInt = 0;\n\tchar tempChar = 0;\n\tsize_t i = (size_t)0;\n\tsize_t j = (size_t)0;\n\n\tif (in[index] == '%' && isxdigit(in[index + (size_t)1]) && isxdigit(in[index + (size_t)2])) {\n\t\t/* Note the \"%2x\", makes sure that we convert a maximum of two\n\t\t * characters. */\n\t\tif (sscanf(&in[index + (size_t)1], \"%2x\", &tempInt) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t\ttempChar = (char)tempInt;\n\t\tfor (i = index + (size_t)3, j = index; j < *max; i++, j++) {\n\t\t\tin[j] = tempChar;\n\t\t\tif (i < *max) {\n\t\t\t\ttempChar = in[i];\n\t\t\t} else {\n\t\t\t\ttempChar = 0;\n\t\t\t}\n\t\t}\n\t\t*max -= (size_t)2;\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint replace_escaped(char *in, size_t index, size_t *max)\n{\n\tint tempInt = 0;\n\tchar tempChar = 0;\n\tsize_t i = (size_t)0;\n\tsize_t j = (size_t)0;\n\n\tif (in[index] == '%' && isxdigit(in[index + (size_t)1]) && isxdigit(in[index + (size_t)2])) {\n\t\t/* Note the \"%2x\", makes sure that we convert a maximum of two\n\t\t * characters. */\n\t\tif (sscanf(&in[index + (size_t)1], \"%2x\", &tempInt) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t\ttempChar = (char)tempInt;\n\t\tfor (i = index + (size_t)3, j = index; j < *max; i++, j++) {\n\t\t\tin[j] = tempChar;\n\t\t\tif (i < *max) {\n\t\t\t\ttempChar = in[i];\n\t\t\t} else {\n\t\t\t\ttempChar = 0;\n\t\t\t}\n\t\t}\n\t\t*max -= (size_t)2;\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint remove_escaped_chars(INOUT char *in, INOUT size_t *size)\n{\n\tsize_t i = (size_t)0;\n\n\tfor (i = (size_t)0; i < *size; i++) {\n\t\treplace_escaped(in, i, size);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "parse_scheme",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "469-499",
    "snippet": "static size_t parse_scheme(\n\t/*! [in] String of characters representing a scheme. */\n\tconst char *in,\n\t/*! [in] Maximum number of characters. */\n\tsize_t max,\n\t/*! [out] Output parameter whose buffer is filled in with the scheme. */\n\ttoken *out)\n{\n    size_t i = (size_t)0;\n\n    out->size = (size_t)0;\n    out->buff = NULL;\n\n    if( ( max == (size_t)0 ) || ( !isalpha( in[0] ) ) )\n        return (size_t)0;\n\n    i++;\n    while( ( i < max ) && ( in[i] != ':' ) ) {\n        if( !( isalnum( in[i] ) || ( in[i] == '+' ) || ( in[i] == '-' )\n               || ( in[i] == '.' ) ) )\n            return (size_t)0;\n        i++;\n    }\n    if( i < max ) {\n        out->size = i;\n        out->buff = &in[0];\n        return i;\n    }\n\n    return (size_t)0;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "in[i]"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "in[0]"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic size_t parse_scheme(\n\t/*! [in] String of characters representing a scheme. */\n\tconst char *in,\n\t/*! [in] Maximum number of characters. */\n\tsize_t max,\n\t/*! [out] Output parameter whose buffer is filled in with the scheme. */\n\ttoken *out)\n{\n    size_t i = (size_t)0;\n\n    out->size = (size_t)0;\n    out->buff = NULL;\n\n    if( ( max == (size_t)0 ) || ( !isalpha( in[0] ) ) )\n        return (size_t)0;\n\n    i++;\n    while( ( i < max ) && ( in[i] != ':' ) ) {\n        if( !( isalnum( in[i] ) || ( in[i] == '+' ) || ( in[i] == '-' )\n               || ( in[i] == '.' ) ) )\n            return (size_t)0;\n        i++;\n    }\n    if( i < max ) {\n        out->size = i;\n        out->buff = &in[0];\n        return i;\n    }\n\n    return (size_t)0;\n}"
  },
  {
    "function_name": "parse_hostport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "323-457",
    "snippet": "static int parse_hostport(\n\t/*! [in] String of characters representing host and port. */\n\tconst char *in,\n\t/*! [out] Output parameter where the host and port are represented as\n\t * an internet address. */\n\tunsigned short int defaultPort,\n\thostport_type *out)\n{\n\tchar workbuf[256];\n\tchar *c;\n\tstruct sockaddr_in *sai4 = (struct sockaddr_in *)&out->IPaddress;\n\tstruct sockaddr_in6 *sai6 = (struct sockaddr_in6 *)&out->IPaddress;\n\tchar *srvname = NULL;\n\tchar *srvport = NULL;\n\tchar *last_dot = NULL;\n\tunsigned short int port;\n\tint af = AF_UNSPEC;\n\tsize_t hostport_size;\n\tint has_port = 0;\n\tint ret;\n\n\tmemset(out, 0, sizeof(hostport_type));\n\tmemset(workbuf, 0, sizeof(workbuf));\n\t/* Work on a copy of the input string. */\n\tstrncpy(workbuf, in, sizeof(workbuf) - 1);\n\tc = workbuf;\n\tif (*c == '[') {\n\t\t/* IPv6 addresses are enclosed in square brackets. */\n\t\tsrvname = ++c;\n\t\twhile (*c != '\\0' && *c != ']')\n\t\t\tc++;\n\t\tif (*c == '\\0')\n\t\t\t/* did not find closing bracket. */\n\t\t\treturn UPNP_E_INVALID_URL;\n\t\t/* NULL terminate the srvname and then increment c. */\n\t\t*c++ = '\\0';\t/* overwrite the ']' */\n\t\tif (*c == ':') {\n\t\t\thas_port = 1;\n\t\t\tc++;\n\t\t}\n\t\taf = AF_INET6;\n\t} else {\n\t\t/* IPv4 address -OR- host name. */\n\t\tsrvname = c;\n\t\twhile (*c != ':' && *c != '/' &&\n\t\t       (isalnum(*c) || *c == '.' || *c == '-')) {\n\t\t\tif (*c == '.')\n\t\t\t\tlast_dot = c;\n\t\t\tc++;\n\t\t}\n\t\thas_port = (*c == ':') ? 1 : 0;\n\t\t/* NULL terminate the srvname */\n\t\t*c = '\\0';\n\t\tif (has_port == 1)\n\t\t\tc++;\n\t\tif (last_dot != NULL && isdigit(*(last_dot + 1)))\n\t\t\t/* Must be an IPv4 address. */\n\t\t\taf = AF_INET;\n\t\telse {\n\t\t\t/* Must be a host name. */\n\t\t\tstruct addrinfo hints, *res, *res0;\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\thints.ai_family = AF_UNSPEC;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n\n\t\t\tret = getaddrinfo(srvname, NULL, &hints, &res0);\n\t\t\tif (ret == 0) {\n\t\t\t\tfor (res = res0; res; res = res->ai_next) {\n\t\t\t\t\tswitch (res->ai_family) {\n\t\t\t\t\tcase AF_INET:\n\t\t\t\t\tcase AF_INET6:\n\t\t\t\t\t\t/* Found a valid IPv4 or IPv6 address. */\n\t\t\t\t\t\tmemcpy(&out->IPaddress,\n\t\t\t\t\t\t       res->ai_addr,\n\t\t\t\t\t\t       res->ai_addrlen);\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\t\t\t\t}\nfound:\n\t\t\t\tfreeaddrinfo(res0);\n\t\t\t\tif (res == NULL)\n\t\t\t\t\t/* Didn't find an AF_INET or AF_INET6 address. */\n\t\t\t\t\treturn UPNP_E_INVALID_URL;\n\t\t\t} else\n\t\t\t\t/* getaddrinfo failed. */\n\t\t\t\treturn UPNP_E_INVALID_URL;\n\t\t}\n\t}\n\t/* Check if a port is specified. */\n\tif (has_port == 1) {\n\t\t/* Port is specified. */\n\t\tsrvport = c;\n\t\twhile (*c != '\\0' && isdigit(*c))\n\t\t\tc++;\n\t\tport = (unsigned short int)atoi(srvport);\n\t\tif (port == 0)\n\t\t\t/* Bad port number. */\n\t\t\treturn UPNP_E_INVALID_URL;\n\t} else\n\t\t/* Port was not specified, use default port. */\n\t\tport = defaultPort;\n\t/* The length of the host and port string can be calculated by */\n\t/* subtracting pointers. */\n\thostport_size = (size_t)c - (size_t)workbuf;\n\t/* Fill in the 'out' information. */\n\tswitch (af) {\n\tcase AF_INET:\n\t\tsai4->sin_family = (sa_family_t)af;\n\t\tsai4->sin_port = htons(port);\n\t\tret = inet_pton(AF_INET, srvname, &sai4->sin_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsai6->sin6_family = (sa_family_t)af;\n\t\tsai6->sin6_port = htons(port);\n\t\tsai6->sin6_scope_id = gIF_INDEX;\n\t\tret = inet_pton(AF_INET6, srvname, &sai6->sin6_addr);\n\t\tbreak;\n\tdefault:\n\t\t/* IP address was set by the hostname (getaddrinfo). */\n\t\t/* Override port: */\n\t\tif (out->IPaddress.ss_family == (sa_family_t)AF_INET)\n\t\t\tsai4->sin_port = htons(port);\n\t\telse\n\t\t\tsai6->sin6_port = htons(port);\n\t\tret = 1;\n\t}\n\t/* Check if address was converted successfully. */\n\tif (ret <= 0)\n\t\treturn UPNP_E_INVALID_URL;\n\tout->text.size = hostport_size;\n\tout->text.buff = in;\n\n\treturn (int)hostport_size;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET6",
            "srvname",
            "&sai6->sin6_addr"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "inet_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "307-321",
          "snippet": "int inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nint inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "srvport"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*c"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "res0"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&out->IPaddress",
            "res->ai_addr",
            "res->ai_addrlen"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "srvname",
            "NULL",
            "&hints",
            "&res0"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*(last_dot + 1)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "*c"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "workbuf",
            "in",
            "sizeof(workbuf) - 1"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic int parse_hostport(\n\t/*! [in] String of characters representing host and port. */\n\tconst char *in,\n\t/*! [out] Output parameter where the host and port are represented as\n\t * an internet address. */\n\tunsigned short int defaultPort,\n\thostport_type *out)\n{\n\tchar workbuf[256];\n\tchar *c;\n\tstruct sockaddr_in *sai4 = (struct sockaddr_in *)&out->IPaddress;\n\tstruct sockaddr_in6 *sai6 = (struct sockaddr_in6 *)&out->IPaddress;\n\tchar *srvname = NULL;\n\tchar *srvport = NULL;\n\tchar *last_dot = NULL;\n\tunsigned short int port;\n\tint af = AF_UNSPEC;\n\tsize_t hostport_size;\n\tint has_port = 0;\n\tint ret;\n\n\tmemset(out, 0, sizeof(hostport_type));\n\tmemset(workbuf, 0, sizeof(workbuf));\n\t/* Work on a copy of the input string. */\n\tstrncpy(workbuf, in, sizeof(workbuf) - 1);\n\tc = workbuf;\n\tif (*c == '[') {\n\t\t/* IPv6 addresses are enclosed in square brackets. */\n\t\tsrvname = ++c;\n\t\twhile (*c != '\\0' && *c != ']')\n\t\t\tc++;\n\t\tif (*c == '\\0')\n\t\t\t/* did not find closing bracket. */\n\t\t\treturn UPNP_E_INVALID_URL;\n\t\t/* NULL terminate the srvname and then increment c. */\n\t\t*c++ = '\\0';\t/* overwrite the ']' */\n\t\tif (*c == ':') {\n\t\t\thas_port = 1;\n\t\t\tc++;\n\t\t}\n\t\taf = AF_INET6;\n\t} else {\n\t\t/* IPv4 address -OR- host name. */\n\t\tsrvname = c;\n\t\twhile (*c != ':' && *c != '/' &&\n\t\t       (isalnum(*c) || *c == '.' || *c == '-')) {\n\t\t\tif (*c == '.')\n\t\t\t\tlast_dot = c;\n\t\t\tc++;\n\t\t}\n\t\thas_port = (*c == ':') ? 1 : 0;\n\t\t/* NULL terminate the srvname */\n\t\t*c = '\\0';\n\t\tif (has_port == 1)\n\t\t\tc++;\n\t\tif (last_dot != NULL && isdigit(*(last_dot + 1)))\n\t\t\t/* Must be an IPv4 address. */\n\t\t\taf = AF_INET;\n\t\telse {\n\t\t\t/* Must be a host name. */\n\t\t\tstruct addrinfo hints, *res, *res0;\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\thints.ai_family = AF_UNSPEC;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n\n\t\t\tret = getaddrinfo(srvname, NULL, &hints, &res0);\n\t\t\tif (ret == 0) {\n\t\t\t\tfor (res = res0; res; res = res->ai_next) {\n\t\t\t\t\tswitch (res->ai_family) {\n\t\t\t\t\tcase AF_INET:\n\t\t\t\t\tcase AF_INET6:\n\t\t\t\t\t\t/* Found a valid IPv4 or IPv6 address. */\n\t\t\t\t\t\tmemcpy(&out->IPaddress,\n\t\t\t\t\t\t       res->ai_addr,\n\t\t\t\t\t\t       res->ai_addrlen);\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\t\t\t\t}\nfound:\n\t\t\t\tfreeaddrinfo(res0);\n\t\t\t\tif (res == NULL)\n\t\t\t\t\t/* Didn't find an AF_INET or AF_INET6 address. */\n\t\t\t\t\treturn UPNP_E_INVALID_URL;\n\t\t\t} else\n\t\t\t\t/* getaddrinfo failed. */\n\t\t\t\treturn UPNP_E_INVALID_URL;\n\t\t}\n\t}\n\t/* Check if a port is specified. */\n\tif (has_port == 1) {\n\t\t/* Port is specified. */\n\t\tsrvport = c;\n\t\twhile (*c != '\\0' && isdigit(*c))\n\t\t\tc++;\n\t\tport = (unsigned short int)atoi(srvport);\n\t\tif (port == 0)\n\t\t\t/* Bad port number. */\n\t\t\treturn UPNP_E_INVALID_URL;\n\t} else\n\t\t/* Port was not specified, use default port. */\n\t\tport = defaultPort;\n\t/* The length of the host and port string can be calculated by */\n\t/* subtracting pointers. */\n\thostport_size = (size_t)c - (size_t)workbuf;\n\t/* Fill in the 'out' information. */\n\tswitch (af) {\n\tcase AF_INET:\n\t\tsai4->sin_family = (sa_family_t)af;\n\t\tsai4->sin_port = htons(port);\n\t\tret = inet_pton(AF_INET, srvname, &sai4->sin_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsai6->sin6_family = (sa_family_t)af;\n\t\tsai6->sin6_port = htons(port);\n\t\tsai6->sin6_scope_id = gIF_INDEX;\n\t\tret = inet_pton(AF_INET6, srvname, &sai6->sin6_addr);\n\t\tbreak;\n\tdefault:\n\t\t/* IP address was set by the hostname (getaddrinfo). */\n\t\t/* Override port: */\n\t\tif (out->IPaddress.ss_family == (sa_family_t)AF_INET)\n\t\t\tsai4->sin_port = htons(port);\n\t\telse\n\t\t\tsai6->sin6_port = htons(port);\n\t\tret = 1;\n\t}\n\t/* Check if address was converted successfully. */\n\tif (ret <= 0)\n\t\treturn UPNP_E_INVALID_URL;\n\tout->text.size = hostport_size;\n\tout->text.buff = in;\n\n\treturn (int)hostport_size;\n}"
  },
  {
    "function_name": "token_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "308-314",
    "snippet": "int token_cmp(token *in1, token *in2)\n{\n\tif (in1->size != in2->size)\n\t\treturn 1;\n\telse\n\t\treturn memcmp(in1->buff, in2->buff, in1->size);\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "in1->buff",
            "in2->buff",
            "in1->size"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint token_cmp(token *in1, token *in2)\n{\n\tif (in1->size != in2->size)\n\t\treturn 1;\n\telse\n\t\treturn memcmp(in1->buff, in2->buff, in1->size);\n}"
  },
  {
    "function_name": "token_string_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "299-306",
    "snippet": "int token_string_cmp(token * in1, char *in2)\n{\n\tsize_t in2_length = strlen(in2);\n\tif (in1->size != in2_length)\n\t\treturn 1;\n\telse\n\t\treturn strncmp(in1->buff, in2, in1->size);\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "in1->buff",
            "in2",
            "in1->size"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "in2"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint token_string_cmp(token * in1, char *in2)\n{\n\tsize_t in2_length = strlen(in2);\n\tif (in1->size != in2_length)\n\t\treturn 1;\n\telse\n\t\treturn strncmp(in1->buff, in2, in1->size);\n}"
  },
  {
    "function_name": "token_string_casecmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "289-296",
    "snippet": "int token_string_casecmp(token *in1, const char *in2)\n{\n\tsize_t in2_length = strlen(in2);\n\tif (in1->size != in2_length)\n\t\treturn 1;\n\telse\n\t\treturn strncasecmp(in1->buff, in2, in1->size);\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "in1->buff",
            "in2",
            "in1->size"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "in2"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint token_string_casecmp(token *in1, const char *in2)\n{\n\tsize_t in2_length = strlen(in2);\n\tif (in1->size != in2_length)\n\t\treturn 1;\n\telse\n\t\treturn strncasecmp(in1->buff, in2, in1->size);\n}"
  },
  {
    "function_name": "print_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "276-285",
    "snippet": "void print_token(token * in)\n{\n\tsize_t i = 0;\n\n\tprintf(\"Token Size : %\" PRIzu \"\\n\\'\", in->size);\n\tfor (i = 0; i < in->size; i++)\n\t\tputchar(in->buff[i]);\n\tputchar('\\'');\n\tputchar('\\n');\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putchar",
          "args": [
            "'\\n'"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putchar",
          "args": [
            "'\\''"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putchar",
          "args": [
            "in->buff[i]"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Token Size : %\" PRIzu \"\\n\\'\"",
            "in->size"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nvoid print_token(token * in)\n{\n\tsize_t i = 0;\n\n\tprintf(\"Token Size : %\" PRIzu \"\\n\\'\", in->size);\n\tfor (i = 0; i < in->size; i++)\n\t\tputchar(in->buff[i]);\n\tputchar('\\'');\n\tputchar('\\n');\n}"
  },
  {
    "function_name": "print_uri",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "265-271",
    "snippet": "void print_uri(uri_type *in)\n{\n\tprint_token(&in->scheme);\n\tprint_token(&in->hostport.text);\n\tprint_token(&in->pathquery);\n\tprint_token(&in->fragment);\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_token",
          "args": [
            "&in->fragment"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "print_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "276-285",
          "snippet": "void print_token(token * in)\n{\n\tsize_t i = 0;\n\n\tprintf(\"Token Size : %\" PRIzu \"\\n\\'\", in->size);\n\tfor (i = 0; i < in->size; i++)\n\t\tputchar(in->buff[i]);\n\tputchar('\\'');\n\tputchar('\\n');\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nvoid print_token(token * in)\n{\n\tsize_t i = 0;\n\n\tprintf(\"Token Size : %\" PRIzu \"\\n\\'\", in->size);\n\tfor (i = 0; i < in->size; i++)\n\t\tputchar(in->buff[i]);\n\tputchar('\\'');\n\tputchar('\\n');\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nvoid print_uri(uri_type *in)\n{\n\tprint_token(&in->scheme);\n\tprint_token(&in->hostport.text);\n\tprint_token(&in->pathquery);\n\tprint_token(&in->fragment);\n}"
  },
  {
    "function_name": "free_URL_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "252-261",
    "snippet": "void free_URL_list(URL_list *list)\n{\n\tif (list->URLs) {\n\t\tfree(list->URLs);\n\t}\n\tif (list->parsedURLs) {\n\t\tfree(list->parsedURLs);\n\t}\n\tlist->size = (size_t)0;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "list->parsedURLs"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "free_URL_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "252-261",
          "snippet": "void free_URL_list(URL_list *list)\n{\n\tif (list->URLs) {\n\t\tfree(list->URLs);\n\t}\n\tif (list->parsedURLs) {\n\t\tfree(list->parsedURLs);\n\t}\n\tlist->size = (size_t)0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nvoid free_URL_list(URL_list *list)\n{\n\tif (list->URLs) {\n\t\tfree(list->URLs);\n\t}\n\tif (list->parsedURLs) {\n\t\tfree(list->parsedURLs);\n\t}\n\tlist->size = (size_t)0;\n}"
  },
  {
    "function_name": "copy_URL_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "214-249",
    "snippet": "int copy_URL_list(URL_list *in, URL_list *out)\n{\n    size_t len = strlen(in->URLs) + (size_t)1;\n    size_t i = (size_t)0;\n\n    out->URLs = NULL;\n    out->parsedURLs = NULL;\n    out->size = (size_t)0;\n\n    out->URLs = malloc(len);\n    out->parsedURLs = malloc(sizeof(uri_type) * in->size);\n\n    if ( !out->URLs || !out->parsedURLs)\n        return UPNP_E_OUTOF_MEMORY;\n    memcpy(out->URLs, in->URLs, len);\n    for( i = (size_t)0; i < in->size; i++ ) {\n        /*copy the parsed uri */\n        out->parsedURLs[i].type = in->parsedURLs[i].type;\n        copy_token( &in->parsedURLs[i].scheme, in->URLs,\n                    &out->parsedURLs[i].scheme, out->URLs );\n        out->parsedURLs[i].path_type = in->parsedURLs[i].path_type;\n        copy_token( &in->parsedURLs[i].pathquery, in->URLs,\n                    &out->parsedURLs[i].pathquery, out->URLs );\n        copy_token( &in->parsedURLs[i].fragment, in->URLs,\n                    &out->parsedURLs[i].fragment, out->URLs );\n        copy_token( &in->parsedURLs[i].hostport.text,\n                    in->URLs, &out->parsedURLs[i].hostport.text,\n                    out->URLs );\n        memcpy( &out->parsedURLs[i].hostport.IPaddress,\n            &in->parsedURLs[i].hostport.IPaddress, \n            sizeof(struct sockaddr_storage) );\n    }\n    out->size = in->size;\n\n    return HTTP_SUCCESS;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&out->parsedURLs[i].hostport.IPaddress",
            "&in->parsedURLs[i].hostport.IPaddress",
            "sizeof(struct sockaddr_storage)"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_token",
          "args": [
            "&in->parsedURLs[i].hostport.text",
            "in->URLs",
            "&out->parsedURLs[i].hostport.text",
            "out->URLs"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "copy_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "199-211",
          "snippet": "static void copy_token(\n\t/*! [in] Source token. */\n\tconst token *in,\n\t/*! [in] . */\n\tconst char *in_base,\n\t/*! [out] Destination token. */\n\ttoken *out,\n\t/*! [in] . */\n\tchar *out_base)\n{\n\tout->size = in->size;\n\tout->buff = out_base + (in->buff - in_base);\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic void copy_token(\n\t/*! [in] Source token. */\n\tconst token *in,\n\t/*! [in] . */\n\tconst char *in_base,\n\t/*! [out] Destination token. */\n\ttoken *out,\n\t/*! [in] . */\n\tchar *out_base)\n{\n\tout->size = in->size;\n\tout->buff = out_base + (in->buff - in_base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(uri_type) * in->size"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "in->URLs"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint copy_URL_list(URL_list *in, URL_list *out)\n{\n    size_t len = strlen(in->URLs) + (size_t)1;\n    size_t i = (size_t)0;\n\n    out->URLs = NULL;\n    out->parsedURLs = NULL;\n    out->size = (size_t)0;\n\n    out->URLs = malloc(len);\n    out->parsedURLs = malloc(sizeof(uri_type) * in->size);\n\n    if ( !out->URLs || !out->parsedURLs)\n        return UPNP_E_OUTOF_MEMORY;\n    memcpy(out->URLs, in->URLs, len);\n    for( i = (size_t)0; i < in->size; i++ ) {\n        /*copy the parsed uri */\n        out->parsedURLs[i].type = in->parsedURLs[i].type;\n        copy_token( &in->parsedURLs[i].scheme, in->URLs,\n                    &out->parsedURLs[i].scheme, out->URLs );\n        out->parsedURLs[i].path_type = in->parsedURLs[i].path_type;\n        copy_token( &in->parsedURLs[i].pathquery, in->URLs,\n                    &out->parsedURLs[i].pathquery, out->URLs );\n        copy_token( &in->parsedURLs[i].fragment, in->URLs,\n                    &out->parsedURLs[i].fragment, out->URLs );\n        copy_token( &in->parsedURLs[i].hostport.text,\n                    in->URLs, &out->parsedURLs[i].hostport.text,\n                    out->URLs );\n        memcpy( &out->parsedURLs[i].hostport.IPaddress,\n            &in->parsedURLs[i].hostport.IPaddress, \n            sizeof(struct sockaddr_storage) );\n    }\n    out->size = in->size;\n\n    return HTTP_SUCCESS;\n}"
  },
  {
    "function_name": "copy_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "199-211",
    "snippet": "static void copy_token(\n\t/*! [in] Source token. */\n\tconst token *in,\n\t/*! [in] . */\n\tconst char *in_base,\n\t/*! [out] Destination token. */\n\ttoken *out,\n\t/*! [in] . */\n\tchar *out_base)\n{\n\tout->size = in->size;\n\tout->buff = out_base + (in->buff - in_base);\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic void copy_token(\n\t/*! [in] Source token. */\n\tconst token *in,\n\t/*! [in] . */\n\tconst char *in_base,\n\t/*! [out] Destination token. */\n\ttoken *out,\n\t/*! [in] . */\n\tchar *out_base)\n{\n\tout->size = in->size;\n\tout->buff = out_base + (in->buff - in_base);\n}"
  },
  {
    "function_name": "parse_uric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "171-191",
    "snippet": "static size_t parse_uric(\n\t/*! [in] String of characters. */\n\tconst char *in,\n\t/*! [in] Maximum limit. */\n\tsize_t max,\n\t/*! [out] Token object where the string of characters is copied. */\n\ttoken *out)\n{\n\tsize_t i = (size_t)0;\n\n\twhile (i < max &&\n\t       (is_unreserved(in[i]) ||\n\t        is_reserved(in[i])   ||\n\t        ((i + (size_t)2 < max) && is_escaped(&in[i])))) {\n\t\ti++;\n\t}\n\n\tout->size = i;\n\tout->buff = in;\n\treturn i;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_escaped",
          "args": [
            "&in[i]"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "is_escaped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "124-133",
          "snippet": "int is_escaped(\n\t/*! [in] Char sequence to be matched for ESCAPED characters. */\n\tconst char *in)\n{\n\tif (in[0] == '%' && isxdigit(in[1]) && isxdigit(in[2])) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint is_escaped(\n\t/*! [in] Char sequence to be matched for ESCAPED characters. */\n\tconst char *in)\n{\n\tif (in[0] == '%' && isxdigit(in[1]) && isxdigit(in[2])) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_reserved",
          "args": [
            "in[i]"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "is_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "68-77",
          "snippet": "static int is_reserved(\n\t/*! [in] Char to be matched for RESERVED characters. */\n\tchar in)\n{\n\tif (strchr(RESERVED, (int)in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic int is_reserved(\n\t/*! [in] Char to be matched for RESERVED characters. */\n\tchar in)\n{\n\tif (strchr(RESERVED, (int)in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_unreserved",
          "args": [
            "in[i]"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "is_unreserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "104-113",
          "snippet": "int is_unreserved(\n\t/*! [in] Char to be matched for UNRESERVED characters. */\n\tchar in)\n{\n\tif (isalnum(in) || is_mark(in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint is_unreserved(\n\t/*! [in] Char to be matched for UNRESERVED characters. */\n\tchar in)\n{\n\tif (isalnum(in) || is_mark(in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic size_t parse_uric(\n\t/*! [in] String of characters. */\n\tconst char *in,\n\t/*! [in] Maximum limit. */\n\tsize_t max,\n\t/*! [out] Token object where the string of characters is copied. */\n\ttoken *out)\n{\n\tsize_t i = (size_t)0;\n\n\twhile (i < max &&\n\t       (is_unreserved(in[i]) ||\n\t        is_reserved(in[i])   ||\n\t        ((i + (size_t)2 < max) && is_escaped(&in[i])))) {\n\t\ti++;\n\t}\n\n\tout->size = i;\n\tout->buff = in;\n\treturn i;\n}"
  },
  {
    "function_name": "replace_escaped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "135-162",
    "snippet": "int replace_escaped(char *in, size_t index, size_t *max)\n{\n\tint tempInt = 0;\n\tchar tempChar = 0;\n\tsize_t i = (size_t)0;\n\tsize_t j = (size_t)0;\n\n\tif (in[index] == '%' && isxdigit(in[index + (size_t)1]) && isxdigit(in[index + (size_t)2])) {\n\t\t/* Note the \"%2x\", makes sure that we convert a maximum of two\n\t\t * characters. */\n\t\tif (sscanf(&in[index + (size_t)1], \"%2x\", &tempInt) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t\ttempChar = (char)tempInt;\n\t\tfor (i = index + (size_t)3, j = index; j < *max; i++, j++) {\n\t\t\tin[j] = tempChar;\n\t\t\tif (i < *max) {\n\t\t\t\ttempChar = in[i];\n\t\t\t} else {\n\t\t\t\ttempChar = 0;\n\t\t\t}\n\t\t}\n\t\t*max -= (size_t)2;\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "&in[index + (size_t)1]",
            "\"%2x\"",
            "&tempInt"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "in[index + (size_t)2]"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "in[index + (size_t)1]"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint replace_escaped(char *in, size_t index, size_t *max)\n{\n\tint tempInt = 0;\n\tchar tempChar = 0;\n\tsize_t i = (size_t)0;\n\tsize_t j = (size_t)0;\n\n\tif (in[index] == '%' && isxdigit(in[index + (size_t)1]) && isxdigit(in[index + (size_t)2])) {\n\t\t/* Note the \"%2x\", makes sure that we convert a maximum of two\n\t\t * characters. */\n\t\tif (sscanf(&in[index + (size_t)1], \"%2x\", &tempInt) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t\ttempChar = (char)tempInt;\n\t\tfor (i = index + (size_t)3, j = index; j < *max; i++, j++) {\n\t\t\tin[j] = tempChar;\n\t\t\tif (i < *max) {\n\t\t\t\ttempChar = in[i];\n\t\t\t} else {\n\t\t\t\ttempChar = 0;\n\t\t\t}\n\t\t}\n\t\t*max -= (size_t)2;\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "is_escaped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "124-133",
    "snippet": "int is_escaped(\n\t/*! [in] Char sequence to be matched for ESCAPED characters. */\n\tconst char *in)\n{\n\tif (in[0] == '%' && isxdigit(in[1]) && isxdigit(in[2])) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "in[2]"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "in[1]"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint is_escaped(\n\t/*! [in] Char sequence to be matched for ESCAPED characters. */\n\tconst char *in)\n{\n\tif (in[0] == '%' && isxdigit(in[1]) && isxdigit(in[2])) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "is_unreserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "104-113",
    "snippet": "int is_unreserved(\n\t/*! [in] Char to be matched for UNRESERVED characters. */\n\tchar in)\n{\n\tif (isalnum(in) || is_mark(in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_mark",
          "args": [
            "in"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "is_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "86-95",
          "snippet": "int is_mark(\n\t/*! [in] Char to be matched for MARKED characters. */\n\tchar in)\n{\n\tif (strchr(MARK, (int)in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint is_mark(\n\t/*! [in] Char to be matched for MARKED characters. */\n\tchar in)\n{\n\tif (strchr(MARK, (int)in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "in"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint is_unreserved(\n\t/*! [in] Char to be matched for UNRESERVED characters. */\n\tchar in)\n{\n\tif (isalnum(in) || is_mark(in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "is_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "86-95",
    "snippet": "int is_mark(\n\t/*! [in] Char to be matched for MARKED characters. */\n\tchar in)\n{\n\tif (strchr(MARK, (int)in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "MARK",
            "(int)in"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint is_mark(\n\t/*! [in] Char to be matched for MARKED characters. */\n\tchar in)\n{\n\tif (strchr(MARK, (int)in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "is_reserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
    "lines": "68-77",
    "snippet": "static int is_reserved(\n\t/*! [in] Char to be matched for RESERVED characters. */\n\tchar in)\n{\n\tif (strchr(RESERVED, (int)in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uri.h\"",
      "#include \"config.h\"",
      "#include <assert.h>",
      "#include <lwres/netdb.h>",
      "#include <osreldate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "RESERVED",
            "(int)in"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nstatic int is_reserved(\n\t/*! [in] Char to be matched for RESERVED characters. */\n\tchar in)\n{\n\tif (strchr(RESERVED, (int)in)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  }
]