[
  {
    "function_name": "inet_pton",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
    "lines": "307-321",
    "snippet": "int inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include \"inet_pton.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inet_pton6",
          "args": [
            "src",
            "dst"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "inet_pton6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "207-287",
          "snippet": "static int inet_pton6(const char *src, u_char *dst)\n{\n\tstatic const char xdigits[] = \"0123456789abcdef\";\n\tu_char tmp[16], *tp, *endp, *colonp;\n\tconst char *curtok;\n\tint ch, saw_xdigit;\n\tu_int val;\n\n\ttp = memset(tmp, '\\0', 16);\n\tendp = tp + 16;\n\tcolonp = NULL;\n\t/* Leading :: requires some special handling. */\n\tif (*src == ':')\n\t\tif (*++src != ':')\n\t\t\treturn (0);\n\tcurtok = src;\n\tsaw_xdigit = 0;\n\tval = 0;\n\twhile ((ch = tolower (*src++)) != '\\0') {\n\t\tconst char *pch;\n\n\t\tpch = strchr(xdigits, ch);\n\t\tif (pch != NULL) {\n\t\t\tval <<= 4;\n\t\t\tval |= (pch - xdigits);\n\t\t\tif (val 0xffff)\n\t\t\t\treturn (0);\n\t\t\tsaw_xdigit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == ':') {\n\t\t\tcurtok = src;\n\t\t\tif (!saw_xdigit) {\n\t\t\t\tif (colonp)\n\t\t\t\t\treturn (0);\n\t\t\t\tcolonp = tp;\n\t\t\t\tcontinue;\n\t\t\t} else if (*src == '\\0') {\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tp + 2 endp)\n\t\t\t\treturn (0);\n\t\t\t*tp++ = (u_char) (val >8) & 0xff;\n\t\t\t*tp++ = (u_char) val & 0xff;\n\t\t\tsaw_xdigit = 0;\n\t\t\tval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' && ((tp + 4) <= endp) &&\n\t\t    inet_pton4(curtok, tp) 0) {\n\t\t\ttp += 4;\n\t\t\tsaw_xdigit = 0;\n\t\t\tbreak;\t/* '\\0' was seen by inet_pton4(). */\n\t\t}\n\t\treturn (0);\n\t}\n\tif (saw_xdigit) {\n\t\tif (tp + 2 endp)\n\t\t\treturn (0);\n\t\t*tp++ = (u_char) (val >8) & 0xff;\n\t\t*tp++ = (u_char) val & 0xff;\n\t}\n\tif (colonp != NULL) {\n\t\t/* Since some memmove()'s erroneously fail to handle\n\t\t * overlapping regions, we'll do the shift by hand. */\n\t\tconst int n = tp - colonp;\n\t\tint i;\n\n\t\tif (tp == endp)\n\t\t\treturn (0);\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tendp[- i] = colonp[n - i];\n\t\t\tcolonp[n - i] = 0;\n\t\t}\n\t\ttp = endp;\n\t}\n\tif (tp != endp)\n\t\treturn (0);\n\tmemcpy(dst, tmp, 16);\n\treturn (1);\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nstatic int inet_pton6(const char *src, u_char *dst)\n{\n\tstatic const char xdigits[] = \"0123456789abcdef\";\n\tu_char tmp[16], *tp, *endp, *colonp;\n\tconst char *curtok;\n\tint ch, saw_xdigit;\n\tu_int val;\n\n\ttp = memset(tmp, '\\0', 16);\n\tendp = tp + 16;\n\tcolonp = NULL;\n\t/* Leading :: requires some special handling. */\n\tif (*src == ':')\n\t\tif (*++src != ':')\n\t\t\treturn (0);\n\tcurtok = src;\n\tsaw_xdigit = 0;\n\tval = 0;\n\twhile ((ch = tolower (*src++)) != '\\0') {\n\t\tconst char *pch;\n\n\t\tpch = strchr(xdigits, ch);\n\t\tif (pch != NULL) {\n\t\t\tval <<= 4;\n\t\t\tval |= (pch - xdigits);\n\t\t\tif (val 0xffff)\n\t\t\t\treturn (0);\n\t\t\tsaw_xdigit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == ':') {\n\t\t\tcurtok = src;\n\t\t\tif (!saw_xdigit) {\n\t\t\t\tif (colonp)\n\t\t\t\t\treturn (0);\n\t\t\t\tcolonp = tp;\n\t\t\t\tcontinue;\n\t\t\t} else if (*src == '\\0') {\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tp + 2 endp)\n\t\t\t\treturn (0);\n\t\t\t*tp++ = (u_char) (val >8) & 0xff;\n\t\t\t*tp++ = (u_char) val & 0xff;\n\t\t\tsaw_xdigit = 0;\n\t\t\tval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' && ((tp + 4) <= endp) &&\n\t\t    inet_pton4(curtok, tp) 0) {\n\t\t\ttp += 4;\n\t\t\tsaw_xdigit = 0;\n\t\t\tbreak;\t/* '\\0' was seen by inet_pton4(). */\n\t\t}\n\t\treturn (0);\n\t}\n\tif (saw_xdigit) {\n\t\tif (tp + 2 endp)\n\t\t\treturn (0);\n\t\t*tp++ = (u_char) (val >8) & 0xff;\n\t\t*tp++ = (u_char) val & 0xff;\n\t}\n\tif (colonp != NULL) {\n\t\t/* Since some memmove()'s erroneously fail to handle\n\t\t * overlapping regions, we'll do the shift by hand. */\n\t\tconst int n = tp - colonp;\n\t\tint i;\n\n\t\tif (tp == endp)\n\t\t\treturn (0);\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tendp[- i] = colonp[n - i];\n\t\t\tcolonp[n - i] = 0;\n\t\t}\n\t\ttp = endp;\n\t}\n\tif (tp != endp)\n\t\treturn (0);\n\tmemcpy(dst, tmp, 16);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_pton4",
          "args": [
            "src",
            "dst"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "inet_pton4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "164-195",
          "snippet": "static int inet_pton4(const char *src,u_char *dst)\n{\n\tint saw_digit, octets, ch;\n\tu_char tmp[4], *tp;\n\n\tsaw_digit = 0;\n\toctets = 0;\n\t*(tp = tmp) = 0;\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (ch >= '0' && ch <= '9') {\n\t\t\tu_int new = *tp * 10 + (ch - '0');\n\t\t\tif (new>255)\n\t\t\t\treturn (0);\n\t\t\t*tp = new;\n\t\t\tif (! saw_digit) {\n\t\t\t\tif (++octets>4)\n\t\t\t\t\treturn (0);\n\t\t\t\tsaw_digit = 1;\n\t\t\t}\n\t\t} else if (ch == '.' && saw_digit) {\n\t\t\tif (octets == 4)\n\t\t\t\treturn (0);\n\t\t\t*++tp = 0;\n\t\t\tsaw_digit = 0;\n\t\t} else\n\t\t\treturn (0);\n\t}\n\tif (octets < 4)\n\t\treturn (0);\n\tmemcpy(dst, tmp, 4);\n\treturn 1;\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nstatic int inet_pton4(const char *src,u_char *dst)\n{\n\tint saw_digit, octets, ch;\n\tu_char tmp[4], *tp;\n\n\tsaw_digit = 0;\n\toctets = 0;\n\t*(tp = tmp) = 0;\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (ch >= '0' && ch <= '9') {\n\t\t\tu_int new = *tp * 10 + (ch - '0');\n\t\t\tif (new>255)\n\t\t\t\treturn (0);\n\t\t\t*tp = new;\n\t\t\tif (! saw_digit) {\n\t\t\t\tif (++octets>4)\n\t\t\t\t\treturn (0);\n\t\t\t\tsaw_digit = 1;\n\t\t\t}\n\t\t} else if (ch == '.' && saw_digit) {\n\t\t\tif (octets == 4)\n\t\t\t\treturn (0);\n\t\t\t*++tp = 0;\n\t\t\tsaw_digit = 0;\n\t\t} else\n\t\t\treturn (0);\n\t}\n\tif (octets < 4)\n\t\treturn (0);\n\tmemcpy(dst, tmp, 4);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inet_pton.h\"\n\nint inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "inet_ntop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
    "lines": "291-305",
    "snippet": "const char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include \"inet_pton.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inet_ntop6",
          "args": [
            "src",
            "dst",
            "size"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "73-154",
          "snippet": "static const char *inet_ntop6(const u_char *src, char *dst, socklen_t size)\n{\n\t/*\n\t * Note that int32_t and int16_t need only be \"at least\" large enough\n\t * to contain a value of the specified size.  On some systems, like\n\t * Crays, there is no such thing as an integer variable with 16 bits.\n\t * Keep this in mind if you think this function should have been coded\n\t * to use pointer overlays.  All the world's not a VAX.\n\t */\n\tchar tmp[sizeof (\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")], *tp;\n\tstruct { int base, len; } best, cur;\n\tu_int words[8];\n\tint i;\n\n\t/*\n\t * Preprocess:\n\t *\tCopy the input (bytewise) array into a wordwise array.\n\t *\tFind the longest run of 0x00's in src[] for :: shorthanding.\n\t */\n\tmemset(words, '\\0', sizeof words);\n\tfor (i = 0; i < 16; i += 2)\n\t\twords[i / 2] = (src[i] << 8) | src[i + 1];\n\tbest.base = -1;\n\tcur.base = -1;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (words[i] == 0) {\n\t\t\tif (cur.base == -1)\n\t\t\t\tcur.base = i, cur.len = 1;\n\t\t\telse\n\t\t\t\tcur.len++;\n\t\t} else {\n\t\t\tif (cur.base != -1) {\n\t\t\t\tif (best.base == -1 || cur.len best.len)\n\t\t\t\t\tbest = cur;\n\t\t\t\tcur.base = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.base != -1) {\n\t\tif (best.base == -1 || cur.len best.len)\n\t\t\tbest = cur;\n\t}\n\tif (best.base != -1 && best.len < 2)\n\t\tbest.base = -1;\n\n\t/*\n\t * Format the result.\n\t */\n\ttp = tmp;\n\tfor (i = 0; i < 8; i++) {\n\t\t/* Are we inside the best run of 0x00's? */\n\t\tif (best.base != -1 && i >= best.base &&\n\t\t    i < (best.base + best.len)) {\n\t\t\tif (i == best.base)\n\t\t\t\t*tp++ = ':';\n\t\t\tcontinue;\n\t\t}\n\t\t/* Are we following an initial run of 0x00s or any real hex? */\n\t\tif (i != 0)\n\t\t\t*tp++ = ':';\n\t\t/* Is this address an encapsulated IPv4? */\n\t\tif (i == 6 && best.base == 0 &&\n\t\t    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n\t\t\tif (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))\n\t\t\t\treturn (NULL);\n\t\t\ttp += strlen(tp);\n\t\t\tbreak;\n\t\t}\n\t\ttp += SPRINTF((tp, \"%x\", words[i]));\n\t}\n\t/* Was it a trailing run of 0x00's? */\n\tif (best.base != -1 && (best.base + best.len) == 8)\n\t\t*tp++ = ':';\n\t*tp++ = '\\0';\n\n\t/* Check for overflow, copy, and we're done. */\n\tif ((socklen_t)(tp - tmp) size) {\n\t\t//__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\treturn strcpy(dst, tmp);\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nstatic const char *inet_ntop6(const u_char *src, char *dst, socklen_t size)\n{\n\t/*\n\t * Note that int32_t and int16_t need only be \"at least\" large enough\n\t * to contain a value of the specified size.  On some systems, like\n\t * Crays, there is no such thing as an integer variable with 16 bits.\n\t * Keep this in mind if you think this function should have been coded\n\t * to use pointer overlays.  All the world's not a VAX.\n\t */\n\tchar tmp[sizeof (\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")], *tp;\n\tstruct { int base, len; } best, cur;\n\tu_int words[8];\n\tint i;\n\n\t/*\n\t * Preprocess:\n\t *\tCopy the input (bytewise) array into a wordwise array.\n\t *\tFind the longest run of 0x00's in src[] for :: shorthanding.\n\t */\n\tmemset(words, '\\0', sizeof words);\n\tfor (i = 0; i < 16; i += 2)\n\t\twords[i / 2] = (src[i] << 8) | src[i + 1];\n\tbest.base = -1;\n\tcur.base = -1;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (words[i] == 0) {\n\t\t\tif (cur.base == -1)\n\t\t\t\tcur.base = i, cur.len = 1;\n\t\t\telse\n\t\t\t\tcur.len++;\n\t\t} else {\n\t\t\tif (cur.base != -1) {\n\t\t\t\tif (best.base == -1 || cur.len best.len)\n\t\t\t\t\tbest = cur;\n\t\t\t\tcur.base = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.base != -1) {\n\t\tif (best.base == -1 || cur.len best.len)\n\t\t\tbest = cur;\n\t}\n\tif (best.base != -1 && best.len < 2)\n\t\tbest.base = -1;\n\n\t/*\n\t * Format the result.\n\t */\n\ttp = tmp;\n\tfor (i = 0; i < 8; i++) {\n\t\t/* Are we inside the best run of 0x00's? */\n\t\tif (best.base != -1 && i >= best.base &&\n\t\t    i < (best.base + best.len)) {\n\t\t\tif (i == best.base)\n\t\t\t\t*tp++ = ':';\n\t\t\tcontinue;\n\t\t}\n\t\t/* Are we following an initial run of 0x00s or any real hex? */\n\t\tif (i != 0)\n\t\t\t*tp++ = ':';\n\t\t/* Is this address an encapsulated IPv4? */\n\t\tif (i == 6 && best.base == 0 &&\n\t\t    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n\t\t\tif (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))\n\t\t\t\treturn (NULL);\n\t\t\ttp += strlen(tp);\n\t\t\tbreak;\n\t\t}\n\t\ttp += SPRINTF((tp, \"%x\", words[i]));\n\t}\n\t/* Was it a trailing run of 0x00's? */\n\tif (best.base != -1 && (best.base + best.len) == 8)\n\t\t*tp++ = ':';\n\t*tp++ = '\\0';\n\n\t/* Check for overflow, copy, and we're done. */\n\tif ((socklen_t)(tp - tmp) size) {\n\t\t//__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\treturn strcpy(dst, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_ntop4",
          "args": [
            "src",
            "dst",
            "size"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "36-67",
          "snippet": "static const char *inet_ntop4(const u_char *src, char *dst, socklen_t size)\n{\n\tchar tmp[sizeof (\"255.255.255.255\") + 1] = \"\\0\";\n\tint octet;\n\tint i;\n\n\ti = 0;\n\tfor (octet = 0; octet <= 3; octet++) {\n\n\t\tif (src[octet]>255) {\n\t\t\t//__set_errno (ENOSPC);\n\t\t\treturn (NULL);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] / 100;\n\t\tif (tmp[i - 1] == '0') {\n\t\t\ttmp[i - 1] = '0' + (src[octet] / 10 % 10);\n\t\t\tif (tmp[i - 1] == '0') i--;\n\t\t} else {\n\t\t\ttmp[i++] = '0' + (src[octet] / 10 % 10);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] % 10;\n\t\ttmp[i++] = '.';\n\t}\n\ttmp[i - 1] = '\\0';\n\n\tif ((socklen_t)strlen(tmp)>size) {\n\t\t//__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\n\treturn strcpy(dst, tmp);\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nstatic const char *inet_ntop4(const u_char *src, char *dst, socklen_t size)\n{\n\tchar tmp[sizeof (\"255.255.255.255\") + 1] = \"\\0\";\n\tint octet;\n\tint i;\n\n\ti = 0;\n\tfor (octet = 0; octet <= 3; octet++) {\n\n\t\tif (src[octet]>255) {\n\t\t\t//__set_errno (ENOSPC);\n\t\t\treturn (NULL);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] / 100;\n\t\tif (tmp[i - 1] == '0') {\n\t\t\ttmp[i - 1] = '0' + (src[octet] / 10 % 10);\n\t\t\tif (tmp[i - 1] == '0') i--;\n\t\t} else {\n\t\t\ttmp[i++] = '0' + (src[octet] / 10 % 10);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] % 10;\n\t\ttmp[i++] = '.';\n\t}\n\ttmp[i - 1] = '\\0';\n\n\tif ((socklen_t)strlen(tmp)>size) {\n\t\t//__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\n\treturn strcpy(dst, tmp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inet_pton.h\"\n\nconst char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "inet_pton6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
    "lines": "207-287",
    "snippet": "static int inet_pton6(const char *src, u_char *dst)\n{\n\tstatic const char xdigits[] = \"0123456789abcdef\";\n\tu_char tmp[16], *tp, *endp, *colonp;\n\tconst char *curtok;\n\tint ch, saw_xdigit;\n\tu_int val;\n\n\ttp = memset(tmp, '\\0', 16);\n\tendp = tp + 16;\n\tcolonp = NULL;\n\t/* Leading :: requires some special handling. */\n\tif (*src == ':')\n\t\tif (*++src != ':')\n\t\t\treturn (0);\n\tcurtok = src;\n\tsaw_xdigit = 0;\n\tval = 0;\n\twhile ((ch = tolower (*src++)) != '\\0') {\n\t\tconst char *pch;\n\n\t\tpch = strchr(xdigits, ch);\n\t\tif (pch != NULL) {\n\t\t\tval <<= 4;\n\t\t\tval |= (pch - xdigits);\n\t\t\tif (val 0xffff)\n\t\t\t\treturn (0);\n\t\t\tsaw_xdigit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == ':') {\n\t\t\tcurtok = src;\n\t\t\tif (!saw_xdigit) {\n\t\t\t\tif (colonp)\n\t\t\t\t\treturn (0);\n\t\t\t\tcolonp = tp;\n\t\t\t\tcontinue;\n\t\t\t} else if (*src == '\\0') {\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tp + 2 endp)\n\t\t\t\treturn (0);\n\t\t\t*tp++ = (u_char) (val >8) & 0xff;\n\t\t\t*tp++ = (u_char) val & 0xff;\n\t\t\tsaw_xdigit = 0;\n\t\t\tval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' && ((tp + 4) <= endp) &&\n\t\t    inet_pton4(curtok, tp) 0) {\n\t\t\ttp += 4;\n\t\t\tsaw_xdigit = 0;\n\t\t\tbreak;\t/* '\\0' was seen by inet_pton4(). */\n\t\t}\n\t\treturn (0);\n\t}\n\tif (saw_xdigit) {\n\t\tif (tp + 2 endp)\n\t\t\treturn (0);\n\t\t*tp++ = (u_char) (val >8) & 0xff;\n\t\t*tp++ = (u_char) val & 0xff;\n\t}\n\tif (colonp != NULL) {\n\t\t/* Since some memmove()'s erroneously fail to handle\n\t\t * overlapping regions, we'll do the shift by hand. */\n\t\tconst int n = tp - colonp;\n\t\tint i;\n\n\t\tif (tp == endp)\n\t\t\treturn (0);\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tendp[- i] = colonp[n - i];\n\t\t\tcolonp[n - i] = 0;\n\t\t}\n\t\ttp = endp;\n\t}\n\tif (tp != endp)\n\t\treturn (0);\n\tmemcpy(dst, tmp, 16);\n\treturn (1);\n}",
    "includes": [
      "#include \"inet_pton.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "tmp",
            "16"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "val >8"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton4",
          "args": [
            "curtok",
            "tp"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "inet_pton4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "164-195",
          "snippet": "static int inet_pton4(const char *src,u_char *dst)\n{\n\tint saw_digit, octets, ch;\n\tu_char tmp[4], *tp;\n\n\tsaw_digit = 0;\n\toctets = 0;\n\t*(tp = tmp) = 0;\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (ch >= '0' && ch <= '9') {\n\t\t\tu_int new = *tp * 10 + (ch - '0');\n\t\t\tif (new>255)\n\t\t\t\treturn (0);\n\t\t\t*tp = new;\n\t\t\tif (! saw_digit) {\n\t\t\t\tif (++octets>4)\n\t\t\t\t\treturn (0);\n\t\t\t\tsaw_digit = 1;\n\t\t\t}\n\t\t} else if (ch == '.' && saw_digit) {\n\t\t\tif (octets == 4)\n\t\t\t\treturn (0);\n\t\t\t*++tp = 0;\n\t\t\tsaw_digit = 0;\n\t\t} else\n\t\t\treturn (0);\n\t}\n\tif (octets < 4)\n\t\treturn (0);\n\tmemcpy(dst, tmp, 4);\n\treturn 1;\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nstatic int inet_pton4(const char *src,u_char *dst)\n{\n\tint saw_digit, octets, ch;\n\tu_char tmp[4], *tp;\n\n\tsaw_digit = 0;\n\toctets = 0;\n\t*(tp = tmp) = 0;\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (ch >= '0' && ch <= '9') {\n\t\t\tu_int new = *tp * 10 + (ch - '0');\n\t\t\tif (new>255)\n\t\t\t\treturn (0);\n\t\t\t*tp = new;\n\t\t\tif (! saw_digit) {\n\t\t\t\tif (++octets>4)\n\t\t\t\t\treturn (0);\n\t\t\t\tsaw_digit = 1;\n\t\t\t}\n\t\t} else if (ch == '.' && saw_digit) {\n\t\t\tif (octets == 4)\n\t\t\t\treturn (0);\n\t\t\t*++tp = 0;\n\t\t\tsaw_digit = 0;\n\t\t} else\n\t\t\treturn (0);\n\t}\n\tif (octets < 4)\n\t\treturn (0);\n\tmemcpy(dst, tmp, 4);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "val >8"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "xdigits",
            "ch"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "*src++"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmp",
            "'\\0'",
            "16"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inet_pton.h\"\n\nstatic int inet_pton6(const char *src, u_char *dst)\n{\n\tstatic const char xdigits[] = \"0123456789abcdef\";\n\tu_char tmp[16], *tp, *endp, *colonp;\n\tconst char *curtok;\n\tint ch, saw_xdigit;\n\tu_int val;\n\n\ttp = memset(tmp, '\\0', 16);\n\tendp = tp + 16;\n\tcolonp = NULL;\n\t/* Leading :: requires some special handling. */\n\tif (*src == ':')\n\t\tif (*++src != ':')\n\t\t\treturn (0);\n\tcurtok = src;\n\tsaw_xdigit = 0;\n\tval = 0;\n\twhile ((ch = tolower (*src++)) != '\\0') {\n\t\tconst char *pch;\n\n\t\tpch = strchr(xdigits, ch);\n\t\tif (pch != NULL) {\n\t\t\tval <<= 4;\n\t\t\tval |= (pch - xdigits);\n\t\t\tif (val 0xffff)\n\t\t\t\treturn (0);\n\t\t\tsaw_xdigit = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == ':') {\n\t\t\tcurtok = src;\n\t\t\tif (!saw_xdigit) {\n\t\t\t\tif (colonp)\n\t\t\t\t\treturn (0);\n\t\t\t\tcolonp = tp;\n\t\t\t\tcontinue;\n\t\t\t} else if (*src == '\\0') {\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tp + 2 endp)\n\t\t\t\treturn (0);\n\t\t\t*tp++ = (u_char) (val >8) & 0xff;\n\t\t\t*tp++ = (u_char) val & 0xff;\n\t\t\tsaw_xdigit = 0;\n\t\t\tval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '.' && ((tp + 4) <= endp) &&\n\t\t    inet_pton4(curtok, tp) 0) {\n\t\t\ttp += 4;\n\t\t\tsaw_xdigit = 0;\n\t\t\tbreak;\t/* '\\0' was seen by inet_pton4(). */\n\t\t}\n\t\treturn (0);\n\t}\n\tif (saw_xdigit) {\n\t\tif (tp + 2 endp)\n\t\t\treturn (0);\n\t\t*tp++ = (u_char) (val >8) & 0xff;\n\t\t*tp++ = (u_char) val & 0xff;\n\t}\n\tif (colonp != NULL) {\n\t\t/* Since some memmove()'s erroneously fail to handle\n\t\t * overlapping regions, we'll do the shift by hand. */\n\t\tconst int n = tp - colonp;\n\t\tint i;\n\n\t\tif (tp == endp)\n\t\t\treturn (0);\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tendp[- i] = colonp[n - i];\n\t\t\tcolonp[n - i] = 0;\n\t\t}\n\t\ttp = endp;\n\t}\n\tif (tp != endp)\n\t\treturn (0);\n\tmemcpy(dst, tmp, 16);\n\treturn (1);\n}"
  },
  {
    "function_name": "inet_pton4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
    "lines": "164-195",
    "snippet": "static int inet_pton4(const char *src,u_char *dst)\n{\n\tint saw_digit, octets, ch;\n\tu_char tmp[4], *tp;\n\n\tsaw_digit = 0;\n\toctets = 0;\n\t*(tp = tmp) = 0;\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (ch >= '0' && ch <= '9') {\n\t\t\tu_int new = *tp * 10 + (ch - '0');\n\t\t\tif (new>255)\n\t\t\t\treturn (0);\n\t\t\t*tp = new;\n\t\t\tif (! saw_digit) {\n\t\t\t\tif (++octets>4)\n\t\t\t\t\treturn (0);\n\t\t\t\tsaw_digit = 1;\n\t\t\t}\n\t\t} else if (ch == '.' && saw_digit) {\n\t\t\tif (octets == 4)\n\t\t\t\treturn (0);\n\t\t\t*++tp = 0;\n\t\t\tsaw_digit = 0;\n\t\t} else\n\t\t\treturn (0);\n\t}\n\tif (octets < 4)\n\t\treturn (0);\n\tmemcpy(dst, tmp, 4);\n\treturn 1;\n}",
    "includes": [
      "#include \"inet_pton.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "tmp",
            "4"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inet_pton.h\"\n\nstatic int inet_pton4(const char *src,u_char *dst)\n{\n\tint saw_digit, octets, ch;\n\tu_char tmp[4], *tp;\n\n\tsaw_digit = 0;\n\toctets = 0;\n\t*(tp = tmp) = 0;\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (ch >= '0' && ch <= '9') {\n\t\t\tu_int new = *tp * 10 + (ch - '0');\n\t\t\tif (new>255)\n\t\t\t\treturn (0);\n\t\t\t*tp = new;\n\t\t\tif (! saw_digit) {\n\t\t\t\tif (++octets>4)\n\t\t\t\t\treturn (0);\n\t\t\t\tsaw_digit = 1;\n\t\t\t}\n\t\t} else if (ch == '.' && saw_digit) {\n\t\t\tif (octets == 4)\n\t\t\t\treturn (0);\n\t\t\t*++tp = 0;\n\t\t\tsaw_digit = 0;\n\t\t} else\n\t\t\treturn (0);\n\t}\n\tif (octets < 4)\n\t\treturn (0);\n\tmemcpy(dst, tmp, 4);\n\treturn 1;\n}"
  },
  {
    "function_name": "inet_ntop6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
    "lines": "73-154",
    "snippet": "static const char *inet_ntop6(const u_char *src, char *dst, socklen_t size)\n{\n\t/*\n\t * Note that int32_t and int16_t need only be \"at least\" large enough\n\t * to contain a value of the specified size.  On some systems, like\n\t * Crays, there is no such thing as an integer variable with 16 bits.\n\t * Keep this in mind if you think this function should have been coded\n\t * to use pointer overlays.  All the world's not a VAX.\n\t */\n\tchar tmp[sizeof (\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")], *tp;\n\tstruct { int base, len; } best, cur;\n\tu_int words[8];\n\tint i;\n\n\t/*\n\t * Preprocess:\n\t *\tCopy the input (bytewise) array into a wordwise array.\n\t *\tFind the longest run of 0x00's in src[] for :: shorthanding.\n\t */\n\tmemset(words, '\\0', sizeof words);\n\tfor (i = 0; i < 16; i += 2)\n\t\twords[i / 2] = (src[i] << 8) | src[i + 1];\n\tbest.base = -1;\n\tcur.base = -1;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (words[i] == 0) {\n\t\t\tif (cur.base == -1)\n\t\t\t\tcur.base = i, cur.len = 1;\n\t\t\telse\n\t\t\t\tcur.len++;\n\t\t} else {\n\t\t\tif (cur.base != -1) {\n\t\t\t\tif (best.base == -1 || cur.len best.len)\n\t\t\t\t\tbest = cur;\n\t\t\t\tcur.base = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.base != -1) {\n\t\tif (best.base == -1 || cur.len best.len)\n\t\t\tbest = cur;\n\t}\n\tif (best.base != -1 && best.len < 2)\n\t\tbest.base = -1;\n\n\t/*\n\t * Format the result.\n\t */\n\ttp = tmp;\n\tfor (i = 0; i < 8; i++) {\n\t\t/* Are we inside the best run of 0x00's? */\n\t\tif (best.base != -1 && i >= best.base &&\n\t\t    i < (best.base + best.len)) {\n\t\t\tif (i == best.base)\n\t\t\t\t*tp++ = ':';\n\t\t\tcontinue;\n\t\t}\n\t\t/* Are we following an initial run of 0x00s or any real hex? */\n\t\tif (i != 0)\n\t\t\t*tp++ = ':';\n\t\t/* Is this address an encapsulated IPv4? */\n\t\tif (i == 6 && best.base == 0 &&\n\t\t    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n\t\t\tif (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))\n\t\t\t\treturn (NULL);\n\t\t\ttp += strlen(tp);\n\t\t\tbreak;\n\t\t}\n\t\ttp += SPRINTF((tp, \"%x\", words[i]));\n\t}\n\t/* Was it a trailing run of 0x00's? */\n\tif (best.base != -1 && (best.base + best.len) == 8)\n\t\t*tp++ = ':';\n\t*tp++ = '\\0';\n\n\t/* Check for overflow, copy, and we're done. */\n\tif ((socklen_t)(tp - tmp) size) {\n\t\t//__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\treturn strcpy(dst, tmp);\n}",
    "includes": [
      "#include \"inet_pton.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dst",
            "tmp"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp - tmp"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPRINTF",
          "args": [
            "(tp, \"%x\", words[i])"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tp"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop4",
          "args": [
            "src+12",
            "tp",
            "sizeof tmp - (tp - tmp)"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "36-67",
          "snippet": "static const char *inet_ntop4(const u_char *src, char *dst, socklen_t size)\n{\n\tchar tmp[sizeof (\"255.255.255.255\") + 1] = \"\\0\";\n\tint octet;\n\tint i;\n\n\ti = 0;\n\tfor (octet = 0; octet <= 3; octet++) {\n\n\t\tif (src[octet]>255) {\n\t\t\t//__set_errno (ENOSPC);\n\t\t\treturn (NULL);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] / 100;\n\t\tif (tmp[i - 1] == '0') {\n\t\t\ttmp[i - 1] = '0' + (src[octet] / 10 % 10);\n\t\t\tif (tmp[i - 1] == '0') i--;\n\t\t} else {\n\t\t\ttmp[i++] = '0' + (src[octet] / 10 % 10);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] % 10;\n\t\ttmp[i++] = '.';\n\t}\n\ttmp[i - 1] = '\\0';\n\n\tif ((socklen_t)strlen(tmp)>size) {\n\t\t//__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\n\treturn strcpy(dst, tmp);\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nstatic const char *inet_ntop4(const u_char *src, char *dst, socklen_t size)\n{\n\tchar tmp[sizeof (\"255.255.255.255\") + 1] = \"\\0\";\n\tint octet;\n\tint i;\n\n\ti = 0;\n\tfor (octet = 0; octet <= 3; octet++) {\n\n\t\tif (src[octet]>255) {\n\t\t\t//__set_errno (ENOSPC);\n\t\t\treturn (NULL);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] / 100;\n\t\tif (tmp[i - 1] == '0') {\n\t\t\ttmp[i - 1] = '0' + (src[octet] / 10 % 10);\n\t\t\tif (tmp[i - 1] == '0') i--;\n\t\t} else {\n\t\t\ttmp[i++] = '0' + (src[octet] / 10 % 10);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] % 10;\n\t\ttmp[i++] = '.';\n\t}\n\ttmp[i - 1] = '\\0';\n\n\tif ((socklen_t)strlen(tmp)>size) {\n\t\t//__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\n\treturn strcpy(dst, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "words",
            "'\\0'",
            "sizeof words"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inet_pton.h\"\n\nstatic const char *inet_ntop6(const u_char *src, char *dst, socklen_t size)\n{\n\t/*\n\t * Note that int32_t and int16_t need only be \"at least\" large enough\n\t * to contain a value of the specified size.  On some systems, like\n\t * Crays, there is no such thing as an integer variable with 16 bits.\n\t * Keep this in mind if you think this function should have been coded\n\t * to use pointer overlays.  All the world's not a VAX.\n\t */\n\tchar tmp[sizeof (\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")], *tp;\n\tstruct { int base, len; } best, cur;\n\tu_int words[8];\n\tint i;\n\n\t/*\n\t * Preprocess:\n\t *\tCopy the input (bytewise) array into a wordwise array.\n\t *\tFind the longest run of 0x00's in src[] for :: shorthanding.\n\t */\n\tmemset(words, '\\0', sizeof words);\n\tfor (i = 0; i < 16; i += 2)\n\t\twords[i / 2] = (src[i] << 8) | src[i + 1];\n\tbest.base = -1;\n\tcur.base = -1;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (words[i] == 0) {\n\t\t\tif (cur.base == -1)\n\t\t\t\tcur.base = i, cur.len = 1;\n\t\t\telse\n\t\t\t\tcur.len++;\n\t\t} else {\n\t\t\tif (cur.base != -1) {\n\t\t\t\tif (best.base == -1 || cur.len best.len)\n\t\t\t\t\tbest = cur;\n\t\t\t\tcur.base = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.base != -1) {\n\t\tif (best.base == -1 || cur.len best.len)\n\t\t\tbest = cur;\n\t}\n\tif (best.base != -1 && best.len < 2)\n\t\tbest.base = -1;\n\n\t/*\n\t * Format the result.\n\t */\n\ttp = tmp;\n\tfor (i = 0; i < 8; i++) {\n\t\t/* Are we inside the best run of 0x00's? */\n\t\tif (best.base != -1 && i >= best.base &&\n\t\t    i < (best.base + best.len)) {\n\t\t\tif (i == best.base)\n\t\t\t\t*tp++ = ':';\n\t\t\tcontinue;\n\t\t}\n\t\t/* Are we following an initial run of 0x00s or any real hex? */\n\t\tif (i != 0)\n\t\t\t*tp++ = ':';\n\t\t/* Is this address an encapsulated IPv4? */\n\t\tif (i == 6 && best.base == 0 &&\n\t\t    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n\t\t\tif (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))\n\t\t\t\treturn (NULL);\n\t\t\ttp += strlen(tp);\n\t\t\tbreak;\n\t\t}\n\t\ttp += SPRINTF((tp, \"%x\", words[i]));\n\t}\n\t/* Was it a trailing run of 0x00's? */\n\tif (best.base != -1 && (best.base + best.len) == 8)\n\t\t*tp++ = ':';\n\t*tp++ = '\\0';\n\n\t/* Check for overflow, copy, and we're done. */\n\tif ((socklen_t)(tp - tmp) size) {\n\t\t//__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\treturn strcpy(dst, tmp);\n}"
  },
  {
    "function_name": "inet_ntop4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
    "lines": "36-67",
    "snippet": "static const char *inet_ntop4(const u_char *src, char *dst, socklen_t size)\n{\n\tchar tmp[sizeof (\"255.255.255.255\") + 1] = \"\\0\";\n\tint octet;\n\tint i;\n\n\ti = 0;\n\tfor (octet = 0; octet <= 3; octet++) {\n\n\t\tif (src[octet]>255) {\n\t\t\t//__set_errno (ENOSPC);\n\t\t\treturn (NULL);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] / 100;\n\t\tif (tmp[i - 1] == '0') {\n\t\t\ttmp[i - 1] = '0' + (src[octet] / 10 % 10);\n\t\t\tif (tmp[i - 1] == '0') i--;\n\t\t} else {\n\t\t\ttmp[i++] = '0' + (src[octet] / 10 % 10);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] % 10;\n\t\ttmp[i++] = '.';\n\t}\n\ttmp[i - 1] = '\\0';\n\n\tif ((socklen_t)strlen(tmp)>size) {\n\t\t//__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\n\treturn strcpy(dst, tmp);\n}",
    "includes": [
      "#include \"inet_pton.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dst",
            "tmp"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inet_pton.h\"\n\nstatic const char *inet_ntop4(const u_char *src, char *dst, socklen_t size)\n{\n\tchar tmp[sizeof (\"255.255.255.255\") + 1] = \"\\0\";\n\tint octet;\n\tint i;\n\n\ti = 0;\n\tfor (octet = 0; octet <= 3; octet++) {\n\n\t\tif (src[octet]>255) {\n\t\t\t//__set_errno (ENOSPC);\n\t\t\treturn (NULL);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] / 100;\n\t\tif (tmp[i - 1] == '0') {\n\t\t\ttmp[i - 1] = '0' + (src[octet] / 10 % 10);\n\t\t\tif (tmp[i - 1] == '0') i--;\n\t\t} else {\n\t\t\ttmp[i++] = '0' + (src[octet] / 10 % 10);\n\t\t}\n\t\ttmp[i++] = '0' + src[octet] % 10;\n\t\ttmp[i++] = '.';\n\t}\n\ttmp[i - 1] = '\\0';\n\n\tif ((socklen_t)strlen(tmp)>size) {\n\t\t//__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\n\treturn strcpy(dst, tmp);\n}"
  }
]