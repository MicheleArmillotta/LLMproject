[
  {
    "function_name": "StopMiniServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "962-1001",
    "snippet": "int StopMiniServer()\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tsocklen_t socklen = sizeof (struct sockaddr_in);\n\tSOCKET sock;\n\tstruct sockaddr_in ssdpAddr;\n\tchar buf[256] = \"ShutDown\";\n\tsize_t bufLen = strlen(buf);\n\n\tswitch(gMServState) {\n\tcase MSERV_RUNNING:\n\t\tgMServState = MSERV_STOPPING;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\"SSDP_SERVER: StopSSDPServer: Error in socket() %s\\n\",\n\t\t\terrorBuffer);\n\t\treturn 0;\n\t}\n\twhile(gMServState != (MiniServerState)MSERV_IDLE) {\n\t\tssdpAddr.sin_family = (sa_family_t)AF_INET;\n\t\tssdpAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\t\tssdpAddr.sin_port = htons(miniStopSockPort);\n\t\tsendto(sock, buf, bufLen, 0,\n\t\t\t(struct sockaddr *)&ssdpAddr, socklen);\n\t\tusleep(1000u);\n\t\tif (gMServState == (MiniServerState)MSERV_IDLE) {\n\t\t\tbreak;\n\t\t}\n\t\tisleep(1u);\n\t}\n\tsock_close(sock);\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_close",
          "args": [
            "sock"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "sock_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/sock.h",
          "lines": "79-89",
          "snippet": "static UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */",
            "#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */",
            "#include \"upnpconfig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */\n#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */\n#include \"upnpconfig.h\"\n\nstatic UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isleep",
          "args": [
            "1u"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000u"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendto",
          "args": [
            "sock",
            "buf",
            "bufLen",
            "0",
            "(struct sockaddr *)&ssdpAddr",
            "socklen"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "miniStopSockPort"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "SSDP",
            "__FILE__",
            "__LINE__",
            "\"SSDP_SERVER: StopSSDPServer: Error in socket() %s\\n\"",
            "errorBuffer"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nint StopMiniServer()\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tsocklen_t socklen = sizeof (struct sockaddr_in);\n\tSOCKET sock;\n\tstruct sockaddr_in ssdpAddr;\n\tchar buf[256] = \"ShutDown\";\n\tsize_t bufLen = strlen(buf);\n\n\tswitch(gMServState) {\n\tcase MSERV_RUNNING:\n\t\tgMServState = MSERV_STOPPING;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\"SSDP_SERVER: StopSSDPServer: Error in socket() %s\\n\",\n\t\t\terrorBuffer);\n\t\treturn 0;\n\t}\n\twhile(gMServState != (MiniServerState)MSERV_IDLE) {\n\t\tssdpAddr.sin_family = (sa_family_t)AF_INET;\n\t\tssdpAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\t\tssdpAddr.sin_port = htons(miniStopSockPort);\n\t\tsendto(sock, buf, bufLen, 0,\n\t\t\t(struct sockaddr *)&ssdpAddr, socklen);\n\t\tusleep(1000u);\n\t\tif (gMServState == (MiniServerState)MSERV_IDLE) {\n\t\t\tbreak;\n\t\t}\n\t\tisleep(1u);\n\t}\n\tsock_close(sock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "StartMiniServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "856-960",
    "snippet": "int StartMiniServer(\n\t/*! [in,out] Port on which the server listens for incoming IPv4\n\t * connections. */\n\tuint16_t *listen_port4, \n\t/*! [in,out] Port on which the server listens for incoming IPv6\n\t * connections. */\n\tuint16_t *listen_port6)\n{\n\tint ret_code;\n\tint count;\n\tint max_count = 10000;\n\tMiniServerSockArray *miniSocket;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tswitch (gMServState) {\n\tcase MSERV_IDLE:\n\t\tbreak;\n\tdefault:\n\t\t/* miniserver running. */\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tminiSocket = (MiniServerSockArray *)malloc(\n\t\tsizeof (MiniServerSockArray));\n\tif (!miniSocket) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tInitMiniServerSockArray(miniSocket);\n#ifdef INTERNAL_WEB_SERVER\n\t/* V4 and V6 http listeners. */\n\tret_code = get_miniserver_sockets(\n\t\tminiSocket, *listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t\t, *listen_port6\n#endif\n\t\t);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n#endif\n\t/* Stop socket (To end miniserver processing). */\n\tret_code = get_miniserver_stopsock(miniSocket);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n\t/* SSDP socket for discovery/advertising. */\n\tret_code = get_ssdp_sockets(miniSocket);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n\tTPJobInit(&job, (start_routine)RunMiniServer, (void *)miniSocket);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tTPJobSetFreeFunction(&job, (free_routine)free);\n\tret_code = ThreadPoolAddPersistent(&gMiniServerThreadPool, &job, NULL);\n\tif (ret_code < 0) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tsock_close(miniSocket->ssdpSock4);\n\t\tsock_close(miniSocket->ssdpSock6);\n\t\tsock_close(miniSocket->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tsock_close(miniSocket->ssdpReqSock4);\n\t\tsock_close(miniSocket->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tfree(miniSocket);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* Wait for miniserver to start. */\n\tcount = 0;\n\twhile (gMServState != (MiniServerState)MSERV_RUNNING && count < max_count) {\n\t\t/* 0.05s */\n\t\tusleep(50u * 1000u);\n\t\tcount++;\n\t}\n\tif (count >= max_count) {\n\t\t/* Took it too long to start that thread. */\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tsock_close(miniSocket->ssdpSock4);\n\t\tsock_close(miniSocket->ssdpSock6);\n\t\tsock_close(miniSocket->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tsock_close(miniSocket->ssdpReqSock4);\n\t\tsock_close(miniSocket->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n#ifdef INTERNAL_WEB_SERVER\n\t*listen_port4 = miniSocket->miniServerPort4;\n\t*listen_port6 = miniSocket->miniServerPort6;\n#endif\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_close",
          "args": [
            "miniSocket->ssdpReqSock6"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "sock_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/sock.h",
          "lines": "79-89",
          "snippet": "static UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */",
            "#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */",
            "#include \"upnpconfig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */\n#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */\n#include \"upnpconfig.h\"\n\nstatic UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50u * 1000u"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "miniSocket"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "free_handle_request_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "182-190",
          "snippet": "static void free_handle_request_arg(\n\t/*! [in] Request Message to be freed. */\n\tvoid *args)\n{\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\n\tsock_close(request->connfd);\n\tfree(request);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic void free_handle_request_arg(\n\t/*! [in] Request Message to be freed. */\n\tvoid *args)\n{\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\n\tsock_close(request->connfd);\n\tfree(request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolAddPersistent",
          "args": [
            "&gMiniServerThreadPool",
            "&job",
            "NULL"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "(free_routine)free"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine)RunMiniServer",
            "(void *)miniSocket"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ssdp_sockets",
          "args": [
            "miniSocket"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "get_ssdp_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "1168-1240",
          "snippet": "int get_ssdp_sockets(MiniServerSockArray * out)\n{\n\tint retVal;\n\n#ifdef INCLUDE_CLIENT_APIS\n\tout->ssdpReqSock4 = INVALID_SOCKET;\n\tout->ssdpReqSock6 = INVALID_SOCKET;\n\t/* Create the IPv4 socket for SSDP REQUESTS */\n\tif (strlen(gIF_IPV4) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_reqv4(&out->ssdpReqSock4);\n\t\tif (retVal != UPNP_E_SUCCESS)\n\t\t\treturn retVal;\n\t\t/* For use by ssdp control point. */\n\t\tgSsdpReqSocket4 = out->ssdpReqSock4;\n\t} else\n\t\tout->ssdpReqSock4 = INVALID_SOCKET;\n\t/* Create the IPv6 socket for SSDP REQUESTS */\n#ifdef UPNP_ENABLE_IPV6\n\tif (strlen(gIF_IPV6) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_reqv6(&out->ssdpReqSock6);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\treturn retVal;\n\t\t}\n\t\t/* For use by ssdp control point. */\n\t\tgSsdpReqSocket6 = out->ssdpReqSock6;\n\t} else\n\t\tout->ssdpReqSock6 = INVALID_SOCKET;\n#endif /* IPv6 */\n#endif /* INCLUDE_CLIENT_APIS */\n\t/* Create the IPv4 socket for SSDP */\n\tif (strlen(gIF_IPV4) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v4(&out->ssdpSock4);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock4 = INVALID_SOCKET;\n\t/* Create the IPv6 socket for SSDP */\n#ifdef UPNP_ENABLE_IPV6\n\tif (strlen(gIF_IPV6) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v6(&out->ssdpSock6);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpSock4);\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock6 = INVALID_SOCKET;\n\tif (strlen(gIF_IPV6_ULA_GUA) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v6_ula_gua(&out->ssdpSock6UlaGua);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpSock4);\n\t\t\tUpnpCloseSocket(out->ssdpSock6);\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock6UlaGua = INVALID_SOCKET;\n#endif /* UPNP_ENABLE_IPV6 */\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nint get_ssdp_sockets(MiniServerSockArray * out)\n{\n\tint retVal;\n\n#ifdef INCLUDE_CLIENT_APIS\n\tout->ssdpReqSock4 = INVALID_SOCKET;\n\tout->ssdpReqSock6 = INVALID_SOCKET;\n\t/* Create the IPv4 socket for SSDP REQUESTS */\n\tif (strlen(gIF_IPV4) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_reqv4(&out->ssdpReqSock4);\n\t\tif (retVal != UPNP_E_SUCCESS)\n\t\t\treturn retVal;\n\t\t/* For use by ssdp control point. */\n\t\tgSsdpReqSocket4 = out->ssdpReqSock4;\n\t} else\n\t\tout->ssdpReqSock4 = INVALID_SOCKET;\n\t/* Create the IPv6 socket for SSDP REQUESTS */\n#ifdef UPNP_ENABLE_IPV6\n\tif (strlen(gIF_IPV6) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_reqv6(&out->ssdpReqSock6);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\treturn retVal;\n\t\t}\n\t\t/* For use by ssdp control point. */\n\t\tgSsdpReqSocket6 = out->ssdpReqSock6;\n\t} else\n\t\tout->ssdpReqSock6 = INVALID_SOCKET;\n#endif /* IPv6 */\n#endif /* INCLUDE_CLIENT_APIS */\n\t/* Create the IPv4 socket for SSDP */\n\tif (strlen(gIF_IPV4) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v4(&out->ssdpSock4);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock4 = INVALID_SOCKET;\n\t/* Create the IPv6 socket for SSDP */\n#ifdef UPNP_ENABLE_IPV6\n\tif (strlen(gIF_IPV6) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v6(&out->ssdpSock6);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpSock4);\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock6 = INVALID_SOCKET;\n\tif (strlen(gIF_IPV6_ULA_GUA) > (size_t)0) {\n\t\tretVal = create_ssdp_sock_v6_ula_gua(&out->ssdpSock6UlaGua);\n\t\tif (retVal != UPNP_E_SUCCESS) {\n\t\t\tUpnpCloseSocket(out->ssdpSock4);\n\t\t\tUpnpCloseSocket(out->ssdpSock6);\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tUpnpCloseSocket(out->ssdpReqSock4);\n\t\t\tUpnpCloseSocket(out->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\treturn retVal;\n\t\t}\n\t} else\n\t\tout->ssdpSock6UlaGua = INVALID_SOCKET;\n#endif /* UPNP_ENABLE_IPV6 */\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_miniserver_stopsock",
          "args": [
            "miniSocket"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_stopsock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "799-837",
          "snippet": "static int get_miniserver_stopsock(\n\t/*! [in] Miniserver Socket Array. */\n\tMiniServerSockArray *out)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_in stop_sockaddr;\n\tSOCKET miniServerStopSock = 0;\n\tint ret = 0;\n\n\tminiServerStopSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (miniServerStopSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* Bind to local socket. */\n\tmemset(&stop_sockaddr, 0, sizeof (stop_sockaddr));\n\tstop_sockaddr.sin_family = (sa_family_t)AF_INET;\n\tstop_sockaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\tret = bind(miniServerStopSock, (struct sockaddr *)&stop_sockaddr,\n\t\tsizeof(stop_sockaddr));\n\tif (ret == SOCKET_ERROR) {\n\t\tUpnpPrintf(UPNP_CRITICAL,\n\t\tMSERV, __FILE__, __LINE__,\n\t\t\t\"Error in binding localhost!!!\\n\");\n\t\tsock_close(miniServerStopSock);\n\t\treturn UPNP_E_SOCKET_BIND;\n\t}\n\tret = get_port(miniServerStopSock, &miniStopSockPort);\n\tif (ret < 0) {\n\t\tsock_close(miniServerStopSock);\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tout->miniServerStopSock = miniServerStopSock;\n\tout->stopPort = miniStopSockPort;\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic int get_miniserver_stopsock(\n\t/*! [in] Miniserver Socket Array. */\n\tMiniServerSockArray *out)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_in stop_sockaddr;\n\tSOCKET miniServerStopSock = 0;\n\tint ret = 0;\n\n\tminiServerStopSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (miniServerStopSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* Bind to local socket. */\n\tmemset(&stop_sockaddr, 0, sizeof (stop_sockaddr));\n\tstop_sockaddr.sin_family = (sa_family_t)AF_INET;\n\tstop_sockaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\tret = bind(miniServerStopSock, (struct sockaddr *)&stop_sockaddr,\n\t\tsizeof(stop_sockaddr));\n\tif (ret == SOCKET_ERROR) {\n\t\tUpnpPrintf(UPNP_CRITICAL,\n\t\tMSERV, __FILE__, __LINE__,\n\t\t\t\"Error in binding localhost!!!\\n\");\n\t\tsock_close(miniServerStopSock);\n\t\treturn UPNP_E_SOCKET_BIND;\n\t}\n\tret = get_port(miniServerStopSock, &miniStopSockPort);\n\tif (ret < 0) {\n\t\tsock_close(miniServerStopSock);\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tout->miniServerStopSock = miniServerStopSock;\n\tout->stopPort = miniStopSockPort;\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_miniserver_sockets",
          "args": [
            "miniSocket",
            "*listen_port4#ifdef UPNP_ENABLE_IPV6",
            "*listen_port6#endif"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitMiniServerSockArray",
          "args": [
            "miniSocket"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "InitMiniServerSockArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "839-854",
          "snippet": "static UPNP_INLINE void InitMiniServerSockArray(MiniServerSockArray *miniSocket)\n{\n\tminiSocket->miniServerSock4 = INVALID_SOCKET;\n\tminiSocket->miniServerSock6 = INVALID_SOCKET;\n\tminiSocket->miniServerStopSock = INVALID_SOCKET;\n\tminiSocket->ssdpSock4 = INVALID_SOCKET;\n\tminiSocket->ssdpSock6 = INVALID_SOCKET;\n\tminiSocket->ssdpSock6UlaGua = INVALID_SOCKET;\n\tminiSocket->stopPort = 0u;\n\tminiSocket->miniServerPort4 = 0u;\n\tminiSocket->miniServerPort6 = 0u;\n#ifdef INCLUDE_CLIENT_APIS\n\tminiSocket->ssdpReqSock4 = INVALID_SOCKET;\n\tminiSocket->ssdpReqSock6 = INVALID_SOCKET;\n#endif /* INCLUDE_CLIENT_APIS */\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void InitMiniServerSockArray(MiniServerSockArray *miniSocket)\n{\n\tminiSocket->miniServerSock4 = INVALID_SOCKET;\n\tminiSocket->miniServerSock6 = INVALID_SOCKET;\n\tminiSocket->miniServerStopSock = INVALID_SOCKET;\n\tminiSocket->ssdpSock4 = INVALID_SOCKET;\n\tminiSocket->ssdpSock6 = INVALID_SOCKET;\n\tminiSocket->ssdpSock6UlaGua = INVALID_SOCKET;\n\tminiSocket->stopPort = 0u;\n\tminiSocket->miniServerPort4 = 0u;\n\tminiSocket->miniServerPort6 = 0u;\n#ifdef INCLUDE_CLIENT_APIS\n\tminiSocket->ssdpReqSock4 = INVALID_SOCKET;\n\tminiSocket->ssdpReqSock6 = INVALID_SOCKET;\n#endif /* INCLUDE_CLIENT_APIS */\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (MiniServerSockArray)"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&job",
            "0",
            "sizeof(job)"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nint StartMiniServer(\n\t/*! [in,out] Port on which the server listens for incoming IPv4\n\t * connections. */\n\tuint16_t *listen_port4, \n\t/*! [in,out] Port on which the server listens for incoming IPv6\n\t * connections. */\n\tuint16_t *listen_port6)\n{\n\tint ret_code;\n\tint count;\n\tint max_count = 10000;\n\tMiniServerSockArray *miniSocket;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tswitch (gMServState) {\n\tcase MSERV_IDLE:\n\t\tbreak;\n\tdefault:\n\t\t/* miniserver running. */\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tminiSocket = (MiniServerSockArray *)malloc(\n\t\tsizeof (MiniServerSockArray));\n\tif (!miniSocket) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tInitMiniServerSockArray(miniSocket);\n#ifdef INTERNAL_WEB_SERVER\n\t/* V4 and V6 http listeners. */\n\tret_code = get_miniserver_sockets(\n\t\tminiSocket, *listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t\t, *listen_port6\n#endif\n\t\t);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n#endif\n\t/* Stop socket (To end miniserver processing). */\n\tret_code = get_miniserver_stopsock(miniSocket);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n\t/* SSDP socket for discovery/advertising. */\n\tret_code = get_ssdp_sockets(miniSocket);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tfree(miniSocket);\n\t\treturn ret_code;\n\t}\n\tTPJobInit(&job, (start_routine)RunMiniServer, (void *)miniSocket);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tTPJobSetFreeFunction(&job, (free_routine)free);\n\tret_code = ThreadPoolAddPersistent(&gMiniServerThreadPool, &job, NULL);\n\tif (ret_code < 0) {\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tsock_close(miniSocket->ssdpSock4);\n\t\tsock_close(miniSocket->ssdpSock6);\n\t\tsock_close(miniSocket->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tsock_close(miniSocket->ssdpReqSock4);\n\t\tsock_close(miniSocket->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\tfree(miniSocket);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* Wait for miniserver to start. */\n\tcount = 0;\n\twhile (gMServState != (MiniServerState)MSERV_RUNNING && count < max_count) {\n\t\t/* 0.05s */\n\t\tusleep(50u * 1000u);\n\t\tcount++;\n\t}\n\tif (count >= max_count) {\n\t\t/* Took it too long to start that thread. */\n\t\tsock_close(miniSocket->miniServerSock4);\n\t\tsock_close(miniSocket->miniServerSock6);\n\t\tsock_close(miniSocket->miniServerStopSock);\n\t\tsock_close(miniSocket->ssdpSock4);\n\t\tsock_close(miniSocket->ssdpSock6);\n\t\tsock_close(miniSocket->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tsock_close(miniSocket->ssdpReqSock4);\n\t\tsock_close(miniSocket->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n#ifdef INTERNAL_WEB_SERVER\n\t*listen_port4 = miniSocket->miniServerPort4;\n\t*listen_port6 = miniSocket->miniServerPort6;\n#endif\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "InitMiniServerSockArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "839-854",
    "snippet": "static UPNP_INLINE void InitMiniServerSockArray(MiniServerSockArray *miniSocket)\n{\n\tminiSocket->miniServerSock4 = INVALID_SOCKET;\n\tminiSocket->miniServerSock6 = INVALID_SOCKET;\n\tminiSocket->miniServerStopSock = INVALID_SOCKET;\n\tminiSocket->ssdpSock4 = INVALID_SOCKET;\n\tminiSocket->ssdpSock6 = INVALID_SOCKET;\n\tminiSocket->ssdpSock6UlaGua = INVALID_SOCKET;\n\tminiSocket->stopPort = 0u;\n\tminiSocket->miniServerPort4 = 0u;\n\tminiSocket->miniServerPort6 = 0u;\n#ifdef INCLUDE_CLIENT_APIS\n\tminiSocket->ssdpReqSock4 = INVALID_SOCKET;\n\tminiSocket->ssdpReqSock6 = INVALID_SOCKET;\n#endif /* INCLUDE_CLIENT_APIS */\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void InitMiniServerSockArray(MiniServerSockArray *miniSocket)\n{\n\tminiSocket->miniServerSock4 = INVALID_SOCKET;\n\tminiSocket->miniServerSock6 = INVALID_SOCKET;\n\tminiSocket->miniServerStopSock = INVALID_SOCKET;\n\tminiSocket->ssdpSock4 = INVALID_SOCKET;\n\tminiSocket->ssdpSock6 = INVALID_SOCKET;\n\tminiSocket->ssdpSock6UlaGua = INVALID_SOCKET;\n\tminiSocket->stopPort = 0u;\n\tminiSocket->miniServerPort4 = 0u;\n\tminiSocket->miniServerPort6 = 0u;\n#ifdef INCLUDE_CLIENT_APIS\n\tminiSocket->ssdpReqSock4 = INVALID_SOCKET;\n\tminiSocket->ssdpReqSock6 = INVALID_SOCKET;\n#endif /* INCLUDE_CLIENT_APIS */\n}"
  },
  {
    "function_name": "get_miniserver_stopsock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "799-837",
    "snippet": "static int get_miniserver_stopsock(\n\t/*! [in] Miniserver Socket Array. */\n\tMiniServerSockArray *out)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_in stop_sockaddr;\n\tSOCKET miniServerStopSock = 0;\n\tint ret = 0;\n\n\tminiServerStopSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (miniServerStopSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* Bind to local socket. */\n\tmemset(&stop_sockaddr, 0, sizeof (stop_sockaddr));\n\tstop_sockaddr.sin_family = (sa_family_t)AF_INET;\n\tstop_sockaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\tret = bind(miniServerStopSock, (struct sockaddr *)&stop_sockaddr,\n\t\tsizeof(stop_sockaddr));\n\tif (ret == SOCKET_ERROR) {\n\t\tUpnpPrintf(UPNP_CRITICAL,\n\t\tMSERV, __FILE__, __LINE__,\n\t\t\t\"Error in binding localhost!!!\\n\");\n\t\tsock_close(miniServerStopSock);\n\t\treturn UPNP_E_SOCKET_BIND;\n\t}\n\tret = get_port(miniServerStopSock, &miniStopSockPort);\n\tif (ret < 0) {\n\t\tsock_close(miniServerStopSock);\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tout->miniServerStopSock = miniServerStopSock;\n\tout->stopPort = miniStopSockPort;\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_close",
          "args": [
            "miniServerStopSock"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "sock_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/sock.h",
          "lines": "79-89",
          "snippet": "static UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */",
            "#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */",
            "#include \"upnpconfig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */\n#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */\n#include \"upnpconfig.h\"\n\nstatic UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_port",
          "args": [
            "miniServerStopSock",
            "&miniStopSockPort"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "get_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "458-482",
          "snippet": "static int get_port(\n\t/*! [in] Socket descriptor. */\n\tSOCKET sockfd,\n\t/*! [out] The port value if successful, otherwise, untouched. */\n\tuint16_t *port)\n{\n\tstruct sockaddr_storage sockinfo;\n\tsocklen_t len;\n\tint code;\n\n\tlen = sizeof(sockinfo);\n\tcode = getsockname(sockfd, (struct sockaddr *)&sockinfo, &len);\n\tif (code == -1) {\n\t\treturn -1;\n\t}\n\tif (sockinfo.ss_family == AF_INET) {\n\t\t*port = ntohs(((struct sockaddr_in*)&sockinfo)->sin_port);\n\t} else if(sockinfo.ss_family == AF_INET6) {\n\t\t*port = ntohs(((struct sockaddr_in6*)&sockinfo)->sin6_port);\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"sockfd = %d, .... port = %d\\n\", sockfd, (int)*port);\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic int get_port(\n\t/*! [in] Socket descriptor. */\n\tSOCKET sockfd,\n\t/*! [out] The port value if successful, otherwise, untouched. */\n\tuint16_t *port)\n{\n\tstruct sockaddr_storage sockinfo;\n\tsocklen_t len;\n\tint code;\n\n\tlen = sizeof(sockinfo);\n\tcode = getsockname(sockfd, (struct sockaddr *)&sockinfo, &len);\n\tif (code == -1) {\n\t\treturn -1;\n\t}\n\tif (sockinfo.ss_family == AF_INET) {\n\t\t*port = ntohs(((struct sockaddr_in*)&sockinfo)->sin_port);\n\t} else if(sockinfo.ss_family == AF_INET6) {\n\t\t*port = ntohs(((struct sockaddr_in6*)&sockinfo)->sin6_port);\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"sockfd = %d, .... port = %d\\n\", sockfd, (int)*port);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_CRITICAL",
            "MSERV",
            "__FILE__",
            "__LINE__",
            "\"Error in binding localhost!!!\\n\""
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "miniServerStopSock",
            "(struct sockaddr *)&stop_sockaddr",
            "sizeof(stop_sockaddr)"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&stop_sockaddr",
            "0",
            "sizeof (stop_sockaddr)"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic int get_miniserver_stopsock(\n\t/*! [in] Miniserver Socket Array. */\n\tMiniServerSockArray *out)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_in stop_sockaddr;\n\tSOCKET miniServerStopSock = 0;\n\tint ret = 0;\n\n\tminiServerStopSock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (miniServerStopSock == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"Error in socket(): %s\\n\", errorBuffer);\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* Bind to local socket. */\n\tmemset(&stop_sockaddr, 0, sizeof (stop_sockaddr));\n\tstop_sockaddr.sin_family = (sa_family_t)AF_INET;\n\tstop_sockaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\tret = bind(miniServerStopSock, (struct sockaddr *)&stop_sockaddr,\n\t\tsizeof(stop_sockaddr));\n\tif (ret == SOCKET_ERROR) {\n\t\tUpnpPrintf(UPNP_CRITICAL,\n\t\tMSERV, __FILE__, __LINE__,\n\t\t\t\"Error in binding localhost!!!\\n\");\n\t\tsock_close(miniServerStopSock);\n\t\treturn UPNP_E_SOCKET_BIND;\n\t}\n\tret = get_port(miniServerStopSock, &miniStopSockPort);\n\tif (ret < 0) {\n\t\tsock_close(miniServerStopSock);\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tout->miniServerStopSock = miniServerStopSock;\n\tout->stopPort = miniStopSockPort;\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "get_miniserver_sockets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "500-786",
    "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define APPLICATION_LISTENING_PORT 49152"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_close",
          "args": [
            "listenfd6"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "sock_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/sock.h",
          "lines": "79-89",
          "snippet": "static UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */",
            "#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */",
            "#include \"upnpconfig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */\n#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */\n#include \"upnpconfig.h\"\n\nstatic UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_port",
          "args": [
            "listenfd6",
            "&actual_port6"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "get_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "458-482",
          "snippet": "static int get_port(\n\t/*! [in] Socket descriptor. */\n\tSOCKET sockfd,\n\t/*! [out] The port value if successful, otherwise, untouched. */\n\tuint16_t *port)\n{\n\tstruct sockaddr_storage sockinfo;\n\tsocklen_t len;\n\tint code;\n\n\tlen = sizeof(sockinfo);\n\tcode = getsockname(sockfd, (struct sockaddr *)&sockinfo, &len);\n\tif (code == -1) {\n\t\treturn -1;\n\t}\n\tif (sockinfo.ss_family == AF_INET) {\n\t\t*port = ntohs(((struct sockaddr_in*)&sockinfo)->sin_port);\n\t} else if(sockinfo.ss_family == AF_INET6) {\n\t\t*port = ntohs(((struct sockaddr_in6*)&sockinfo)->sin6_port);\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"sockfd = %d, .... port = %d\\n\", sockfd, (int)*port);\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic int get_port(\n\t/*! [in] Socket descriptor. */\n\tSOCKET sockfd,\n\t/*! [out] The port value if successful, otherwise, untouched. */\n\tuint16_t *port)\n{\n\tstruct sockaddr_storage sockinfo;\n\tsocklen_t len;\n\tint code;\n\n\tlen = sizeof(sockinfo);\n\tcode = getsockname(sockfd, (struct sockaddr *)&sockinfo, &len);\n\tif (code == -1) {\n\t\treturn -1;\n\t}\n\tif (sockinfo.ss_family == AF_INET) {\n\t\t*port = ntohs(((struct sockaddr_in*)&sockinfo)->sin_port);\n\t} else if(sockinfo.ss_family == AF_INET6) {\n\t\t*port = ntohs(((struct sockaddr_in6*)&sockinfo)->sin6_port);\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"sockfd = %d, .... port = %d\\n\", sockfd, (int)*port);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "MSERV",
            "__FILE__",
            "__LINE__",
            "\"mserv start: Error in IPv6 listen(): %s\\n\"",
            "errorBuffer"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "listenfd6",
            "SOMAXCONN"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "listenfd4",
            "SOMAXCONN"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "listenfd6",
            "(struct sockaddr *)serverAddr6",
            "sizeof(*serverAddr6)"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "listen_port6++"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "listenfd4",
            "(struct sockaddr *)serverAddr4",
            "sizeof(*serverAddr4)"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "listen_port4++"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "listenfd6",
            "(struct sockaddr *)&__ss_v6",
            "sizeof (__ss_v6)"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "listen_port6"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "listenfd6",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(const char *)&reuseaddr_on",
            "sizeof (int)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "listenfd4",
            "(struct sockaddr *)&__ss_v4",
            "sizeof (__ss_v4)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "listen_port4"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "listenfd4",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(const char *)&reuseaddr_on",
            "sizeof (int)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET6",
            "gIF_IPV6",
            "&serverAddr6->sin6_addr"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "inet_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "307-321",
          "snippet": "int inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nint inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&__ss_v6",
            "0",
            "sizeof (__ss_v6)"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "listenfd6",
            "IPPROTO_IPV6",
            "IPV6_V6ONLY",
            "(char *)&onOff",
            "sizeof(onOff)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET6",
            "SOCK_STREAM",
            "0"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "458-482",
    "snippet": "static int get_port(\n\t/*! [in] Socket descriptor. */\n\tSOCKET sockfd,\n\t/*! [out] The port value if successful, otherwise, untouched. */\n\tuint16_t *port)\n{\n\tstruct sockaddr_storage sockinfo;\n\tsocklen_t len;\n\tint code;\n\n\tlen = sizeof(sockinfo);\n\tcode = getsockname(sockfd, (struct sockaddr *)&sockinfo, &len);\n\tif (code == -1) {\n\t\treturn -1;\n\t}\n\tif (sockinfo.ss_family == AF_INET) {\n\t\t*port = ntohs(((struct sockaddr_in*)&sockinfo)->sin_port);\n\t} else if(sockinfo.ss_family == AF_INET6) {\n\t\t*port = ntohs(((struct sockaddr_in6*)&sockinfo)->sin6_port);\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"sockfd = %d, .... port = %d\\n\", sockfd, (int)*port);\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "MSERV",
            "__FILE__",
            "__LINE__",
            "\"sockfd = %d, .... port = %d\\n\"",
            "sockfd",
            "(int)*port"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "((struct sockaddr_in6*)&sockinfo)->sin6_port"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "((struct sockaddr_in*)&sockinfo)->sin_port"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "sockfd",
            "(struct sockaddr *)&sockinfo",
            "&len"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic int get_port(\n\t/*! [in] Socket descriptor. */\n\tSOCKET sockfd,\n\t/*! [out] The port value if successful, otherwise, untouched. */\n\tuint16_t *port)\n{\n\tstruct sockaddr_storage sockinfo;\n\tsocklen_t len;\n\tint code;\n\n\tlen = sizeof(sockinfo);\n\tcode = getsockname(sockfd, (struct sockaddr *)&sockinfo, &len);\n\tif (code == -1) {\n\t\treturn -1;\n\t}\n\tif (sockinfo.ss_family == AF_INET) {\n\t\t*port = ntohs(((struct sockaddr_in*)&sockinfo)->sin_port);\n\t} else if(sockinfo.ss_family == AF_INET6) {\n\t\t*port = ntohs(((struct sockaddr_in6*)&sockinfo)->sin6_port);\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"sockfd = %d, .... port = %d\\n\", sockfd, (int)*port);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "RunMiniServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "371-451",
    "snippet": "static void RunMiniServer(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *miniSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tfd_set expSet;\n\tfd_set rdSet;\n\tSOCKET maxMiniSock;\n\tint ret = 0;\n\tint stopSock = 0;\n\n\tmaxMiniSock = 0;\n\tmaxMiniSock = max(maxMiniSock, miniSock->miniServerSock4);\n\tmaxMiniSock = max(maxMiniSock, miniSock->miniServerSock6);\n\tmaxMiniSock = max(maxMiniSock, miniSock->miniServerStopSock);\n\tmaxMiniSock = max(maxMiniSock, miniSock->ssdpSock4);\n\tmaxMiniSock = max(maxMiniSock, miniSock->ssdpSock6);\n\tmaxMiniSock = max(maxMiniSock, miniSock->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\tmaxMiniSock = max(maxMiniSock, miniSock->ssdpReqSock4);\n\tmaxMiniSock = max(maxMiniSock, miniSock->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t++maxMiniSock;\n\n\tgMServState = MSERV_RUNNING;\n\twhile (!stopSock) {\n\t\tFD_ZERO(&rdSet);\n\t\tFD_ZERO(&expSet);\n\t\t/* FD_SET()'s */\n\t\tFD_SET(miniSock->miniServerStopSock, &expSet);\n\t\tFD_SET(miniSock->miniServerStopSock, &rdSet);\n\t\tfdset_if_valid(miniSock->miniServerSock4, &rdSet);\n\t\tfdset_if_valid(miniSock->miniServerSock6, &rdSet);\n\t\tfdset_if_valid(miniSock->ssdpSock4, &rdSet);\n\t\tfdset_if_valid(miniSock->ssdpSock6, &rdSet);\n\t\tfdset_if_valid(miniSock->ssdpSock6UlaGua, &rdSet);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tfdset_if_valid(miniSock->ssdpReqSock4, &rdSet);\n\t\tfdset_if_valid(miniSock->ssdpReqSock6, &rdSet);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t/* select() */\n\t\tret = select((int) maxMiniSock, &rdSet, NULL, &expSet, NULL);\n\t\tif (ret == SOCKET_ERROR && errno == EINTR) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t\t\"Error in select(): %s\\n\", errorBuffer);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tweb_server_accept(miniSock->miniServerSock4, &rdSet);\n\t\t\tweb_server_accept(miniSock->miniServerSock6, &rdSet);\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tssdp_read(miniSock->ssdpReqSock4, &rdSet);\n\t\t\tssdp_read(miniSock->ssdpReqSock6, &rdSet);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\tssdp_read(miniSock->ssdpSock4, &rdSet);\n\t\t\tssdp_read(miniSock->ssdpSock6, &rdSet);\n\t\t\tssdp_read(miniSock->ssdpSock6UlaGua, &rdSet);\n\t\t\tstopSock = receive_from_stopSock(\n\t\t\t\tminiSock->miniServerStopSock, &rdSet);\n\t\t}\n\t}\n\t/* Close all sockets. */\n\tsock_close(miniSock->miniServerSock4);\n\tsock_close(miniSock->miniServerSock6);\n\tsock_close(miniSock->miniServerStopSock);\n\tsock_close(miniSock->ssdpSock4);\n\tsock_close(miniSock->ssdpSock6);\n\tsock_close(miniSock->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\tsock_close(miniSock->ssdpReqSock4);\n\tsock_close(miniSock->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t/* Free minisock. */\n\tfree(miniSock);\n\tgMServState = MSERV_IDLE;\n\n\treturn;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "miniSock"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "free_handle_request_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "182-190",
          "snippet": "static void free_handle_request_arg(\n\t/*! [in] Request Message to be freed. */\n\tvoid *args)\n{\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\n\tsock_close(request->connfd);\n\tfree(request);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic void free_handle_request_arg(\n\t/*! [in] Request Message to be freed. */\n\tvoid *args)\n{\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\n\tsock_close(request->connfd);\n\tfree(request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_close",
          "args": [
            "miniSock->ssdpReqSock6"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "sock_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/sock.h",
          "lines": "79-89",
          "snippet": "static UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */",
            "#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */",
            "#include \"upnpconfig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */\n#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */\n#include \"upnpconfig.h\"\n\nstatic UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_from_stopSock",
          "args": [
            "miniSock->miniServerStopSock",
            "&rdSet"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "receive_from_stopSock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "331-362",
          "snippet": "static int receive_from_stopSock(SOCKET ssock, fd_set *set)\n{\n\tssize_t byteReceived;\n\tsocklen_t clientLen;\n\tstruct sockaddr_storage clientAddr;\n\tchar requestBuf[256];\n\tchar buf_ntop[INET6_ADDRSTRLEN];\n\n\tif (FD_ISSET(ssock, set)) {\n\t\tclientLen = sizeof(clientAddr);\n\t\tmemset((char *)&clientAddr, 0, sizeof(clientAddr));\n\t\tbyteReceived = recvfrom(ssock, requestBuf,\n\t\t\t(size_t)25, 0, (struct sockaddr *)&clientAddr, &clientLen);\n\t\tif (byteReceived > 0) {\n\t\t\trequestBuf[byteReceived] = '\\0';\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t&((struct sockaddr_in*)&clientAddr)->sin_addr,\n\t\t\t\tbuf_ntop, sizeof(buf_ntop));\n\t\t\tUpnpPrintf( UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"Received response: %s From host %s \\n\",\n\t\t\t\trequestBuf, buf_ntop );\n\t\t\tUpnpPrintf( UPNP_PACKET, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"Received multicast packet: \\n %s\\n\",\n\t\t\t\trequestBuf);\n\t\t\tif (NULL != strstr(requestBuf, \"ShutDown\")) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic int receive_from_stopSock(SOCKET ssock, fd_set *set)\n{\n\tssize_t byteReceived;\n\tsocklen_t clientLen;\n\tstruct sockaddr_storage clientAddr;\n\tchar requestBuf[256];\n\tchar buf_ntop[INET6_ADDRSTRLEN];\n\n\tif (FD_ISSET(ssock, set)) {\n\t\tclientLen = sizeof(clientAddr);\n\t\tmemset((char *)&clientAddr, 0, sizeof(clientAddr));\n\t\tbyteReceived = recvfrom(ssock, requestBuf,\n\t\t\t(size_t)25, 0, (struct sockaddr *)&clientAddr, &clientLen);\n\t\tif (byteReceived > 0) {\n\t\t\trequestBuf[byteReceived] = '\\0';\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t&((struct sockaddr_in*)&clientAddr)->sin_addr,\n\t\t\t\tbuf_ntop, sizeof(buf_ntop));\n\t\t\tUpnpPrintf( UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"Received response: %s From host %s \\n\",\n\t\t\t\trequestBuf, buf_ntop );\n\t\t\tUpnpPrintf( UPNP_PACKET, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"Received multicast packet: \\n %s\\n\",\n\t\t\t\trequestBuf);\n\t\t\tif (NULL != strstr(requestBuf, \"ShutDown\")) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssdp_read",
          "args": [
            "miniSock->ssdpSock6UlaGua",
            "&rdSet"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "ssdp_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "324-329",
          "snippet": "static void ssdp_read(SOCKET rsock, fd_set *set)\n{\n\tif (rsock != INVALID_SOCKET && FD_ISSET(rsock, set)) {\n\t\treadFromSSDPSocket(rsock);\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic void ssdp_read(SOCKET rsock, fd_set *set)\n{\n\tif (rsock != INVALID_SOCKET && FD_ISSET(rsock, set)) {\n\t\treadFromSSDPSocket(rsock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "web_server_accept",
          "args": [
            "miniSock->miniServerSock6",
            "&rdSet"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "web_server_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "299-322",
          "snippet": "static void web_server_accept(SOCKET lsock, fd_set *set)\n{\n#ifdef INTERNAL_WEB_SERVER\n\tSOCKET asock;\n\tsocklen_t clientLen;\n\tstruct sockaddr_storage clientAddr;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (lsock != INVALID_SOCKET && FD_ISSET(lsock, set)) {\n\t\tclientLen = sizeof(clientAddr);\n\t\tasock = accept(lsock, (struct sockaddr *)&clientAddr,\n\t\t\t&clientLen);\n\t\tif (asock == INVALID_SOCKET) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"miniserver: Error in accept(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t} else {\n\t\t\tschedule_request_job(asock,\n\t\t\t\t(struct sockaddr *)&clientAddr);\n\t\t}\n\t}\n#endif /* INTERNAL_WEB_SERVER */\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic void web_server_accept(SOCKET lsock, fd_set *set)\n{\n#ifdef INTERNAL_WEB_SERVER\n\tSOCKET asock;\n\tsocklen_t clientLen;\n\tstruct sockaddr_storage clientAddr;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (lsock != INVALID_SOCKET && FD_ISSET(lsock, set)) {\n\t\tclientLen = sizeof(clientAddr);\n\t\tasock = accept(lsock, (struct sockaddr *)&clientAddr,\n\t\t\t&clientLen);\n\t\tif (asock == INVALID_SOCKET) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"miniserver: Error in accept(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t} else {\n\t\t\tschedule_request_job(asock,\n\t\t\t\t(struct sockaddr *)&clientAddr);\n\t\t}\n\t}\n#endif /* INTERNAL_WEB_SERVER */\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_CRITICAL",
            "SSDP",
            "__FILE__",
            "__LINE__",
            "\"Error in select(): %s\\n\"",
            "errorBuffer"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "(int) maxMiniSock",
            "&rdSet",
            "NULL",
            "&expSet",
            "NULL"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdset_if_valid",
          "args": [
            "miniSock->ssdpReqSock6",
            "&rdSet"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "fdset_if_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "292-297",
          "snippet": "static UPNP_INLINE void fdset_if_valid(SOCKET sock, fd_set *set)\n{\n\tif (sock != INVALID_SOCKET) {\n\t\tFD_SET(sock, set);\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void fdset_if_valid(SOCKET sock, fd_set *set)\n{\n\tif (sock != INVALID_SOCKET) {\n\t\tFD_SET(sock, set);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "miniSock->miniServerStopSock",
            "&rdSet"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "miniSock->miniServerStopSock",
            "&expSet"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&expSet"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&rdSet"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "maxMiniSock",
            "miniSock->ssdpReqSock6"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "maxMiniSock",
            "miniSock->ssdpReqSock4"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "maxMiniSock",
            "miniSock->ssdpSock6UlaGua"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "maxMiniSock",
            "miniSock->ssdpSock6"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "maxMiniSock",
            "miniSock->ssdpSock4"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "maxMiniSock",
            "miniSock->miniServerStopSock"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "maxMiniSock",
            "miniSock->miniServerSock6"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "maxMiniSock",
            "miniSock->miniServerSock4"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic void RunMiniServer(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *miniSock)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tfd_set expSet;\n\tfd_set rdSet;\n\tSOCKET maxMiniSock;\n\tint ret = 0;\n\tint stopSock = 0;\n\n\tmaxMiniSock = 0;\n\tmaxMiniSock = max(maxMiniSock, miniSock->miniServerSock4);\n\tmaxMiniSock = max(maxMiniSock, miniSock->miniServerSock6);\n\tmaxMiniSock = max(maxMiniSock, miniSock->miniServerStopSock);\n\tmaxMiniSock = max(maxMiniSock, miniSock->ssdpSock4);\n\tmaxMiniSock = max(maxMiniSock, miniSock->ssdpSock6);\n\tmaxMiniSock = max(maxMiniSock, miniSock->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\tmaxMiniSock = max(maxMiniSock, miniSock->ssdpReqSock4);\n\tmaxMiniSock = max(maxMiniSock, miniSock->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t++maxMiniSock;\n\n\tgMServState = MSERV_RUNNING;\n\twhile (!stopSock) {\n\t\tFD_ZERO(&rdSet);\n\t\tFD_ZERO(&expSet);\n\t\t/* FD_SET()'s */\n\t\tFD_SET(miniSock->miniServerStopSock, &expSet);\n\t\tFD_SET(miniSock->miniServerStopSock, &rdSet);\n\t\tfdset_if_valid(miniSock->miniServerSock4, &rdSet);\n\t\tfdset_if_valid(miniSock->miniServerSock6, &rdSet);\n\t\tfdset_if_valid(miniSock->ssdpSock4, &rdSet);\n\t\tfdset_if_valid(miniSock->ssdpSock6, &rdSet);\n\t\tfdset_if_valid(miniSock->ssdpSock6UlaGua, &rdSet);\n#ifdef INCLUDE_CLIENT_APIS\n\t\tfdset_if_valid(miniSock->ssdpReqSock4, &rdSet);\n\t\tfdset_if_valid(miniSock->ssdpReqSock6, &rdSet);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t/* select() */\n\t\tret = select((int) maxMiniSock, &rdSet, NULL, &expSet, NULL);\n\t\tif (ret == SOCKET_ERROR && errno == EINTR) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,\n\t\t\t\t\"Error in select(): %s\\n\", errorBuffer);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tweb_server_accept(miniSock->miniServerSock4, &rdSet);\n\t\t\tweb_server_accept(miniSock->miniServerSock6, &rdSet);\n#ifdef INCLUDE_CLIENT_APIS\n\t\t\tssdp_read(miniSock->ssdpReqSock4, &rdSet);\n\t\t\tssdp_read(miniSock->ssdpReqSock6, &rdSet);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t\tssdp_read(miniSock->ssdpSock4, &rdSet);\n\t\t\tssdp_read(miniSock->ssdpSock6, &rdSet);\n\t\t\tssdp_read(miniSock->ssdpSock6UlaGua, &rdSet);\n\t\t\tstopSock = receive_from_stopSock(\n\t\t\t\tminiSock->miniServerStopSock, &rdSet);\n\t\t}\n\t}\n\t/* Close all sockets. */\n\tsock_close(miniSock->miniServerSock4);\n\tsock_close(miniSock->miniServerSock6);\n\tsock_close(miniSock->miniServerStopSock);\n\tsock_close(miniSock->ssdpSock4);\n\tsock_close(miniSock->ssdpSock6);\n\tsock_close(miniSock->ssdpSock6UlaGua);\n#ifdef INCLUDE_CLIENT_APIS\n\tsock_close(miniSock->ssdpReqSock4);\n\tsock_close(miniSock->ssdpReqSock6);\n#endif /* INCLUDE_CLIENT_APIS */\n\t/* Free minisock. */\n\tfree(miniSock);\n\tgMServState = MSERV_IDLE;\n\n\treturn;\n}"
  },
  {
    "function_name": "receive_from_stopSock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "331-362",
    "snippet": "static int receive_from_stopSock(SOCKET ssock, fd_set *set)\n{\n\tssize_t byteReceived;\n\tsocklen_t clientLen;\n\tstruct sockaddr_storage clientAddr;\n\tchar requestBuf[256];\n\tchar buf_ntop[INET6_ADDRSTRLEN];\n\n\tif (FD_ISSET(ssock, set)) {\n\t\tclientLen = sizeof(clientAddr);\n\t\tmemset((char *)&clientAddr, 0, sizeof(clientAddr));\n\t\tbyteReceived = recvfrom(ssock, requestBuf,\n\t\t\t(size_t)25, 0, (struct sockaddr *)&clientAddr, &clientLen);\n\t\tif (byteReceived > 0) {\n\t\t\trequestBuf[byteReceived] = '\\0';\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t&((struct sockaddr_in*)&clientAddr)->sin_addr,\n\t\t\t\tbuf_ntop, sizeof(buf_ntop));\n\t\t\tUpnpPrintf( UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"Received response: %s From host %s \\n\",\n\t\t\t\trequestBuf, buf_ntop );\n\t\t\tUpnpPrintf( UPNP_PACKET, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"Received multicast packet: \\n %s\\n\",\n\t\t\t\trequestBuf);\n\t\t\tif (NULL != strstr(requestBuf, \"ShutDown\")) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "requestBuf",
            "\"ShutDown\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_PACKET",
            "MSERV",
            "__FILE__",
            "__LINE__",
            "\"Received multicast packet: \\n %s\\n\"",
            "requestBuf"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "AF_INET",
            "&((struct sockaddr_in*)&clientAddr)->sin_addr",
            "buf_ntop",
            "sizeof(buf_ntop)"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "291-305",
          "snippet": "const char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nconst char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "recvfrom",
          "args": [
            "ssock",
            "requestBuf",
            "(size_t)25",
            "0",
            "(struct sockaddr *)&clientAddr",
            "&clientLen"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&clientAddr",
            "0",
            "sizeof(clientAddr)"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "ssock",
            "set"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic int receive_from_stopSock(SOCKET ssock, fd_set *set)\n{\n\tssize_t byteReceived;\n\tsocklen_t clientLen;\n\tstruct sockaddr_storage clientAddr;\n\tchar requestBuf[256];\n\tchar buf_ntop[INET6_ADDRSTRLEN];\n\n\tif (FD_ISSET(ssock, set)) {\n\t\tclientLen = sizeof(clientAddr);\n\t\tmemset((char *)&clientAddr, 0, sizeof(clientAddr));\n\t\tbyteReceived = recvfrom(ssock, requestBuf,\n\t\t\t(size_t)25, 0, (struct sockaddr *)&clientAddr, &clientLen);\n\t\tif (byteReceived > 0) {\n\t\t\trequestBuf[byteReceived] = '\\0';\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t&((struct sockaddr_in*)&clientAddr)->sin_addr,\n\t\t\t\tbuf_ntop, sizeof(buf_ntop));\n\t\t\tUpnpPrintf( UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"Received response: %s From host %s \\n\",\n\t\t\t\trequestBuf, buf_ntop );\n\t\t\tUpnpPrintf( UPNP_PACKET, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"Received multicast packet: \\n %s\\n\",\n\t\t\t\trequestBuf);\n\t\t\tif (NULL != strstr(requestBuf, \"ShutDown\")) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ssdp_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "324-329",
    "snippet": "static void ssdp_read(SOCKET rsock, fd_set *set)\n{\n\tif (rsock != INVALID_SOCKET && FD_ISSET(rsock, set)) {\n\t\treadFromSSDPSocket(rsock);\n\t}\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readFromSSDPSocket",
          "args": [
            "rsock"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "readFromSSDPSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "697-780",
          "snippet": "void readFromSSDPSocket(SOCKET socket)\n{\n\tchar *requestBuf = NULL;\n\tchar staticBuf[BUFSIZE];\n\tstruct sockaddr_storage __ss;\n\tThreadPoolJob job;\n\tssdp_thread_data *data = NULL;\n\tsocklen_t socklen = sizeof(__ss);\n\tssize_t byteReceived = 0;\n\tchar ntop_buf[INET6_ADDRSTRLEN];\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequestBuf = staticBuf;\n\t/* in case memory can't be allocated, still drain the socket using a\n\t * static buffer. */\n\tdata = malloc(sizeof(ssdp_thread_data));\n\tif (data) {\n\t\t/* initialize parser */\n#ifdef INCLUDE_CLIENT_APIS\n\t\tif (socket == gSsdpReqSocket4\n\t#ifdef UPNP_ENABLE_IPV6\n\t\t    || socket == gSsdpReqSocket6\n\t#endif /* UPNP_ENABLE_IPV6 */\n\t\t    )\n\t\t\tparser_response_init(&data->parser, HTTPMETHOD_MSEARCH);\n\t\telse\n\t\t\tparser_request_init(&data->parser);\n#else /* INCLUDE_CLIENT_APIS */\n\t\tparser_request_init(&data->parser);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t/* set size of parser buffer */\n\t\tif (membuffer_set_size(&data->parser.msg.msg, BUFSIZE) == 0)\n\t\t\t/* use this as the buffer for recv */\n\t\t\trequestBuf = data->parser.msg.msg.buf;\n\t\telse {\n\t\t\tfree(data);\n\t\t\tdata = NULL;\n\t\t}\n\t}\n\tbyteReceived = recvfrom(socket, requestBuf, BUFSIZE - (size_t)1, 0,\n\t\t\t\t(struct sockaddr *)&__ss, &socklen);\n\tif (byteReceived > 0) {\n\t\trequestBuf[byteReceived] = '\\0';\n\t\tswitch (__ss.ss_family) {\n\t\tcase AF_INET:\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t  &((struct sockaddr_in *)&__ss)->sin_addr,\n\t\t\t\t  ntop_buf, sizeof(ntop_buf));\n\t\t\tbreak;\n#ifdef UPNP_ENABLE_IPV6\n\t\tcase AF_INET6:\n\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t  &((struct sockaddr_in6 *)&__ss)->sin6_addr,\n\t\t\t\t  ntop_buf, sizeof(ntop_buf));\n\t\t\tbreak;\n#endif /* UPNP_ENABLE_IPV6 */\n\t\tdefault:\n\t\t\tmemset(ntop_buf, 0, sizeof(ntop_buf));\n\t\t\tstrncpy(ntop_buf, \"<Invalid address family>\",\n\t\t\t\tsizeof(ntop_buf) - 1);\n\t\t}\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Start of received response ----------------------------------------------------\\n\"\n\t\t\t   \"%s\\n\"\n\t\t\t   \"End of received response ------------------------------------------------------\\n\"\n\t\t\t   \"From host %s\\n\", requestBuf, ntop_buf);\n\t\t/* add thread pool job to handle request */\n\t\tif (data != NULL) {\n\t\t\tdata->parser.msg.msg.length += (size_t) byteReceived;\n\t\t\t/* null-terminate */\n\t\t\tdata->parser.msg.msg.buf[byteReceived] = 0;\n\t\t\tmemcpy(&data->dest_addr, &__ss, sizeof(__ss));\n\t\t\tTPJobInit(&job, (start_routine)\n\t\t\t\t  ssdp_event_handler_thread, data);\n\t\t\tTPJobSetFreeFunction(&job,\n\t\t\t\t\t     free_ssdp_event_handler_data);\n\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\tif (ThreadPoolAdd(&gRecvThreadPool, &job, NULL) != 0)\n\t\t\t\tfree_ssdp_event_handler_data(data);\n\t\t}\n\t} else\n\t\tfree_ssdp_event_handler_data(data);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nvoid readFromSSDPSocket(SOCKET socket)\n{\n\tchar *requestBuf = NULL;\n\tchar staticBuf[BUFSIZE];\n\tstruct sockaddr_storage __ss;\n\tThreadPoolJob job;\n\tssdp_thread_data *data = NULL;\n\tsocklen_t socklen = sizeof(__ss);\n\tssize_t byteReceived = 0;\n\tchar ntop_buf[INET6_ADDRSTRLEN];\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequestBuf = staticBuf;\n\t/* in case memory can't be allocated, still drain the socket using a\n\t * static buffer. */\n\tdata = malloc(sizeof(ssdp_thread_data));\n\tif (data) {\n\t\t/* initialize parser */\n#ifdef INCLUDE_CLIENT_APIS\n\t\tif (socket == gSsdpReqSocket4\n\t#ifdef UPNP_ENABLE_IPV6\n\t\t    || socket == gSsdpReqSocket6\n\t#endif /* UPNP_ENABLE_IPV6 */\n\t\t    )\n\t\t\tparser_response_init(&data->parser, HTTPMETHOD_MSEARCH);\n\t\telse\n\t\t\tparser_request_init(&data->parser);\n#else /* INCLUDE_CLIENT_APIS */\n\t\tparser_request_init(&data->parser);\n#endif /* INCLUDE_CLIENT_APIS */\n\t\t/* set size of parser buffer */\n\t\tif (membuffer_set_size(&data->parser.msg.msg, BUFSIZE) == 0)\n\t\t\t/* use this as the buffer for recv */\n\t\t\trequestBuf = data->parser.msg.msg.buf;\n\t\telse {\n\t\t\tfree(data);\n\t\t\tdata = NULL;\n\t\t}\n\t}\n\tbyteReceived = recvfrom(socket, requestBuf, BUFSIZE - (size_t)1, 0,\n\t\t\t\t(struct sockaddr *)&__ss, &socklen);\n\tif (byteReceived > 0) {\n\t\trequestBuf[byteReceived] = '\\0';\n\t\tswitch (__ss.ss_family) {\n\t\tcase AF_INET:\n\t\t\tinet_ntop(AF_INET,\n\t\t\t\t  &((struct sockaddr_in *)&__ss)->sin_addr,\n\t\t\t\t  ntop_buf, sizeof(ntop_buf));\n\t\t\tbreak;\n#ifdef UPNP_ENABLE_IPV6\n\t\tcase AF_INET6:\n\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t  &((struct sockaddr_in6 *)&__ss)->sin6_addr,\n\t\t\t\t  ntop_buf, sizeof(ntop_buf));\n\t\t\tbreak;\n#endif /* UPNP_ENABLE_IPV6 */\n\t\tdefault:\n\t\t\tmemset(ntop_buf, 0, sizeof(ntop_buf));\n\t\t\tstrncpy(ntop_buf, \"<Invalid address family>\",\n\t\t\t\tsizeof(ntop_buf) - 1);\n\t\t}\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"Start of received response ----------------------------------------------------\\n\"\n\t\t\t   \"%s\\n\"\n\t\t\t   \"End of received response ------------------------------------------------------\\n\"\n\t\t\t   \"From host %s\\n\", requestBuf, ntop_buf);\n\t\t/* add thread pool job to handle request */\n\t\tif (data != NULL) {\n\t\t\tdata->parser.msg.msg.length += (size_t) byteReceived;\n\t\t\t/* null-terminate */\n\t\t\tdata->parser.msg.msg.buf[byteReceived] = 0;\n\t\t\tmemcpy(&data->dest_addr, &__ss, sizeof(__ss));\n\t\t\tTPJobInit(&job, (start_routine)\n\t\t\t\t  ssdp_event_handler_thread, data);\n\t\t\tTPJobSetFreeFunction(&job,\n\t\t\t\t\t     free_ssdp_event_handler_data);\n\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\tif (ThreadPoolAdd(&gRecvThreadPool, &job, NULL) != 0)\n\t\t\t\tfree_ssdp_event_handler_data(data);\n\t\t}\n\t} else\n\t\tfree_ssdp_event_handler_data(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "rsock",
            "set"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic void ssdp_read(SOCKET rsock, fd_set *set)\n{\n\tif (rsock != INVALID_SOCKET && FD_ISSET(rsock, set)) {\n\t\treadFromSSDPSocket(rsock);\n\t}\n}"
  },
  {
    "function_name": "web_server_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "299-322",
    "snippet": "static void web_server_accept(SOCKET lsock, fd_set *set)\n{\n#ifdef INTERNAL_WEB_SERVER\n\tSOCKET asock;\n\tsocklen_t clientLen;\n\tstruct sockaddr_storage clientAddr;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (lsock != INVALID_SOCKET && FD_ISSET(lsock, set)) {\n\t\tclientLen = sizeof(clientAddr);\n\t\tasock = accept(lsock, (struct sockaddr *)&clientAddr,\n\t\t\t&clientLen);\n\t\tif (asock == INVALID_SOCKET) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"miniserver: Error in accept(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t} else {\n\t\t\tschedule_request_job(asock,\n\t\t\t\t(struct sockaddr *)&clientAddr);\n\t\t}\n\t}\n#endif /* INTERNAL_WEB_SERVER */\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_request_job",
          "args": [
            "asock",
            "(struct sockaddr *)&clientAddr"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_request_job",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "256-289",
          "snippet": "static UPNP_INLINE void schedule_request_job(\n\t/*! [in] Socket Descriptor on which connection is accepted. */\n\tSOCKET connfd,\n\t/*! [in] Clients Address information. */\n\tstruct sockaddr *clientAddr)\n{\n\tstruct mserv_request_t *request;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequest = (struct mserv_request_t *)malloc(\n\t\tsizeof (struct mserv_request_t));\n\tif (request == NULL) {\n\t\tUpnpPrintf( UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"mserv %d: out of memory\\n\", connfd);\n\t\tsock_close(connfd);\n\t\treturn;\n\t}\n\n\trequest->connfd = connfd;\n\tmemcpy(&request->foreign_sockaddr, clientAddr,\n\t\tsizeof(request->foreign_sockaddr));\n\tTPJobInit(&job, (start_routine)handle_request, (void *)request);\n\tTPJobSetFreeFunction(&job, free_handle_request_arg);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tif (ThreadPoolAdd(&gMiniServerThreadPool, &job, NULL) != 0) {\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"mserv %d: cannot schedule request\\n\", connfd);\n\t\tfree(request);\n\t\tsock_close(connfd);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void schedule_request_job(\n\t/*! [in] Socket Descriptor on which connection is accepted. */\n\tSOCKET connfd,\n\t/*! [in] Clients Address information. */\n\tstruct sockaddr *clientAddr)\n{\n\tstruct mserv_request_t *request;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequest = (struct mserv_request_t *)malloc(\n\t\tsizeof (struct mserv_request_t));\n\tif (request == NULL) {\n\t\tUpnpPrintf( UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"mserv %d: out of memory\\n\", connfd);\n\t\tsock_close(connfd);\n\t\treturn;\n\t}\n\n\trequest->connfd = connfd;\n\tmemcpy(&request->foreign_sockaddr, clientAddr,\n\t\tsizeof(request->foreign_sockaddr));\n\tTPJobInit(&job, (start_routine)handle_request, (void *)request);\n\tTPJobSetFreeFunction(&job, free_handle_request_arg);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tif (ThreadPoolAdd(&gMiniServerThreadPool, &job, NULL) != 0) {\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"mserv %d: cannot schedule request\\n\", connfd);\n\t\tfree(request);\n\t\tsock_close(connfd);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "MSERV",
            "__FILE__",
            "__LINE__",
            "\"miniserver: Error in accept(): %s\\n\"",
            "errorBuffer"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "lsock",
            "(struct sockaddr *)&clientAddr",
            "&clientLen"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "lsock",
            "set"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic void web_server_accept(SOCKET lsock, fd_set *set)\n{\n#ifdef INTERNAL_WEB_SERVER\n\tSOCKET asock;\n\tsocklen_t clientLen;\n\tstruct sockaddr_storage clientAddr;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (lsock != INVALID_SOCKET && FD_ISSET(lsock, set)) {\n\t\tclientLen = sizeof(clientAddr);\n\t\tasock = accept(lsock, (struct sockaddr *)&clientAddr,\n\t\t\t&clientLen);\n\t\tif (asock == INVALID_SOCKET) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"miniserver: Error in accept(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t} else {\n\t\t\tschedule_request_job(asock,\n\t\t\t\t(struct sockaddr *)&clientAddr);\n\t\t}\n\t}\n#endif /* INTERNAL_WEB_SERVER */\n}"
  },
  {
    "function_name": "fdset_if_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "292-297",
    "snippet": "static UPNP_INLINE void fdset_if_valid(SOCKET sock, fd_set *set)\n{\n\tif (sock != INVALID_SOCKET) {\n\t\tFD_SET(sock, set);\n\t}\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "sock",
            "set"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void fdset_if_valid(SOCKET sock, fd_set *set)\n{\n\tif (sock != INVALID_SOCKET) {\n\t\tFD_SET(sock, set);\n\t}\n}"
  },
  {
    "function_name": "schedule_request_job",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "256-289",
    "snippet": "static UPNP_INLINE void schedule_request_job(\n\t/*! [in] Socket Descriptor on which connection is accepted. */\n\tSOCKET connfd,\n\t/*! [in] Clients Address information. */\n\tstruct sockaddr *clientAddr)\n{\n\tstruct mserv_request_t *request;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequest = (struct mserv_request_t *)malloc(\n\t\tsizeof (struct mserv_request_t));\n\tif (request == NULL) {\n\t\tUpnpPrintf( UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"mserv %d: out of memory\\n\", connfd);\n\t\tsock_close(connfd);\n\t\treturn;\n\t}\n\n\trequest->connfd = connfd;\n\tmemcpy(&request->foreign_sockaddr, clientAddr,\n\t\tsizeof(request->foreign_sockaddr));\n\tTPJobInit(&job, (start_routine)handle_request, (void *)request);\n\tTPJobSetFreeFunction(&job, free_handle_request_arg);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tif (ThreadPoolAdd(&gMiniServerThreadPool, &job, NULL) != 0) {\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"mserv %d: cannot schedule request\\n\", connfd);\n\t\tfree(request);\n\t\tsock_close(connfd);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_close",
          "args": [
            "connfd"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "sock_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/sock.h",
          "lines": "79-89",
          "snippet": "static UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */",
            "#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */",
            "#include \"upnpconfig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */\n#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */\n#include \"upnpconfig.h\"\n\nstatic UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "request"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "free_handle_request_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "182-190",
          "snippet": "static void free_handle_request_arg(\n\t/*! [in] Request Message to be freed. */\n\tvoid *args)\n{\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\n\tsock_close(request->connfd);\n\tfree(request);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic void free_handle_request_arg(\n\t/*! [in] Request Message to be freed. */\n\tvoid *args)\n{\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\n\tsock_close(request->connfd);\n\tfree(request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "MSERV",
            "__FILE__",
            "__LINE__",
            "\"mserv %d: cannot schedule request\\n\"",
            "connfd"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gMiniServerThreadPool",
            "&job",
            "NULL"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "free_handle_request_arg"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine)handle_request",
            "(void *)request"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&request->foreign_sockaddr",
            "clientAddr",
            "sizeof(request->foreign_sockaddr)"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (struct mserv_request_t)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&job",
            "0",
            "sizeof(job)"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void schedule_request_job(\n\t/*! [in] Socket Descriptor on which connection is accepted. */\n\tSOCKET connfd,\n\t/*! [in] Clients Address information. */\n\tstruct sockaddr *clientAddr)\n{\n\tstruct mserv_request_t *request;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequest = (struct mserv_request_t *)malloc(\n\t\tsizeof (struct mserv_request_t));\n\tif (request == NULL) {\n\t\tUpnpPrintf( UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"mserv %d: out of memory\\n\", connfd);\n\t\tsock_close(connfd);\n\t\treturn;\n\t}\n\n\trequest->connfd = connfd;\n\tmemcpy(&request->foreign_sockaddr, clientAddr,\n\t\tsizeof(request->foreign_sockaddr));\n\tTPJobInit(&job, (start_routine)handle_request, (void *)request);\n\tTPJobSetFreeFunction(&job, free_handle_request_arg);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tif (ThreadPoolAdd(&gMiniServerThreadPool, &job, NULL) != 0) {\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"mserv %d: cannot schedule request\\n\", connfd);\n\t\tfree(request);\n\t\tsock_close(connfd);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "handle_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "195-250",
    "snippet": "static void handle_request(\n\t/*! [in] Request Message to be handled. */\n\tvoid *args)\n{\n\tSOCKINFO info;\n\tint http_error_code;\n\tint ret_code;\n\tint major = 1;\n\tint minor = 1;\n\thttp_parser_t parser;\n\thttp_message_t *hmsg = NULL;\n\tint timeout = HTTP_DEFAULT_TIMEOUT;\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\tSOCKET connfd = request->connfd;\n\n\tUpnpPrintf( UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"miniserver %d: READING\\n\", connfd );\n\t/* parser_request_init( &parser ); */ /* LEAK_FIX_MK */\n\thmsg = &parser.msg;\n\tret_code = sock_init_with_ip(\n\t\t&info, connfd, (struct sockaddr *)&request->foreign_sockaddr);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tfree(request);\n\t\thttpmsg_destroy(hmsg);\n\t\treturn;\n\t}\n\t/* read */\n\tret_code = http_RecvMessage(\n\t\t&info, &parser, HTTPMETHOD_UNKNOWN, &timeout, &http_error_code);\n\tif (ret_code != 0) {\n\t\tgoto error_handler;\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"miniserver %d: PROCESSING...\\n\", connfd);\n\t/* dispatch */\n\thttp_error_code = dispatch_request(&info, &parser);\n\tif (http_error_code != 0) {\n\t\tgoto error_handler;\n\t}\n\thttp_error_code = 0;\n\nerror_handler:\n\tif (http_error_code > 0) {\n\t\tif (hmsg) {\n\t\t\tmajor = hmsg->major_version;\n\t\t\tminor = hmsg->minor_version;\n\t\t}\n\t\thandle_error(&info, http_error_code, major, minor);\n\t}\n\tsock_destroy(&info, SD_BOTH);\n\thttpmsg_destroy(hmsg);\n\tfree(request);\n\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"miniserver %d: COMPLETE\\n\", connfd);\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "MSERV",
            "__FILE__",
            "__LINE__",
            "\"miniserver %d: COMPLETE\\n\"",
            "connfd"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "request"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "free_handle_request_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "182-190",
          "snippet": "static void free_handle_request_arg(\n\t/*! [in] Request Message to be freed. */\n\tvoid *args)\n{\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\n\tsock_close(request->connfd);\n\tfree(request);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic void free_handle_request_arg(\n\t/*! [in] Request Message to be freed. */\n\tvoid *args)\n{\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\n\tsock_close(request->connfd);\n\tfree(request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "hmsg"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_destroy",
          "args": [
            "&info",
            "SD_BOTH"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "sock_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "118-143",
          "snippet": "int sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_error",
          "args": [
            "&info",
            "http_error_code",
            "major",
            "minor"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "165-176",
          "snippet": "static UPNP_INLINE void handle_error(\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! [in] HTTP Error Code. */\n\tint http_error_code,\n\t/*! [in] Major Version Number. */\n\tint major,\n\t/*! [in] Minor Version Number. */\n\tint minor)\n{\n\thttp_SendStatusResponse(info, http_error_code, major, minor);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void handle_error(\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! [in] HTTP Error Code. */\n\tint http_error_code,\n\t/*! [in] Major Version Number. */\n\tint major,\n\t/*! [in] Minor Version Number. */\n\tint minor)\n{\n\thttp_SendStatusResponse(info, http_error_code, major, minor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dispatch_request",
          "args": [
            "&info",
            "&parser"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "dispatch_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "122-160",
          "snippet": "static int dispatch_request(\n\t/*! [in] Socket Information object. */\n\tIN SOCKINFO *info,\n\t/*! [in] HTTP parser object. */\n\thttp_parser_t *hparser)\n{\n\tMiniServerCallback callback;\n\n\tswitch (hparser->msg.method) {\n\t/* Soap Call */\n\tcase SOAPMETHOD_POST:\n\tcase HTTPMETHOD_MPOST:\n\t\tcallback = gSoapCallback;\n\t\tbreak;\n\t/* Gena Call */\n\tcase HTTPMETHOD_NOTIFY:\n\tcase HTTPMETHOD_SUBSCRIBE:\n\tcase HTTPMETHOD_UNSUBSCRIBE:\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"miniserver %d: got GENA msg\\n\", info->socket);\n\t\t\tcallback = gGenaCallback;\n\t\tbreak;\n\t/* HTTP server call */\n\tcase HTTPMETHOD_GET:\n\tcase HTTPMETHOD_POST:\n\tcase HTTPMETHOD_HEAD:\n\tcase HTTPMETHOD_SIMPLEGET:\n\t\tcallback = gGetCallback;\n\t\tbreak;\n\tdefault:\n\t\tcallback = NULL;\n\t}\n\tif (callback == NULL) {\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\tcallback(hparser, &hparser->msg, info);\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic int dispatch_request(\n\t/*! [in] Socket Information object. */\n\tIN SOCKINFO *info,\n\t/*! [in] HTTP parser object. */\n\thttp_parser_t *hparser)\n{\n\tMiniServerCallback callback;\n\n\tswitch (hparser->msg.method) {\n\t/* Soap Call */\n\tcase SOAPMETHOD_POST:\n\tcase HTTPMETHOD_MPOST:\n\t\tcallback = gSoapCallback;\n\t\tbreak;\n\t/* Gena Call */\n\tcase HTTPMETHOD_NOTIFY:\n\tcase HTTPMETHOD_SUBSCRIBE:\n\tcase HTTPMETHOD_UNSUBSCRIBE:\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"miniserver %d: got GENA msg\\n\", info->socket);\n\t\t\tcallback = gGenaCallback;\n\t\tbreak;\n\t/* HTTP server call */\n\tcase HTTPMETHOD_GET:\n\tcase HTTPMETHOD_POST:\n\tcase HTTPMETHOD_HEAD:\n\tcase HTTPMETHOD_SIMPLEGET:\n\t\tcallback = gGetCallback;\n\t\tbreak;\n\tdefault:\n\t\tcallback = NULL;\n\t}\n\tif (callback == NULL) {\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\tcallback(hparser, &hparser->msg, info);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_RecvMessage",
          "args": [
            "&info",
            "&parser",
            "HTTPMETHOD_UNKNOWN",
            "&timeout",
            "&http_error_code"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "http_RecvMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "344-435",
          "snippet": "int http_RecvMessage(\n\tIN SOCKINFO *info,\n\tOUT http_parser_t *parser,\n\tIN http_method_t request_method,\n\tIN OUT int *timeout_secs,\n\tOUT int *http_error_code)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tint line = 0;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar buf[2 * 1024];\n\n\tif (request_method == (http_method_t)HTTPMETHOD_UNKNOWN) {\n\t\tparser_request_init(parser);\n\t} else {\n\t\tparser_response_init(parser, request_method);\n\t}\n\n\twhile (TRUE) {\n\t\tnum_read = sock_read(info, buf, sizeof buf, timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* got data */\n\t\t\tstatus = parser_append(parser, buf, (size_t)num_read);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_SUCCESS:\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers( &parser->msg );\n\t\t\t\tif (g_maxContentLength > (size_t)0 && parser->content_length > (unsigned int)g_maxContentLength) {\n\t\t\t\t\t*http_error_code = HTTP_REQ_ENTITY_TOO_LARGE;\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_BOUNDS;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_FAILURE:\n\t\t\tcase PARSE_NO_MATCH:\n\t\t\t\t*http_error_code = parser->http_error_code;\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_INCOMPLETE_ENTITY:\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_CONTINUE_1:\n\t\t\t\t/* Web post request. */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = PARSE_SUCCESS;\n\t\t\t\tgoto ExitFunction;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*http_error_code = HTTP_BAD_REQUEST;    /* or response */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\tline = __LINE__;\n\t\t\tret = num_read;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, line,\n\t\t\t\"(http_RecvMessage): Error %d, http_error_code = %d.\\n\",\n\t\t\tret,\n\t\t\t*http_error_code);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_RecvMessage(\n\tIN SOCKINFO *info,\n\tOUT http_parser_t *parser,\n\tIN http_method_t request_method,\n\tIN OUT int *timeout_secs,\n\tOUT int *http_error_code)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tint line = 0;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar buf[2 * 1024];\n\n\tif (request_method == (http_method_t)HTTPMETHOD_UNKNOWN) {\n\t\tparser_request_init(parser);\n\t} else {\n\t\tparser_response_init(parser, request_method);\n\t}\n\n\twhile (TRUE) {\n\t\tnum_read = sock_read(info, buf, sizeof buf, timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* got data */\n\t\t\tstatus = parser_append(parser, buf, (size_t)num_read);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_SUCCESS:\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers( &parser->msg );\n\t\t\t\tif (g_maxContentLength > (size_t)0 && parser->content_length > (unsigned int)g_maxContentLength) {\n\t\t\t\t\t*http_error_code = HTTP_REQ_ENTITY_TOO_LARGE;\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_BOUNDS;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_FAILURE:\n\t\t\tcase PARSE_NO_MATCH:\n\t\t\t\t*http_error_code = parser->http_error_code;\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_INCOMPLETE_ENTITY:\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_CONTINUE_1:\n\t\t\t\t/* Web post request. */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = PARSE_SUCCESS;\n\t\t\t\tgoto ExitFunction;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*http_error_code = HTTP_BAD_REQUEST;    /* or response */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\tline = __LINE__;\n\t\t\tret = num_read;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, line,\n\t\t\t\"(http_RecvMessage): Error %d, http_error_code = %d.\\n\",\n\t\t\tret,\n\t\t\t*http_error_code);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_init_with_ip",
          "args": [
            "&info",
            "connfd",
            "(struct sockaddr *)&request->foreign_sockaddr"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "sock_init_with_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "83-97",
          "snippet": "int sock_init_with_ip(SOCKINFO *info, SOCKET sockfd,\n\tstruct sockaddr *foreign_sockaddr)\n{\n\tint ret;\n\n\tret = sock_init(info, sockfd);\n\tif (ret != UPNP_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tmemcpy(&info->foreign_sockaddr, foreign_sockaddr,\n\t       sizeof(info->foreign_sockaddr));\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_init_with_ip(SOCKINFO *info, SOCKET sockfd,\n\tstruct sockaddr *foreign_sockaddr)\n{\n\tint ret;\n\n\tret = sock_init(info, sockfd);\n\tif (ret != UPNP_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tmemcpy(&info->foreign_sockaddr, foreign_sockaddr,\n\t       sizeof(info->foreign_sockaddr));\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic void handle_request(\n\t/*! [in] Request Message to be handled. */\n\tvoid *args)\n{\n\tSOCKINFO info;\n\tint http_error_code;\n\tint ret_code;\n\tint major = 1;\n\tint minor = 1;\n\thttp_parser_t parser;\n\thttp_message_t *hmsg = NULL;\n\tint timeout = HTTP_DEFAULT_TIMEOUT;\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\tSOCKET connfd = request->connfd;\n\n\tUpnpPrintf( UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"miniserver %d: READING\\n\", connfd );\n\t/* parser_request_init( &parser ); */ /* LEAK_FIX_MK */\n\thmsg = &parser.msg;\n\tret_code = sock_init_with_ip(\n\t\t&info, connfd, (struct sockaddr *)&request->foreign_sockaddr);\n\tif (ret_code != UPNP_E_SUCCESS) {\n\t\tfree(request);\n\t\thttpmsg_destroy(hmsg);\n\t\treturn;\n\t}\n\t/* read */\n\tret_code = http_RecvMessage(\n\t\t&info, &parser, HTTPMETHOD_UNKNOWN, &timeout, &http_error_code);\n\tif (ret_code != 0) {\n\t\tgoto error_handler;\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"miniserver %d: PROCESSING...\\n\", connfd);\n\t/* dispatch */\n\thttp_error_code = dispatch_request(&info, &parser);\n\tif (http_error_code != 0) {\n\t\tgoto error_handler;\n\t}\n\thttp_error_code = 0;\n\nerror_handler:\n\tif (http_error_code > 0) {\n\t\tif (hmsg) {\n\t\t\tmajor = hmsg->major_version;\n\t\t\tminor = hmsg->minor_version;\n\t\t}\n\t\thandle_error(&info, http_error_code, major, minor);\n\t}\n\tsock_destroy(&info, SD_BOTH);\n\thttpmsg_destroy(hmsg);\n\tfree(request);\n\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"miniserver %d: COMPLETE\\n\", connfd);\n}"
  },
  {
    "function_name": "free_handle_request_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "182-190",
    "snippet": "static void free_handle_request_arg(\n\t/*! [in] Request Message to be freed. */\n\tvoid *args)\n{\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\n\tsock_close(request->connfd);\n\tfree(request);\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "request"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "free_handle_request_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "182-190",
          "snippet": "static void free_handle_request_arg(\n\t/*! [in] Request Message to be freed. */\n\tvoid *args)\n{\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\n\tsock_close(request->connfd);\n\tfree(request);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sock_close",
          "args": [
            "request->connfd"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "sock_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inc/sock.h",
          "lines": "79-89",
          "snippet": "static UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */",
            "#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */",
            "#include \"upnpconfig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include \"UpnpGlobal.h\"\t\t/* for UPNP_INLINE */\n#include \"UpnpInet.h\"\t\t/* for SOCKET, netinet/in */\n#include \"upnpconfig.h\"\n\nstatic UPNP_INLINE int sock_close(\n\t/*! Socket descriptor. */\n\tSOCKET sock)\n{\n\tint ret = -1;\n\n\tif (sock != INVALID_SOCKET)\n\t\tret = UpnpCloseSocket(sock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic void free_handle_request_arg(\n\t/*! [in] Request Message to be freed. */\n\tvoid *args)\n{\n\tstruct mserv_request_t *request = (struct mserv_request_t *)args;\n\n\tsock_close(request->connfd);\n\tfree(request);\n}"
  },
  {
    "function_name": "handle_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "165-176",
    "snippet": "static UPNP_INLINE void handle_error(\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! [in] HTTP Error Code. */\n\tint http_error_code,\n\t/*! [in] Major Version Number. */\n\tint major,\n\t/*! [in] Minor Version Number. */\n\tint minor)\n{\n\thttp_SendStatusResponse(info, http_error_code, major, minor);\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_SendStatusResponse",
          "args": [
            "info",
            "http_error_code",
            "major",
            "minor"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendStatusResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1445-1468",
          "snippet": "int http_SendStatusResponse(IN SOCKINFO *info, IN int http_status_code,\n\tIN int request_major_version, IN int request_minor_version)\n{\n\tint response_major, response_minor;\n\tmembuffer membuf;\n\tint ret;\n\tint timeout;\n\n\thttp_CalcResponseVersion(request_major_version, request_minor_version,\n\t\t\t\t &response_major, &response_minor);\n\tmembuffer_init(&membuf);\n\tmembuf.size_inc = (size_t)70;\n\t/* response start line */\n\tret = http_MakeMessage(&membuf, response_major, response_minor, \"RSCB\",\n\t\t\t       http_status_code, http_status_code);\n\tif (ret == 0) {\n\t\ttimeout = HTTP_DEFAULT_TIMEOUT;\n\t\tret = http_SendMessage(info, &timeout, \"b\",\n\t\t       membuf.buf, membuf.length);\n\t}\n\tmembuffer_destroy(&membuf);\n\n\treturn ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_SendStatusResponse(IN SOCKINFO *info, IN int http_status_code,\n\tIN int request_major_version, IN int request_minor_version)\n{\n\tint response_major, response_minor;\n\tmembuffer membuf;\n\tint ret;\n\tint timeout;\n\n\thttp_CalcResponseVersion(request_major_version, request_minor_version,\n\t\t\t\t &response_major, &response_minor);\n\tmembuffer_init(&membuf);\n\tmembuf.size_inc = (size_t)70;\n\t/* response start line */\n\tret = http_MakeMessage(&membuf, response_major, response_minor, \"RSCB\",\n\t\t\t       http_status_code, http_status_code);\n\tif (ret == 0) {\n\t\ttimeout = HTTP_DEFAULT_TIMEOUT;\n\t\tret = http_SendMessage(info, &timeout, \"b\",\n\t\t       membuf.buf, membuf.length);\n\t}\n\tmembuffer_destroy(&membuf);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void handle_error(\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! [in] HTTP Error Code. */\n\tint http_error_code,\n\t/*! [in] Major Version Number. */\n\tint major,\n\t/*! [in] Minor Version Number. */\n\tint minor)\n{\n\thttp_SendStatusResponse(info, http_error_code, major, minor);\n}"
  },
  {
    "function_name": "dispatch_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "122-160",
    "snippet": "static int dispatch_request(\n\t/*! [in] Socket Information object. */\n\tIN SOCKINFO *info,\n\t/*! [in] HTTP parser object. */\n\thttp_parser_t *hparser)\n{\n\tMiniServerCallback callback;\n\n\tswitch (hparser->msg.method) {\n\t/* Soap Call */\n\tcase SOAPMETHOD_POST:\n\tcase HTTPMETHOD_MPOST:\n\t\tcallback = gSoapCallback;\n\t\tbreak;\n\t/* Gena Call */\n\tcase HTTPMETHOD_NOTIFY:\n\tcase HTTPMETHOD_SUBSCRIBE:\n\tcase HTTPMETHOD_UNSUBSCRIBE:\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"miniserver %d: got GENA msg\\n\", info->socket);\n\t\t\tcallback = gGenaCallback;\n\t\tbreak;\n\t/* HTTP server call */\n\tcase HTTPMETHOD_GET:\n\tcase HTTPMETHOD_POST:\n\tcase HTTPMETHOD_HEAD:\n\tcase HTTPMETHOD_SIMPLEGET:\n\t\tcallback = gGetCallback;\n\t\tbreak;\n\tdefault:\n\t\tcallback = NULL;\n\t}\n\tif (callback == NULL) {\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\tcallback(hparser, &hparser->msg, info);\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "hparser",
            "&hparser->msg",
            "info"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "soap_device_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "701-780",
          "snippet": "void soap_device_callback(\n\t/*! [in] Parsed request received by the device. */\n\thttp_parser_t *parser,\n\t/*! [in] HTTP request. */\n\thttp_message_t *request,\n\t/*! [in,out] Socket info. */\n\tSOCKINFO *info)\n{\n\tint err_code;\n\tIXML_Document *xml_doc = NULL;\n\tsoap_devserv_t *soap_info = NULL;\n\tIXML_Node *req_node = NULL;\n\n\t/* get device/service identified by the request-URI */\n\tsoap_info = malloc(sizeof(soap_devserv_t));\n\tif (NULL == soap_info) {\n\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\tgoto error_handler;\n\t}\n\tif (get_dev_service(request,\n\t\t\tinfo->foreign_sockaddr.ss_family, soap_info) < 0) {\n\t\terr_code = HTTP_NOT_FOUND;\n\t\tgoto error_handler;\n\t}\n\t/* validate: content-type == text/xml */\n\tif (!has_xml_content_type(request)) {\n\t\terr_code = HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAPACTION HTTP header */\n\terr_code = check_soapaction_hdr(request, soap_info);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tswitch (err_code) {\n\t\tcase SREQ_NOT_EXTENDED:\n\t\t\terr_code = HTTP_NOT_EXTENDED;\n\t\t\tbreak;\n\t\tcase UPNP_E_OUTOF_MEMORY:\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\t\tbreak;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* parse XML */\n\terr_code = ixmlParseBufferEx(request->entity.buf, &xml_doc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code)\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\telse\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAP body */\n\tif (check_soap_request(soap_info, xml_doc, &req_node) < 0)\n\t{\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* process SOAP request */\n\tif (NULL == soap_info->action_name.buf)\n\t\t/* query var */\n\t\thandle_query_variable(info, request, soap_info, req_node);\n\telse\n\t\t/* invoke action */\n\t\thandle_invoke_action(info, request, soap_info, req_node);\n\n\terr_code = HTTP_OK;\n\nerror_handler:\n\tixmlDocument_free(xml_doc);\n\tfree(soap_info);\n\tif (err_code != HTTP_OK) {\n\t\thttp_SendStatusResponse(info, err_code, request->major_version,\n\t\t\t\trequest->minor_version);\n\t}\n\treturn;\n\tparser = parser;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SREQ_NOT_EXTENDED\t -3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SREQ_NOT_EXTENDED\t -3\n\nvoid soap_device_callback(\n\t/*! [in] Parsed request received by the device. */\n\thttp_parser_t *parser,\n\t/*! [in] HTTP request. */\n\thttp_message_t *request,\n\t/*! [in,out] Socket info. */\n\tSOCKINFO *info)\n{\n\tint err_code;\n\tIXML_Document *xml_doc = NULL;\n\tsoap_devserv_t *soap_info = NULL;\n\tIXML_Node *req_node = NULL;\n\n\t/* get device/service identified by the request-URI */\n\tsoap_info = malloc(sizeof(soap_devserv_t));\n\tif (NULL == soap_info) {\n\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\tgoto error_handler;\n\t}\n\tif (get_dev_service(request,\n\t\t\tinfo->foreign_sockaddr.ss_family, soap_info) < 0) {\n\t\terr_code = HTTP_NOT_FOUND;\n\t\tgoto error_handler;\n\t}\n\t/* validate: content-type == text/xml */\n\tif (!has_xml_content_type(request)) {\n\t\terr_code = HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAPACTION HTTP header */\n\terr_code = check_soapaction_hdr(request, soap_info);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tswitch (err_code) {\n\t\tcase SREQ_NOT_EXTENDED:\n\t\t\terr_code = HTTP_NOT_EXTENDED;\n\t\t\tbreak;\n\t\tcase UPNP_E_OUTOF_MEMORY:\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\t\tbreak;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* parse XML */\n\terr_code = ixmlParseBufferEx(request->entity.buf, &xml_doc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code)\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\telse\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAP body */\n\tif (check_soap_request(soap_info, xml_doc, &req_node) < 0)\n\t{\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* process SOAP request */\n\tif (NULL == soap_info->action_name.buf)\n\t\t/* query var */\n\t\thandle_query_variable(info, request, soap_info, req_node);\n\telse\n\t\t/* invoke action */\n\t\thandle_invoke_action(info, request, soap_info, req_node);\n\n\terr_code = HTTP_OK;\n\nerror_handler:\n\tixmlDocument_free(xml_doc);\n\tfree(soap_info);\n\tif (err_code != HTTP_OK) {\n\t\thttp_SendStatusResponse(info, err_code, request->major_version,\n\t\t\t\trequest->minor_version);\n\t}\n\treturn;\n\tparser = parser;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "MSERV",
            "__FILE__",
            "__LINE__",
            "\"miniserver %d: got GENA msg\\n\"",
            "info->socket"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nstatic int dispatch_request(\n\t/*! [in] Socket Information object. */\n\tIN SOCKINFO *info,\n\t/*! [in] HTTP parser object. */\n\thttp_parser_t *hparser)\n{\n\tMiniServerCallback callback;\n\n\tswitch (hparser->msg.method) {\n\t/* Soap Call */\n\tcase SOAPMETHOD_POST:\n\tcase HTTPMETHOD_MPOST:\n\t\tcallback = gSoapCallback;\n\t\tbreak;\n\t/* Gena Call */\n\tcase HTTPMETHOD_NOTIFY:\n\tcase HTTPMETHOD_SUBSCRIBE:\n\tcase HTTPMETHOD_UNSUBSCRIBE:\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"miniserver %d: got GENA msg\\n\", info->socket);\n\t\t\tcallback = gGenaCallback;\n\t\tbreak;\n\t/* HTTP server call */\n\tcase HTTPMETHOD_GET:\n\tcase HTTPMETHOD_POST:\n\tcase HTTPMETHOD_HEAD:\n\tcase HTTPMETHOD_SIMPLEGET:\n\t\tcallback = gGetCallback;\n\t\tbreak;\n\tdefault:\n\t\tcallback = NULL;\n\t}\n\tif (callback == NULL) {\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\tcallback(hparser, &hparser->msg, info);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "SetGenaCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "112-115",
    "snippet": "void SetGenaCallback(MiniServerCallback callback)\n{\n\tgGenaCallback = callback;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nvoid SetGenaCallback(MiniServerCallback callback)\n{\n\tgGenaCallback = callback;\n}"
  },
  {
    "function_name": "SetSoapCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "106-109",
    "snippet": "void SetSoapCallback(MiniServerCallback callback)\n{\n\tgSoapCallback = callback;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nvoid SetSoapCallback(MiniServerCallback callback)\n{\n\tgSoapCallback = callback;\n}"
  },
  {
    "function_name": "SetHTTPGetCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
    "lines": "100-103",
    "snippet": "void SetHTTPGetCallback(MiniServerCallback callback)\n{\n\tgGetCallback = callback;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"upnputil.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
      "#include \"ThreadPool.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"miniserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\nvoid SetHTTPGetCallback(MiniServerCallback callback)\n{\n\tgGetCallback = callback;\n}"
  }
]