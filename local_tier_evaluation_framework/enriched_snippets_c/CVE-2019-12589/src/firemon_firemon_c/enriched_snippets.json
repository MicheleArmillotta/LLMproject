[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
    "lines": "124-312",
    "snippet": "int main(int argc, char **argv) {\n\tunsigned pid = 0;\n\tint i;\n\n\t// handle CTRL-C\n\tsignal (SIGINT, my_handler);\n\tsignal (SIGTERM, my_handler);\n\n\tfor (i = 1; i < argc; i++) {\n\t\t// default options\n\t\tif (strcmp(argv[i], \"--help\") == 0 ||\n\t\t    strcmp(argv[i], \"-?\") == 0) {\n\t\t\tusage();\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--version\") == 0) {\n\t\t\tprintf(\"firemon version %s\\n\\n\", VERSION);\n\t\t\treturn 0;\n\t\t}\n\n\t\t// options without a pid argument\n\t\telse if (strcmp(argv[i], \"--top\") == 0)\n\t\t\targ_top = 1;\n\t\telse if (strcmp(argv[i], \"--list\") == 0)\n\t\t\targ_list = 1;\n\t\telse if (strcmp(argv[i], \"--tree\") == 0)\n\t\t\targ_tree = 1;\n\t\telse if (strcmp(argv[i], \"--netstats\") == 0) {\n\t\t\tstruct stat s;\n\t\t\tif (getuid() != 0 && stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: this feature is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_netstats = 1;\n\t\t}\n\n\n\t\t// cumulative options with or without a pid argument\n\t\telse if (strcmp(argv[i], \"--x11\") == 0)\n\t\t\targ_x11 = 1;\n\t\telse if (strcmp(argv[i], \"--cgroup\") == 0)\n\t\t\targ_cgroup = 1;\n\t\telse if (strcmp(argv[i], \"--cpu\") == 0)\n\t\t\targ_cpu = 1;\n\t\telse if (strcmp(argv[i], \"--seccomp\") == 0)\n\t\t\targ_seccomp = 1;\n\t\telse if (strcmp(argv[i], \"--caps\") == 0)\n\t\t\targ_caps = 1;\n\t\telse if (strcmp(argv[i], \"--interface\") == 0) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: you need to be root to run this command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_interface = 1;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--route\") == 0)\n\t\t\targ_route = 1;\n\t\telse if (strcmp(argv[i], \"--arp\") == 0)\n\t\t\targ_arp = 1;\n\t\telse if (strcmp(argv[i], \"--apparmor\") == 0)\n\t\t\targ_apparmor = 1;\n\n\t\telse if (strncmp(argv[i], \"--name=\", 7) == 0) {\n\t\t\tchar *name = argv[i] + 7;\n\t\t\tif (name2pid(name, (pid_t *) &pid)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot find sandbox %s\\n\", name);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t// etc\n\t\telse if (strcmp(argv[i], \"--nowrap\") == 0)\n\t\t\targ_nowrap = 1;\n\n\t\t// invalid option\n\t\telse if (*argv[i] == '-') {\n\t\t\tfprintf(stderr, \"Error: invalid option\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t// PID argument\n\t\telse {\n\t\t\t// this should be a pid number\n\t\t\tchar *ptr = argv[i];\n\t\t\twhile (*ptr != '\\0') {\n\t\t\t\tif (!isdigit(*ptr)) {\n\t\t\t\t\tfprintf(stderr, \"Error: not a valid PID number\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tptr++;\n\t\t\t}\n\n\t\t\tsscanf(argv[i], \"%u\", &pid);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t// if the parent is firejail, skip the process\n\tpid_t ppid = getppid();\n\tchar *pcomm = pid_proc_comm(ppid);\n\tif (pcomm && strcmp(pcomm, \"firejail\") == 0)\n\t\tskip_process = ppid;\n\n\t// allow only root user if /proc is mounted hidepid\n\tif (pid_hidepid() && getuid() != 0) {\n\t\tfprintf(stderr, \"Error: /proc is mounted hidepid, you would need to be root to run this command\\n\");\n\t\texit(1);\n\t}\n\n\tif (arg_top) {\n\t\ttop();\t// print all sandboxes, --name disregarded\n\t\treturn 0;\n\t}\n\tif (arg_list) {\n\t\tlist();\t// print all sandboxes, --name disregarded\n\t\treturn 0;\n\t}\n\tif (arg_netstats) {\n\t\tnetstats();\t// print all sandboxes, --name disregarded\n\t\treturn 0;\n\t}\n\tif (arg_tree) {\n\t\ttree(pid);\n\t\treturn 0;\n\t}\n\n\t// if --name requested without other options, print all data\n\tif (pid && !arg_cpu && !arg_seccomp && !arg_caps && !arg_apparmor &&\n\t    !arg_cgroup && !arg_x11 && !arg_interface && !arg_route && !arg_arp) {\n\t\targ_tree = 1;\n\t\targ_cpu = 1;\n\t\targ_seccomp = 1;\n\t\targ_caps = 1;\n\t\targ_cgroup = 1;\n\t\targ_x11 = 1;\n\t\targ_interface = 1;\n\t\targ_route = 1;\n\t\targ_arp = 1;\n\t\targ_apparmor = 1;\n\t}\n\n\t// cumulative options\n\tint print_procs = 1;\n\tif (arg_cpu) {\n\t\tcpu((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_seccomp) {\n\t\tseccomp((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_caps) {\n\t\tcaps((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_apparmor) {\n\t\tapparmor((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_cgroup) {\n\t\tcgroup((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_x11) {\n\t\tx11((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_interface && getuid() == 0) {\n\t\tinterface((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_route) {\n\t\troute((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_arp) {\n\t\tarp((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\t(void) print_procs;\n\n\tif (getuid() == 0) {\n\t\ttree((pid_t) pid);\t// pid initialized as zero, will print the tree for all processes if a specific pid was not requested\n\t\tprocevent((pid_t) pid);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <grp.h>",
      "#include <sys/prctl.h>",
      "#include <sys/ioctl.h>",
      "#include <termios.h>",
      "#include <signal.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "pid_t skip_process = 0;",
      "static int arg_route = 0;",
      "static int arg_arp = 0;",
      "static int arg_tree = 0;",
      "static int arg_interface = 0;",
      "static int arg_seccomp = 0;",
      "static int arg_caps = 0;",
      "static int arg_cpu = 0;",
      "static int arg_cgroup = 0;",
      "static int arg_x11 = 0;",
      "static int arg_top = 0;",
      "static int arg_list = 0;",
      "static int arg_netstats = 0;",
      "static int arg_apparmor = 0;",
      "int arg_nowrap = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "procevent",
          "args": [
            "(pid_t) pid"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "procevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/procevent.c",
          "lines": "484-501",
          "snippet": "void procevent(pid_t pid) {\n\t// need to be root for this\n\tif (getuid() != 0) {\n\t\tfprintf(stderr, \"Error: you need to be root to get process events\\n\");\n\t\texit(1);\n\t}\n\n\t// monitor using netlink\n\tint sock = procevent_netlink_setup();\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error: cannot open netlink socket\\n\");\n\t\texit(1);\n\t}\n\n\tprocevent_monitor(sock, pid); // it will never return from here\n\tassert(0);\n\tclose(sock); // quiet static analyzers\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <time.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/netlink.h>",
            "#include <linux/connector.h>",
            "#include <sys/socket.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <time.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <linux/cn_proc.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <sys/socket.h>\n#include \"firemon.h\"\n\nvoid procevent(pid_t pid) {\n\t// need to be root for this\n\tif (getuid() != 0) {\n\t\tfprintf(stderr, \"Error: you need to be root to get process events\\n\");\n\t\texit(1);\n\t}\n\n\t// monitor using netlink\n\tint sock = procevent_netlink_setup();\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error: cannot open netlink socket\\n\");\n\t\texit(1);\n\t}\n\n\tprocevent_monitor(sock, pid); // it will never return from here\n\tassert(0);\n\tclose(sock); // quiet static analyzers\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree",
          "args": [
            "(pid_t) pid"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/tree.c",
          "lines": "22-34",
          "snippet": "void tree(pid_t pid) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (i == skip_process)\n\t\t\tcontinue;\n\t\tif (pids[i].level == 1)\n\t\t\tpid_print_tree(i, 0, arg_nowrap);\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firemon.h\"\n\nvoid tree(pid_t pid) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (i == skip_process)\n\t\t\tcontinue;\n\t\tif (pids[i].level == 1)\n\t\t\tpid_print_tree(i, 0, arg_nowrap);\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp",
          "args": [
            "(pid_t) pid",
            "print_procs"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "arp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/arp.c",
          "lines": "75-95",
          "snippet": "void arp(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1) {\n\t\t\t\tchar *fname;\n\t\t\t\tif (asprintf(&fname, \"/proc/%d/net/arp\", child) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprint_arp(fname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firemon.h\"\n\nvoid arp(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1) {\n\t\t\t\tchar *fname;\n\t\t\t\tif (asprintf(&fname, \"/proc/%d/net/arp\", child) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprint_arp(fname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "route",
          "args": [
            "(pid_t) pid",
            "print_procs"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "route",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/route.c",
          "lines": "184-209",
          "snippet": "void route(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1) {\n\t\t\t\tchar *fname;\n\t\t\t\tif (asprintf(&fname, \"/proc/%d/net/fib_trie\", child) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\textract_if(fname);\n\t\t\t\tfree(fname);\n\n\t\t\t\tif (asprintf(&fname, \"/proc/%d/net/route\", child) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprint_route(fname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <assert.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <assert.h>\n#include \"firemon.h\"\n\nvoid route(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1) {\n\t\t\t\tchar *fname;\n\t\t\t\tif (asprintf(&fname, \"/proc/%d/net/fib_trie\", child) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\textract_if(fname);\n\t\t\t\tfree(fname);\n\n\t\t\t\tif (asprintf(&fname, \"/proc/%d/net/route\", child) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprint_route(fname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "interface",
          "args": [
            "(pid_t) pid",
            "print_procs"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/interface.c",
          "lines": "158-174",
          "snippet": "void interface(pid_t pid, int print_procs) {\n\tpid_read(pid); // a pid of 0 will include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1) {\n\t\t\t\tprint_sandbox(child);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <linux/sockios.h>",
            "#include <linux/if_link.h>",
            "#include <linux/netlink.h>",
            "#include <linux/connector.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <linux/sockios.h>\n#include <linux/if_link.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"firemon.h\"\n\nvoid interface(pid_t pid, int print_procs) {\n\tpid_read(pid); // a pid of 0 will include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1) {\n\t\t\t\tprint_sandbox(child);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11",
          "args": [
            "(pid_t) pid",
            "print_procs"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "x11",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/x11.c",
          "lines": "25-55",
          "snippet": "void x11(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\n\t\t\tchar *x11file;\n\t\t\t// todo: use macro from src/firejail/firejail.h for /run/firejail/x11 directory\n\t\t\tif (asprintf(&x11file, \"/run/firejail/x11/%d\", i) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\n\t\t\tFILE *fp = fopen(x11file, \"r\");\n\t\t\tif (!fp) {\n\t\t\t\tfree(x11file);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint display;\n\t\t\tint rv = fscanf(fp, \"%d\", &display);\n\t\t\tif (rv == 1)\n\t\t\t\tprintf(\"  DISPLAY :%d\\n\", display);\n\t\t\tfclose(fp);\n\t\t\tfree(x11file);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firemon.h\"\n\nvoid x11(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\n\t\t\tchar *x11file;\n\t\t\t// todo: use macro from src/firejail/firejail.h for /run/firejail/x11 directory\n\t\t\tif (asprintf(&x11file, \"/run/firejail/x11/%d\", i) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\n\t\t\tFILE *fp = fopen(x11file, \"r\");\n\t\t\tif (!fp) {\n\t\t\t\tfree(x11file);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint display;\n\t\t\tint rv = fscanf(fp, \"%d\", &display);\n\t\t\tif (rv == 1)\n\t\t\t\tprintf(\"  DISPLAY :%d\\n\", display);\n\t\t\tfclose(fp);\n\t\t\tfree(x11file);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup",
          "args": [
            "(pid_t) pid",
            "print_procs"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/cgroup.c",
          "lines": "47-63",
          "snippet": "void cgroup(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tprintf(\"  cgroup: \");\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_cgroup(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firemon.h\"\n\nvoid cgroup(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tprintf(\"  cgroup: \");\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_cgroup(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "apparmor",
          "args": [
            "(pid_t) pid",
            "print_procs"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "apparmor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/apparmor.c",
          "lines": "58-62",
          "snippet": "void apparmor(pid_t pid, int print_procs) {\n\t(void) pid;\n\t(void) print_procs;\n\tprintf(\"AppArmor support not available\\n\");\n}",
          "includes": [
            "#include <sys/apparmor.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/apparmor.h>\n#include \"firemon.h\"\n\nvoid apparmor(pid_t pid, int print_procs) {\n\t(void) pid;\n\t(void) print_procs;\n\tprintf(\"AppArmor support not available\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "caps",
          "args": [
            "(pid_t) pid",
            "print_procs"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/caps.c",
          "lines": "48-63",
          "snippet": "void caps(pid_t pid, int print_procs) {\n\tpid_read(pid);\t// include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_caps(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firemon.h\"\n\nvoid caps(pid_t pid, int print_procs) {\n\tpid_read(pid);\t// include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_caps(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp",
          "args": [
            "(pid_t) pid",
            "print_procs"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/seccomp.c",
          "lines": "47-62",
          "snippet": "void seccomp(pid_t pid, int print_procs) {\n\tpid_read(pid);\t// include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_seccomp(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firemon.h\"\n\nvoid seccomp(pid_t pid, int print_procs) {\n\tpid_read(pid);\t// include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_seccomp(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu",
          "args": [
            "(pid_t) pid",
            "print_procs"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/cpu.c",
          "lines": "49-64",
          "snippet": "void cpu(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_cpu(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firemon.h\"\n\nvoid cpu(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_cpu(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "netstats",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "netstats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/netstats.c",
          "lines": "198-249",
          "snippet": "void netstats(void) {\n\tpid_read(0);\t// include all processes\n\n\tprintf(\"Displaying network statistics only for sandboxes using a new network namespace.\\n\");\n\n\t// print processes\n\twhile (1) {\n\t\t// set pid table\n\t\tint i;\n\t\tint itv = 1; \t// 1 second  interval\n\t\tpid_read(0);\n\n\t\t// start rx/tx measurements\n\t\tfor (i = 0; i < max_pids; i++) {\n\t\t\tif (pids[i].level == 1)\n\t\t\t\tget_stats(i);\n\t\t}\n\n\t\t// wait 1 seconds\n\t\tfiremon_sleep(itv);\n\n\t\t// grab screen size\n\t\tstruct winsize sz;\n\t\tint row = 24;\n\t\tint col = 80;\n\t\tif (!ioctl(0, TIOCGWINSZ, &sz)) {\n\t\t\tcol = sz.ws_col;\n\t\t\trow = sz.ws_row;\n\t\t}\n\n\t\t// start printing\n\t\tfiremon_clrscr();\n\t\tchar *header = get_header();\n\t\tif (strlen(header) > (size_t)col)\n\t\t\theader[col] = '\\0';\n\t\tprintf(\"%s\\n\", header);\n\t\tif (row > 0)\n\t\t\trow--;\n\t\tfree(header);\n\n\t\t// start rx/tx measurements\n\t\tfor (i = 0; i < max_pids; i++) {\n\t\t\tif (pids[i].level == 1) {\n\t\t\t\tget_stats(i);\n\t\t\t\tprint_proc(i, itv, col);\n\t\t\t}\n\t\t}\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include \"firemon.h\"\n\nvoid netstats(void) {\n\tpid_read(0);\t// include all processes\n\n\tprintf(\"Displaying network statistics only for sandboxes using a new network namespace.\\n\");\n\n\t// print processes\n\twhile (1) {\n\t\t// set pid table\n\t\tint i;\n\t\tint itv = 1; \t// 1 second  interval\n\t\tpid_read(0);\n\n\t\t// start rx/tx measurements\n\t\tfor (i = 0; i < max_pids; i++) {\n\t\t\tif (pids[i].level == 1)\n\t\t\t\tget_stats(i);\n\t\t}\n\n\t\t// wait 1 seconds\n\t\tfiremon_sleep(itv);\n\n\t\t// grab screen size\n\t\tstruct winsize sz;\n\t\tint row = 24;\n\t\tint col = 80;\n\t\tif (!ioctl(0, TIOCGWINSZ, &sz)) {\n\t\t\tcol = sz.ws_col;\n\t\t\trow = sz.ws_row;\n\t\t}\n\n\t\t// start printing\n\t\tfiremon_clrscr();\n\t\tchar *header = get_header();\n\t\tif (strlen(header) > (size_t)col)\n\t\t\theader[col] = '\\0';\n\t\tprintf(\"%s\\n\", header);\n\t\tif (row > 0)\n\t\t\trow--;\n\t\tfree(header);\n\n\t\t// start rx/tx measurements\n\t\tfor (i = 0; i < max_pids; i++) {\n\t\t\tif (pids[i].level == 1) {\n\t\t\t\tget_stats(i);\n\t\t\t\tprint_proc(i, itv, col);\n\t\t\t}\n\t\t}\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/list.c",
          "lines": "22-33",
          "snippet": "void list(void) {\n\tpid_read(0);\t// include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (i == skip_process)\n\t\t\tcontinue;\n\t\tif (pids[i].level == 1)\n\t\t\tpid_print_list(i, arg_nowrap);\n\t}\n}",
          "includes": [
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firemon.h\"\n\nvoid list(void) {\n\tpid_read(0);\t// include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (i == skip_process)\n\t\t\tcontinue;\n\t\tif (pids[i].level == 1)\n\t\t\tpid_print_list(i, arg_nowrap);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "top",
          "args": [],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/top.c",
          "lines": "262-333",
          "snippet": "void top(void) {\n\twhile (1) {\n\t\t// clear linked list\n\t\thead_clear();\n\n\t\t// set pid table\n\t\tint i;\n\t\tint itv = 1; // 1 second  interval\n\t\tpid_read(0);\n\n\t\t// start cpu measurements\n\t\tunsigned utime = 0;\n\t\tunsigned stime = 0;\n\t\tfor (i = 0; i < max_pids; i++) {\n\t\t\tif (i == skip_process)\n\t\t\t\tcontinue;\n\t\t\tif (pids[i].level == 1)\n\t\t\t\tpid_store_cpu(i, 0, &utime, &stime);\n\t\t}\n\n\t\t// wait 1 second\n\t\tfiremon_sleep(itv);\n\n\t\t// grab screen size\n\t\tstruct winsize sz;\n\t\tint row = 24;\n\t\tint col = 80;\n\t\tif (!ioctl(STDIN_FILENO, TIOCGWINSZ, &sz)) {\n\t\t\tif (sz.ws_col > 0 && sz.ws_row > 0) {\n\t\t\t\tcol = sz.ws_col;\n\t\t\t\trow = sz.ws_row;\n\t\t\t}\n\t\t}\n\n\t\t// start printing\n\t\tfiremon_clrscr();\n\t\tchar *header = get_header();\n\t\tif (strlen(header) > (size_t)col)\n\t\t\theader[col] = '\\0';\n\t\tprintf(\"%s\\n\", header);\n\t\tif (row > 0)\n\t\t\trow--;\n\t\tfree(header);\n\n\t\t// find system uptime\n\t\tFILE *fp = fopen(\"/proc/uptime\", \"r\");\n\t\tif (fp) {\n\t\t\tfloat f;\n\t\t\tint rv = fscanf(fp, \"%f\", &f);\n\t\t\t(void) rv;\n\t\t\tsysuptime = (unsigned long long) f;\n\t\t\tfclose(fp);\n\t\t}\n\n\t\t// print processes\n\t\tfor (i = 0; i < max_pids; i++) {\n\t\t\tif (i == skip_process)\n\t\t\t\tcontinue;\n\t\t\tif (pids[i].level == 1) {\n\t\t\t\tfloat cpu = 0;\n\t\t\t\tint cnt = 0; // process count\n\t\t\t\tchar *line = print_top(i, 0, &utime, &stime, itv, &cpu, &cnt);\n\t\t\t\tif (line)\n\t\t\t\t\thead_add(cpu, line);\n\t\t\t}\n\t\t}\n\t\thead_print(col, row);\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long long sysuptime = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include \"firemon.h\"\n\nstatic unsigned long long sysuptime = 0;\n\nvoid top(void) {\n\twhile (1) {\n\t\t// clear linked list\n\t\thead_clear();\n\n\t\t// set pid table\n\t\tint i;\n\t\tint itv = 1; // 1 second  interval\n\t\tpid_read(0);\n\n\t\t// start cpu measurements\n\t\tunsigned utime = 0;\n\t\tunsigned stime = 0;\n\t\tfor (i = 0; i < max_pids; i++) {\n\t\t\tif (i == skip_process)\n\t\t\t\tcontinue;\n\t\t\tif (pids[i].level == 1)\n\t\t\t\tpid_store_cpu(i, 0, &utime, &stime);\n\t\t}\n\n\t\t// wait 1 second\n\t\tfiremon_sleep(itv);\n\n\t\t// grab screen size\n\t\tstruct winsize sz;\n\t\tint row = 24;\n\t\tint col = 80;\n\t\tif (!ioctl(STDIN_FILENO, TIOCGWINSZ, &sz)) {\n\t\t\tif (sz.ws_col > 0 && sz.ws_row > 0) {\n\t\t\t\tcol = sz.ws_col;\n\t\t\t\trow = sz.ws_row;\n\t\t\t}\n\t\t}\n\n\t\t// start printing\n\t\tfiremon_clrscr();\n\t\tchar *header = get_header();\n\t\tif (strlen(header) > (size_t)col)\n\t\t\theader[col] = '\\0';\n\t\tprintf(\"%s\\n\", header);\n\t\tif (row > 0)\n\t\t\trow--;\n\t\tfree(header);\n\n\t\t// find system uptime\n\t\tFILE *fp = fopen(\"/proc/uptime\", \"r\");\n\t\tif (fp) {\n\t\t\tfloat f;\n\t\t\tint rv = fscanf(fp, \"%f\", &f);\n\t\t\t(void) rv;\n\t\t\tsysuptime = (unsigned long long) f;\n\t\t\tfclose(fp);\n\t\t}\n\n\t\t// print processes\n\t\tfor (i = 0; i < max_pids; i++) {\n\t\t\tif (i == skip_process)\n\t\t\t\tcontinue;\n\t\t\tif (pids[i].level == 1) {\n\t\t\t\tfloat cpu = 0;\n\t\t\t\tint cnt = 0; // process count\n\t\t\t\tchar *line = print_top(i, 0, &utime, &stime, itv, &cpu, &cnt);\n\t\t\t\tif (line)\n\t\t\t\t\thead_add(cpu, line);\n\t\t\t}\n\t\t}\n\t\thead_print(col, row);\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: /proc is mounted hidepid, you would need to be root to run this command\\n\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_hidepid",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "pid_hidepid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "270-288",
          "snippet": "int pid_hidepid(void) {\n\tFILE *fp = fopen(\"/proc/mounts\", \"r\");\n\tif (!fp)\n\t\treturn 1;\n\n\tchar buf[BUFLEN];\n\twhile (fgets(buf, BUFLEN, fp)) {\n\t\tif (strstr(buf, \"proc /proc proc\")) {\n\t\t\tfclose(fp);\n\t\t\t// check hidepid\n\t\t\tif (strstr(buf, \"hidepid=2\") || strstr(buf, \"hidepid=1\"))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define BUFLEN 4096",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define BUFLEN 4096\n#define BUFLEN 4096\n\nint pid_hidepid(void) {\n\tFILE *fp = fopen(\"/proc/mounts\", \"r\");\n\tif (!fp)\n\t\treturn 1;\n\n\tchar buf[BUFLEN];\n\twhile (fgets(buf, BUFLEN, fp)) {\n\t\tif (strstr(buf, \"proc /proc proc\")) {\n\t\t\tfclose(fp);\n\t\t\t// check hidepid\n\t\t\tif (strstr(buf, \"hidepid=2\") || strstr(buf, \"hidepid=1\"))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pcomm",
            "\"firejail\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_proc_comm",
          "args": [
            "ppid"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "pid_proc_comm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "128-164",
          "snippet": "char *pid_proc_comm(const pid_t pid) {\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/comm\", pid) == -1)\n\t\treturn NULL;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn NULL;\n\t}\n\tfree(fname);\n\n\t// read file\n\tchar buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// remove \\n\n\tchar *ptr = strchr(buffer, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\t// return a malloc copy of the command line\n\tchar *rv = strdup(buffer);\n\tif (!rv)\n\t\treturn NULL;\n\tif (strlen(rv) == 0) {\n\t\tfree(rv);\n\t\treturn NULL;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define BUFLEN 4096",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define BUFLEN 4096\n#define BUFLEN 4096\n\nchar *pid_proc_comm(const pid_t pid) {\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/comm\", pid) == -1)\n\t\treturn NULL;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn NULL;\n\t}\n\tfree(fname);\n\n\t// read file\n\tchar buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// remove \\n\n\tchar *ptr = strchr(buffer, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\t// return a malloc copy of the command line\n\tchar *rv = strdup(buffer);\n\tif (!rv)\n\t\treturn NULL;\n\tif (strlen(rv) == 0) {\n\t\tfree(rv);\n\t\treturn NULL;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getppid",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"%u\"",
            "&pid"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: not a valid PID number\\n\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*ptr"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid option\\n\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--nowrap\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find sandbox %s\\n\"",
            "name"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name2pid",
          "args": [
            "name",
            "(pid_t *) &pid"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "name2pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "63-126",
          "snippet": "int name2pid(const char *name, pid_t *pid) {\n\tpid_t parent = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir))) {\n\t\tpid_t newpid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (newpid == parent)\n\t\t\tcontinue;\n\n\t\t// check if this is a firejail executable\n\t\tchar *comm = pid_proc_comm(newpid);\n\t\tif (comm) {\n\t\t\tif (strcmp(comm, \"firejail\")) {\n\t\t\t\tfree(comm);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t}\n\n\t\t// look for the sandbox name in /run/firejail/name/<PID>\n\t\t// todo: use RUN_FIREJAIL_NAME_DIR define from src/firejail/firejail.h\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/run/firejail/name/%d\", newpid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\tif (fgets(buf, BUFLEN, fp)) {\n\t\t\t\t// remove \\n\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\t\tif (strcmp(buf, name) == 0) {\n\t\t\t\t\t\t// we found it!\n\t\t\t\t\t\tfclose(fp);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\t*pid = newpid;\n\t\t\t\t\t\tclosedir(dir);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"Error: invalid %s\\n\", fname);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tfree(fname);\n\t}\n\tclosedir(dir);\n\treturn 1;\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define BUFLEN 4096",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define BUFLEN 4096\n#define BUFLEN 4096\n\nint name2pid(const char *name, pid_t *pid) {\n\tpid_t parent = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir))) {\n\t\tpid_t newpid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (newpid == parent)\n\t\t\tcontinue;\n\n\t\t// check if this is a firejail executable\n\t\tchar *comm = pid_proc_comm(newpid);\n\t\tif (comm) {\n\t\t\tif (strcmp(comm, \"firejail\")) {\n\t\t\t\tfree(comm);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t}\n\n\t\t// look for the sandbox name in /run/firejail/name/<PID>\n\t\t// todo: use RUN_FIREJAIL_NAME_DIR define from src/firejail/firejail.h\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/run/firejail/name/%d\", newpid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\tif (fgets(buf, BUFLEN, fp)) {\n\t\t\t\t// remove \\n\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\t\tif (strcmp(buf, name) == 0) {\n\t\t\t\t\t\t// we found it!\n\t\t\t\t\t\tfclose(fp);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\t*pid = newpid;\n\t\t\t\t\t\tclosedir(dir);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"Error: invalid %s\\n\", fname);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tfree(fname);\n\t}\n\tclosedir(dir);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--name=\"",
            "7"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--apparmor\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--arp\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--route\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: you need to be root to run this command\\n\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--interface\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--caps\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--seccomp\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--cpu\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--cgroup\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--x11\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: this feature is not available on Grsecurity systems\\n\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/proc/sys/kernel/grsecurity\"",
            "&s"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--netstats\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--tree\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--list\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--top\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"firemon version %s\\n\\n\"",
            "VERSION"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--version\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/usage.c",
          "lines": "81-84",
          "snippet": "void usage(void) {\n\tprintf(\"firemon - version %s\\n\", VERSION);\n\tputs(help_str);\n}",
          "includes": [
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *help_str =\n\t\"Usage: firemon [OPTIONS] [PID]\\n\\n\"\n\t\"Monitor processes started in a Firejail sandbox. Without any PID specified,\\n\"\n\t\"all processes started by Firejail are monitored. Descendants of these processes\\n\"\n\t\"are also being monitored. On Grsecurity systems only root user\\n\"\n\t\"can run this program.\\n\\n\"\n\t\"Options:\\n\"\n\t\"\\t--apparmor - print AppArmor confinement status for each sandbox.\\n\\n\"\n\t\"\\t--arp - print ARP table for each sandbox.\\n\\n\"\n\t\"\\t--caps - print capabilities configuration for each sandbox.\\n\\n\"\n\t\"\\t--cgroup - print control group information for each sandbox.\\n\\n\"\n\t\"\\t--cpu - print CPU affinity for each sandbox.\\n\\n\"\n\t\"\\t--help, -? - this help screen.\\n\\n\"\n\t\"\\t--interface - print network interface information for each sandbox.\\n\\n\"\n\t\"\\t--list - list all sandboxes.\\n\\n\"\n\t\"\\t--name=name - print information only about named sandbox.\\n\\n\"\n\t\"\\t--netstats - monitor network statistics for sandboxes creating a new\\n\"\n\t\"\\t\\tnetwork namespace.\\n\\n\"\n\t\"\\t--nowrap - enable line wrapping in terminals.\\n\\n\"\n\t\"\\t--route - print route table for each sandbox.\\n\\n\"\n\t\"\\t--seccomp - print seccomp configuration for each sandbox.\\n\\n\"\n\t\"\\t--tree - print a tree of all sandboxed processes.\\n\\n\"\n\t\"\\t--top - monitor the most CPU-intensive sandboxes.\\n\\n\"\n\t\"\\t--version - print program version and exit.\\n\\n\"\n\t\"\\t--x11 - print X11 display number.\\n\\n\"\n\n\t\"Without any options, firemon monitors all fork, exec, id change, and exit\\n\"\n\t\"events in the sandbox. Monitoring a specific PID is also supported.\\n\\n\"\n\n\t\"Option --list prints a list of all sandboxes. The format for each entry is as\\n\"\n\t\"follows:\\n\\n\"\n\t\"\\tPID:USER:Command\\n\\n\"\n\n\t\"Option --tree prints the tree of processes running in the sandbox. The format\\n\"\n\t\"for each process entry is as follows:\\n\\n\"\n\t\"\\tPID:USER:Command\\n\\n\"\n\n\t\"Option --top is similar to the UNIX top command, however it applies only to\\n\"\n\t\"sandboxes. Listed below are the available fields (columns) in alphabetical\\n\"\n\t\"order:\\n\\n\"\n\t\"\\tCommand - command used to start the sandbox.\\n\"\n\t\"\\tCPU%% - CPU usage, the sandbox share of the elapsed CPU time since the\\n\"\n\t\"\\t       last screen update\\n\"\n\t\"\\tPID - Unique process ID for the task controlling the sandbox.\\n\"\n\t\"\\tPrcs - number of processes running in sandbox, including the\\n\"\n\t\"\\t       controlling process.\\n\"\n\t\"\\tRES - Resident Memory Size (KiB), sandbox non-swapped physical memory.\\n\"\n\t\"\\t      It is a sum of the RES values for all processes running in the\\n\"\n\t\"\\t      sandbox.\\n\"\n\t\"\\tSHR - Shared Memory Size (KiB), it reflects memory shared with other\\n\"\n\t\"\\t      processes. It is a sum of the SHR values for all processes\\n\"\n\t\"\\t      running in the sandbox, including the controlling process.\\n\"\n\t\"\\tUptime - sandbox running time in hours:minutes:seconds format.\\n\"\n\t\"\\tUser - The owner of the sandbox.\\n\"\n\t\"\\n\"\n\t\"License GPL version 2 or later\\n\"\n\t\"Homepage: https://firejail.wordpress.com\\n\"\n\t\"\\n\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firemon.h\"\n\nstatic char *help_str =\n\t\"Usage: firemon [OPTIONS] [PID]\\n\\n\"\n\t\"Monitor processes started in a Firejail sandbox. Without any PID specified,\\n\"\n\t\"all processes started by Firejail are monitored. Descendants of these processes\\n\"\n\t\"are also being monitored. On Grsecurity systems only root user\\n\"\n\t\"can run this program.\\n\\n\"\n\t\"Options:\\n\"\n\t\"\\t--apparmor - print AppArmor confinement status for each sandbox.\\n\\n\"\n\t\"\\t--arp - print ARP table for each sandbox.\\n\\n\"\n\t\"\\t--caps - print capabilities configuration for each sandbox.\\n\\n\"\n\t\"\\t--cgroup - print control group information for each sandbox.\\n\\n\"\n\t\"\\t--cpu - print CPU affinity for each sandbox.\\n\\n\"\n\t\"\\t--help, -? - this help screen.\\n\\n\"\n\t\"\\t--interface - print network interface information for each sandbox.\\n\\n\"\n\t\"\\t--list - list all sandboxes.\\n\\n\"\n\t\"\\t--name=name - print information only about named sandbox.\\n\\n\"\n\t\"\\t--netstats - monitor network statistics for sandboxes creating a new\\n\"\n\t\"\\t\\tnetwork namespace.\\n\\n\"\n\t\"\\t--nowrap - enable line wrapping in terminals.\\n\\n\"\n\t\"\\t--route - print route table for each sandbox.\\n\\n\"\n\t\"\\t--seccomp - print seccomp configuration for each sandbox.\\n\\n\"\n\t\"\\t--tree - print a tree of all sandboxed processes.\\n\\n\"\n\t\"\\t--top - monitor the most CPU-intensive sandboxes.\\n\\n\"\n\t\"\\t--version - print program version and exit.\\n\\n\"\n\t\"\\t--x11 - print X11 display number.\\n\\n\"\n\n\t\"Without any options, firemon monitors all fork, exec, id change, and exit\\n\"\n\t\"events in the sandbox. Monitoring a specific PID is also supported.\\n\\n\"\n\n\t\"Option --list prints a list of all sandboxes. The format for each entry is as\\n\"\n\t\"follows:\\n\\n\"\n\t\"\\tPID:USER:Command\\n\\n\"\n\n\t\"Option --tree prints the tree of processes running in the sandbox. The format\\n\"\n\t\"for each process entry is as follows:\\n\\n\"\n\t\"\\tPID:USER:Command\\n\\n\"\n\n\t\"Option --top is similar to the UNIX top command, however it applies only to\\n\"\n\t\"sandboxes. Listed below are the available fields (columns) in alphabetical\\n\"\n\t\"order:\\n\\n\"\n\t\"\\tCommand - command used to start the sandbox.\\n\"\n\t\"\\tCPU%% - CPU usage, the sandbox share of the elapsed CPU time since the\\n\"\n\t\"\\t       last screen update\\n\"\n\t\"\\tPID - Unique process ID for the task controlling the sandbox.\\n\"\n\t\"\\tPrcs - number of processes running in sandbox, including the\\n\"\n\t\"\\t       controlling process.\\n\"\n\t\"\\tRES - Resident Memory Size (KiB), sandbox non-swapped physical memory.\\n\"\n\t\"\\t      It is a sum of the RES values for all processes running in the\\n\"\n\t\"\\t      sandbox.\\n\"\n\t\"\\tSHR - Shared Memory Size (KiB), it reflects memory shared with other\\n\"\n\t\"\\t      processes. It is a sum of the SHR values for all processes\\n\"\n\t\"\\t      running in the sandbox, including the controlling process.\\n\"\n\t\"\\tUptime - sandbox running time in hours:minutes:seconds format.\\n\"\n\t\"\\tUser - The owner of the sandbox.\\n\"\n\t\"\\n\"\n\t\"License GPL version 2 or later\\n\"\n\t\"Homepage: https://firejail.wordpress.com\\n\"\n\t\"\\n\";\n\nvoid usage(void) {\n\tprintf(\"firemon - version %s\\n\", VERSION);\n\tputs(help_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-?\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--help\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "my_handler"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "my_handler"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\npid_t skip_process = 0;\nstatic int arg_route = 0;\nstatic int arg_arp = 0;\nstatic int arg_tree = 0;\nstatic int arg_interface = 0;\nstatic int arg_seccomp = 0;\nstatic int arg_caps = 0;\nstatic int arg_cpu = 0;\nstatic int arg_cgroup = 0;\nstatic int arg_x11 = 0;\nstatic int arg_top = 0;\nstatic int arg_list = 0;\nstatic int arg_netstats = 0;\nstatic int arg_apparmor = 0;\nint arg_nowrap = 0;\n\nint main(int argc, char **argv) {\n\tunsigned pid = 0;\n\tint i;\n\n\t// handle CTRL-C\n\tsignal (SIGINT, my_handler);\n\tsignal (SIGTERM, my_handler);\n\n\tfor (i = 1; i < argc; i++) {\n\t\t// default options\n\t\tif (strcmp(argv[i], \"--help\") == 0 ||\n\t\t    strcmp(argv[i], \"-?\") == 0) {\n\t\t\tusage();\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--version\") == 0) {\n\t\t\tprintf(\"firemon version %s\\n\\n\", VERSION);\n\t\t\treturn 0;\n\t\t}\n\n\t\t// options without a pid argument\n\t\telse if (strcmp(argv[i], \"--top\") == 0)\n\t\t\targ_top = 1;\n\t\telse if (strcmp(argv[i], \"--list\") == 0)\n\t\t\targ_list = 1;\n\t\telse if (strcmp(argv[i], \"--tree\") == 0)\n\t\t\targ_tree = 1;\n\t\telse if (strcmp(argv[i], \"--netstats\") == 0) {\n\t\t\tstruct stat s;\n\t\t\tif (getuid() != 0 && stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: this feature is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_netstats = 1;\n\t\t}\n\n\n\t\t// cumulative options with or without a pid argument\n\t\telse if (strcmp(argv[i], \"--x11\") == 0)\n\t\t\targ_x11 = 1;\n\t\telse if (strcmp(argv[i], \"--cgroup\") == 0)\n\t\t\targ_cgroup = 1;\n\t\telse if (strcmp(argv[i], \"--cpu\") == 0)\n\t\t\targ_cpu = 1;\n\t\telse if (strcmp(argv[i], \"--seccomp\") == 0)\n\t\t\targ_seccomp = 1;\n\t\telse if (strcmp(argv[i], \"--caps\") == 0)\n\t\t\targ_caps = 1;\n\t\telse if (strcmp(argv[i], \"--interface\") == 0) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: you need to be root to run this command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_interface = 1;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--route\") == 0)\n\t\t\targ_route = 1;\n\t\telse if (strcmp(argv[i], \"--arp\") == 0)\n\t\t\targ_arp = 1;\n\t\telse if (strcmp(argv[i], \"--apparmor\") == 0)\n\t\t\targ_apparmor = 1;\n\n\t\telse if (strncmp(argv[i], \"--name=\", 7) == 0) {\n\t\t\tchar *name = argv[i] + 7;\n\t\t\tif (name2pid(name, (pid_t *) &pid)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot find sandbox %s\\n\", name);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t// etc\n\t\telse if (strcmp(argv[i], \"--nowrap\") == 0)\n\t\t\targ_nowrap = 1;\n\n\t\t// invalid option\n\t\telse if (*argv[i] == '-') {\n\t\t\tfprintf(stderr, \"Error: invalid option\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t// PID argument\n\t\telse {\n\t\t\t// this should be a pid number\n\t\t\tchar *ptr = argv[i];\n\t\t\twhile (*ptr != '\\0') {\n\t\t\t\tif (!isdigit(*ptr)) {\n\t\t\t\t\tfprintf(stderr, \"Error: not a valid PID number\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tptr++;\n\t\t\t}\n\n\t\t\tsscanf(argv[i], \"%u\", &pid);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t// if the parent is firejail, skip the process\n\tpid_t ppid = getppid();\n\tchar *pcomm = pid_proc_comm(ppid);\n\tif (pcomm && strcmp(pcomm, \"firejail\") == 0)\n\t\tskip_process = ppid;\n\n\t// allow only root user if /proc is mounted hidepid\n\tif (pid_hidepid() && getuid() != 0) {\n\t\tfprintf(stderr, \"Error: /proc is mounted hidepid, you would need to be root to run this command\\n\");\n\t\texit(1);\n\t}\n\n\tif (arg_top) {\n\t\ttop();\t// print all sandboxes, --name disregarded\n\t\treturn 0;\n\t}\n\tif (arg_list) {\n\t\tlist();\t// print all sandboxes, --name disregarded\n\t\treturn 0;\n\t}\n\tif (arg_netstats) {\n\t\tnetstats();\t// print all sandboxes, --name disregarded\n\t\treturn 0;\n\t}\n\tif (arg_tree) {\n\t\ttree(pid);\n\t\treturn 0;\n\t}\n\n\t// if --name requested without other options, print all data\n\tif (pid && !arg_cpu && !arg_seccomp && !arg_caps && !arg_apparmor &&\n\t    !arg_cgroup && !arg_x11 && !arg_interface && !arg_route && !arg_arp) {\n\t\targ_tree = 1;\n\t\targ_cpu = 1;\n\t\targ_seccomp = 1;\n\t\targ_caps = 1;\n\t\targ_cgroup = 1;\n\t\targ_x11 = 1;\n\t\targ_interface = 1;\n\t\targ_route = 1;\n\t\targ_arp = 1;\n\t\targ_apparmor = 1;\n\t}\n\n\t// cumulative options\n\tint print_procs = 1;\n\tif (arg_cpu) {\n\t\tcpu((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_seccomp) {\n\t\tseccomp((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_caps) {\n\t\tcaps((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_apparmor) {\n\t\tapparmor((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_cgroup) {\n\t\tcgroup((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_x11) {\n\t\tx11((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_interface && getuid() == 0) {\n\t\tinterface((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_route) {\n\t\troute((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\tif (arg_arp) {\n\t\tarp((pid_t) pid, print_procs);\n\t\tprint_procs = 0;\n\t}\n\t(void) print_procs;\n\n\tif (getuid() == 0) {\n\t\ttree((pid_t) pid);\t// pid initialized as zero, will print the tree for all processes if a specific pid was not requested\n\t\tprocevent((pid_t) pid);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "firemon_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
    "lines": "90-121",
    "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <grp.h>",
      "#include <sys/prctl.h>",
      "#include <sys/ioctl.h>",
      "#include <termios.h>",
      "#include <signal.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct termios tlocal;",
      "static struct termios twait;",
      "static int terminal_set = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "0",
            "TCSANOW",
            "&tlocal"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "0",
            "TCSANOW",
            "&tlocal"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getchar",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "0",
            "&fds"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "maxfd",
            "&fds",
            "(fd_set *) 0",
            "(fd_set *) 0",
            "&ts"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "0",
            "&fds"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fds"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "0",
            "TCSANOW",
            "&twait"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tlocal",
            "&twait",
            "sizeof(tlocal)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "0",
            "&twait"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
  },
  {
    "function_name": "find_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
    "lines": "65-87",
    "snippet": "int find_child(int id) {\n\tint i;\n\tint first_child = -1;\n\n\t// find the first child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 2 && pids[i].parent == id) {\n\t\t\tfirst_child = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (first_child == -1)\n\t\treturn -1;\n\n\t// find the second child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 3 && pids[i].parent == first_child)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <grp.h>",
      "#include <sys/prctl.h>",
      "#include <sys/ioctl.h>",
      "#include <termios.h>",
      "#include <signal.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nint find_child(int id) {\n\tint i;\n\tint first_child = -1;\n\n\t// find the first child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 2 && pids[i].parent == id) {\n\t\t\tfirst_child = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (first_child == -1)\n\t\treturn -1;\n\n\t// find the second child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 3 && pids[i].parent == first_child)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "my_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
    "lines": "48-55",
    "snippet": "static void my_handler(int s){\n\t// Remove unused parameter warning\n\t(void)s;\n\n\tif (terminal_set)\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\texit(0);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <grp.h>",
      "#include <sys/prctl.h>",
      "#include <sys/ioctl.h>",
      "#include <termios.h>",
      "#include <signal.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct termios tlocal;",
      "static int terminal_set = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "0",
            "TCSANOW",
            "&tlocal"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic int terminal_set = 0;\n\nstatic void my_handler(int s){\n\t// Remove unused parameter warning\n\t(void)s;\n\n\tif (terminal_set)\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\texit(0);\n}"
  }
]