[
  {
    "function_name": "env_apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
    "lines": "209-222",
    "snippet": "void env_apply(void) {\n\tEnv *env = envlist;\n\n\twhile (env) {\n\t\tif (env->op == SETENV) {\n\t\t\tif (setenv(env->name, env->value, 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\telse if (env->op == RMENV) {\n\t\t\tunsetenv(env->name);\n\t\t}\n\t\tenv = env->next;\n\t}\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Env *envlist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unsetenv",
          "args": [
            "env->name"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "env->name",
            "env->value",
            "1"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic Env *envlist = NULL;\n\nvoid env_apply(void) {\n\tEnv *env = envlist;\n\n\twhile (env) {\n\t\tif (env->op == SETENV) {\n\t\t\tif (setenv(env->name, env->value, 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\telse if (env->op == RMENV) {\n\t\t\tunsetenv(env->name);\n\t\t}\n\t\tenv = env->next;\n\t}\n}"
  },
  {
    "function_name": "env_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
    "lines": "167-206",
    "snippet": "void env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid --env setting\\n\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_add",
          "args": [
            "env"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "env_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
          "lines": "34-51",
          "snippet": "static void env_add(Env *env) {\n\tenv->next = NULL;\n\n\t// add the new entry at the end of the list\n\tif (envlist == NULL) {\n\t\tenvlist = env;\n\t\treturn;\n\t}\n\n\tEnv *ptr = envlist;\n\twhile (1) {\n\t\tif (ptr->next == NULL) {\n\t\t\tptr->next = env;\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Env *envlist = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic Env *envlist = NULL;\n\nstatic void env_add(Env *env) {\n\tenv->next = NULL;\n\n\t// add the new entry at the end of the list\n\tif (envlist == NULL) {\n\t\tenvlist = env;\n\t\treturn;\n\t}\n\n\tEnv *ptr = envlist;\n\twhile (1) {\n\t\tif (ptr->next == NULL) {\n\t\t\tptr->next = env;\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ptr2"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "env->name",
            "'='"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "env",
            "0",
            "sizeof(Env)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(Env)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'='"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}"
  },
  {
    "function_name": "env_defaults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
    "lines": "118-164",
    "snippet": "void env_defaults(void) {\n\t// Qt fixes\n\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n\tif (setenv(\"QML_DISABLE_DISK_CACHE\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n//\tif (setenv(\"QTWEBENGINE_DISABLE_SANDBOX\", \"1\", 1) < 0)\n//\t\terrExit(\"setenv\");\n//\tif (setenv(\"MOZ_NO_REMOTE, \"1\", 1) < 0)\n//\t\terrExit(\"setenv\");\n\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\terrExit(\"setenv\");\n\tif (!cfg.shell)\n\t\tcfg.shell = guess_shell();\n\tif (cfg.shell && setenv(\"SHELL\", cfg.shell, 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// spawn KIO slaves inside the sandbox\n\tif (setenv(\"KDE_FORK_SLAVES\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// set prompt color to green\n\tint set_prompt = 0;\n\tif (checkcfg(CFG_FIREJAIL_PROMPT))\n\t\tset_prompt = 1;\n\telse { // check FIREJAIL_PROMPT=\"yes\" environment variable\n\t\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\t\tif (prompt && strcmp(prompt, \"yes\") == 0)\n\t\t\tset_prompt = 1;\n\t}\n\n\tif (set_prompt) {\n\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\telse {\n\t\t// remove PROMPT_COMMAND\n\t\tif (setenv(\"PROMPT_COMMAND\", \":\", 1) < 0) // unsetenv() will not work here, bash still picks it up from somewhere\n\t\t\terrExit(\"setenv\");\n\t}\n\n\t// set the window title\n\tif (!arg_quiet)\n\t\tprintf(\"\\033]0;firejail %s\\007\", cfg.window_title);\n\tfflush(0);\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\033]0;firejail %s\\007\"",
            "cfg.window_title"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"PROMPT_COMMAND\"",
            "\":\"",
            "1"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"PROMPT_COMMAND\"",
            "\"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\"",
            "1"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "prompt",
            "\"yes\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_PROMPT\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_FIREJAIL_PROMPT"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/checkcfg.c",
          "lines": "35-213",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *xpra_extra_params = \"\";",
            "char *xvfb_screen = \"800x600x24\";",
            "char *xvfb_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *xpra_extra_params = \"\";\nchar *xvfb_screen = \"800x600x24\";\nchar *xvfb_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"KDE_FORK_SLAVES\"",
            "\"1\"",
            "1"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"SHELL\"",
            "cfg.shell",
            "1"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_shell",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "guess_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "810-835",
          "snippet": "char *guess_shell(void) {\n\tchar *shell = NULL;\n\tstruct stat s;\n\n\tshell = getenv(\"SHELL\");\n\tif (shell) {\n\t\tinvalid_filename(shell, 0); // no globbing\n\t\tif (!is_dir(shell) && strstr(shell, \"..\") == NULL && stat(shell, &s) == 0 && access(shell, X_OK) == 0)\n\t\t\treturn shell;\n\t}\n\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], X_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nchar *guess_shell(void) {\n\tchar *shell = NULL;\n\tstruct stat s;\n\n\tshell = getenv(\"SHELL\");\n\tif (shell) {\n\t\tinvalid_filename(shell, 0); // no globbing\n\t\tif (!is_dir(shell) && strstr(shell, \"..\") == NULL && stat(shell, &s) == 0 && access(shell, X_OK) == 0)\n\t\t\treturn shell;\n\t}\n\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], X_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"container\"",
            "\"firejail\"",
            "1"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"QML_DISABLE_DISK_CACHE\"",
            "\"1\"",
            "1"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"QT_X11_NO_MITSHM\"",
            "\"1\"",
            "1"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_defaults(void) {\n\t// Qt fixes\n\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n\tif (setenv(\"QML_DISABLE_DISK_CACHE\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n//\tif (setenv(\"QTWEBENGINE_DISABLE_SANDBOX\", \"1\", 1) < 0)\n//\t\terrExit(\"setenv\");\n//\tif (setenv(\"MOZ_NO_REMOTE, \"1\", 1) < 0)\n//\t\terrExit(\"setenv\");\n\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\terrExit(\"setenv\");\n\tif (!cfg.shell)\n\t\tcfg.shell = guess_shell();\n\tif (cfg.shell && setenv(\"SHELL\", cfg.shell, 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// spawn KIO slaves inside the sandbox\n\tif (setenv(\"KDE_FORK_SLAVES\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// set prompt color to green\n\tint set_prompt = 0;\n\tif (checkcfg(CFG_FIREJAIL_PROMPT))\n\t\tset_prompt = 1;\n\telse { // check FIREJAIL_PROMPT=\"yes\" environment variable\n\t\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\t\tif (prompt && strcmp(prompt, \"yes\") == 0)\n\t\t\tset_prompt = 1;\n\t}\n\n\tif (set_prompt) {\n\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\telse {\n\t\t// remove PROMPT_COMMAND\n\t\tif (setenv(\"PROMPT_COMMAND\", \":\", 1) < 0) // unsetenv() will not work here, bash still picks it up from somewhere\n\t\t\terrExit(\"setenv\");\n\t}\n\n\t// set the window title\n\tif (!arg_quiet)\n\t\tprintf(\"\\033]0;firejail %s\\007\", cfg.window_title);\n\tfflush(0);\n}"
  },
  {
    "function_name": "env_ibus_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
    "lines": "54-114",
    "snippet": "void env_ibus_load(void) {\n\tEUID_ASSERT();\n\n\t// check ~/.config/ibus/bus directory\n\tchar *dirname;\n\tif (asprintf(&dirname, \"%s/.config/ibus/bus\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(dirname, &s) == -1)\n\t\treturn;\n\n\t// find the file\n\t/* coverity[toctou] */\n\tDIR *dir = opendir(dirname);\n\tif (!dir) {\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\t// check the file name ends in \"unix-0\"\n\t\tchar *ptr = strstr(entry->d_name, \"unix-0\");\n\t\tif (!ptr)\n\t\t\tcontinue;\n\t\tif (strlen(ptr) != 6)\n\t\t\tcontinue;\n\n\t\t// open the file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tfree(fname);\n\t\tif (!fp)\n\t\t\tcontinue;\n\n\t\t// read the file\n\t\tconst int maxline = 4096;\n\t\tchar buf[maxline];\n\t\twhile (fgets(buf, maxline, fp)) {\n\t\t\tif (strncmp(buf, \"IBUS_\", 5) != 0)\n\t\t\t\tcontinue;\n\t\t\tchar *ptr = strchr(buf, '=');\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"%s\\n\", buf);\n\t\t\tenv_store(buf, SETENV);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tfree(dirname);\n\tclosedir(dir);\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dirname"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_store",
          "args": [
            "buf",
            "SETENV"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "env_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
          "lines": "167-206",
          "snippet": "void env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "buf"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'='"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"IBUS_\"",
            "5"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "maxline",
            "fp"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/%s\"",
            "dirname",
            "entry->d_name"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "entry->d_name",
            "\"unix-0\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dirname"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "dirname"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "466-473",
          "snippet": "DIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_opendir_t orig_opendir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dirname",
            "&s"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dirname",
            "\"%s/.config/ibus/bus\"",
            "cfg.homedir"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_ibus_load(void) {\n\tEUID_ASSERT();\n\n\t// check ~/.config/ibus/bus directory\n\tchar *dirname;\n\tif (asprintf(&dirname, \"%s/.config/ibus/bus\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(dirname, &s) == -1)\n\t\treturn;\n\n\t// find the file\n\t/* coverity[toctou] */\n\tDIR *dir = opendir(dirname);\n\tif (!dir) {\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\t// check the file name ends in \"unix-0\"\n\t\tchar *ptr = strstr(entry->d_name, \"unix-0\");\n\t\tif (!ptr)\n\t\t\tcontinue;\n\t\tif (strlen(ptr) != 6)\n\t\t\tcontinue;\n\n\t\t// open the file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tfree(fname);\n\t\tif (!fp)\n\t\t\tcontinue;\n\n\t\t// read the file\n\t\tconst int maxline = 4096;\n\t\tchar buf[maxline];\n\t\twhile (fgets(buf, maxline, fp)) {\n\t\t\tif (strncmp(buf, \"IBUS_\", 5) != 0)\n\t\t\t\tcontinue;\n\t\t\tchar *ptr = strchr(buf, '=');\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"%s\\n\", buf);\n\t\t\tenv_store(buf, SETENV);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tfree(dirname);\n\tclosedir(dir);\n}"
  },
  {
    "function_name": "env_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
    "lines": "34-51",
    "snippet": "static void env_add(Env *env) {\n\tenv->next = NULL;\n\n\t// add the new entry at the end of the list\n\tif (envlist == NULL) {\n\t\tenvlist = env;\n\t\treturn;\n\t}\n\n\tEnv *ptr = envlist;\n\twhile (1) {\n\t\tif (ptr->next == NULL) {\n\t\t\tptr->next = env;\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Env *envlist = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic Env *envlist = NULL;\n\nstatic void env_add(Env *env) {\n\tenv->next = NULL;\n\n\t// add the new entry at the end of the list\n\tif (envlist == NULL) {\n\t\tenvlist = env;\n\t\treturn;\n\t}\n\n\tEnv *ptr = envlist;\n\twhile (1) {\n\t\tif (ptr->next == NULL) {\n\t\t\tptr->next = env;\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n}"
  }
]