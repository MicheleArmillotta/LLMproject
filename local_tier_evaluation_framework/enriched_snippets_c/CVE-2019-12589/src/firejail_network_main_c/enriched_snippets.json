[
  {
    "function_name": "net_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
    "lines": "376-381",
    "snippet": "void net_print(pid_t pid) {\n\tEUID_ASSERT();\n\n\tenter_network_namespace(pid);\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET_MAIN, \"printif\");\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <stdarg.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sbox_run",
          "args": [
            "SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP",
            "2",
            "PATH_FNET_MAIN",
            "\"printif\""
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "sbox_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sbox.c",
          "lines": "107-223",
          "snippet": "int sbox_run(unsigned filter, int num, ...) {\n\tEUID_ROOT();\n\n\tint i;\n\tva_list valist;\n\tva_start(valist, num);\n\n\t// build argument list\n\tchar *arg[num + 1];\n\tfor (i = 0; i < num; i++)\n\t\targ[i] = va_arg(valist, char*);\n\targ[i] = NULL;\n\tva_end(valist);\n\n\tif (arg_debug) {\n\t\tprintf(\"sbox run: \");\n\t\tfor (i = 0; i <= num; i++)\n\t\t\tprintf(\"%s \", arg[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// clean the new process\n\t\tclearenv();\n\n\t\tif (filter & SBOX_STDIN_FROM_FILE) {\n\t\t\tint fd;\n\t\t\tif((fd = open(SBOX_STDIN_FILE, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr,\"Error: cannot open %s\\n\", SBOX_STDIN_FILE);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tdup2(fd,STDIN_FILENO);\n\t\t\tclose(fd);\n\t\t}\n\t\telse if ((filter & SBOX_ALLOW_STDIN) == 0) {\n\t\t\tint fd = open(\"/dev/null\",O_RDWR, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse // the user could run the sandbox without /dev/null\n\t\t\t\tclose(STDIN_FILENO);\n\t\t}\n\n\t\t// close all other file descriptors\n\t\tint max = 20; // getdtablesize() is overkill for a firejail process\n\t\tfor (i = 3; i < max; i++)\n\t\t\tclose(i); // close open files\n\n\t\tumask(027);\n\n\t\t// apply filters\n\t\tif (filter & SBOX_CAPS_NONE) {\n\t\t\tcaps_drop_all();\n\t\t}\n\t\telse if (filter & SBOX_CAPS_NETWORK) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_NET_ADMIN;\n\t\t\tset |=  ((uint64_t) 1) << CAP_NET_RAW;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\t\telse if (filter & SBOX_CAPS_HIDEPID) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_SYS_PTRACE;\n\t\t\tset |=  ((uint64_t) 1) << CAP_SYS_PACCT;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\n\t\tif (filter & SBOX_SECCOMP) {\n\t\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\t\t}\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\t\t\tperror(\"prctl(PR_SET_SECCOMP)\");\n\t\t\t}\n\t\t}\n\n\t\tif (filter & SBOX_ROOT) {\n\t\t\t// elevate privileges in order to get grsecurity working\n\t\t\tif (setreuid(0, 0))\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0))\n\t\t\t\terrExit(\"setregid\");\n\t\t}\n\t\telse if (filter & SBOX_USER)\n\t\t\tdrop_privs(1);\n\n\t\tclearenv();\n\n\t\t// --quiet is passed as an environment variable\n\t\tif (arg_quiet)\n\t\t\tsetenv(\"FIREJAIL_QUIET\", \"yes\", 1);\n\n\t\tif (arg[0])\t// get rid of scan-build warning\n\t\t\texecvp(arg[0], arg);\n\t\telse\n\t\t\tassert(0);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tint status;\n\tif (waitpid(child, &status, 0) == -1 ) {\n\t\terrExit(\"waitpid\");\n\t}\n\tif (WIFEXITED(status) && status != 0) {\n\t\tfprintf(stderr, \"Error: failed to run %s\\n\", arg[0]);\n\t\texit(1);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"../include/seccomp.h\"",
            "#include <sys/wait.h>",
            "#include <stdarg.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sock_filter filter[] = {\n\tVALIDATE_ARCHITECTURE,\n\tEXAMINE_SYSCALL,\n\n#if defined(__x86_64__)\n#define X32_SYSCALL_BIT 0x40000000\n\t// handle X32 ABI\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, X32_SYSCALL_BIT, 1, 0),\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, 0, 1, 0),\n\tRETURN_ERRNO(EPERM),\n#endif\n\n\t// syscall list\n#ifdef SYS_mount\n\tBLACKLIST(SYS_mount),  // mount/unmount filesystems\n#endif\n#ifdef SYS_umount2\n\tBLACKLIST(SYS_umount2),\n#endif\n#ifdef SYS_ptrace\n\tBLACKLIST(SYS_ptrace), // trace processes\n#endif\n#ifdef SYS_kexec_file_load\n\tBLACKLIST(SYS_kexec_file_load),\n#endif\n#ifdef SYS_kexec_load\n\tBLACKLIST(SYS_kexec_load), // loading a different kernel\n#endif\n#ifdef SYS_name_to_handle_at\n\tBLACKLIST(SYS_name_to_handle_at),\n#endif\n#ifdef SYS_open_by_handle_at\n\tBLACKLIST(SYS_open_by_handle_at), // open by handle\n#endif\n#ifdef SYS_init_module\n\tBLACKLIST(SYS_init_module), // kernel module handling\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\tBLACKLIST(SYS_finit_module),\n#endif\n#ifdef SYS_create_module\n\tBLACKLIST(SYS_create_module),\n#endif\n#ifdef SYS_delete_module\n\tBLACKLIST(SYS_delete_module),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioperm\n\tBLACKLIST(SYS_ioperm),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioprio_set\n\tBLACKLIST(SYS_ioprio_set),\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\tBLACKLIST(SYS_ni_syscall),\n#endif\n#ifdef SYS_swapon\n\tBLACKLIST(SYS_swapon), // swap on/off\n#endif\n#ifdef SYS_swapoff\n\tBLACKLIST(SYS_swapoff),\n#endif\n#ifdef SYS_syslog\n\tBLACKLIST(SYS_syslog), // kernel printk control\n#endif\n\tRETURN_ALLOW\n};",
            "static struct sock_fprog prog = {\n\t.len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),\n\t.filter = filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/seccomp.h\"\n#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic struct sock_filter filter[] = {\n\tVALIDATE_ARCHITECTURE,\n\tEXAMINE_SYSCALL,\n\n#if defined(__x86_64__)\n#define X32_SYSCALL_BIT 0x40000000\n\t// handle X32 ABI\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, X32_SYSCALL_BIT, 1, 0),\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, 0, 1, 0),\n\tRETURN_ERRNO(EPERM),\n#endif\n\n\t// syscall list\n#ifdef SYS_mount\n\tBLACKLIST(SYS_mount),  // mount/unmount filesystems\n#endif\n#ifdef SYS_umount2\n\tBLACKLIST(SYS_umount2),\n#endif\n#ifdef SYS_ptrace\n\tBLACKLIST(SYS_ptrace), // trace processes\n#endif\n#ifdef SYS_kexec_file_load\n\tBLACKLIST(SYS_kexec_file_load),\n#endif\n#ifdef SYS_kexec_load\n\tBLACKLIST(SYS_kexec_load), // loading a different kernel\n#endif\n#ifdef SYS_name_to_handle_at\n\tBLACKLIST(SYS_name_to_handle_at),\n#endif\n#ifdef SYS_open_by_handle_at\n\tBLACKLIST(SYS_open_by_handle_at), // open by handle\n#endif\n#ifdef SYS_init_module\n\tBLACKLIST(SYS_init_module), // kernel module handling\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\tBLACKLIST(SYS_finit_module),\n#endif\n#ifdef SYS_create_module\n\tBLACKLIST(SYS_create_module),\n#endif\n#ifdef SYS_delete_module\n\tBLACKLIST(SYS_delete_module),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioperm\n\tBLACKLIST(SYS_ioperm),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioprio_set\n\tBLACKLIST(SYS_ioprio_set),\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\tBLACKLIST(SYS_ni_syscall),\n#endif\n#ifdef SYS_swapon\n\tBLACKLIST(SYS_swapon), // swap on/off\n#endif\n#ifdef SYS_swapoff\n\tBLACKLIST(SYS_swapoff),\n#endif\n#ifdef SYS_syslog\n\tBLACKLIST(SYS_syslog), // kernel printk control\n#endif\n\tRETURN_ALLOW\n};\nstatic struct sock_fprog prog = {\n\t.len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),\n\t.filter = filter,\n};\n\nint sbox_run(unsigned filter, int num, ...) {\n\tEUID_ROOT();\n\n\tint i;\n\tva_list valist;\n\tva_start(valist, num);\n\n\t// build argument list\n\tchar *arg[num + 1];\n\tfor (i = 0; i < num; i++)\n\t\targ[i] = va_arg(valist, char*);\n\targ[i] = NULL;\n\tva_end(valist);\n\n\tif (arg_debug) {\n\t\tprintf(\"sbox run: \");\n\t\tfor (i = 0; i <= num; i++)\n\t\t\tprintf(\"%s \", arg[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// clean the new process\n\t\tclearenv();\n\n\t\tif (filter & SBOX_STDIN_FROM_FILE) {\n\t\t\tint fd;\n\t\t\tif((fd = open(SBOX_STDIN_FILE, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr,\"Error: cannot open %s\\n\", SBOX_STDIN_FILE);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tdup2(fd,STDIN_FILENO);\n\t\t\tclose(fd);\n\t\t}\n\t\telse if ((filter & SBOX_ALLOW_STDIN) == 0) {\n\t\t\tint fd = open(\"/dev/null\",O_RDWR, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse // the user could run the sandbox without /dev/null\n\t\t\t\tclose(STDIN_FILENO);\n\t\t}\n\n\t\t// close all other file descriptors\n\t\tint max = 20; // getdtablesize() is overkill for a firejail process\n\t\tfor (i = 3; i < max; i++)\n\t\t\tclose(i); // close open files\n\n\t\tumask(027);\n\n\t\t// apply filters\n\t\tif (filter & SBOX_CAPS_NONE) {\n\t\t\tcaps_drop_all();\n\t\t}\n\t\telse if (filter & SBOX_CAPS_NETWORK) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_NET_ADMIN;\n\t\t\tset |=  ((uint64_t) 1) << CAP_NET_RAW;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\t\telse if (filter & SBOX_CAPS_HIDEPID) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_SYS_PTRACE;\n\t\t\tset |=  ((uint64_t) 1) << CAP_SYS_PACCT;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\n\t\tif (filter & SBOX_SECCOMP) {\n\t\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\t\t}\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\t\t\tperror(\"prctl(PR_SET_SECCOMP)\");\n\t\t\t}\n\t\t}\n\n\t\tif (filter & SBOX_ROOT) {\n\t\t\t// elevate privileges in order to get grsecurity working\n\t\t\tif (setreuid(0, 0))\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0))\n\t\t\t\terrExit(\"setregid\");\n\t\t}\n\t\telse if (filter & SBOX_USER)\n\t\t\tdrop_privs(1);\n\n\t\tclearenv();\n\n\t\t// --quiet is passed as an environment variable\n\t\tif (arg_quiet)\n\t\t\tsetenv(\"FIREJAIL_QUIET\", \"yes\", 1);\n\n\t\tif (arg[0])\t// get rid of scan-build warning\n\t\t\texecvp(arg[0], arg);\n\t\telse\n\t\t\tassert(0);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tint status;\n\tif (waitpid(child, &status, 0) == -1 ) {\n\t\terrExit(\"waitpid\");\n\t}\n\tif (WIFEXITED(status) && status != 0) {\n\t\tfprintf(stderr, \"Error: failed to run %s\\n\", arg[0]);\n\t\texit(1);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_network_namespace",
          "args": [
            "pid"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "enter_network_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1305-1341",
          "snippet": "void enter_network_namespace(pid_t pid) {\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid_t child = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(child)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// check network namespace\n\tchar *name;\n\tif (asprintf(&name, \"/run/firejail/network/%d-netmap\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: the sandbox doesn't use a new network namespace\\n\");\n\t\texit(1);\n\t}\n\n\t// join the namespace\n\tEUID_ROOT();\n\tif (join_namespace(child, \"net\")) {\n\t\tfprintf(stderr, \"Error: cannot join the network namespace\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid enter_network_namespace(pid_t pid) {\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid_t child = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(child)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// check network namespace\n\tchar *name;\n\tif (asprintf(&name, \"/run/firejail/network/%d-netmap\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: the sandbox doesn't use a new network namespace\\n\");\n\t\texit(1);\n\t}\n\n\t// join the namespace\n\tEUID_ROOT();\n\tif (join_namespace(child, \"net\")) {\n\t\tfprintf(stderr, \"Error: cannot join the network namespace\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_print(pid_t pid) {\n\tEUID_ASSERT();\n\n\tenter_network_namespace(pid);\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET_MAIN, \"printif\");\n}"
  },
  {
    "function_name": "network_main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
    "lines": "324-374",
    "snippet": "void network_main(pid_t child) {\n\tchar *cstr;\n\tif (asprintf(&cstr, \"%d\", child) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// create veth pair or macvlan device\n\tif (cfg.bridge0.configured) {\n\t\tif (cfg.bridge0.macvlan == 0) {\n\t\t\tnet_configure_veth_pair(&cfg.bridge0, \"eth0\", child);\n\t\t}\n\t\telse\n\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 6, PATH_FNET_MAIN, \"create\", \"macvlan\", cfg.bridge0.devsandbox, cfg.bridge0.dev, cstr);\n\t}\n\n\tif (cfg.bridge1.configured) {\n\t\tif (cfg.bridge1.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge1, \"eth1\", child);\n\t\telse\n\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 6, PATH_FNET_MAIN, \"create\", \"macvlan\", cfg.bridge1.devsandbox, cfg.bridge1.dev, cstr);\n\t}\n\n\tif (cfg.bridge2.configured) {\n\t\tif (cfg.bridge2.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge2, \"eth2\", child);\n\t\telse\n\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 6, PATH_FNET_MAIN, \"create\", \"macvlan\", cfg.bridge2.devsandbox, cfg.bridge2.dev, cstr);\n\t}\n\n\tif (cfg.bridge3.configured) {\n\t\tif (cfg.bridge3.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge3, \"eth3\", child);\n\t\telse\n\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 6, PATH_FNET_MAIN, \"create\", \"macvlan\", cfg.bridge3.devsandbox, cfg.bridge3.dev, cstr);\n\t}\n\n\t// move interfaces in sandbox\n\tif (cfg.interface0.configured) {\n\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 4, PATH_FNET_MAIN, \"moveif\", cfg.interface0.dev, cstr);\n\t}\n\tif (cfg.interface1.configured) {\n\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 4, PATH_FNET_MAIN, \"moveif\", cfg.interface1.dev, cstr);\n\t}\n\tif (cfg.interface2.configured) {\n\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 4, PATH_FNET_MAIN, \"moveif\", cfg.interface2.dev, cstr);\n\t}\n\tif (cfg.interface3.configured) {\n\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 4, PATH_FNET_MAIN, \"moveif\", cfg.interface3.dev, cstr);\n\t}\n\n\tfree(cstr);\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <stdarg.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cstr"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sbox_run",
          "args": [
            "SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP",
            "4",
            "PATH_FNET_MAIN",
            "\"moveif\"",
            "cfg.interface3.dev",
            "cstr"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "sbox_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sbox.c",
          "lines": "107-223",
          "snippet": "int sbox_run(unsigned filter, int num, ...) {\n\tEUID_ROOT();\n\n\tint i;\n\tva_list valist;\n\tva_start(valist, num);\n\n\t// build argument list\n\tchar *arg[num + 1];\n\tfor (i = 0; i < num; i++)\n\t\targ[i] = va_arg(valist, char*);\n\targ[i] = NULL;\n\tva_end(valist);\n\n\tif (arg_debug) {\n\t\tprintf(\"sbox run: \");\n\t\tfor (i = 0; i <= num; i++)\n\t\t\tprintf(\"%s \", arg[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// clean the new process\n\t\tclearenv();\n\n\t\tif (filter & SBOX_STDIN_FROM_FILE) {\n\t\t\tint fd;\n\t\t\tif((fd = open(SBOX_STDIN_FILE, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr,\"Error: cannot open %s\\n\", SBOX_STDIN_FILE);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tdup2(fd,STDIN_FILENO);\n\t\t\tclose(fd);\n\t\t}\n\t\telse if ((filter & SBOX_ALLOW_STDIN) == 0) {\n\t\t\tint fd = open(\"/dev/null\",O_RDWR, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse // the user could run the sandbox without /dev/null\n\t\t\t\tclose(STDIN_FILENO);\n\t\t}\n\n\t\t// close all other file descriptors\n\t\tint max = 20; // getdtablesize() is overkill for a firejail process\n\t\tfor (i = 3; i < max; i++)\n\t\t\tclose(i); // close open files\n\n\t\tumask(027);\n\n\t\t// apply filters\n\t\tif (filter & SBOX_CAPS_NONE) {\n\t\t\tcaps_drop_all();\n\t\t}\n\t\telse if (filter & SBOX_CAPS_NETWORK) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_NET_ADMIN;\n\t\t\tset |=  ((uint64_t) 1) << CAP_NET_RAW;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\t\telse if (filter & SBOX_CAPS_HIDEPID) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_SYS_PTRACE;\n\t\t\tset |=  ((uint64_t) 1) << CAP_SYS_PACCT;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\n\t\tif (filter & SBOX_SECCOMP) {\n\t\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\t\t}\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\t\t\tperror(\"prctl(PR_SET_SECCOMP)\");\n\t\t\t}\n\t\t}\n\n\t\tif (filter & SBOX_ROOT) {\n\t\t\t// elevate privileges in order to get grsecurity working\n\t\t\tif (setreuid(0, 0))\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0))\n\t\t\t\terrExit(\"setregid\");\n\t\t}\n\t\telse if (filter & SBOX_USER)\n\t\t\tdrop_privs(1);\n\n\t\tclearenv();\n\n\t\t// --quiet is passed as an environment variable\n\t\tif (arg_quiet)\n\t\t\tsetenv(\"FIREJAIL_QUIET\", \"yes\", 1);\n\n\t\tif (arg[0])\t// get rid of scan-build warning\n\t\t\texecvp(arg[0], arg);\n\t\telse\n\t\t\tassert(0);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tint status;\n\tif (waitpid(child, &status, 0) == -1 ) {\n\t\terrExit(\"waitpid\");\n\t}\n\tif (WIFEXITED(status) && status != 0) {\n\t\tfprintf(stderr, \"Error: failed to run %s\\n\", arg[0]);\n\t\texit(1);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"../include/seccomp.h\"",
            "#include <sys/wait.h>",
            "#include <stdarg.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sock_filter filter[] = {\n\tVALIDATE_ARCHITECTURE,\n\tEXAMINE_SYSCALL,\n\n#if defined(__x86_64__)\n#define X32_SYSCALL_BIT 0x40000000\n\t// handle X32 ABI\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, X32_SYSCALL_BIT, 1, 0),\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, 0, 1, 0),\n\tRETURN_ERRNO(EPERM),\n#endif\n\n\t// syscall list\n#ifdef SYS_mount\n\tBLACKLIST(SYS_mount),  // mount/unmount filesystems\n#endif\n#ifdef SYS_umount2\n\tBLACKLIST(SYS_umount2),\n#endif\n#ifdef SYS_ptrace\n\tBLACKLIST(SYS_ptrace), // trace processes\n#endif\n#ifdef SYS_kexec_file_load\n\tBLACKLIST(SYS_kexec_file_load),\n#endif\n#ifdef SYS_kexec_load\n\tBLACKLIST(SYS_kexec_load), // loading a different kernel\n#endif\n#ifdef SYS_name_to_handle_at\n\tBLACKLIST(SYS_name_to_handle_at),\n#endif\n#ifdef SYS_open_by_handle_at\n\tBLACKLIST(SYS_open_by_handle_at), // open by handle\n#endif\n#ifdef SYS_init_module\n\tBLACKLIST(SYS_init_module), // kernel module handling\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\tBLACKLIST(SYS_finit_module),\n#endif\n#ifdef SYS_create_module\n\tBLACKLIST(SYS_create_module),\n#endif\n#ifdef SYS_delete_module\n\tBLACKLIST(SYS_delete_module),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioperm\n\tBLACKLIST(SYS_ioperm),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioprio_set\n\tBLACKLIST(SYS_ioprio_set),\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\tBLACKLIST(SYS_ni_syscall),\n#endif\n#ifdef SYS_swapon\n\tBLACKLIST(SYS_swapon), // swap on/off\n#endif\n#ifdef SYS_swapoff\n\tBLACKLIST(SYS_swapoff),\n#endif\n#ifdef SYS_syslog\n\tBLACKLIST(SYS_syslog), // kernel printk control\n#endif\n\tRETURN_ALLOW\n};",
            "static struct sock_fprog prog = {\n\t.len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),\n\t.filter = filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/seccomp.h\"\n#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic struct sock_filter filter[] = {\n\tVALIDATE_ARCHITECTURE,\n\tEXAMINE_SYSCALL,\n\n#if defined(__x86_64__)\n#define X32_SYSCALL_BIT 0x40000000\n\t// handle X32 ABI\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, X32_SYSCALL_BIT, 1, 0),\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, 0, 1, 0),\n\tRETURN_ERRNO(EPERM),\n#endif\n\n\t// syscall list\n#ifdef SYS_mount\n\tBLACKLIST(SYS_mount),  // mount/unmount filesystems\n#endif\n#ifdef SYS_umount2\n\tBLACKLIST(SYS_umount2),\n#endif\n#ifdef SYS_ptrace\n\tBLACKLIST(SYS_ptrace), // trace processes\n#endif\n#ifdef SYS_kexec_file_load\n\tBLACKLIST(SYS_kexec_file_load),\n#endif\n#ifdef SYS_kexec_load\n\tBLACKLIST(SYS_kexec_load), // loading a different kernel\n#endif\n#ifdef SYS_name_to_handle_at\n\tBLACKLIST(SYS_name_to_handle_at),\n#endif\n#ifdef SYS_open_by_handle_at\n\tBLACKLIST(SYS_open_by_handle_at), // open by handle\n#endif\n#ifdef SYS_init_module\n\tBLACKLIST(SYS_init_module), // kernel module handling\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\tBLACKLIST(SYS_finit_module),\n#endif\n#ifdef SYS_create_module\n\tBLACKLIST(SYS_create_module),\n#endif\n#ifdef SYS_delete_module\n\tBLACKLIST(SYS_delete_module),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioperm\n\tBLACKLIST(SYS_ioperm),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioprio_set\n\tBLACKLIST(SYS_ioprio_set),\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\tBLACKLIST(SYS_ni_syscall),\n#endif\n#ifdef SYS_swapon\n\tBLACKLIST(SYS_swapon), // swap on/off\n#endif\n#ifdef SYS_swapoff\n\tBLACKLIST(SYS_swapoff),\n#endif\n#ifdef SYS_syslog\n\tBLACKLIST(SYS_syslog), // kernel printk control\n#endif\n\tRETURN_ALLOW\n};\nstatic struct sock_fprog prog = {\n\t.len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),\n\t.filter = filter,\n};\n\nint sbox_run(unsigned filter, int num, ...) {\n\tEUID_ROOT();\n\n\tint i;\n\tva_list valist;\n\tva_start(valist, num);\n\n\t// build argument list\n\tchar *arg[num + 1];\n\tfor (i = 0; i < num; i++)\n\t\targ[i] = va_arg(valist, char*);\n\targ[i] = NULL;\n\tva_end(valist);\n\n\tif (arg_debug) {\n\t\tprintf(\"sbox run: \");\n\t\tfor (i = 0; i <= num; i++)\n\t\t\tprintf(\"%s \", arg[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// clean the new process\n\t\tclearenv();\n\n\t\tif (filter & SBOX_STDIN_FROM_FILE) {\n\t\t\tint fd;\n\t\t\tif((fd = open(SBOX_STDIN_FILE, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr,\"Error: cannot open %s\\n\", SBOX_STDIN_FILE);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tdup2(fd,STDIN_FILENO);\n\t\t\tclose(fd);\n\t\t}\n\t\telse if ((filter & SBOX_ALLOW_STDIN) == 0) {\n\t\t\tint fd = open(\"/dev/null\",O_RDWR, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse // the user could run the sandbox without /dev/null\n\t\t\t\tclose(STDIN_FILENO);\n\t\t}\n\n\t\t// close all other file descriptors\n\t\tint max = 20; // getdtablesize() is overkill for a firejail process\n\t\tfor (i = 3; i < max; i++)\n\t\t\tclose(i); // close open files\n\n\t\tumask(027);\n\n\t\t// apply filters\n\t\tif (filter & SBOX_CAPS_NONE) {\n\t\t\tcaps_drop_all();\n\t\t}\n\t\telse if (filter & SBOX_CAPS_NETWORK) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_NET_ADMIN;\n\t\t\tset |=  ((uint64_t) 1) << CAP_NET_RAW;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\t\telse if (filter & SBOX_CAPS_HIDEPID) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_SYS_PTRACE;\n\t\t\tset |=  ((uint64_t) 1) << CAP_SYS_PACCT;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\n\t\tif (filter & SBOX_SECCOMP) {\n\t\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\t\t}\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\t\t\tperror(\"prctl(PR_SET_SECCOMP)\");\n\t\t\t}\n\t\t}\n\n\t\tif (filter & SBOX_ROOT) {\n\t\t\t// elevate privileges in order to get grsecurity working\n\t\t\tif (setreuid(0, 0))\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0))\n\t\t\t\terrExit(\"setregid\");\n\t\t}\n\t\telse if (filter & SBOX_USER)\n\t\t\tdrop_privs(1);\n\n\t\tclearenv();\n\n\t\t// --quiet is passed as an environment variable\n\t\tif (arg_quiet)\n\t\t\tsetenv(\"FIREJAIL_QUIET\", \"yes\", 1);\n\n\t\tif (arg[0])\t// get rid of scan-build warning\n\t\t\texecvp(arg[0], arg);\n\t\telse\n\t\t\tassert(0);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tint status;\n\tif (waitpid(child, &status, 0) == -1 ) {\n\t\terrExit(\"waitpid\");\n\t}\n\tif (WIFEXITED(status) && status != 0) {\n\t\tfprintf(stderr, \"Error: failed to run %s\\n\", arg[0]);\n\t\texit(1);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_configure_veth_pair",
          "args": [
            "&cfg.bridge3",
            "\"eth3\"",
            "child"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "net_configure_veth_pair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
          "lines": "143-169",
          "snippet": "void net_configure_veth_pair(Bridge *br, const char *ifname, pid_t child) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\t// create a veth pair\n\tchar *dev;\n\tif (br->veth_name == NULL) {\n\t\tif (asprintf(&dev, \"veth%u%s\", getpid(), ifname) < 0)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse\n\t\tdev = br->veth_name;\n\n\tchar *cstr;\n\tif (asprintf(&cstr, \"%d\", child) == -1)\n\t\terrExit(\"asprintf\");\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 7, PATH_FNET_MAIN, \"create\", \"veth\", dev, ifname, br->dev, cstr);\n\tfree(cstr);\n\n\tchar *msg;\n\tif (asprintf(&msg, \"%d.%d.%d.%d address assigned to sandbox\", PRINT_IP(br->ipsandbox)) == -1)\n\t\terrExit(\"asprintf\");\n\tlogmsg(msg);\n\tfflush(0);\n\tfree(msg);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <stdarg.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_configure_veth_pair(Bridge *br, const char *ifname, pid_t child) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\t// create a veth pair\n\tchar *dev;\n\tif (br->veth_name == NULL) {\n\t\tif (asprintf(&dev, \"veth%u%s\", getpid(), ifname) < 0)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse\n\t\tdev = br->veth_name;\n\n\tchar *cstr;\n\tif (asprintf(&cstr, \"%d\", child) == -1)\n\t\terrExit(\"asprintf\");\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 7, PATH_FNET_MAIN, \"create\", \"veth\", dev, ifname, br->dev, cstr);\n\tfree(cstr);\n\n\tchar *msg;\n\tif (asprintf(&msg, \"%d.%d.%d.%d address assigned to sandbox\", PRINT_IP(br->ipsandbox)) == -1)\n\t\terrExit(\"asprintf\");\n\tlogmsg(msg);\n\tfflush(0);\n\tfree(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cstr",
            "\"%d\"",
            "child"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid network_main(pid_t child) {\n\tchar *cstr;\n\tif (asprintf(&cstr, \"%d\", child) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// create veth pair or macvlan device\n\tif (cfg.bridge0.configured) {\n\t\tif (cfg.bridge0.macvlan == 0) {\n\t\t\tnet_configure_veth_pair(&cfg.bridge0, \"eth0\", child);\n\t\t}\n\t\telse\n\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 6, PATH_FNET_MAIN, \"create\", \"macvlan\", cfg.bridge0.devsandbox, cfg.bridge0.dev, cstr);\n\t}\n\n\tif (cfg.bridge1.configured) {\n\t\tif (cfg.bridge1.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge1, \"eth1\", child);\n\t\telse\n\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 6, PATH_FNET_MAIN, \"create\", \"macvlan\", cfg.bridge1.devsandbox, cfg.bridge1.dev, cstr);\n\t}\n\n\tif (cfg.bridge2.configured) {\n\t\tif (cfg.bridge2.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge2, \"eth2\", child);\n\t\telse\n\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 6, PATH_FNET_MAIN, \"create\", \"macvlan\", cfg.bridge2.devsandbox, cfg.bridge2.dev, cstr);\n\t}\n\n\tif (cfg.bridge3.configured) {\n\t\tif (cfg.bridge3.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge3, \"eth3\", child);\n\t\telse\n\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 6, PATH_FNET_MAIN, \"create\", \"macvlan\", cfg.bridge3.devsandbox, cfg.bridge3.dev, cstr);\n\t}\n\n\t// move interfaces in sandbox\n\tif (cfg.interface0.configured) {\n\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 4, PATH_FNET_MAIN, \"moveif\", cfg.interface0.dev, cstr);\n\t}\n\tif (cfg.interface1.configured) {\n\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 4, PATH_FNET_MAIN, \"moveif\", cfg.interface1.dev, cstr);\n\t}\n\tif (cfg.interface2.configured) {\n\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 4, PATH_FNET_MAIN, \"moveif\", cfg.interface2.dev, cstr);\n\t}\n\tif (cfg.interface3.configured) {\n\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 4, PATH_FNET_MAIN, \"moveif\", cfg.interface3.dev, cstr);\n\t}\n\n\tfree(cstr);\n}"
  },
  {
    "function_name": "net_dns_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
    "lines": "268-322",
    "snippet": "void net_dns_print(pid_t pid) {\n\tEUID_ASSERT();\n\t// drop privileges - will not be able to read /etc/resolv.conf for --noroot option\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(pid)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\tif (join_namespace(pid, \"mnt\"))\n\t\texit(1);\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tcaps_drop_all();\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\n\t\t// access /etc/resolv.conf\n\t\tFILE *fp = fopen(\"/etc/resolv.conf\", \"r\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Error: cannot access /etc/resolv.conf\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tchar buf[MAXBUF];\n\t\twhile (fgets(buf, MAXBUF, fp))\n\t\t\tprintf(\"%s\", buf);\n\t\tprintf(\"\\n\");\n\t\tfclose(fp);\n\t\texit(0);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tflush_stdin();\n\texit(0);\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <stdarg.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAXBUF 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_stdin",
          "args": [],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "flush_stdin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "959-969",
          "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\"",
            "buf"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fp"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot access /etc/resolv.conf\\n\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/etc/resolv.conf\"",
            "\"r\""
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "fchdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "684-708",
          "snippet": "int fchdir(int fd) {\n#ifdef DEBUG\n\tprintf(\"%s %d\\n\", __FUNCTION__, fd);\n#endif\n\tif (!orig_fchdir)\n\t\torig_fchdir = (orig_fchdir_t)dlsym(RTLD_NEXT, \"fchdir\");\n\n\tfree(cwd);\n\tchar *pathname=malloc(PATH_MAX);\n\tif (pathname) {\n\t\tif (snprintf(pathname,PATH_MAX,\"/proc/self/fd/%d\", fd)>0) {\n\t\t\tcwd = realpath(pathname, NULL);\n\t\t} else {\n\t\t\tcwd = NULL;\n\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t}\n\t\tfree(pathname);\n\t} else {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tcwd = NULL;\n\t}\n\n\tint rv = orig_fchdir(fd);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char* cwd = NULL;",
            "static orig_fchdir_t orig_fchdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char* cwd = NULL;\nstatic orig_fchdir_t orig_fchdir = NULL;\n\nint fchdir(int fd) {\n#ifdef DEBUG\n\tprintf(\"%s %d\\n\", __FUNCTION__, fd);\n#endif\n\tif (!orig_fchdir)\n\t\torig_fchdir = (orig_fchdir_t)dlsym(RTLD_NEXT, \"fchdir\");\n\n\tfree(cwd);\n\tchar *pathname=malloc(PATH_MAX);\n\tif (pathname) {\n\t\tif (snprintf(pathname,PATH_MAX,\"/proc/self/fd/%d\", fd)>0) {\n\t\t\tcwd = realpath(pathname, NULL);\n\t\t} else {\n\t\t\tcwd = NULL;\n\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t}\n\t\tfree(pathname);\n\t} else {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tcwd = NULL;\n\t}\n\n\tint rv = orig_fchdir(fd);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "caps_drop_all",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "caps_drop_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/caps.c",
          "lines": "315-325",
          "snippet": "void caps_drop_all(void) {\n\tif (arg_debug)\n\t\tprintf(\"Dropping all capabilities\\n\");\n\n\tunsigned long cap;\n\tfor (cap=0; cap <= 63; cap++) {\n\t\tint code = prctl(PR_CAPBSET_DROP, cap, 0, 0, 0);\n\t\tif (code == -1 && errno != EINVAL)\n\t\t\terrExit(\"PR_CAPBSET_DROP\");\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nvoid caps_drop_all(void) {\n\tif (arg_debug)\n\t\tprintf(\"Dropping all capabilities\\n\");\n\n\tunsigned long cap;\n\tfor (cap=0; cap <= 63; cap++) {\n\t\tint code = prctl(PR_CAPBSET_DROP, cap, 0, 0, 0);\n\t\tif (code == -1 && errno != EINVAL)\n\t\t\terrExit(\"PR_CAPBSET_DROP\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "pid",
            "\"mnt\""
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "join_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "36-59",
          "snippet": "int join_namespace(pid_t pid, char *type) {\n\tchar *path;\n\tif (asprintf(&path, \"/proc/%u/ns/%s\", pid, type) == -1)\n\t\terrExit(\"asprintf\");\n\n\tint fd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto errout;\n\n\tif (syscall(__NR_setns, fd, 0) < 0) {\n\t\tclose(fd);\n\t\tgoto errout;\n\t}\n\n\tclose(fd);\n\tfree(path);\n\treturn 0;\n\nerrout:\n\tfree(path);\n\tfprintf(stderr, \"Error: cannot join namespace %s\\\\n\", type);\n\treturn -1;\n\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nint join_namespace(pid_t pid, char *type) {\n\tchar *path;\n\tif (asprintf(&path, \"/proc/%u/ns/%s\", pid, type) == -1)\n\t\terrExit(\"asprintf\");\n\n\tint fd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto errout;\n\n\tif (syscall(__NR_setns, fd, 0) < 0) {\n\t\tclose(fd);\n\t\tgoto errout;\n\t}\n\n\tclose(fd);\n\tfree(path);\n\treturn 0;\n\nerrout:\n\tfree(path);\n\tfprintf(stderr, \"Error: cannot join namespace %s\\\\n\", type);\n\treturn -1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: permission denied.\\n\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_get_uid",
          "args": [
            "pid"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "pid_get_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "823-865",
          "snippet": "uid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 4;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\treturn rv;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nuid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 4;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no valid sandbox\\n\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_sandbox",
          "args": [
            "pid"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "invalid_sandbox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1214-1272",
          "snippet": "int invalid_sandbox(const pid_t pid) {\n\t// check if a file \"ready-for-join\" exists\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_READY_FOR_JOIN) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tFILE *fp = fopen(fname, \"re\");\n\tEUID_USER();\n\tfree(fname);\n\tif (!fp)\n\t\treturn 1;\n\t// regular file owned by root\n\tint fd = fileno(fp);\n\tif (fd == -1)\n\t\terrExit(\"fileno\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != 0) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\t// check if it is non-empty\n\tchar buf[BUFLEN];\n\tif (fgets(buf, BUFLEN, fp) == NULL) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\tfclose(fp);\n\t// confirm \"ready\" string was written\n\tif (strncmp(buf, \"ready\\n\", 6) != 0)\n\t\treturn 1;\n\n\t// walk down the process tree a few nodes, there should be no firejail leaf\n#define MAXNODES 5\n\tpid_t current = pid, next;\n\tint i;\n\tfor (i = 0; i < MAXNODES; i++) {\n\t\tif (find_child(current, &next) == 1) {\n\t\t\t// found a leaf\n\t\t\tEUID_ROOT();\n\t\t\tchar *comm = pid_proc_comm(current);\n\t\t\tEUID_USER();\n\t\t\tif (!comm) {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\t\tfree(comm);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXNODES 5",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define MAXNODES 5\n#define BUFLEN 4096\n\nint invalid_sandbox(const pid_t pid) {\n\t// check if a file \"ready-for-join\" exists\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_READY_FOR_JOIN) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tFILE *fp = fopen(fname, \"re\");\n\tEUID_USER();\n\tfree(fname);\n\tif (!fp)\n\t\treturn 1;\n\t// regular file owned by root\n\tint fd = fileno(fp);\n\tif (fd == -1)\n\t\terrExit(\"fileno\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != 0) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\t// check if it is non-empty\n\tchar buf[BUFLEN];\n\tif (fgets(buf, BUFLEN, fp) == NULL) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\tfclose(fp);\n\t// confirm \"ready\" string was written\n\tif (strncmp(buf, \"ready\\n\", 6) != 0)\n\t\treturn 1;\n\n\t// walk down the process tree a few nodes, there should be no firejail leaf\n#define MAXNODES 5\n\tpid_t current = pid, next;\n\tint i;\n\tfor (i = 0; i < MAXNODES; i++) {\n\t\tif (find_child(current, &next) == 1) {\n\t\t\t// found a leaf\n\t\t\tEUID_ROOT();\n\t\t\tchar *comm = pid_proc_comm(current);\n\t\t\tEUID_USER();\n\t\t\tif (!comm) {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\t\tfree(comm);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "switch_to_child",
          "args": [
            "pid"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "switch_to_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "258-284",
          "snippet": "pid_t switch_to_child(pid_t pid) {\n\tEUID_ROOT();\n\terrno = 0;\n\tchar *comm = pid_proc_comm(pid);\n\tif (!comm) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Error: cannot find process with pid %d\\n\", pid);\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tEUID_USER();\n\tif (strcmp(comm, \"firejail\") == 0) {\n\t\tpid_t child;\n\t\tif (find_child(pid, &child) == 1) {\n\t\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfmessage(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) child);\n\t\tpid = child;\n\t}\n\tfree(comm);\n\treturn pid;\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\npid_t switch_to_child(pid_t pid) {\n\tEUID_ROOT();\n\terrno = 0;\n\tchar *comm = pid_proc_comm(pid);\n\tif (!comm) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Error: cannot find process with pid %d\\n\", pid);\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tEUID_USER();\n\tif (strcmp(comm, \"firejail\") == 0) {\n\t\tpid_t child;\n\t\tif (find_child(pid, &child) == 1) {\n\t\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfmessage(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) child);\n\t\tpid = child;\n\t}\n\tfree(comm);\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4096\n\nvoid net_dns_print(pid_t pid) {\n\tEUID_ASSERT();\n\t// drop privileges - will not be able to read /etc/resolv.conf for --noroot option\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(pid)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\tif (join_namespace(pid, \"mnt\"))\n\t\texit(1);\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tcaps_drop_all();\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\n\t\t// access /etc/resolv.conf\n\t\tFILE *fp = fopen(\"/etc/resolv.conf\", \"r\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Error: cannot access /etc/resolv.conf\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tchar buf[MAXBUF];\n\t\twhile (fgets(buf, MAXBUF, fp))\n\t\t\tprintf(\"%s\", buf);\n\t\tprintf(\"\\n\");\n\t\tfclose(fp);\n\t\texit(0);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tflush_stdin();\n\texit(0);\n}"
  },
  {
    "function_name": "net_check_cfg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
    "lines": "199-265",
    "snippet": "void net_check_cfg(void) {\n\tEUID_ASSERT();\n\tint net_configured = 0;\n\tif (cfg.bridge0.configured) {\n\t\tnet_configure_bridge(&cfg.bridge0);\n\t\tnet_configured++;\n\t}\n\tif (cfg.bridge1.configured) {\n\t\tnet_configure_bridge(&cfg.bridge1);\n\t\tnet_configured++;\n\t}\n\tif (cfg.bridge2.configured) {\n\t\tnet_configure_bridge(&cfg.bridge2);\n\t\tnet_configured++;\n\t}\n\tif (cfg.bridge3.configured) {\n\t\tnet_configure_bridge(&cfg.bridge3);\n\t\tnet_configured++;\n\t}\n\n\tint if_configured = 0;\n\tif (cfg.interface0.configured)\n\t\tif_configured++;\n\tif (cfg.interface1.configured)\n\t\tif_configured++;\n\tif (cfg.interface2.configured)\n\t\tif_configured++;\n\tif (cfg.interface3.configured)\n\t\tif_configured++;\n\n\t// --defaultgw requires a network or an interface\n\tif (cfg.defaultgw && net_configured == 0 && if_configured == 0) {\n\t\tfprintf(stderr, \"Error: option --defaultgw requires at least one network or one interface to be configured\\n\");\n\t\texit(1);\n\t}\n\n\tif (net_configured == 0) // nothing to check\n\t\treturn;\n\n\t// --net=none\n\tif (arg_nonetwork && net_configured) {\n\t\tfprintf(stderr, \"Error: --net and --net=none are mutually exclusive\\n\");\n\t\texit(1);\n\t}\n\n\t// check default gateway address or assign one\n\tassert(cfg.bridge0.configured);\n\tif (cfg.defaultgw)\n\t\tcheck_default_gw(cfg.defaultgw);\n\telse {\n\t\t// first network is a regular bridge\n\t\tif (cfg.bridge0.macvlan == 0)\n\t\t\tcfg.defaultgw = cfg.bridge0.ip;\n\t\t// first network is a mac device\n\t\telse {\n\t\t\t// get the host default gw\n\t\t\tEUID_ROOT();\t// rise permissions for grsecurity\n\t\t\t// Error fopen:network_get_defaultgw(479): Permission denied\n\t\t\tuint32_t gw = network_get_defaultgw();\n\t\t\tEUID_USER();\n\t\t\t// check the gateway is network range\n\t\t\tif (in_netrange(gw, cfg.bridge0.ip, cfg.bridge0.mask))\n\t\t\t\tgw = 0;\n\t\t\tcfg.defaultgw = gw;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <stdarg.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "gw",
            "cfg.bridge0.ip",
            "cfg.bridge0.mask"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "in_netrange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "73-81",
          "snippet": "static inline char *in_netrange(uint32_t ip, uint32_t ifip, uint32_t ifmask) {\n\tif ((ip & ifmask) != (ifip & ifmask))\n\t\treturn \"Error: the IP address is not in the interface range\\n\";\n\telse if ((ip & ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\telse if ((ip | ~ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\treturn NULL;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline char *in_netrange(uint32_t ip, uint32_t ifip, uint32_t ifmask) {\n\tif ((ip & ifmask) != (ifip & ifmask))\n\t\treturn \"Error: the IP address is not in the interface range\\n\";\n\telse if ((ip & ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\telse if ((ip | ~ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "network_get_defaultgw",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "network_get_defaultgw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network.c",
          "lines": "220-248",
          "snippet": "uint32_t network_get_defaultgw(void) {\n\tFILE *fp = fopen(\"/proc/self/net/route\", \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\tchar buf[BUFSIZE];\n\tuint32_t retval = 0;\n\twhile (fgets(buf, BUFSIZE, fp)) {\n\t\tif (strncmp(buf, \"Iface\", 5) == 0)\n\t\t\tcontinue;\n\n\t\tchar *ptr = buf;\n\t\twhile (*ptr != ' ' && *ptr != '\\t')\n\t\t\tptr++;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\n\t\tunsigned dest;\n\t\tunsigned gw;\n\t\tint rv = sscanf(ptr, \"%x %x\", &dest, &gw);\n\t\tif (rv == 2 && dest == 0) {\n\t\t\tretval = ntohl(gw);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFSIZE 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\n#define BUFSIZE 1024\n\nuint32_t network_get_defaultgw(void) {\n\tFILE *fp = fopen(\"/proc/self/net/route\", \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\tchar buf[BUFSIZE];\n\tuint32_t retval = 0;\n\twhile (fgets(buf, BUFSIZE, fp)) {\n\t\tif (strncmp(buf, \"Iface\", 5) == 0)\n\t\t\tcontinue;\n\n\t\tchar *ptr = buf;\n\t\twhile (*ptr != ' ' && *ptr != '\\t')\n\t\t\tptr++;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\n\t\tunsigned dest;\n\t\tunsigned gw;\n\t\tint rv = sscanf(ptr, \"%x %x\", &dest, &gw);\n\t\tif (rv == 2 && dest == 0) {\n\t\t\tretval = ntohl(gw);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_default_gw",
          "args": [
            "cfg.defaultgw"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "check_default_gw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
          "lines": "172-197",
          "snippet": "void check_default_gw(uint32_t defaultgw) {\n\tassert(defaultgw);\n\tif (cfg.bridge0.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge0.ip, cfg.bridge0.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge1.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge1.ip, cfg.bridge1.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge2.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge2.ip, cfg.bridge2.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge3.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge3.ip, cfg.bridge3.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: default gateway %d.%d.%d.%d is not in the range of any network\\n\", PRINT_IP(defaultgw));\n\texit(1);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <stdarg.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid check_default_gw(uint32_t defaultgw) {\n\tassert(defaultgw);\n\tif (cfg.bridge0.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge0.ip, cfg.bridge0.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge1.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge1.ip, cfg.bridge1.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge2.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge2.ip, cfg.bridge2.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge3.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge3.ip, cfg.bridge3.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: default gateway %d.%d.%d.%d is not in the range of any network\\n\", PRINT_IP(defaultgw));\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cfg.bridge0.configured"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --net and --net=none are mutually exclusive\\n\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: option --defaultgw requires at least one network or one interface to be configured\\n\""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_configure_bridge",
          "args": [
            "&cfg.bridge3"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "net_configure_bridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
          "lines": "31-109",
          "snippet": "static void net_configure_bridge(Bridge *br) {\n\tassert(br);\n\tassert(br->dev);\n\n\t// check the bridge device exists\n\tchar sysbridge[30 + strlen(br->dev)];\n\tsprintf(sysbridge, \"/sys/class/net/%s/bridge\", br->dev);\n\tstruct stat s;\n\tint rv = stat(sysbridge, &s);\n\tif (rv == 0) {\n\t\t// this is a bridge device\n\t\tbr->macvlan = 0;\n\t}\n\telse {\n\t\t// is this a regular Ethernet interface\n\t\tif (if_nametoindex(br->dev) > 0) {\n\t\t\tbr->macvlan = 1;\n\t\t\tchar *newname;\n\t\t\tif (asprintf(&newname, \"%s-%u\", br->devsandbox, getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tbr->devsandbox = newname;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", br->dev);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tint mtu = br->mtu;\t// preserve mtu value in case the user changed it with --mtu\n\tif (net_get_if_addr(br->dev, &br->ip, &br->mask, br->mac, &br->mtu))\n\t\t// allow unconfigured interfaces\n\t\tfwarning(\"the network interface %s is not configured\\n\", br->dev);\n\tif (mtu)\n\t\tbr->mtu = mtu;\n\n\tif (arg_debug) {\n\t\tif (br->macvlan == 0)\n\t\t\tprintf(\"Bridge device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t\telse\n\t\t\tprintf(\"macvlan parent device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t}\n\n\tif (br->mask) {\n\t\tuint32_t range = ~br->mask + 1;\t\t  // the number of potential addresses\n\t\t// this software is not supported for /31 networks\n\t\tif (range < 4) {\n\t\t\tfprintf(stderr, \"Error: the software is not supported for /31 networks\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\n\t// no interface network mask - no ip address will be configured\n\tif (br->mask == 0)\n\t\tgoto err_no_ip;\n\t// no interface ip - extract the network address from the address configured by the user\n\telse if (br->ip == 0 && br->ipsandbox)\n\t\tbr->ip = br->ipsandbox & br->mask;\n\t// no interface ip - extract the network address from the default gateway configured by the user\n\telse if (br->ip == 0 && cfg.defaultgw)\n\t\tbr->ip = cfg.defaultgw & br->mask;\n\t// no ip address will be configured\n\telse if (br->ip == 0)\n\t\tgoto err_no_ip;\n\n\tif ((br->iprange_start && in_netrange(br->iprange_start, br->ip, br->mask)) ||\n\t    (br->iprange_end && in_netrange(br->iprange_end, br->ip, br->mask))) {\n\t\tfprintf(stderr, \"Error: IP range addresses not in network range\\n\");\n\t\texit(1);\n\t}\n\n\treturn;\n\nerr_no_ip:\n\tbr->arg_ip_none = 1;\n\tfwarning(\"Not enough information to configure an IP address for\\n   interface --net=%s\\n\", br->dev);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <stdarg.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic void net_configure_bridge(Bridge *br) {\n\tassert(br);\n\tassert(br->dev);\n\n\t// check the bridge device exists\n\tchar sysbridge[30 + strlen(br->dev)];\n\tsprintf(sysbridge, \"/sys/class/net/%s/bridge\", br->dev);\n\tstruct stat s;\n\tint rv = stat(sysbridge, &s);\n\tif (rv == 0) {\n\t\t// this is a bridge device\n\t\tbr->macvlan = 0;\n\t}\n\telse {\n\t\t// is this a regular Ethernet interface\n\t\tif (if_nametoindex(br->dev) > 0) {\n\t\t\tbr->macvlan = 1;\n\t\t\tchar *newname;\n\t\t\tif (asprintf(&newname, \"%s-%u\", br->devsandbox, getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tbr->devsandbox = newname;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", br->dev);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tint mtu = br->mtu;\t// preserve mtu value in case the user changed it with --mtu\n\tif (net_get_if_addr(br->dev, &br->ip, &br->mask, br->mac, &br->mtu))\n\t\t// allow unconfigured interfaces\n\t\tfwarning(\"the network interface %s is not configured\\n\", br->dev);\n\tif (mtu)\n\t\tbr->mtu = mtu;\n\n\tif (arg_debug) {\n\t\tif (br->macvlan == 0)\n\t\t\tprintf(\"Bridge device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t\telse\n\t\t\tprintf(\"macvlan parent device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t}\n\n\tif (br->mask) {\n\t\tuint32_t range = ~br->mask + 1;\t\t  // the number of potential addresses\n\t\t// this software is not supported for /31 networks\n\t\tif (range < 4) {\n\t\t\tfprintf(stderr, \"Error: the software is not supported for /31 networks\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\n\t// no interface network mask - no ip address will be configured\n\tif (br->mask == 0)\n\t\tgoto err_no_ip;\n\t// no interface ip - extract the network address from the address configured by the user\n\telse if (br->ip == 0 && br->ipsandbox)\n\t\tbr->ip = br->ipsandbox & br->mask;\n\t// no interface ip - extract the network address from the default gateway configured by the user\n\telse if (br->ip == 0 && cfg.defaultgw)\n\t\tbr->ip = cfg.defaultgw & br->mask;\n\t// no ip address will be configured\n\telse if (br->ip == 0)\n\t\tgoto err_no_ip;\n\n\tif ((br->iprange_start && in_netrange(br->iprange_start, br->ip, br->mask)) ||\n\t    (br->iprange_end && in_netrange(br->iprange_end, br->ip, br->mask))) {\n\t\tfprintf(stderr, \"Error: IP range addresses not in network range\\n\");\n\t\texit(1);\n\t}\n\n\treturn;\n\nerr_no_ip:\n\tbr->arg_ip_none = 1;\n\tfwarning(\"Not enough information to configure an IP address for\\n   interface --net=%s\\n\", br->dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_check_cfg(void) {\n\tEUID_ASSERT();\n\tint net_configured = 0;\n\tif (cfg.bridge0.configured) {\n\t\tnet_configure_bridge(&cfg.bridge0);\n\t\tnet_configured++;\n\t}\n\tif (cfg.bridge1.configured) {\n\t\tnet_configure_bridge(&cfg.bridge1);\n\t\tnet_configured++;\n\t}\n\tif (cfg.bridge2.configured) {\n\t\tnet_configure_bridge(&cfg.bridge2);\n\t\tnet_configured++;\n\t}\n\tif (cfg.bridge3.configured) {\n\t\tnet_configure_bridge(&cfg.bridge3);\n\t\tnet_configured++;\n\t}\n\n\tint if_configured = 0;\n\tif (cfg.interface0.configured)\n\t\tif_configured++;\n\tif (cfg.interface1.configured)\n\t\tif_configured++;\n\tif (cfg.interface2.configured)\n\t\tif_configured++;\n\tif (cfg.interface3.configured)\n\t\tif_configured++;\n\n\t// --defaultgw requires a network or an interface\n\tif (cfg.defaultgw && net_configured == 0 && if_configured == 0) {\n\t\tfprintf(stderr, \"Error: option --defaultgw requires at least one network or one interface to be configured\\n\");\n\t\texit(1);\n\t}\n\n\tif (net_configured == 0) // nothing to check\n\t\treturn;\n\n\t// --net=none\n\tif (arg_nonetwork && net_configured) {\n\t\tfprintf(stderr, \"Error: --net and --net=none are mutually exclusive\\n\");\n\t\texit(1);\n\t}\n\n\t// check default gateway address or assign one\n\tassert(cfg.bridge0.configured);\n\tif (cfg.defaultgw)\n\t\tcheck_default_gw(cfg.defaultgw);\n\telse {\n\t\t// first network is a regular bridge\n\t\tif (cfg.bridge0.macvlan == 0)\n\t\t\tcfg.defaultgw = cfg.bridge0.ip;\n\t\t// first network is a mac device\n\t\telse {\n\t\t\t// get the host default gw\n\t\t\tEUID_ROOT();\t// rise permissions for grsecurity\n\t\t\t// Error fopen:network_get_defaultgw(479): Permission denied\n\t\t\tuint32_t gw = network_get_defaultgw();\n\t\t\tEUID_USER();\n\t\t\t// check the gateway is network range\n\t\t\tif (in_netrange(gw, cfg.bridge0.ip, cfg.bridge0.mask))\n\t\t\t\tgw = 0;\n\t\t\tcfg.defaultgw = gw;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_default_gw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
    "lines": "172-197",
    "snippet": "void check_default_gw(uint32_t defaultgw) {\n\tassert(defaultgw);\n\tif (cfg.bridge0.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge0.ip, cfg.bridge0.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge1.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge1.ip, cfg.bridge1.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge2.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge2.ip, cfg.bridge2.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge3.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge3.ip, cfg.bridge3.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: default gateway %d.%d.%d.%d is not in the range of any network\\n\", PRINT_IP(defaultgw));\n\texit(1);\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <stdarg.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: default gateway %d.%d.%d.%d is not in the range of any network\\n\"",
            "PRINT_IP(defaultgw)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "defaultgw"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "defaultgw",
            "cfg.bridge3.ip",
            "cfg.bridge3.mask"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "in_netrange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "73-81",
          "snippet": "static inline char *in_netrange(uint32_t ip, uint32_t ifip, uint32_t ifmask) {\n\tif ((ip & ifmask) != (ifip & ifmask))\n\t\treturn \"Error: the IP address is not in the interface range\\n\";\n\telse if ((ip & ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\telse if ((ip | ~ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\treturn NULL;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline char *in_netrange(uint32_t ip, uint32_t ifip, uint32_t ifmask) {\n\tif ((ip & ifmask) != (ifip & ifmask))\n\t\treturn \"Error: the IP address is not in the interface range\\n\";\n\telse if ((ip & ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\telse if ((ip | ~ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "defaultgw"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid check_default_gw(uint32_t defaultgw) {\n\tassert(defaultgw);\n\tif (cfg.bridge0.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge0.ip, cfg.bridge0.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge1.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge1.ip, cfg.bridge1.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge2.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge2.ip, cfg.bridge2.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge3.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge3.ip, cfg.bridge3.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: default gateway %d.%d.%d.%d is not in the range of any network\\n\", PRINT_IP(defaultgw));\n\texit(1);\n}"
  },
  {
    "function_name": "net_configure_veth_pair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
    "lines": "143-169",
    "snippet": "void net_configure_veth_pair(Bridge *br, const char *ifname, pid_t child) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\t// create a veth pair\n\tchar *dev;\n\tif (br->veth_name == NULL) {\n\t\tif (asprintf(&dev, \"veth%u%s\", getpid(), ifname) < 0)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse\n\t\tdev = br->veth_name;\n\n\tchar *cstr;\n\tif (asprintf(&cstr, \"%d\", child) == -1)\n\t\terrExit(\"asprintf\");\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 7, PATH_FNET_MAIN, \"create\", \"veth\", dev, ifname, br->dev, cstr);\n\tfree(cstr);\n\n\tchar *msg;\n\tif (asprintf(&msg, \"%d.%d.%d.%d address assigned to sandbox\", PRINT_IP(br->ipsandbox)) == -1)\n\t\terrExit(\"asprintf\");\n\tlogmsg(msg);\n\tfflush(0);\n\tfree(msg);\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <stdarg.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logmsg",
          "args": [
            "msg"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "logmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "210-217",
          "snippet": "void logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&msg",
            "\"%d.%d.%d.%d address assigned to sandbox\"",
            "PRINT_IP(br->ipsandbox)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cstr"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sbox_run",
          "args": [
            "SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP",
            "7",
            "PATH_FNET_MAIN",
            "\"create\"",
            "\"veth\"",
            "dev",
            "ifname",
            "br->dev",
            "cstr"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "sbox_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sbox.c",
          "lines": "107-223",
          "snippet": "int sbox_run(unsigned filter, int num, ...) {\n\tEUID_ROOT();\n\n\tint i;\n\tva_list valist;\n\tva_start(valist, num);\n\n\t// build argument list\n\tchar *arg[num + 1];\n\tfor (i = 0; i < num; i++)\n\t\targ[i] = va_arg(valist, char*);\n\targ[i] = NULL;\n\tva_end(valist);\n\n\tif (arg_debug) {\n\t\tprintf(\"sbox run: \");\n\t\tfor (i = 0; i <= num; i++)\n\t\t\tprintf(\"%s \", arg[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// clean the new process\n\t\tclearenv();\n\n\t\tif (filter & SBOX_STDIN_FROM_FILE) {\n\t\t\tint fd;\n\t\t\tif((fd = open(SBOX_STDIN_FILE, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr,\"Error: cannot open %s\\n\", SBOX_STDIN_FILE);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tdup2(fd,STDIN_FILENO);\n\t\t\tclose(fd);\n\t\t}\n\t\telse if ((filter & SBOX_ALLOW_STDIN) == 0) {\n\t\t\tint fd = open(\"/dev/null\",O_RDWR, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse // the user could run the sandbox without /dev/null\n\t\t\t\tclose(STDIN_FILENO);\n\t\t}\n\n\t\t// close all other file descriptors\n\t\tint max = 20; // getdtablesize() is overkill for a firejail process\n\t\tfor (i = 3; i < max; i++)\n\t\t\tclose(i); // close open files\n\n\t\tumask(027);\n\n\t\t// apply filters\n\t\tif (filter & SBOX_CAPS_NONE) {\n\t\t\tcaps_drop_all();\n\t\t}\n\t\telse if (filter & SBOX_CAPS_NETWORK) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_NET_ADMIN;\n\t\t\tset |=  ((uint64_t) 1) << CAP_NET_RAW;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\t\telse if (filter & SBOX_CAPS_HIDEPID) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_SYS_PTRACE;\n\t\t\tset |=  ((uint64_t) 1) << CAP_SYS_PACCT;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\n\t\tif (filter & SBOX_SECCOMP) {\n\t\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\t\t}\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\t\t\tperror(\"prctl(PR_SET_SECCOMP)\");\n\t\t\t}\n\t\t}\n\n\t\tif (filter & SBOX_ROOT) {\n\t\t\t// elevate privileges in order to get grsecurity working\n\t\t\tif (setreuid(0, 0))\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0))\n\t\t\t\terrExit(\"setregid\");\n\t\t}\n\t\telse if (filter & SBOX_USER)\n\t\t\tdrop_privs(1);\n\n\t\tclearenv();\n\n\t\t// --quiet is passed as an environment variable\n\t\tif (arg_quiet)\n\t\t\tsetenv(\"FIREJAIL_QUIET\", \"yes\", 1);\n\n\t\tif (arg[0])\t// get rid of scan-build warning\n\t\t\texecvp(arg[0], arg);\n\t\telse\n\t\t\tassert(0);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tint status;\n\tif (waitpid(child, &status, 0) == -1 ) {\n\t\terrExit(\"waitpid\");\n\t}\n\tif (WIFEXITED(status) && status != 0) {\n\t\tfprintf(stderr, \"Error: failed to run %s\\n\", arg[0]);\n\t\texit(1);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"../include/seccomp.h\"",
            "#include <sys/wait.h>",
            "#include <stdarg.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sock_filter filter[] = {\n\tVALIDATE_ARCHITECTURE,\n\tEXAMINE_SYSCALL,\n\n#if defined(__x86_64__)\n#define X32_SYSCALL_BIT 0x40000000\n\t// handle X32 ABI\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, X32_SYSCALL_BIT, 1, 0),\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, 0, 1, 0),\n\tRETURN_ERRNO(EPERM),\n#endif\n\n\t// syscall list\n#ifdef SYS_mount\n\tBLACKLIST(SYS_mount),  // mount/unmount filesystems\n#endif\n#ifdef SYS_umount2\n\tBLACKLIST(SYS_umount2),\n#endif\n#ifdef SYS_ptrace\n\tBLACKLIST(SYS_ptrace), // trace processes\n#endif\n#ifdef SYS_kexec_file_load\n\tBLACKLIST(SYS_kexec_file_load),\n#endif\n#ifdef SYS_kexec_load\n\tBLACKLIST(SYS_kexec_load), // loading a different kernel\n#endif\n#ifdef SYS_name_to_handle_at\n\tBLACKLIST(SYS_name_to_handle_at),\n#endif\n#ifdef SYS_open_by_handle_at\n\tBLACKLIST(SYS_open_by_handle_at), // open by handle\n#endif\n#ifdef SYS_init_module\n\tBLACKLIST(SYS_init_module), // kernel module handling\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\tBLACKLIST(SYS_finit_module),\n#endif\n#ifdef SYS_create_module\n\tBLACKLIST(SYS_create_module),\n#endif\n#ifdef SYS_delete_module\n\tBLACKLIST(SYS_delete_module),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioperm\n\tBLACKLIST(SYS_ioperm),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioprio_set\n\tBLACKLIST(SYS_ioprio_set),\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\tBLACKLIST(SYS_ni_syscall),\n#endif\n#ifdef SYS_swapon\n\tBLACKLIST(SYS_swapon), // swap on/off\n#endif\n#ifdef SYS_swapoff\n\tBLACKLIST(SYS_swapoff),\n#endif\n#ifdef SYS_syslog\n\tBLACKLIST(SYS_syslog), // kernel printk control\n#endif\n\tRETURN_ALLOW\n};",
            "static struct sock_fprog prog = {\n\t.len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),\n\t.filter = filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/seccomp.h\"\n#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic struct sock_filter filter[] = {\n\tVALIDATE_ARCHITECTURE,\n\tEXAMINE_SYSCALL,\n\n#if defined(__x86_64__)\n#define X32_SYSCALL_BIT 0x40000000\n\t// handle X32 ABI\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, X32_SYSCALL_BIT, 1, 0),\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, 0, 1, 0),\n\tRETURN_ERRNO(EPERM),\n#endif\n\n\t// syscall list\n#ifdef SYS_mount\n\tBLACKLIST(SYS_mount),  // mount/unmount filesystems\n#endif\n#ifdef SYS_umount2\n\tBLACKLIST(SYS_umount2),\n#endif\n#ifdef SYS_ptrace\n\tBLACKLIST(SYS_ptrace), // trace processes\n#endif\n#ifdef SYS_kexec_file_load\n\tBLACKLIST(SYS_kexec_file_load),\n#endif\n#ifdef SYS_kexec_load\n\tBLACKLIST(SYS_kexec_load), // loading a different kernel\n#endif\n#ifdef SYS_name_to_handle_at\n\tBLACKLIST(SYS_name_to_handle_at),\n#endif\n#ifdef SYS_open_by_handle_at\n\tBLACKLIST(SYS_open_by_handle_at), // open by handle\n#endif\n#ifdef SYS_init_module\n\tBLACKLIST(SYS_init_module), // kernel module handling\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\tBLACKLIST(SYS_finit_module),\n#endif\n#ifdef SYS_create_module\n\tBLACKLIST(SYS_create_module),\n#endif\n#ifdef SYS_delete_module\n\tBLACKLIST(SYS_delete_module),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioperm\n\tBLACKLIST(SYS_ioperm),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioprio_set\n\tBLACKLIST(SYS_ioprio_set),\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\tBLACKLIST(SYS_ni_syscall),\n#endif\n#ifdef SYS_swapon\n\tBLACKLIST(SYS_swapon), // swap on/off\n#endif\n#ifdef SYS_swapoff\n\tBLACKLIST(SYS_swapoff),\n#endif\n#ifdef SYS_syslog\n\tBLACKLIST(SYS_syslog), // kernel printk control\n#endif\n\tRETURN_ALLOW\n};\nstatic struct sock_fprog prog = {\n\t.len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),\n\t.filter = filter,\n};\n\nint sbox_run(unsigned filter, int num, ...) {\n\tEUID_ROOT();\n\n\tint i;\n\tva_list valist;\n\tva_start(valist, num);\n\n\t// build argument list\n\tchar *arg[num + 1];\n\tfor (i = 0; i < num; i++)\n\t\targ[i] = va_arg(valist, char*);\n\targ[i] = NULL;\n\tva_end(valist);\n\n\tif (arg_debug) {\n\t\tprintf(\"sbox run: \");\n\t\tfor (i = 0; i <= num; i++)\n\t\t\tprintf(\"%s \", arg[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// clean the new process\n\t\tclearenv();\n\n\t\tif (filter & SBOX_STDIN_FROM_FILE) {\n\t\t\tint fd;\n\t\t\tif((fd = open(SBOX_STDIN_FILE, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr,\"Error: cannot open %s\\n\", SBOX_STDIN_FILE);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tdup2(fd,STDIN_FILENO);\n\t\t\tclose(fd);\n\t\t}\n\t\telse if ((filter & SBOX_ALLOW_STDIN) == 0) {\n\t\t\tint fd = open(\"/dev/null\",O_RDWR, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse // the user could run the sandbox without /dev/null\n\t\t\t\tclose(STDIN_FILENO);\n\t\t}\n\n\t\t// close all other file descriptors\n\t\tint max = 20; // getdtablesize() is overkill for a firejail process\n\t\tfor (i = 3; i < max; i++)\n\t\t\tclose(i); // close open files\n\n\t\tumask(027);\n\n\t\t// apply filters\n\t\tif (filter & SBOX_CAPS_NONE) {\n\t\t\tcaps_drop_all();\n\t\t}\n\t\telse if (filter & SBOX_CAPS_NETWORK) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_NET_ADMIN;\n\t\t\tset |=  ((uint64_t) 1) << CAP_NET_RAW;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\t\telse if (filter & SBOX_CAPS_HIDEPID) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_SYS_PTRACE;\n\t\t\tset |=  ((uint64_t) 1) << CAP_SYS_PACCT;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\n\t\tif (filter & SBOX_SECCOMP) {\n\t\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\t\t}\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\t\t\tperror(\"prctl(PR_SET_SECCOMP)\");\n\t\t\t}\n\t\t}\n\n\t\tif (filter & SBOX_ROOT) {\n\t\t\t// elevate privileges in order to get grsecurity working\n\t\t\tif (setreuid(0, 0))\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0))\n\t\t\t\terrExit(\"setregid\");\n\t\t}\n\t\telse if (filter & SBOX_USER)\n\t\t\tdrop_privs(1);\n\n\t\tclearenv();\n\n\t\t// --quiet is passed as an environment variable\n\t\tif (arg_quiet)\n\t\t\tsetenv(\"FIREJAIL_QUIET\", \"yes\", 1);\n\n\t\tif (arg[0])\t// get rid of scan-build warning\n\t\t\texecvp(arg[0], arg);\n\t\telse\n\t\t\tassert(0);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tint status;\n\tif (waitpid(child, &status, 0) == -1 ) {\n\t\terrExit(\"waitpid\");\n\t}\n\tif (WIFEXITED(status) && status != 0) {\n\t\tfprintf(stderr, \"Error: failed to run %s\\n\", arg[0]);\n\t\texit(1);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cstr",
            "\"%d\"",
            "child"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dev",
            "\"veth%u%s\"",
            "getpid()",
            "ifname"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_configure_veth_pair(Bridge *br, const char *ifname, pid_t child) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\t// create a veth pair\n\tchar *dev;\n\tif (br->veth_name == NULL) {\n\t\tif (asprintf(&dev, \"veth%u%s\", getpid(), ifname) < 0)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse\n\t\tdev = br->veth_name;\n\n\tchar *cstr;\n\tif (asprintf(&cstr, \"%d\", child) == -1)\n\t\terrExit(\"asprintf\");\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 7, PATH_FNET_MAIN, \"create\", \"veth\", dev, ifname, br->dev, cstr);\n\tfree(cstr);\n\n\tchar *msg;\n\tif (asprintf(&msg, \"%d.%d.%d.%d address assigned to sandbox\", PRINT_IP(br->ipsandbox)) == -1)\n\t\terrExit(\"asprintf\");\n\tlogmsg(msg);\n\tfflush(0);\n\tfree(msg);\n}"
  },
  {
    "function_name": "net_configure_sandbox_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
    "lines": "112-135",
    "snippet": "void net_configure_sandbox_ip(Bridge *br) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\tif (br->arg_ip_none)\n\t\tbr->ipsandbox = 0;\n\telse if (br->ipsandbox) {\n\t\t// check network range\n\t\tchar *rv = in_netrange(br->ipsandbox, br->ip, br->mask);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"%s\", rv);\n\t\t\texit(1);\n\t\t}\n\t\t// send an ARP request and check if there is anybody on this IP address\n\t\tif (arp_check(br->dev, br->ipsandbox)) {\n\t\t\tfprintf(stderr, \"Error: IP address %d.%d.%d.%d is already in use\\n\", PRINT_IP(br->ipsandbox));\n\t\t\texit(1);\n\t\t}\n\t}\n\telse\n\t\t// ip address assigned by arp-scan for a bridge device\n\t\tbr->ipsandbox = arp_assign(br->dev, br); //br->ip, br->mask);\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <stdarg.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arp_assign",
          "args": [
            "br->dev",
            "br"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "arp_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/arp.c",
          "lines": "352-373",
          "snippet": "uint32_t arp_assign(const char *dev, Bridge *br) {\n\tassert(br);\n\tuint32_t ip = 0;\n\n\t// try two random IP addresses\n\tip = arp_random(dev, br);\n\tif (!ip)\n\t\tip = arp_random(dev, br);\n\n\t// try all possible IP addresses one by one\n\tif (!ip)\n\t\tip = arp_sequential(dev, br);\n\n\t// print result\n\tif (!ip) {\n\t\tfprintf(stderr, \"Error: cannot assign an IP address; it looks like all of them are in use.\\n\");\n\t\tlogerr(\"Cannot assign an IP address; it looks like all of them are in use.\");\n\t\texit(1);\n\t}\n\n\treturn ip;\n}",
          "includes": [
            "#include <linux/if_packet.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_packet.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include \"firejail.h\"\n\nuint32_t arp_assign(const char *dev, Bridge *br) {\n\tassert(br);\n\tuint32_t ip = 0;\n\n\t// try two random IP addresses\n\tip = arp_random(dev, br);\n\tif (!ip)\n\t\tip = arp_random(dev, br);\n\n\t// try all possible IP addresses one by one\n\tif (!ip)\n\t\tip = arp_sequential(dev, br);\n\n\t// print result\n\tif (!ip) {\n\t\tfprintf(stderr, \"Error: cannot assign an IP address; it looks like all of them are in use.\\n\");\n\t\tlogerr(\"Cannot assign an IP address; it looks like all of them are in use.\");\n\t\texit(1);\n\t}\n\n\treturn ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: IP address %d.%d.%d.%d is already in use\\n\"",
            "PRINT_IP(br->ipsandbox)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_check",
          "args": [
            "br->dev",
            "br->ipsandbox"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "arp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/arp.c",
          "lines": "118-245",
          "snippet": "int arp_check(const char *dev, uint32_t destaddr) {\n\t// RFC 5227 - using a source IP address of 0 for probing\n\tuint32_t srcaddr = 0;\n\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Trying %d.%d.%d.%d ...\\n\", PRINT_IP(destaddr));\n\n\t// find interface address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\n\tsrcaddr = htonl(srcaddr);\n\tdestaddr = htonl(destaddr);\n\n\t// Find interface MAC address\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ - 1);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\n\t// configure layer2 socket address information\n\tstruct sockaddr_ll addr;\n\tmemset(&addr, 0, sizeof(addr));\n\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\terrExit(\"if_nametoindex\");\n\taddr.sll_family = AF_PACKET;\n\tmemcpy (addr.sll_addr, ifr.ifr_hwaddr.sa_data, 6);\n\taddr.sll_halen = ETH_ALEN;\n\n\t// build the arp packet header\n\tArpHdr hdr;\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.htype = htons(1);\n\thdr.ptype = htons(ETH_P_IP);\n\thdr.hlen = 6;\n\thdr.plen = 4;\n\thdr.opcode = htons(1); //ARPOP_REQUEST\n\tmemcpy(hdr.sender_mac, ifr.ifr_hwaddr.sa_data, 6);\n\tmemcpy(hdr.sender_ip, (uint8_t *)&srcaddr, 4);\n\tmemcpy(hdr.target_ip, (uint8_t *)&destaddr, 4);\n\n\t// build ethernet frame\n\tuint8_t frame[ETH_FRAME_LEN]; // includes eth header, vlan, and crc\n\tmemset(frame, 0, sizeof(frame));\n\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\tmemcpy(frame + 6, ifr.ifr_hwaddr.sa_data, 6);\n\tframe[12] = ETH_P_ARP / 256;\n\tframe[13] = ETH_P_ARP % 256;\n\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\tint len;\n\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\terrExit(\"send\");\n\tfflush(0);\n\n\t// send two probes at 0.5 seconds interva;\n\tint  cnt = checkcfg(CFG_ARP_PROBES);\n\tuint8_t framerx[ETH_FRAME_LEN]; // includes eth header, vlan, and crc\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(sock, &fds);\n\tint maxfd = sock;\n\tstruct timeval ts;\n\tts.tv_sec = 0; // 0.5 seconds wait time\n\tts.tv_usec = 500000;\n\twhile (1) {\n\t\tint nready = select(maxfd + 1,  &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\t\telse if (nready == 0) { // timeout\n\t\t\tif (--cnt <= 0) {\n\t\t\t\tclose(sock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\t\t\terrExit(\"send\");\n\t\t\tts.tv_sec = 0; // 0.5 seconds wait time\n\t\t\tts.tv_usec = 500000;\n\t\t\tfflush(0);\n\t\t}\n\t\telse {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, framerx, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\t\t\tif (framerx[12] != (ETH_P_ARP / 256) || framerx[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\t\t\tmemcpy(&hdr, framerx + 14, sizeof(ArpHdr));\n\t\t\tif (hdr.opcode == htons(1))\n\t\t\t\tcontinue;\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(ifr.ifr_hwaddr.sa_data, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != srcaddr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// it will never get here!\n\tclose(sock);\n\treturn -1;\n}",
          "includes": [
            "#include <linux/if_packet.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_packet.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include \"firejail.h\"\n\nint arp_check(const char *dev, uint32_t destaddr) {\n\t// RFC 5227 - using a source IP address of 0 for probing\n\tuint32_t srcaddr = 0;\n\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Trying %d.%d.%d.%d ...\\n\", PRINT_IP(destaddr));\n\n\t// find interface address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\n\tsrcaddr = htonl(srcaddr);\n\tdestaddr = htonl(destaddr);\n\n\t// Find interface MAC address\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ - 1);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\n\t// configure layer2 socket address information\n\tstruct sockaddr_ll addr;\n\tmemset(&addr, 0, sizeof(addr));\n\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\terrExit(\"if_nametoindex\");\n\taddr.sll_family = AF_PACKET;\n\tmemcpy (addr.sll_addr, ifr.ifr_hwaddr.sa_data, 6);\n\taddr.sll_halen = ETH_ALEN;\n\n\t// build the arp packet header\n\tArpHdr hdr;\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.htype = htons(1);\n\thdr.ptype = htons(ETH_P_IP);\n\thdr.hlen = 6;\n\thdr.plen = 4;\n\thdr.opcode = htons(1); //ARPOP_REQUEST\n\tmemcpy(hdr.sender_mac, ifr.ifr_hwaddr.sa_data, 6);\n\tmemcpy(hdr.sender_ip, (uint8_t *)&srcaddr, 4);\n\tmemcpy(hdr.target_ip, (uint8_t *)&destaddr, 4);\n\n\t// build ethernet frame\n\tuint8_t frame[ETH_FRAME_LEN]; // includes eth header, vlan, and crc\n\tmemset(frame, 0, sizeof(frame));\n\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\tmemcpy(frame + 6, ifr.ifr_hwaddr.sa_data, 6);\n\tframe[12] = ETH_P_ARP / 256;\n\tframe[13] = ETH_P_ARP % 256;\n\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\tint len;\n\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\terrExit(\"send\");\n\tfflush(0);\n\n\t// send two probes at 0.5 seconds interva;\n\tint  cnt = checkcfg(CFG_ARP_PROBES);\n\tuint8_t framerx[ETH_FRAME_LEN]; // includes eth header, vlan, and crc\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(sock, &fds);\n\tint maxfd = sock;\n\tstruct timeval ts;\n\tts.tv_sec = 0; // 0.5 seconds wait time\n\tts.tv_usec = 500000;\n\twhile (1) {\n\t\tint nready = select(maxfd + 1,  &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\t\telse if (nready == 0) { // timeout\n\t\t\tif (--cnt <= 0) {\n\t\t\t\tclose(sock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\t\t\terrExit(\"send\");\n\t\t\tts.tv_sec = 0; // 0.5 seconds wait time\n\t\t\tts.tv_usec = 500000;\n\t\t\tfflush(0);\n\t\t}\n\t\telse {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, framerx, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\t\t\tif (framerx[12] != (ETH_P_ARP / 256) || framerx[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\t\t\tmemcpy(&hdr, framerx + 14, sizeof(ArpHdr));\n\t\t\tif (hdr.opcode == htons(1))\n\t\t\t\tcontinue;\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(ifr.ifr_hwaddr.sa_data, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != srcaddr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// it will never get here!\n\tclose(sock);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "rv"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "br->ipsandbox",
            "br->ip",
            "br->mask"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "in_netrange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "73-81",
          "snippet": "static inline char *in_netrange(uint32_t ip, uint32_t ifip, uint32_t ifmask) {\n\tif ((ip & ifmask) != (ifip & ifmask))\n\t\treturn \"Error: the IP address is not in the interface range\\n\";\n\telse if ((ip & ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\telse if ((ip | ~ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\treturn NULL;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline char *in_netrange(uint32_t ip, uint32_t ifip, uint32_t ifmask) {\n\tif ((ip & ifmask) != (ifip & ifmask))\n\t\treturn \"Error: the IP address is not in the interface range\\n\";\n\telse if ((ip & ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\telse if ((ip | ~ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_configure_sandbox_ip(Bridge *br) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\tif (br->arg_ip_none)\n\t\tbr->ipsandbox = 0;\n\telse if (br->ipsandbox) {\n\t\t// check network range\n\t\tchar *rv = in_netrange(br->ipsandbox, br->ip, br->mask);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"%s\", rv);\n\t\t\texit(1);\n\t\t}\n\t\t// send an ARP request and check if there is anybody on this IP address\n\t\tif (arp_check(br->dev, br->ipsandbox)) {\n\t\t\tfprintf(stderr, \"Error: IP address %d.%d.%d.%d is already in use\\n\", PRINT_IP(br->ipsandbox));\n\t\t\texit(1);\n\t\t}\n\t}\n\telse\n\t\t// ip address assigned by arp-scan for a bridge device\n\t\tbr->ipsandbox = arp_assign(br->dev, br); //br->ip, br->mask);\n}"
  },
  {
    "function_name": "net_configure_bridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
    "lines": "31-109",
    "snippet": "static void net_configure_bridge(Bridge *br) {\n\tassert(br);\n\tassert(br->dev);\n\n\t// check the bridge device exists\n\tchar sysbridge[30 + strlen(br->dev)];\n\tsprintf(sysbridge, \"/sys/class/net/%s/bridge\", br->dev);\n\tstruct stat s;\n\tint rv = stat(sysbridge, &s);\n\tif (rv == 0) {\n\t\t// this is a bridge device\n\t\tbr->macvlan = 0;\n\t}\n\telse {\n\t\t// is this a regular Ethernet interface\n\t\tif (if_nametoindex(br->dev) > 0) {\n\t\t\tbr->macvlan = 1;\n\t\t\tchar *newname;\n\t\t\tif (asprintf(&newname, \"%s-%u\", br->devsandbox, getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tbr->devsandbox = newname;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", br->dev);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tint mtu = br->mtu;\t// preserve mtu value in case the user changed it with --mtu\n\tif (net_get_if_addr(br->dev, &br->ip, &br->mask, br->mac, &br->mtu))\n\t\t// allow unconfigured interfaces\n\t\tfwarning(\"the network interface %s is not configured\\n\", br->dev);\n\tif (mtu)\n\t\tbr->mtu = mtu;\n\n\tif (arg_debug) {\n\t\tif (br->macvlan == 0)\n\t\t\tprintf(\"Bridge device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t\telse\n\t\t\tprintf(\"macvlan parent device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t}\n\n\tif (br->mask) {\n\t\tuint32_t range = ~br->mask + 1;\t\t  // the number of potential addresses\n\t\t// this software is not supported for /31 networks\n\t\tif (range < 4) {\n\t\t\tfprintf(stderr, \"Error: the software is not supported for /31 networks\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\n\t// no interface network mask - no ip address will be configured\n\tif (br->mask == 0)\n\t\tgoto err_no_ip;\n\t// no interface ip - extract the network address from the address configured by the user\n\telse if (br->ip == 0 && br->ipsandbox)\n\t\tbr->ip = br->ipsandbox & br->mask;\n\t// no interface ip - extract the network address from the default gateway configured by the user\n\telse if (br->ip == 0 && cfg.defaultgw)\n\t\tbr->ip = cfg.defaultgw & br->mask;\n\t// no ip address will be configured\n\telse if (br->ip == 0)\n\t\tgoto err_no_ip;\n\n\tif ((br->iprange_start && in_netrange(br->iprange_start, br->ip, br->mask)) ||\n\t    (br->iprange_end && in_netrange(br->iprange_end, br->ip, br->mask))) {\n\t\tfprintf(stderr, \"Error: IP range addresses not in network range\\n\");\n\t\texit(1);\n\t}\n\n\treturn;\n\nerr_no_ip:\n\tbr->arg_ip_none = 1;\n\tfwarning(\"Not enough information to configure an IP address for\\n   interface --net=%s\\n\", br->dev);\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <stdarg.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"Not enough information to configure an IP address for\\n   interface --net=%s\\n\"",
            "br->dev"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: IP range addresses not in network range\\n\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "br->iprange_end",
            "br->ip",
            "br->mask"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "in_netrange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "73-81",
          "snippet": "static inline char *in_netrange(uint32_t ip, uint32_t ifip, uint32_t ifmask) {\n\tif ((ip & ifmask) != (ifip & ifmask))\n\t\treturn \"Error: the IP address is not in the interface range\\n\";\n\telse if ((ip & ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\telse if ((ip | ~ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\treturn NULL;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline char *in_netrange(uint32_t ip, uint32_t ifip, uint32_t ifmask) {\n\tif ((ip & ifmask) != (ifip & ifmask))\n\t\treturn \"Error: the IP address is not in the interface range\\n\";\n\telse if ((ip & ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\telse if ((ip | ~ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: the software is not supported for /31 networks\\n\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"macvlan parent device %s at %d.%d.%d.%d/%d\\n\"",
            "br->dev",
            "PRINT_IP(br->ip)",
            "mask2bits(br->mask)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mask2bits",
          "args": [
            "br->mask"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "mask2bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "47-59",
          "snippet": "static inline uint8_t mask2bits(uint32_t mask) {\n\tuint32_t tmp = 0x80000000;\n\tint i;\n\tuint8_t rv = 0;\n\n\tfor (i = 0; i < 32; i++, tmp >>= 1) {\n\t\tif (tmp & mask)\n\t\t\trv++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline uint8_t mask2bits(uint32_t mask) {\n\tuint32_t tmp = 0x80000000;\n\tint i;\n\tuint8_t rv = 0;\n\n\tfor (i = 0; i < 32; i++, tmp >>= 1) {\n\t\tif (tmp & mask)\n\t\t\trv++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ip"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Bridge device %s at %d.%d.%d.%d/%d\\n\"",
            "br->dev",
            "PRINT_IP(br->ip)",
            "mask2bits(br->mask)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ip"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_get_if_addr",
          "args": [
            "br->dev",
            "&br->ip",
            "&br->mask",
            "br->mac",
            "&br->mtu"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "net_get_if_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network.c",
          "lines": "117-155",
          "snippet": "int net_get_if_addr(const char *bridge, uint32_t *ip, uint32_t *mask, uint8_t mac[6], int *mtu) {\n\tassert(bridge);\n\tassert(ip);\n\tassert(mask);\n\n\tif (arg_debug)\n\t\tprintf(\"get interface %s configuration\\n\", bridge);\n\n\tint rv = -1;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\t// walk through the linked list; if the interface is found, extract IP address and mask\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(ifa->ifa_name, bridge) != 0)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\t*mask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\t*ip = ntohl(si->sin_addr.s_addr);\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") != 0) {\n\t\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\t\t*mtu = net_get_mtu(bridge);\n\t\t\t}\n\n\t\t\trv = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn rv;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_get_if_addr(const char *bridge, uint32_t *ip, uint32_t *mask, uint8_t mac[6], int *mtu) {\n\tassert(bridge);\n\tassert(ip);\n\tassert(mask);\n\n\tif (arg_debug)\n\t\tprintf(\"get interface %s configuration\\n\", bridge);\n\n\tint rv = -1;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\t// walk through the linked list; if the interface is found, extract IP address and mask\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(ifa->ifa_name, bridge) != 0)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\t*mask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\t*ip = ntohl(si->sin_addr.s_addr);\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") != 0) {\n\t\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\t\t*mtu = net_get_mtu(bridge);\n\t\t\t}\n\n\t\t\trv = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find network device %s\\n\"",
            "br->dev"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&newname",
            "\"%s-%u\"",
            "br->devsandbox",
            "getpid()"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "br->dev"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "sysbridge",
            "&s"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "sysbridge",
            "\"/sys/class/net/%s/bridge\"",
            "br->dev"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "br->dev"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br->dev"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic void net_configure_bridge(Bridge *br) {\n\tassert(br);\n\tassert(br->dev);\n\n\t// check the bridge device exists\n\tchar sysbridge[30 + strlen(br->dev)];\n\tsprintf(sysbridge, \"/sys/class/net/%s/bridge\", br->dev);\n\tstruct stat s;\n\tint rv = stat(sysbridge, &s);\n\tif (rv == 0) {\n\t\t// this is a bridge device\n\t\tbr->macvlan = 0;\n\t}\n\telse {\n\t\t// is this a regular Ethernet interface\n\t\tif (if_nametoindex(br->dev) > 0) {\n\t\t\tbr->macvlan = 1;\n\t\t\tchar *newname;\n\t\t\tif (asprintf(&newname, \"%s-%u\", br->devsandbox, getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tbr->devsandbox = newname;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", br->dev);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tint mtu = br->mtu;\t// preserve mtu value in case the user changed it with --mtu\n\tif (net_get_if_addr(br->dev, &br->ip, &br->mask, br->mac, &br->mtu))\n\t\t// allow unconfigured interfaces\n\t\tfwarning(\"the network interface %s is not configured\\n\", br->dev);\n\tif (mtu)\n\t\tbr->mtu = mtu;\n\n\tif (arg_debug) {\n\t\tif (br->macvlan == 0)\n\t\t\tprintf(\"Bridge device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t\telse\n\t\t\tprintf(\"macvlan parent device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t}\n\n\tif (br->mask) {\n\t\tuint32_t range = ~br->mask + 1;\t\t  // the number of potential addresses\n\t\t// this software is not supported for /31 networks\n\t\tif (range < 4) {\n\t\t\tfprintf(stderr, \"Error: the software is not supported for /31 networks\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\n\t// no interface network mask - no ip address will be configured\n\tif (br->mask == 0)\n\t\tgoto err_no_ip;\n\t// no interface ip - extract the network address from the address configured by the user\n\telse if (br->ip == 0 && br->ipsandbox)\n\t\tbr->ip = br->ipsandbox & br->mask;\n\t// no interface ip - extract the network address from the default gateway configured by the user\n\telse if (br->ip == 0 && cfg.defaultgw)\n\t\tbr->ip = cfg.defaultgw & br->mask;\n\t// no ip address will be configured\n\telse if (br->ip == 0)\n\t\tgoto err_no_ip;\n\n\tif ((br->iprange_start && in_netrange(br->iprange_start, br->ip, br->mask)) ||\n\t    (br->iprange_end && in_netrange(br->iprange_end, br->ip, br->mask))) {\n\t\tfprintf(stderr, \"Error: IP range addresses not in network range\\n\");\n\t\texit(1);\n\t}\n\n\treturn;\n\nerr_no_ip:\n\tbr->arg_ip_none = 1;\n\tfwarning(\"Not enough information to configure an IP address for\\n   interface --net=%s\\n\", br->dev);\n}"
  }
]