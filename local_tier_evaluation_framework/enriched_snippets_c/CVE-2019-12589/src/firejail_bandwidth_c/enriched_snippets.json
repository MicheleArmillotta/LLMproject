[
  {
    "function_name": "bandwidth_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "297-400",
    "snippet": "void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {\n\tEUID_ASSERT();\n\tenter_network_namespace(pid);\n\n\t//************************\n\t// build command\n\t//************************\n\tchar *devname = NULL;\n\tif (dev) {\n\t\t// read network map file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%d-netmap\", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Error: cannot read network map file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\n\t\tchar buf[1024];\n\t\tint len = strlen(dev);\n\t\twhile (fgets(buf, 1024, fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\n\t\t\tif (strncmp(buf, dev, len) == 0  && buf[len] == ':') {\n\t\t\t\tdevname = strdup(buf + len + 1);\n\t\t\t\tif (!devname)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\t// check device in namespace\n\t\t\t\tif (if_nametoindex(devname) == 0) {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", devname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(fname);\n\t\tfclose(fp);\n\t}\n\n\t// set run file\n\tif (strcmp(command, \"set\") == 0) {\n\t\tif (devname == NULL) {\n\t\t\tfprintf(stderr, \"Error: cannot find a %s interface inside the sandbox\\n\", dev);\n\t\t\texit(1);\n\t\t}\n\t\tbandwidth_set(pid, devname, down, up);\n\t}\n\telse if (strcmp(command, \"clear\") == 0) {\n\t\tif (devname == NULL) {\n\t\t\tfprintf(stderr, \"Error: cannot find a %s interface inside the sandbox\\n\", dev);\n\t\t\texit(1);\n\t\t}\n\t\tbandwidth_remove(pid, devname);\n\t}\n\n\t// build fshaper.sh command\n\tchar *cmd = NULL;\n\tif (devname) {\n\t\tif (strcmp(command, \"set\") == 0) {\n\t\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s %s %d %d\",\n\t\t\t\tLIBDIR, command, devname, down, up) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\telse {\n\t\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s %s\",\n\t\t\t\tLIBDIR, command, devname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t}\n\telse {\n\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s\", LIBDIR, command) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\tassert(cmd);\n\n\t// wipe out environment variables\n\tenviron = NULL;\n\n\t//************************\n\t// build command\n\t//************************\n\t// elevate privileges\n\tif (setreuid(0, 0))\n\t\terrExit(\"setreuid\");\n\tif (setregid(0, 0))\n\t\terrExit(\"setregid\");\n\n\tchar *arg[4];\n\targ[0] = \"/bin/sh\";\n\targ[1] = \"-c\";\n\targ[2] = cmd;\n\targ[3] = NULL;\n\tclearenv();\n\texecvp(arg[0], arg);\n\n\t// it will never get here\n\terrExit(\"execvp\");\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"execvp\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "arg[0]",
            "arg"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clearenv",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setregid\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setregid",
          "args": [
            "0",
            "0"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "setregid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "646-654",
          "snippet": "int setregid(gid_t rgid, gid_t egid) {\n\tif (!orig_setregid)\n\t\torig_setregid = (orig_setregid_t)dlsym(RTLD_NEXT, \"setregid\");\n\n\tint rv = orig_setregid(rgid, egid);\n\tprintf(\"%u:%s:setregid %d %d:%d\\n\", pid(), name(), rgid, egid, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_setregid_t orig_setregid = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_setregid_t orig_setregid = NULL;\n\nint setregid(gid_t rgid, gid_t egid) {\n\tif (!orig_setregid)\n\t\torig_setregid = (orig_setregid_t)dlsym(RTLD_NEXT, \"setregid\");\n\n\tint rv = orig_setregid(rgid, egid);\n\tprintf(\"%u:%s:setregid %d %d:%d\\n\", pid(), name(), rgid, egid, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setreuid\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setreuid",
          "args": [
            "0",
            "0"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "setreuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "634-642",
          "snippet": "int setreuid(uid_t ruid, uid_t euid) {\n\tif (!orig_setreuid)\n\t\torig_setreuid = (orig_setreuid_t)dlsym(RTLD_NEXT, \"setreuid\");\n\n\tint rv = orig_setreuid(ruid, euid);\n\tprintf(\"%u:%s:setreuid %d %d:%d\\n\", pid(), name(), ruid, euid, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_setreuid_t orig_setreuid = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_setreuid_t orig_setreuid = NULL;\n\nint setreuid(uid_t ruid, uid_t euid) {\n\tif (!orig_setreuid)\n\t\torig_setreuid = (orig_setreuid_t)dlsym(RTLD_NEXT, \"setreuid\");\n\n\tint rv = orig_setreuid(ruid, euid);\n\tprintf(\"%u:%s:setreuid %d %d:%d\\n\", pid(), name(), ruid, euid, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cmd"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cmd",
            "\"%s/firejail/fshaper.sh --%s\"",
            "LIBDIR",
            "command"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cmd",
            "\"%s/firejail/fshaper.sh --%s %s\"",
            "LIBDIR",
            "command",
            "devname"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cmd",
            "\"%s/firejail/fshaper.sh --%s %s %d %d\"",
            "LIBDIR",
            "command",
            "devname",
            "down",
            "up"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "command",
            "\"set\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bandwidth_remove",
          "args": [
            "pid",
            "devname"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "bandwidth_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "241-257",
          "snippet": "void bandwidth_remove(pid_t pid, const char *dev) {\n\tbandwidth_create_run_file(pid);\n\n\t// read bandwidth file\n\tread_bandwidth_file(pid);\n\n\t// find the element and remove it\n\tIFBW *elem = ifbw_find(dev);\n\tif (elem) {\n\t\tifbw_remove(elem);\n\t\twrite_bandwidth_file(pid) ;\n\t}\n\n\t// remove the file if there are no entries in the list\n\tif (ifbw == NULL)\n\t\t delete_bandwidth_run_file(pid);\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "IFBW *ifbw = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nvoid bandwidth_remove(pid_t pid, const char *dev) {\n\tbandwidth_create_run_file(pid);\n\n\t// read bandwidth file\n\tread_bandwidth_file(pid);\n\n\t// find the element and remove it\n\tIFBW *elem = ifbw_find(dev);\n\tif (elem) {\n\t\tifbw_remove(elem);\n\t\twrite_bandwidth_file(pid) ;\n\t}\n\n\t// remove the file if there are no entries in the list\n\tif (ifbw == NULL)\n\t\t delete_bandwidth_run_file(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find a %s interface inside the sandbox\\n\"",
            "dev"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "command",
            "\"clear\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bandwidth_set",
          "args": [
            "pid",
            "devname",
            "down",
            "up"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "bandwidth_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "260-291",
          "snippet": "void bandwidth_set(pid_t pid, const char *dev, int down, int up) {\n\t// create bandwidth directory & file in case they are not in the filesystem yet\n\tbandwidth_create_run_file(pid);\n\n\t// create the new text entry\n\tchar *txt;\n\tif (asprintf(&txt, \"%s: RX %dKB/s, TX %dKB/s\", dev, down, up) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// read bandwidth file\n\tread_bandwidth_file(pid);\n\n\t// look for an existing entry and replace the text\n\tIFBW *ptr = ifbw_find(dev);\n\tif (ptr) {\n\t\tassert(ptr->txt);\n\t\tfree(ptr->txt);\n\t\tptr->txt = txt;\n\t}\n\t// ... or add a new entry\n\telse {\n\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\tif (!ifbw_new)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\tifbw_new->txt = txt;\n\n\t\t// add it to the linked list\n\t\tifbw_add(ifbw_new);\n\t}\n\twrite_bandwidth_file(pid) ;\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nvoid bandwidth_set(pid_t pid, const char *dev, int down, int up) {\n\t// create bandwidth directory & file in case they are not in the filesystem yet\n\tbandwidth_create_run_file(pid);\n\n\t// create the new text entry\n\tchar *txt;\n\tif (asprintf(&txt, \"%s: RX %dKB/s, TX %dKB/s\", dev, down, up) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// read bandwidth file\n\tread_bandwidth_file(pid);\n\n\t// look for an existing entry and replace the text\n\tIFBW *ptr = ifbw_find(dev);\n\tif (ptr) {\n\t\tassert(ptr->txt);\n\t\tfree(ptr->txt);\n\t\tptr->txt = txt;\n\t}\n\t// ... or add a new entry\n\telse {\n\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\tif (!ifbw_new)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\tifbw_new->txt = txt;\n\n\t\t// add it to the linked list\n\t\tifbw_add(ifbw_new);\n\t}\n\twrite_bandwidth_file(pid) ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find a %s interface inside the sandbox\\n\"",
            "dev"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "command",
            "\"set\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find network device %s\\n\"",
            "devname"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "devname"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buf + len + 1"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "dev",
            "len"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "1024",
            "fp"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dev"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot read network map file %s\\n\"",
            "fname"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/%d-netmap\"",
            "RUN_FIREJAIL_NETWORK_DIR",
            "(int) pid"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_network_namespace",
          "args": [
            "pid"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "enter_network_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1305-1341",
          "snippet": "void enter_network_namespace(pid_t pid) {\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid_t child = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(child)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// check network namespace\n\tchar *name;\n\tif (asprintf(&name, \"/run/firejail/network/%d-netmap\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: the sandbox doesn't use a new network namespace\\n\");\n\t\texit(1);\n\t}\n\n\t// join the namespace\n\tEUID_ROOT();\n\tif (join_namespace(child, \"net\")) {\n\t\tfprintf(stderr, \"Error: cannot join the network namespace\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid enter_network_namespace(pid_t pid) {\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid_t child = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(child)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// check network namespace\n\tchar *name;\n\tif (asprintf(&name, \"/run/firejail/network/%d-netmap\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: the sandbox doesn't use a new network namespace\\n\");\n\t\texit(1);\n\t}\n\n\t// join the namespace\n\tEUID_ROOT();\n\tif (join_namespace(child, \"net\")) {\n\t\tfprintf(stderr, \"Error: cannot join the network namespace\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nvoid bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {\n\tEUID_ASSERT();\n\tenter_network_namespace(pid);\n\n\t//************************\n\t// build command\n\t//************************\n\tchar *devname = NULL;\n\tif (dev) {\n\t\t// read network map file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%d-netmap\", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Error: cannot read network map file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\n\t\tchar buf[1024];\n\t\tint len = strlen(dev);\n\t\twhile (fgets(buf, 1024, fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\n\t\t\tif (strncmp(buf, dev, len) == 0  && buf[len] == ':') {\n\t\t\t\tdevname = strdup(buf + len + 1);\n\t\t\t\tif (!devname)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\t// check device in namespace\n\t\t\t\tif (if_nametoindex(devname) == 0) {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", devname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(fname);\n\t\tfclose(fp);\n\t}\n\n\t// set run file\n\tif (strcmp(command, \"set\") == 0) {\n\t\tif (devname == NULL) {\n\t\t\tfprintf(stderr, \"Error: cannot find a %s interface inside the sandbox\\n\", dev);\n\t\t\texit(1);\n\t\t}\n\t\tbandwidth_set(pid, devname, down, up);\n\t}\n\telse if (strcmp(command, \"clear\") == 0) {\n\t\tif (devname == NULL) {\n\t\t\tfprintf(stderr, \"Error: cannot find a %s interface inside the sandbox\\n\", dev);\n\t\t\texit(1);\n\t\t}\n\t\tbandwidth_remove(pid, devname);\n\t}\n\n\t// build fshaper.sh command\n\tchar *cmd = NULL;\n\tif (devname) {\n\t\tif (strcmp(command, \"set\") == 0) {\n\t\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s %s %d %d\",\n\t\t\t\tLIBDIR, command, devname, down, up) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\telse {\n\t\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s %s\",\n\t\t\t\tLIBDIR, command, devname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t}\n\telse {\n\t\tif (asprintf(&cmd, \"%s/firejail/fshaper.sh --%s\", LIBDIR, command) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\tassert(cmd);\n\n\t// wipe out environment variables\n\tenviron = NULL;\n\n\t//************************\n\t// build command\n\t//************************\n\t// elevate privileges\n\tif (setreuid(0, 0))\n\t\terrExit(\"setreuid\");\n\tif (setregid(0, 0))\n\t\terrExit(\"setregid\");\n\n\tchar *arg[4];\n\targ[0] = \"/bin/sh\";\n\targ[1] = \"-c\";\n\targ[2] = cmd;\n\targ[3] = NULL;\n\tclearenv();\n\texecvp(arg[0], arg);\n\n\t// it will never get here\n\terrExit(\"execvp\");\n}"
  },
  {
    "function_name": "bandwidth_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "260-291",
    "snippet": "void bandwidth_set(pid_t pid, const char *dev, int down, int up) {\n\t// create bandwidth directory & file in case they are not in the filesystem yet\n\tbandwidth_create_run_file(pid);\n\n\t// create the new text entry\n\tchar *txt;\n\tif (asprintf(&txt, \"%s: RX %dKB/s, TX %dKB/s\", dev, down, up) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// read bandwidth file\n\tread_bandwidth_file(pid);\n\n\t// look for an existing entry and replace the text\n\tIFBW *ptr = ifbw_find(dev);\n\tif (ptr) {\n\t\tassert(ptr->txt);\n\t\tfree(ptr->txt);\n\t\tptr->txt = txt;\n\t}\n\t// ... or add a new entry\n\telse {\n\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\tif (!ifbw_new)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\tifbw_new->txt = txt;\n\n\t\t// add it to the linked list\n\t\tifbw_add(ifbw_new);\n\t}\n\twrite_bandwidth_file(pid) ;\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_bandwidth_file",
          "args": [
            "pid"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "write_bandwidth_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "209-234",
          "snippet": "static void write_bandwidth_file(pid_t pid) {\n\tif (ifbw == NULL)\n\t\treturn; // nothing to do\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tIFBW *ptr = ifbw;\n\t\twhile (ptr) {\n\t\t\tif (fprintf(fp, \"%s\\n\", ptr->txt) < 0)\n\t\t\t\tgoto errout;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfclose(fp);\n\t}\n\telse\n\t\tgoto errout;\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: cannot write bandwidth file %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "IFBW *ifbw = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nstatic void write_bandwidth_file(pid_t pid) {\n\tif (ifbw == NULL)\n\t\treturn; // nothing to do\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tIFBW *ptr = ifbw;\n\t\twhile (ptr) {\n\t\t\tif (fprintf(fp, \"%s\\n\", ptr->txt) < 0)\n\t\t\t\tgoto errout;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfclose(fp);\n\t}\n\telse\n\t\tgoto errout;\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: cannot write bandwidth file %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifbw_add",
          "args": [
            "ifbw_new"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "ifbw_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "48-54",
          "snippet": "static void ifbw_add(IFBW *ptr) {\n\tassert(ptr);\n\n\tif (ifbw != NULL)\n\t\tptr->next = ifbw;\n\tifbw = ptr;\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "IFBW *ifbw = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nstatic void ifbw_add(IFBW *ptr) {\n\tassert(ptr);\n\n\tif (ifbw != NULL)\n\t\tptr->next = ifbw;\n\tifbw = ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ifbw_new",
            "0",
            "sizeof(IFBW)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(IFBW)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr->txt"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ptr->txt"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifbw_find",
          "args": [
            "dev"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "ifbw_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "57-73",
          "snippet": "IFBW *ifbw_find(const char *dev) {\n\tassert(dev);\n\tint len = strlen(dev);\n\tassert(len);\n\n\tif (ifbw == NULL)\n\t\treturn NULL;\n\n\tIFBW *ptr = ifbw;\n\twhile (ptr) {\n\t\tif (strncmp(ptr->txt, dev, len) == 0 && ptr->txt[len] == ':')\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "IFBW *ifbw = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nIFBW *ifbw_find(const char *dev) {\n\tassert(dev);\n\tint len = strlen(dev);\n\tassert(len);\n\n\tif (ifbw == NULL)\n\t\treturn NULL;\n\n\tIFBW *ptr = ifbw;\n\twhile (ptr) {\n\t\tif (strncmp(ptr->txt, dev, len) == 0 && ptr->txt[len] == ':')\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_bandwidth_file",
          "args": [
            "pid"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "read_bandwidth_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "174-207",
          "snippet": "static void read_bandwidth_file(pid_t pid) {\n\tassert(ifbw == NULL);\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tchar buf[1024];\n\t\twhile (fgets(buf, 1024,fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (strlen(buf) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// create a new IFBW entry\n\t\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\t\tif (!ifbw_new)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\t\tifbw_new->txt = strdup(buf);\n\t\t\tif (!ifbw_new->txt)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// add it to the linked list\n\t\t\tifbw_add(ifbw_new);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "IFBW *ifbw = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nstatic void read_bandwidth_file(pid_t pid) {\n\tassert(ifbw == NULL);\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tchar buf[1024];\n\t\twhile (fgets(buf, 1024,fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (strlen(buf) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// create a new IFBW entry\n\t\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\t\tif (!ifbw_new)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\t\tifbw_new->txt = strdup(buf);\n\t\t\tif (!ifbw_new->txt)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// add it to the linked list\n\t\t\tifbw_add(ifbw_new);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&txt",
            "\"%s: RX %dKB/s, TX %dKB/s\"",
            "dev",
            "down",
            "up"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bandwidth_create_run_file",
          "args": [
            "pid"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "bandwidth_create_run_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "117-142",
          "snippet": "static void bandwidth_create_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if the file already exists, do nothing\n\tstruct stat s;\n\tif (stat(fname, &s) == 0) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// create an empty file and set mod and ownership\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create bandwidth file\\n\");\n\t\texit(1);\n\t}\n\n\tfree(fname);\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic void bandwidth_create_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if the file already exists, do nothing\n\tstruct stat s;\n\tif (stat(fname, &s) == 0) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// create an empty file and set mod and ownership\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create bandwidth file\\n\");\n\t\texit(1);\n\t}\n\n\tfree(fname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nvoid bandwidth_set(pid_t pid, const char *dev, int down, int up) {\n\t// create bandwidth directory & file in case they are not in the filesystem yet\n\tbandwidth_create_run_file(pid);\n\n\t// create the new text entry\n\tchar *txt;\n\tif (asprintf(&txt, \"%s: RX %dKB/s, TX %dKB/s\", dev, down, up) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// read bandwidth file\n\tread_bandwidth_file(pid);\n\n\t// look for an existing entry and replace the text\n\tIFBW *ptr = ifbw_find(dev);\n\tif (ptr) {\n\t\tassert(ptr->txt);\n\t\tfree(ptr->txt);\n\t\tptr->txt = txt;\n\t}\n\t// ... or add a new entry\n\telse {\n\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\tif (!ifbw_new)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\tifbw_new->txt = txt;\n\n\t\t// add it to the linked list\n\t\tifbw_add(ifbw_new);\n\t}\n\twrite_bandwidth_file(pid) ;\n}"
  },
  {
    "function_name": "bandwidth_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "241-257",
    "snippet": "void bandwidth_remove(pid_t pid, const char *dev) {\n\tbandwidth_create_run_file(pid);\n\n\t// read bandwidth file\n\tread_bandwidth_file(pid);\n\n\t// find the element and remove it\n\tIFBW *elem = ifbw_find(dev);\n\tif (elem) {\n\t\tifbw_remove(elem);\n\t\twrite_bandwidth_file(pid) ;\n\t}\n\n\t// remove the file if there are no entries in the list\n\tif (ifbw == NULL)\n\t\t delete_bandwidth_run_file(pid);\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "IFBW *ifbw = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delete_bandwidth_run_file",
          "args": [
            "pid"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "delete_bandwidth_run_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/run_files.c",
          "lines": "52-58",
          "snippet": "void delete_bandwidth_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\tunlink(fname);\n\tfree(fname);\n}",
          "includes": [
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nvoid delete_bandwidth_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\tunlink(fname);\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_bandwidth_file",
          "args": [
            "pid"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "write_bandwidth_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "209-234",
          "snippet": "static void write_bandwidth_file(pid_t pid) {\n\tif (ifbw == NULL)\n\t\treturn; // nothing to do\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tIFBW *ptr = ifbw;\n\t\twhile (ptr) {\n\t\t\tif (fprintf(fp, \"%s\\n\", ptr->txt) < 0)\n\t\t\t\tgoto errout;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfclose(fp);\n\t}\n\telse\n\t\tgoto errout;\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: cannot write bandwidth file %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "IFBW *ifbw = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nstatic void write_bandwidth_file(pid_t pid) {\n\tif (ifbw == NULL)\n\t\treturn; // nothing to do\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tIFBW *ptr = ifbw;\n\t\twhile (ptr) {\n\t\t\tif (fprintf(fp, \"%s\\n\", ptr->txt) < 0)\n\t\t\t\tgoto errout;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfclose(fp);\n\t}\n\telse\n\t\tgoto errout;\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: cannot write bandwidth file %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifbw_remove",
          "args": [
            "elem"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ifbw_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "75-99",
          "snippet": "void ifbw_remove(IFBW *r) {\n\tif (ifbw == NULL)\n\t\treturn;\n\n\t// remove the first element\n\tif (ifbw == r) {\n\t\tifbw = ifbw->next;\n\t\treturn;\n\t}\n\n\t// walk the list\n\tIFBW *ptr = ifbw->next;\n\tIFBW *prev = ifbw;\n\twhile (ptr) {\n\t\tif (ptr == r) {\n\t\t\tprev->next = ptr->next;\n\t\t\treturn;\n\t\t}\n\n\t\tprev = ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "IFBW *ifbw = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nvoid ifbw_remove(IFBW *r) {\n\tif (ifbw == NULL)\n\t\treturn;\n\n\t// remove the first element\n\tif (ifbw == r) {\n\t\tifbw = ifbw->next;\n\t\treturn;\n\t}\n\n\t// walk the list\n\tIFBW *ptr = ifbw->next;\n\tIFBW *prev = ifbw;\n\twhile (ptr) {\n\t\tif (ptr == r) {\n\t\t\tprev->next = ptr->next;\n\t\t\treturn;\n\t\t}\n\n\t\tprev = ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifbw_find",
          "args": [
            "dev"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "ifbw_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "57-73",
          "snippet": "IFBW *ifbw_find(const char *dev) {\n\tassert(dev);\n\tint len = strlen(dev);\n\tassert(len);\n\n\tif (ifbw == NULL)\n\t\treturn NULL;\n\n\tIFBW *ptr = ifbw;\n\twhile (ptr) {\n\t\tif (strncmp(ptr->txt, dev, len) == 0 && ptr->txt[len] == ':')\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "IFBW *ifbw = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nIFBW *ifbw_find(const char *dev) {\n\tassert(dev);\n\tint len = strlen(dev);\n\tassert(len);\n\n\tif (ifbw == NULL)\n\t\treturn NULL;\n\n\tIFBW *ptr = ifbw;\n\twhile (ptr) {\n\t\tif (strncmp(ptr->txt, dev, len) == 0 && ptr->txt[len] == ':')\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_bandwidth_file",
          "args": [
            "pid"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "read_bandwidth_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "174-207",
          "snippet": "static void read_bandwidth_file(pid_t pid) {\n\tassert(ifbw == NULL);\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tchar buf[1024];\n\t\twhile (fgets(buf, 1024,fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (strlen(buf) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// create a new IFBW entry\n\t\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\t\tif (!ifbw_new)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\t\tifbw_new->txt = strdup(buf);\n\t\t\tif (!ifbw_new->txt)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// add it to the linked list\n\t\t\tifbw_add(ifbw_new);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "IFBW *ifbw = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nstatic void read_bandwidth_file(pid_t pid) {\n\tassert(ifbw == NULL);\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tchar buf[1024];\n\t\twhile (fgets(buf, 1024,fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (strlen(buf) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// create a new IFBW entry\n\t\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\t\tif (!ifbw_new)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\t\tifbw_new->txt = strdup(buf);\n\t\t\tif (!ifbw_new->txt)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// add it to the linked list\n\t\t\tifbw_add(ifbw_new);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bandwidth_create_run_file",
          "args": [
            "pid"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "bandwidth_create_run_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "117-142",
          "snippet": "static void bandwidth_create_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if the file already exists, do nothing\n\tstruct stat s;\n\tif (stat(fname, &s) == 0) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// create an empty file and set mod and ownership\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create bandwidth file\\n\");\n\t\texit(1);\n\t}\n\n\tfree(fname);\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic void bandwidth_create_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if the file already exists, do nothing\n\tstruct stat s;\n\tif (stat(fname, &s) == 0) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// create an empty file and set mod and ownership\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create bandwidth file\\n\");\n\t\texit(1);\n\t}\n\n\tfree(fname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nvoid bandwidth_remove(pid_t pid, const char *dev) {\n\tbandwidth_create_run_file(pid);\n\n\t// read bandwidth file\n\tread_bandwidth_file(pid);\n\n\t// find the element and remove it\n\tIFBW *elem = ifbw_find(dev);\n\tif (elem) {\n\t\tifbw_remove(elem);\n\t\twrite_bandwidth_file(pid) ;\n\t}\n\n\t// remove the file if there are no entries in the list\n\tif (ifbw == NULL)\n\t\t delete_bandwidth_run_file(pid);\n}"
  },
  {
    "function_name": "write_bandwidth_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "209-234",
    "snippet": "static void write_bandwidth_file(pid_t pid) {\n\tif (ifbw == NULL)\n\t\treturn; // nothing to do\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tIFBW *ptr = ifbw;\n\t\twhile (ptr) {\n\t\t\tif (fprintf(fp, \"%s\\n\", ptr->txt) < 0)\n\t\t\t\tgoto errout;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfclose(fp);\n\t}\n\telse\n\t\tgoto errout;\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: cannot write bandwidth file %s\\n\", fname);\n\texit(1);\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "IFBW *ifbw = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot write bandwidth file %s\\n\"",
            "fname"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"%s\\n\"",
            "ptr->txt"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"w\""
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/%d-bandwidth\"",
            "RUN_FIREJAIL_BANDWIDTH_DIR",
            "(int) pid"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nstatic void write_bandwidth_file(pid_t pid) {\n\tif (ifbw == NULL)\n\t\treturn; // nothing to do\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tIFBW *ptr = ifbw;\n\t\twhile (ptr) {\n\t\t\tif (fprintf(fp, \"%s\\n\", ptr->txt) < 0)\n\t\t\t\tgoto errout;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfclose(fp);\n\t}\n\telse\n\t\tgoto errout;\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: cannot write bandwidth file %s\\n\", fname);\n\texit(1);\n}"
  },
  {
    "function_name": "read_bandwidth_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "174-207",
    "snippet": "static void read_bandwidth_file(pid_t pid) {\n\tassert(ifbw == NULL);\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tchar buf[1024];\n\t\twhile (fgets(buf, 1024,fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (strlen(buf) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// create a new IFBW entry\n\t\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\t\tif (!ifbw_new)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\t\tifbw_new->txt = strdup(buf);\n\t\t\tif (!ifbw_new->txt)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// add it to the linked list\n\t\t\tifbw_add(ifbw_new);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "IFBW *ifbw = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifbw_add",
          "args": [
            "ifbw_new"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "ifbw_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
          "lines": "48-54",
          "snippet": "static void ifbw_add(IFBW *ptr) {\n\tassert(ptr);\n\n\tif (ifbw != NULL)\n\t\tptr->next = ifbw;\n\tifbw = ptr;\n}",
          "includes": [
            "#include \"firejail.h\"",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "IFBW *ifbw = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nstatic void ifbw_add(IFBW *ptr) {\n\tassert(ptr);\n\n\tif (ifbw != NULL)\n\t\tptr->next = ifbw;\n\tifbw = ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buf"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ifbw_new",
            "0",
            "sizeof(IFBW)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(IFBW)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "1024",
            "fp"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/%d-bandwidth\"",
            "RUN_FIREJAIL_BANDWIDTH_DIR",
            "(int) pid"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ifbw == NULL"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nstatic void read_bandwidth_file(pid_t pid) {\n\tassert(ifbw == NULL);\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tchar buf[1024];\n\t\twhile (fgets(buf, 1024,fp)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (strlen(buf) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// create a new IFBW entry\n\t\t\tIFBW *ifbw_new = malloc(sizeof(IFBW));\n\t\t\tif (!ifbw_new)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tmemset(ifbw_new, 0, sizeof(IFBW));\n\t\t\tifbw_new->txt = strdup(buf);\n\t\t\tif (!ifbw_new->txt)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// add it to the linked list\n\t\t\tifbw_add(ifbw_new);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n}"
  },
  {
    "function_name": "network_set_run_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "145-171",
    "snippet": "void network_set_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-netmap\", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// create an empty file and set mod and ownership\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tif (cfg.bridge0.configured)\n\t\t\tfprintf(fp, \"%s:%s\\n\", cfg.bridge0.dev, cfg.bridge0.devsandbox);\n\t\tif (cfg.bridge1.configured)\n\t\t\tfprintf(fp, \"%s:%s\\n\", cfg.bridge1.dev, cfg.bridge1.devsandbox);\n\t\tif (cfg.bridge2.configured)\n\t\t\tfprintf(fp, \"%s:%s\\n\", cfg.bridge2.dev, cfg.bridge2.devsandbox);\n\t\tif (cfg.bridge3.configured)\n\t\t\tfprintf(fp, \"%s:%s\\n\", cfg.bridge3.dev, cfg.bridge3.devsandbox);\n\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create network map file\\n\");\n\t\texit(1);\n\t}\n\n\tfree(fname);\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create network map file\\n\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "0",
            "0",
            "0644"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"%s:%s\\n\"",
            "cfg.bridge3.dev",
            "cfg.bridge3.devsandbox"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"%s:%s\\n\"",
            "cfg.bridge2.dev",
            "cfg.bridge2.devsandbox"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"%s:%s\\n\"",
            "cfg.bridge1.dev",
            "cfg.bridge1.devsandbox"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"%s:%s\\n\"",
            "cfg.bridge0.dev",
            "cfg.bridge0.devsandbox"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"w\""
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/%d-netmap\"",
            "RUN_FIREJAIL_NETWORK_DIR",
            "(int) pid"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nvoid network_set_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-netmap\", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// create an empty file and set mod and ownership\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tif (cfg.bridge0.configured)\n\t\t\tfprintf(fp, \"%s:%s\\n\", cfg.bridge0.dev, cfg.bridge0.devsandbox);\n\t\tif (cfg.bridge1.configured)\n\t\t\tfprintf(fp, \"%s:%s\\n\", cfg.bridge1.dev, cfg.bridge1.devsandbox);\n\t\tif (cfg.bridge2.configured)\n\t\t\tfprintf(fp, \"%s:%s\\n\", cfg.bridge2.dev, cfg.bridge2.devsandbox);\n\t\tif (cfg.bridge3.configured)\n\t\t\tfprintf(fp, \"%s:%s\\n\", cfg.bridge3.dev, cfg.bridge3.devsandbox);\n\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create network map file\\n\");\n\t\texit(1);\n\t}\n\n\tfree(fname);\n}"
  },
  {
    "function_name": "bandwidth_create_run_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "117-142",
    "snippet": "static void bandwidth_create_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if the file already exists, do nothing\n\tstruct stat s;\n\tif (stat(fname, &s) == 0) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// create an empty file and set mod and ownership\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create bandwidth file\\n\");\n\t\texit(1);\n\t}\n\n\tfree(fname);\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create bandwidth file\\n\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "0",
            "0",
            "0644"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"w\""
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/%d-bandwidth\"",
            "RUN_FIREJAIL_BANDWIDTH_DIR",
            "(int) pid"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic void bandwidth_create_run_file(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d-bandwidth\", RUN_FIREJAIL_BANDWIDTH_DIR, (int) pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if the file already exists, do nothing\n\tstruct stat s;\n\tif (stat(fname, &s) == 0) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// create an empty file and set mod and ownership\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"w\");\n\tif (fp) {\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create bandwidth file\\n\");\n\t\texit(1);\n\t}\n\n\tfree(fname);\n}"
  },
  {
    "function_name": "fibw_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "101-111",
    "snippet": "int fibw_count(void) {\n\tint rv = 0;\n\tIFBW *ptr = ifbw;\n\n\twhile (ptr) {\n\t\trv++;\n\t\tptr = ptr->next;\n\t}\n\n\treturn rv;\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "IFBW *ifbw = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nint fibw_count(void) {\n\tint rv = 0;\n\tIFBW *ptr = ifbw;\n\n\twhile (ptr) {\n\t\trv++;\n\t\tptr = ptr->next;\n\t}\n\n\treturn rv;\n}"
  },
  {
    "function_name": "ifbw_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "75-99",
    "snippet": "void ifbw_remove(IFBW *r) {\n\tif (ifbw == NULL)\n\t\treturn;\n\n\t// remove the first element\n\tif (ifbw == r) {\n\t\tifbw = ifbw->next;\n\t\treturn;\n\t}\n\n\t// walk the list\n\tIFBW *ptr = ifbw->next;\n\tIFBW *prev = ifbw;\n\twhile (ptr) {\n\t\tif (ptr == r) {\n\t\t\tprev->next = ptr->next;\n\t\t\treturn;\n\t\t}\n\n\t\tprev = ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "IFBW *ifbw = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nvoid ifbw_remove(IFBW *r) {\n\tif (ifbw == NULL)\n\t\treturn;\n\n\t// remove the first element\n\tif (ifbw == r) {\n\t\tifbw = ifbw->next;\n\t\treturn;\n\t}\n\n\t// walk the list\n\tIFBW *ptr = ifbw->next;\n\tIFBW *prev = ifbw;\n\twhile (ptr) {\n\t\tif (ptr == r) {\n\t\t\tprev->next = ptr->next;\n\t\t\treturn;\n\t\t}\n\n\t\tprev = ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "ifbw_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "57-73",
    "snippet": "IFBW *ifbw_find(const char *dev) {\n\tassert(dev);\n\tint len = strlen(dev);\n\tassert(len);\n\n\tif (ifbw == NULL)\n\t\treturn NULL;\n\n\tIFBW *ptr = ifbw;\n\twhile (ptr) {\n\t\tif (strncmp(ptr->txt, dev, len) == 0 && ptr->txt[len] == ':')\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "IFBW *ifbw = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr->txt",
            "dev",
            "len"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dev"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dev"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nIFBW *ifbw_find(const char *dev) {\n\tassert(dev);\n\tint len = strlen(dev);\n\tassert(len);\n\n\tif (ifbw == NULL)\n\t\treturn NULL;\n\n\tIFBW *ptr = ifbw;\n\twhile (ptr) {\n\t\tif (strncmp(ptr->txt, dev, len) == 0 && ptr->txt[len] == ':')\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ifbw_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "48-54",
    "snippet": "static void ifbw_add(IFBW *ptr) {\n\tassert(ptr);\n\n\tif (ifbw != NULL)\n\t\tptr->next = ifbw;\n\tifbw = ptr;\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "IFBW *ifbw = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ptr"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nstatic void ifbw_add(IFBW *ptr) {\n\tassert(ptr);\n\n\tif (ifbw != NULL)\n\t\tptr->next = ifbw;\n\tifbw = ptr;\n}"
  },
  {
    "function_name": "ifbw_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/bandwidth.c",
    "lines": "39-45",
    "snippet": "static void ifbw_print(void) {\n\tIFBW *ptr = ifbw;\n\twhile (ptr) {\n\t\tprintf(\"#%s#\\n\", ptr->txt);\n\t\tptr = ptr->next;\n\t}\n}",
    "includes": [
      "#include \"firejail.h\"",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "IFBW *ifbw = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"#%s#\\n\"",
            "ptr->txt"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nIFBW *ifbw = NULL;\n\nstatic void ifbw_print(void) {\n\tIFBW *ptr = ifbw;\n\twhile (ptr) {\n\t\tprintf(\"#%s#\\n\", ptr->txt);\n\t\tptr = ptr->next;\n\t}\n}"
  }
]