[
  {
    "function_name": "net_if_ip6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
    "lines": "312-372",
    "snippet": "void net_if_ip6(const char *ifname, const char *addr6) {\n\tcheck_if_name(ifname);\n\tif (strchr(addr6, ':') == NULL) {\n\t\tfprintf(stderr, \"Error fnet: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// extract prefix\n\tunsigned long prefix;\n\tchar *ptr;\n\tif ((ptr = strchr(addr6, '/'))) {\n\t\tprefix = atol(ptr + 1);\n\t\tif (prefix > 128) {\n\t\t\tfprintf(stderr, \"Error fnet: invalid prefix for IPv6 address %s\\n\", addr6);\n\t\t\texit(1);\n\t\t}\n\t\t*ptr = '\\0';\t// mark the end of the address\n\t}\n\telse\n\t\tprefix = 128;\n\n\t// extract address\n\tstruct sockaddr_in6 sin6;\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n\tint rv = inet_pton(AF_INET6, addr6, sin6.sin6_addr.s6_addr);\n\tif (rv <= 0) {\n\t\tfprintf(stderr, \"Error fnet: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// open socket\n\tint sock = socket(PF_INET6, SOCK_DGRAM, IPPROTO_IP);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error fnet: IPv6 is not supported on this system\\n\");\n\t\texit(1);\n\t}\n\n\t// find interface index\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\tif (ioctl(sock, SIOGIFINDEX, &ifr) < 0) {\n\t\tperror(\"ioctl SIOGIFINDEX\");\n\t\texit(1);\n\t}\n\n\t// configure address\n\tstruct ifreq6 ifr6;\n\tmemset(&ifr6, 0, sizeof(ifr6));\n\tifr6.ifr6_prefixlen = prefix;\n\tifr6.ifr6_ifindex = ifr.ifr_ifindex;\n\tmemcpy((char *) &ifr6.ifr6_addr, (char *) &sin6.sin6_addr, sizeof(struct in6_addr));\n\tif (ioctl(sock, SIOCSIFADDR, &ifr6) < 0) {\n\t\tperror(\"ioctl SIOCSIFADDR\");\n\t\texit(1);\n\t}\n\n\tclose(sock);\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl SIOCSIFADDR\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFADDR",
            "&ifr6"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) &ifr6.ifr6_addr",
            "(char *) &sin6.sin6_addr",
            "sizeof(struct in6_addr)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr6",
            "0",
            "sizeof(ifr6)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl SIOGIFINDEX\""
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOGIFINDEX",
            "&ifr"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ - 1"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fnet: IPv6 is not supported on this system\\n\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_INET6",
            "SOCK_DGRAM",
            "IPPROTO_IP"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fnet: invalid IPv6 address %s\\n\"",
            "addr6"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET6",
            "addr6",
            "sin6.sin6_addr.s6_addr"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sin6",
            "0",
            "sizeof(sin6)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fnet: invalid prefix for IPv6 address %s\\n\"",
            "addr6"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "ptr + 1"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "addr6",
            "'/'"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fnet: invalid IPv6 address %s\\n\"",
            "addr6"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "addr6",
            "':'"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_if_name",
          "args": [
            "ifname"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "check_if_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "32-37",
          "snippet": "static void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nstatic void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_if_ip6(const char *ifname, const char *addr6) {\n\tcheck_if_name(ifname);\n\tif (strchr(addr6, ':') == NULL) {\n\t\tfprintf(stderr, \"Error fnet: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// extract prefix\n\tunsigned long prefix;\n\tchar *ptr;\n\tif ((ptr = strchr(addr6, '/'))) {\n\t\tprefix = atol(ptr + 1);\n\t\tif (prefix > 128) {\n\t\t\tfprintf(stderr, \"Error fnet: invalid prefix for IPv6 address %s\\n\", addr6);\n\t\t\texit(1);\n\t\t}\n\t\t*ptr = '\\0';\t// mark the end of the address\n\t}\n\telse\n\t\tprefix = 128;\n\n\t// extract address\n\tstruct sockaddr_in6 sin6;\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n\tint rv = inet_pton(AF_INET6, addr6, sin6.sin6_addr.s6_addr);\n\tif (rv <= 0) {\n\t\tfprintf(stderr, \"Error fnet: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// open socket\n\tint sock = socket(PF_INET6, SOCK_DGRAM, IPPROTO_IP);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error fnet: IPv6 is not supported on this system\\n\");\n\t\texit(1);\n\t}\n\n\t// find interface index\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\tif (ioctl(sock, SIOGIFINDEX, &ifr) < 0) {\n\t\tperror(\"ioctl SIOGIFINDEX\");\n\t\texit(1);\n\t}\n\n\t// configure address\n\tstruct ifreq6 ifr6;\n\tmemset(&ifr6, 0, sizeof(ifr6));\n\tifr6.ifr6_prefixlen = prefix;\n\tifr6.ifr6_ifindex = ifr.ifr_ifindex;\n\tmemcpy((char *) &ifr6.ifr6_addr, (char *) &sin6.sin6_addr, sizeof(struct in6_addr));\n\tif (ioctl(sock, SIOCSIFADDR, &ifr6) < 0) {\n\t\tperror(\"ioctl SIOCSIFADDR\");\n\t\texit(1);\n\t}\n\n\tclose(sock);\n}"
  },
  {
    "function_name": "net_if_mac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
    "lines": "286-303",
    "snippet": "int net_if_mac(const char *ifname, const unsigned char mac[6]) {\n\tcheck_if_name(ifname);\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\tmemcpy(ifr.ifr_hwaddr.sa_data, mac, 6);\n\n\tif (ioctl(sock, SIOCSIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFHWADDR",
            "&ifr"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ifr.ifr_hwaddr.sa_data",
            "mac",
            "6"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ - 1"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_if_name",
          "args": [
            "ifname"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "check_if_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "32-37",
          "snippet": "static void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nstatic void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nint net_if_mac(const char *ifname, const unsigned char mac[6]) {\n\tcheck_if_name(ifname);\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\tmemcpy(ifr.ifr_hwaddr.sa_data, mac, 6);\n\n\tif (ioctl(sock, SIOCSIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\treturn 0;\n}"
  },
  {
    "function_name": "net_if_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
    "lines": "253-284",
    "snippet": "void net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu) {\n\tcheck_if_name(ifname);\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr = htonl(ip);\n\tif (ioctl( sock, SIOCSIFADDR, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\tif (ip != 0) {\n\t\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr =  htonl(mask);\n\t\tif (ioctl( sock, SIOCSIFNETMASK, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t}\n\n\t// configure mtu\n\tif (mtu > 0) {\n\t\tifr.ifr_mtu = mtu;\n\t\tif (ioctl( sock, SIOCSIFMTU, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t}\n\n\tclose(sock);\n\tusleep(10000);\t\t\t\t  // sleep 10ms\n\treturn;\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10000"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFMTU",
            "&ifr"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFNETMASK",
            "&ifr"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "mask"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFADDR",
            "&ifr"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "ip"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ - 1"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_if_name",
          "args": [
            "ifname"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "check_if_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "32-37",
          "snippet": "static void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nstatic void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu) {\n\tcheck_if_name(ifname);\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr = htonl(ip);\n\tif (ioctl( sock, SIOCSIFADDR, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\tif (ip != 0) {\n\t\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr =  htonl(mask);\n\t\tif (ioctl( sock, SIOCSIFNETMASK, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t}\n\n\t// configure mtu\n\tif (mtu > 0) {\n\t\tifr.ifr_mtu = mtu;\n\t\tif (ioctl( sock, SIOCSIFMTU, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t}\n\n\tclose(sock);\n\tusleep(10000);\t\t\t\t  // sleep 10ms\n\treturn;\n}"
  },
  {
    "function_name": "net_get_mac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
    "lines": "231-250",
    "snippet": "int net_get_mac(const char *ifname, unsigned char mac[6]) {\n\tcheck_if_name(ifname);\n\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tmemcpy(mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\tclose(sock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mac",
            "ifr.ifr_hwaddr.sa_data",
            "6"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCGIFHWADDR",
            "&ifr"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ - 1"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_if_name",
          "args": [
            "ifname"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "check_if_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "32-37",
          "snippet": "static void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nstatic void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nint net_get_mac(const char *ifname, unsigned char mac[6]) {\n\tcheck_if_name(ifname);\n\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tmemcpy(mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\tclose(sock);\n\treturn 0;\n}"
  },
  {
    "function_name": "net_ifprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
    "lines": "167-229",
    "snippet": "void net_ifprint(int scan) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\tfmessage(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\"Interface\", \"MAC\", \"IP\", \"Mask\", \"Status\");\n\t// walk through the linked list\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\t// interface status\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t// ip address and mask\n\t\t\tchar ipstr[30];\n\t\t\tsprintf(ipstr, \"%d.%d.%d.%d\", PRINT_IP(ip));\n\t\t\tchar maskstr[30];\n\t\t\tsprintf(maskstr, \"%d.%d.%d.%d\", PRINT_IP(mask));\n\n\t\t\t// mac address\n\t\t\tunsigned char mac[6];\n\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\tchar macstr[30];\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\n\t\t\t\tmacstr[0] = '\\0';\n\t\t\telse\n\t\t\t\tsprintf(macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\", PRINT_MAC(mac));\n\n\t\t\t// print\n\t\t\tfmessage(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\t\tifa->ifa_name, macstr, ipstr, maskstr, status);\n\n\t\t\t// network scanning\n\t\t\tif (!scan)\t\t\t\t// scanning disabled\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\t// no loopbabck scanning\n\t\t\t\tcontinue;\n\t\t\tif (mask2bits(mask) < 16)\t\t// not scanning large networks\n\t\t\t\tcontinue;\n\t\t\tif (!ip)\t\t\t\t\t// if not configured\n\t\t\t\tcontinue;\n\t\t\t// only if the interface is up and running\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tarp_scan(ifa->ifa_name, ip, mask);\n\t\t}\n\t}\n\tfreeifaddrs(ifaddr);\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "ifaddr"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_scan",
          "args": [
            "ifa->ifa_name",
            "ip",
            "mask"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "arp_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/arp.c",
          "lines": "45-205",
          "snippet": "void arp_scan(const char *dev, uint32_t ifip, uint32_t ifmask) {\n\tassert(dev);\n\tassert(ifip);\n\n//\tprintf(\"Scanning interface %s (%d.%d.%d.%d/%d)\\n\",\n//\t\tdev, PRINT_IP(ifip & ifmask), mask2bits(ifmask));\n\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\n\t// find interface mac address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ - 1);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\tuint8_t mac[6];\n\tmemcpy (mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\t// try all possible ip addresses in ascending order\n\tuint32_t range = ~ifmask + 1; // the number of potential addresses\n\t// this software is not supported for /31 networks\n\tif (range < 4) {\n\t\tfprintf(stderr, \"Warning: this option is not supported for /31 networks\\n\");\n\t\tclose(sock);\n\t\treturn;\n\t}\n\n\tuint32_t dest = (ifip & ifmask) + 1;\n\tuint32_t last = dest + range - 1;\n\tuint32_t src = htonl(ifip);\n\n\t// wait not more than one second for an answer\n\tint header_printed = 0;\n\tuint32_t last_ip = 0;\n\tstruct timeval ts;\n\tts.tv_sec = 2; // 2 seconds receive timeout\n\tts.tv_usec = 0;\n\n\twhile (1) {\n\t\tfd_set rfds;\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(sock, &rfds);\n\t\tfd_set wfds;\n\t\tFD_ZERO(&wfds);\n\t\tFD_SET(sock, &wfds);\n\t\tint maxfd = sock;\n\n\t\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\t\tmemset(frame, 0, ETH_FRAME_LEN);\n\n\t\tint nready;\n\t\tif (dest < last)\n\t\t\tnready = select(maxfd + 1,  &rfds, &wfds, (fd_set *) 0, NULL);\n\t\telse\n\t\t\tnready = select(maxfd + 1,  &rfds,  (fd_set *) 0, (fd_set *) 0, &ts);\n\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\n\t\tif (nready == 0) { // timeout\n\t\t\tbreak;\n\t\t}\n\n\t\tif (FD_ISSET(sock, &wfds) && dest < last) {\n\t\t\t// configure layer2 socket address information\n\t\t\tstruct sockaddr_ll addr;\n\t\t\tmemset(&addr, 0, sizeof(addr));\n\t\t\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\t\t\terrExit(\"if_nametoindex\");\n\t\t\taddr.sll_family = AF_PACKET;\n\t\t\tmemcpy (addr.sll_addr, mac, 6);\n\t\t\taddr.sll_halen = ETH_ALEN;\n\n\t\t\t// build the arp packet header\n\t\t\tArpHdr hdr;\n\t\t\tmemset(&hdr, 0, sizeof(hdr));\n\t\t\thdr.htype = htons(1);\n\t\t\thdr.ptype = htons(ETH_P_IP);\n\t\t\thdr.hlen = 6;\n\t\t\thdr.plen = 4;\n\t\t\thdr.opcode = htons(1); //ARPOP_REQUEST\n\t\t\tmemcpy(hdr.sender_mac, mac, 6);\n\t\t\tmemcpy(hdr.sender_ip, (uint8_t *)&src, 4);\n\t\t\tuint32_t dst = htonl(dest);\n\t\t\tmemcpy(hdr.target_ip, (uint8_t *)&dst, 4);\n\n\t\t\t// build ethernet frame\n\t\t\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\t\t\tmemset(frame, 0, sizeof(frame));\n\t\t\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\t\t\tmemcpy(frame + 6, mac, 6);\n\t\t\tframe[12] = ETH_P_ARP / 256;\n\t\t\tframe[13] = ETH_P_ARP % 256;\n\t\t\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t\t\t// send packet\n\t\t\tint len;\n\t\t\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\t\t\terrExit(\"send\");\n//printf(\"send %d bytes to %d.%d.%d.%d\\n\", len, PRINT_IP(dest));\n\t\t\tfflush(0);\n\t\t\tdest++;\n\t\t}\n\n\t\tif (FD_ISSET(sock, &rfds)) {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, frame, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t}\n\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\n\t\t\t// look only at ARP packets\n\t\t\tif (frame[12] != (ETH_P_ARP / 256) || frame[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\n\t\t\tArpHdr hdr;\n\t\t\tmemcpy(&hdr, frame + 14, sizeof(ArpHdr));\n\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(mac, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != src)\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(&ip, hdr.sender_ip, 4);\n\t\t\t\tip = ntohl(ip);\n\n\t\t\t\tif (ip == last_ip) // filter duplicates\n\t\t\t\t\tcontinue;\n\t\t\t\tlast_ip = ip;\n\n\t\t\t\t// printing\n\t\t\t\tif (header_printed == 0) {\n\t\t\t\t\tfmessage(\"   Network scan:\\n\");\n\t\t\t\t\theader_printed = 1;\n\t\t\t\t}\n\t\t\t\tfmessage(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\tPRINT_MAC(hdr.sender_mac), PRINT_IP(ip));\n\t\t\t}\n\t\t}\n\t}\n\n\tclose(sock);\n}",
          "includes": [
            "#include <linux/if_packet.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_packet.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include \"fnet.h\"\n\nvoid arp_scan(const char *dev, uint32_t ifip, uint32_t ifmask) {\n\tassert(dev);\n\tassert(ifip);\n\n//\tprintf(\"Scanning interface %s (%d.%d.%d.%d/%d)\\n\",\n//\t\tdev, PRINT_IP(ifip & ifmask), mask2bits(ifmask));\n\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\n\t// find interface mac address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ - 1);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\tuint8_t mac[6];\n\tmemcpy (mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\t// try all possible ip addresses in ascending order\n\tuint32_t range = ~ifmask + 1; // the number of potential addresses\n\t// this software is not supported for /31 networks\n\tif (range < 4) {\n\t\tfprintf(stderr, \"Warning: this option is not supported for /31 networks\\n\");\n\t\tclose(sock);\n\t\treturn;\n\t}\n\n\tuint32_t dest = (ifip & ifmask) + 1;\n\tuint32_t last = dest + range - 1;\n\tuint32_t src = htonl(ifip);\n\n\t// wait not more than one second for an answer\n\tint header_printed = 0;\n\tuint32_t last_ip = 0;\n\tstruct timeval ts;\n\tts.tv_sec = 2; // 2 seconds receive timeout\n\tts.tv_usec = 0;\n\n\twhile (1) {\n\t\tfd_set rfds;\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(sock, &rfds);\n\t\tfd_set wfds;\n\t\tFD_ZERO(&wfds);\n\t\tFD_SET(sock, &wfds);\n\t\tint maxfd = sock;\n\n\t\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\t\tmemset(frame, 0, ETH_FRAME_LEN);\n\n\t\tint nready;\n\t\tif (dest < last)\n\t\t\tnready = select(maxfd + 1,  &rfds, &wfds, (fd_set *) 0, NULL);\n\t\telse\n\t\t\tnready = select(maxfd + 1,  &rfds,  (fd_set *) 0, (fd_set *) 0, &ts);\n\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\n\t\tif (nready == 0) { // timeout\n\t\t\tbreak;\n\t\t}\n\n\t\tif (FD_ISSET(sock, &wfds) && dest < last) {\n\t\t\t// configure layer2 socket address information\n\t\t\tstruct sockaddr_ll addr;\n\t\t\tmemset(&addr, 0, sizeof(addr));\n\t\t\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\t\t\terrExit(\"if_nametoindex\");\n\t\t\taddr.sll_family = AF_PACKET;\n\t\t\tmemcpy (addr.sll_addr, mac, 6);\n\t\t\taddr.sll_halen = ETH_ALEN;\n\n\t\t\t// build the arp packet header\n\t\t\tArpHdr hdr;\n\t\t\tmemset(&hdr, 0, sizeof(hdr));\n\t\t\thdr.htype = htons(1);\n\t\t\thdr.ptype = htons(ETH_P_IP);\n\t\t\thdr.hlen = 6;\n\t\t\thdr.plen = 4;\n\t\t\thdr.opcode = htons(1); //ARPOP_REQUEST\n\t\t\tmemcpy(hdr.sender_mac, mac, 6);\n\t\t\tmemcpy(hdr.sender_ip, (uint8_t *)&src, 4);\n\t\t\tuint32_t dst = htonl(dest);\n\t\t\tmemcpy(hdr.target_ip, (uint8_t *)&dst, 4);\n\n\t\t\t// build ethernet frame\n\t\t\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\t\t\tmemset(frame, 0, sizeof(frame));\n\t\t\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\t\t\tmemcpy(frame + 6, mac, 6);\n\t\t\tframe[12] = ETH_P_ARP / 256;\n\t\t\tframe[13] = ETH_P_ARP % 256;\n\t\t\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t\t\t// send packet\n\t\t\tint len;\n\t\t\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\t\t\terrExit(\"send\");\n//printf(\"send %d bytes to %d.%d.%d.%d\\n\", len, PRINT_IP(dest));\n\t\t\tfflush(0);\n\t\t\tdest++;\n\t\t}\n\n\t\tif (FD_ISSET(sock, &rfds)) {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, frame, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t}\n\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\n\t\t\t// look only at ARP packets\n\t\t\tif (frame[12] != (ETH_P_ARP / 256) || frame[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\n\t\t\tArpHdr hdr;\n\t\t\tmemcpy(&hdr, frame + 14, sizeof(ArpHdr));\n\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(mac, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != src)\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(&ip, hdr.sender_ip, 4);\n\t\t\t\tip = ntohl(ip);\n\n\t\t\t\tif (ip == last_ip) // filter duplicates\n\t\t\t\t\tcontinue;\n\t\t\t\tlast_ip = ip;\n\n\t\t\t\t// printing\n\t\t\t\tif (header_printed == 0) {\n\t\t\t\t\tfmessage(\"   Network scan:\\n\");\n\t\t\t\t\theader_printed = 1;\n\t\t\t\t}\n\t\t\t\tfmessage(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\tPRINT_MAC(hdr.sender_mac), PRINT_IP(ip));\n\t\t\t}\n\t\t}\n\t}\n\n\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mask2bits",
          "args": [
            "mask"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "mask2bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "47-59",
          "snippet": "static inline uint8_t mask2bits(uint32_t mask) {\n\tuint32_t tmp = 0x80000000;\n\tint i;\n\tuint8_t rv = 0;\n\n\tfor (i = 0; i < 32; i++, tmp >>= 1) {\n\t\tif (tmp & mask)\n\t\t\trv++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline uint8_t mask2bits(uint32_t mask) {\n\tuint32_t tmp = 0x80000000;\n\tint i;\n\tuint8_t rv = 0;\n\n\tfor (i = 0; i < 32; i++, tmp >>= 1) {\n\t\tif (tmp & mask)\n\t\t\trv++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ifa->ifa_name",
            "\"lo\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\"",
            "ifa->ifa_name",
            "macstr",
            "ipstr",
            "maskstr",
            "status"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/main.c",
          "lines": "27-36",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/firejail/util.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_quiet = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"fnet.h\"\n\nint arg_quiet = 0;\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/firejail/util.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "macstr",
            "\"%02x:%02x:%02x:%02x:%02x:%02x\"",
            "PRINT_MAC(mac)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_MAC",
          "args": [
            "mac"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ifa->ifa_name",
            "\"lo\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_get_mac",
          "args": [
            "ifa->ifa_name",
            "mac"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "net_get_mac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "231-250",
          "snippet": "int net_get_mac(const char *ifname, unsigned char mac[6]) {\n\tcheck_if_name(ifname);\n\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tmemcpy(mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nint net_get_mac(const char *ifname, unsigned char mac[6]) {\n\tcheck_if_name(ifname);\n\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tmemcpy(mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "maskstr",
            "\"%d.%d.%d.%d\"",
            "PRINT_IP(mask)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "mask"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ipstr",
            "\"%d.%d.%d.%d\"",
            "PRINT_IP(ip)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "ip"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "si->sin_addr.s_addr"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "si->sin_addr.s_addr"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"getifaddrs\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&ifaddr"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_ifprint(int scan) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\tfmessage(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\"Interface\", \"MAC\", \"IP\", \"Mask\", \"Status\");\n\t// walk through the linked list\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\t// interface status\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t// ip address and mask\n\t\t\tchar ipstr[30];\n\t\t\tsprintf(ipstr, \"%d.%d.%d.%d\", PRINT_IP(ip));\n\t\t\tchar maskstr[30];\n\t\t\tsprintf(maskstr, \"%d.%d.%d.%d\", PRINT_IP(mask));\n\n\t\t\t// mac address\n\t\t\tunsigned char mac[6];\n\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\tchar macstr[30];\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\n\t\t\t\tmacstr[0] = '\\0';\n\t\t\telse\n\t\t\t\tsprintf(macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\", PRINT_MAC(mac));\n\n\t\t\t// print\n\t\t\tfmessage(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\t\tifa->ifa_name, macstr, ipstr, maskstr, status);\n\n\t\t\t// network scanning\n\t\t\tif (!scan)\t\t\t\t// scanning disabled\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\t// no loopbabck scanning\n\t\t\t\tcontinue;\n\t\t\tif (mask2bits(mask) < 16)\t\t// not scanning large networks\n\t\t\t\tcontinue;\n\t\t\tif (!ip)\t\t\t\t\t// if not configured\n\t\t\t\tcontinue;\n\t\t\t// only if the interface is up and running\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tarp_scan(ifa->ifa_name, ip, mask);\n\t\t}\n\t}\n\tfreeifaddrs(ifaddr);\n}"
  },
  {
    "function_name": "net_set_mtu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
    "lines": "147-164",
    "snippet": "void net_set_mtu(const char *ifname, int mtu) {\n\tcheck_if_name(ifname);\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_mtu = mtu;\n\tif (ioctl(s, SIOCSIFMTU, (caddr_t)&ifr) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fnet: cannot set mtu for interface %s\\n\", ifname);\n\t}\n\tclose(s);\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning fnet: cannot set mtu for interface %s\\n\"",
            "ifname"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "s",
            "SIOCSIFMTU",
            "(caddr_t)&ifr"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ - 1"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_if_name",
          "args": [
            "ifname"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "check_if_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "32-37",
          "snippet": "static void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nstatic void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_set_mtu(const char *ifname, int mtu) {\n\tcheck_if_name(ifname);\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_mtu = mtu;\n\tif (ioctl(s, SIOCSIFMTU, (caddr_t)&ifr) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fnet: cannot set mtu for interface %s\\n\", ifname);\n\t}\n\tclose(s);\n}"
  },
  {
    "function_name": "net_get_mtu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
    "lines": "127-145",
    "snippet": "int net_get_mtu(const char *ifname) {\n\tcheck_if_name(ifname);\n\tint mtu = 0;\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tif (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == 0)\n\t\tmtu = ifr.ifr_mtu;\n\tclose(s);\n\n\n\treturn mtu;\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "s",
            "SIOCGIFMTU",
            "(caddr_t)&ifr"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ - 1"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_if_name",
          "args": [
            "ifname"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "check_if_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "32-37",
          "snippet": "static void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nstatic void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nint net_get_mtu(const char *ifname) {\n\tcheck_if_name(ifname);\n\tint mtu = 0;\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tif (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == 0)\n\t\tmtu = ifr.ifr_mtu;\n\tclose(s);\n\n\n\treturn mtu;\n}"
  },
  {
    "function_name": "net_if_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
    "lines": "83-125",
    "snippet": "void net_if_up(const char *ifname) {\n\tcheck_if_name(ifname);\n\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCGIFFLAGS",
            "&ifr"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10000"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCGIFFLAGS",
            "&ifr"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFFLAGS",
            "&ifr"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCGIFFLAGS",
            "&ifr"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ - 1"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_if_name",
          "args": [
            "ifname"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "check_if_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "32-37",
          "snippet": "static void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nstatic void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_if_up(const char *ifname) {\n\tcheck_if_name(ifname);\n\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}"
  },
  {
    "function_name": "net_bridge_add_interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
    "lines": "40-79",
    "snippet": "void net_bridge_add_interface(const char *bridge, const char *dev) {\n\tcheck_if_name(bridge);\n\tcheck_if_name(dev);\n\n\t// somehow adding the interface to the bridge resets MTU on bridge device!!!\n\t// workaround: restore MTU on the bridge device\n\t// todo: put a real fix in\n\tint mtu1 = net_get_mtu(bridge);\n\n\tstruct ifreq ifr;\n\tint err;\n\tint ifindex = if_nametoindex(dev);\n\n\tif (ifindex <= 0)\n\t\terrExit(\"if_nametoindex\");\n\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ - 1);\n#ifdef SIOCBRADDIF\n\tifr.ifr_ifindex = ifindex;\n\terr = ioctl(sock, SIOCBRADDIF, &ifr);\n\tif (err < 0)\n#endif\n\t{\n\t\tunsigned long args[4] = { BRCTL_ADD_IF, ifindex, 0, 0 };\n\n\t\tifr.ifr_data = (char *) args;\n\t\terr = ioctl(sock, SIOCDEVPRIVATE, &ifr);\n\t}\n\t(void) err;\n\tclose(sock);\n\n\tint mtu2 = net_get_mtu(bridge);\n\tif (mtu1 != mtu2)\n\t\tnet_set_mtu(bridge, mtu1);\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_set_mtu",
          "args": [
            "bridge",
            "mtu1"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "net_set_mtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "147-164",
          "snippet": "void net_set_mtu(const char *ifname, int mtu) {\n\tcheck_if_name(ifname);\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_mtu = mtu;\n\tif (ioctl(s, SIOCSIFMTU, (caddr_t)&ifr) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fnet: cannot set mtu for interface %s\\n\", ifname);\n\t}\n\tclose(s);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_set_mtu(const char *ifname, int mtu) {\n\tcheck_if_name(ifname);\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_mtu = mtu;\n\tif (ioctl(s, SIOCSIFMTU, (caddr_t)&ifr) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fnet: cannot set mtu for interface %s\\n\", ifname);\n\t}\n\tclose(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_get_mtu",
          "args": [
            "bridge"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "net_get_mtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "127-145",
          "snippet": "int net_get_mtu(const char *ifname) {\n\tcheck_if_name(ifname);\n\tint mtu = 0;\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tif (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == 0)\n\t\tmtu = ifr.ifr_mtu;\n\tclose(s);\n\n\n\treturn mtu;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nint net_get_mtu(const char *ifname) {\n\tcheck_if_name(ifname);\n\tint mtu = 0;\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tif (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == 0)\n\t\tmtu = ifr.ifr_mtu;\n\tclose(s);\n\n\n\treturn mtu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCDEVPRIVATE",
            "&ifr"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCBRADDIF",
            "&ifr"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "bridge",
            "IFNAMSIZ - 1"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"if_nametoindex\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "dev"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_if_name",
          "args": [
            "dev"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "check_if_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "32-37",
          "snippet": "static void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nstatic void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_bridge_add_interface(const char *bridge, const char *dev) {\n\tcheck_if_name(bridge);\n\tcheck_if_name(dev);\n\n\t// somehow adding the interface to the bridge resets MTU on bridge device!!!\n\t// workaround: restore MTU on the bridge device\n\t// todo: put a real fix in\n\tint mtu1 = net_get_mtu(bridge);\n\n\tstruct ifreq ifr;\n\tint err;\n\tint ifindex = if_nametoindex(dev);\n\n\tif (ifindex <= 0)\n\t\terrExit(\"if_nametoindex\");\n\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ - 1);\n#ifdef SIOCBRADDIF\n\tifr.ifr_ifindex = ifindex;\n\terr = ioctl(sock, SIOCBRADDIF, &ifr);\n\tif (err < 0)\n#endif\n\t{\n\t\tunsigned long args[4] = { BRCTL_ADD_IF, ifindex, 0, 0 };\n\n\t\tifr.ifr_data = (char *) args;\n\t\terr = ioctl(sock, SIOCDEVPRIVATE, &ifr);\n\t}\n\t(void) err;\n\tclose(sock);\n\n\tint mtu2 = net_get_mtu(bridge);\n\tif (mtu1 != mtu2)\n\t\tnet_set_mtu(bridge, mtu1);\n}"
  },
  {
    "function_name": "check_if_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
    "lines": "32-37",
    "snippet": "static void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fnet: invalid network device name %s\\n\"",
            "ifname"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nstatic void check_if_name(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error fnet: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n}"
  }
]