[
  {
    "function_name": "fs_private_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "1543-1565",
    "snippet": "void fs_private_cache(void) {\n\tchar *cache;\n\tif (asprintf(&cache, \"%s/.cache\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// check if ~/.cache is a valid destination\n\tstruct stat s;\n\tif (lstat(cache, &s) == -1) {\n\t\tfwarning(\"cannot find %s, tmpfs not mounted\\n\", cache);\n\t\tfree(cache);\n\t\treturn;\n\t}\n\tif (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfwarning(\"%s is a symbolic link, tmpfs not mounted\\n\", cache);\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it\\n\", cache);\n\t\tfree(cache);\n\t\treturn;\n\t}\n\t// do the mount\n\tfs_tmpfs(cache, getuid()); // check ownership of ~/.cache\n\tfree(cache);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cache"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_tmpfs",
          "args": [
            "cache",
            "getuid()"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "fs_tmpfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "451-490",
          "snippet": "void fs_tmpfs(const char *dir, unsigned check_owner) {\n\tassert(dir);\n\t// get a file descriptor for dir, fails if there is any symlink\n\tint fd = safe_fd(dir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (check_owner && s.st_uid != getuid()) {\n\t\tfwarning(\"no tmpfs mounted on %s: not owned by the current user\\n\", dir);\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on %s\\n\", dir);\n\t// preserve ownership, mode\n\tchar *options;\n\tif (asprintf(&options, \"mode=%o,uid=%u,gid=%u\", s.st_mode & 07777, s.st_uid, s.st_gid) == -1)\n\t\terrExit(\"asprintf\");\n\t// preserve mount flags, but remove read-only flag\n\tstruct statvfs buf;\n\tif (fstatvfs(fd, &buf) == -1)\n\t\terrExit(\"fstatvfs\");\n\tunsigned long flags = buf.f_flag & ~(MS_RDONLY|MS_BIND);\n\t// mount via the symbolic link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"tmpfs\", proc, \"tmpfs\", flags|MS_NOSUID|MS_NODEV, options) < 0)\n\t\terrExit(\"mounting tmpfs\");\n\t// check the last mount operation\n\tMountData *mdata = get_last_mount();\n\tif (strcmp(mdata->fstype, \"tmpfs\") != 0 || strcmp(mdata->dir, dir) != 0)\n\t\terrLogExit(\"invalid tmpfs mount\");\n\tfs_logger2(\"tmpfs\", dir);\n\tfree(options);\n\tfree(proc);\n\tclose(fd);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_tmpfs(const char *dir, unsigned check_owner) {\n\tassert(dir);\n\t// get a file descriptor for dir, fails if there is any symlink\n\tint fd = safe_fd(dir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (check_owner && s.st_uid != getuid()) {\n\t\tfwarning(\"no tmpfs mounted on %s: not owned by the current user\\n\", dir);\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on %s\\n\", dir);\n\t// preserve ownership, mode\n\tchar *options;\n\tif (asprintf(&options, \"mode=%o,uid=%u,gid=%u\", s.st_mode & 07777, s.st_uid, s.st_gid) == -1)\n\t\terrExit(\"asprintf\");\n\t// preserve mount flags, but remove read-only flag\n\tstruct statvfs buf;\n\tif (fstatvfs(fd, &buf) == -1)\n\t\terrExit(\"fstatvfs\");\n\tunsigned long flags = buf.f_flag & ~(MS_RDONLY|MS_BIND);\n\t// mount via the symbolic link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"tmpfs\", proc, \"tmpfs\", flags|MS_NOSUID|MS_NODEV, options) < 0)\n\t\terrExit(\"mounting tmpfs\");\n\t// check the last mount operation\n\tMountData *mdata = get_last_mount();\n\tif (strcmp(mdata->fstype, \"tmpfs\") != 0 || strcmp(mdata->dir, dir) != 0)\n\t\terrLogExit(\"invalid tmpfs mount\");\n\tfs_logger2(\"tmpfs\", dir);\n\tfree(options);\n\tfree(proc);\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cache"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"%s is not a directory; cannot mount a tmpfs on top of it\\n\"",
            "cache"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "s.st_mode"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cache"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "cache",
            "&s"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cache",
            "\"%s/.cache\"",
            "cfg.homedir"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private_cache(void) {\n\tchar *cache;\n\tif (asprintf(&cache, \"%s/.cache\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// check if ~/.cache is a valid destination\n\tstruct stat s;\n\tif (lstat(cache, &s) == -1) {\n\t\tfwarning(\"cannot find %s, tmpfs not mounted\\n\", cache);\n\t\tfree(cache);\n\t\treturn;\n\t}\n\tif (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfwarning(\"%s is a symbolic link, tmpfs not mounted\\n\", cache);\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it\\n\", cache);\n\t\tfree(cache);\n\t\treturn;\n\t}\n\t// do the mount\n\tfs_tmpfs(cache, getuid()); // check ownership of ~/.cache\n\tfree(cache);\n}"
  },
  {
    "function_name": "fs_private_tmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "1501-1540",
    "snippet": "void fs_private_tmp(void) {\n\t// check XAUTHORITY file, KDE keeps it under /tmp\n\tchar *xauth = getenv(\"XAUTHORITY\");\n\tif (xauth) {\n\t\tchar *rp = realpath(xauth, NULL);\n\t\tif (rp && strncmp(rp, \"/tmp/\", 5) == 0) {\n\t\t\tchar *cmd;\n\t\t\tif (asprintf(&cmd, \"whitelist %s\", rp) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tprofile_add(cmd); // profile_add does not duplicate the string\n\t\t}\n\t\tif (rp)\n\t\t\tfree(rp);\n\t}\n\n\t// whitelist x11 directory\n\tprofile_add(\"whitelist /tmp/.X11-unix\");\n\n\t// whitelist any pulse* file in /tmp directory\n\t// some distros use PulseAudio sockets under /tmp instead of the socket in /urn/user\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tchar *cmd;\n\t\t\tif (asprintf(&cmd, \"whitelist /tmp/%s\", entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tprofile_add(cmd); // profile_add does not duplicate the string\n\t\t}\n\t}\n\tclosedir(dir);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);",
      "static void fs_rdwr_rec(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_add",
          "args": [
            "cmd"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "1364-1383",
          "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cmd",
            "\"whitelist /tmp/%s\"",
            "entry->d_name"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->d_name",
            "\"pulse-\"",
            "6"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/tmp\""
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "466-473",
          "snippet": "DIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_opendir_t orig_opendir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "firemon_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "90-121",
          "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios tlocal;",
            "static struct termios twait;",
            "static int terminal_set = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rp"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cmd",
            "\"whitelist %s\"",
            "rp"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "rp",
            "\"/tmp/\"",
            "5"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "xauth",
            "NULL"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_private_tmp(void) {\n\t// check XAUTHORITY file, KDE keeps it under /tmp\n\tchar *xauth = getenv(\"XAUTHORITY\");\n\tif (xauth) {\n\t\tchar *rp = realpath(xauth, NULL);\n\t\tif (rp && strncmp(rp, \"/tmp/\", 5) == 0) {\n\t\t\tchar *cmd;\n\t\t\tif (asprintf(&cmd, \"whitelist %s\", rp) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tprofile_add(cmd); // profile_add does not duplicate the string\n\t\t}\n\t\tif (rp)\n\t\t\tfree(rp);\n\t}\n\n\t// whitelist x11 directory\n\tprofile_add(\"whitelist /tmp/.X11-unix\");\n\n\t// whitelist any pulse* file in /tmp directory\n\t// some distros use PulseAudio sockets under /tmp instead of the socket in /urn/user\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tchar *cmd;\n\t\t\tif (asprintf(&cmd, \"whitelist /tmp/%s\", entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tprofile_add(cmd); // profile_add does not duplicate the string\n\t\t}\n\t}\n\tclosedir(dir);\n}"
  },
  {
    "function_name": "fs_chroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "1366-1497",
    "snippet": "void fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);",
      "static void fs_rdwr_rec(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_config",
          "args": [],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "disable_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "797-816",
          "snippet": "static void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restrict_users",
          "args": [],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "restrict_users",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
          "lines": "388-409",
          "snippet": "void restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_run();\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nvoid restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_run();\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_machineid",
          "args": [],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "fs_machineid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_etc.c",
          "lines": "28-75",
          "snippet": "void fs_machineid(void) {\n\tunion machineid_t {\n\t\tuint8_t u8[16];\n\t\tuint32_t u32[4];\n\t} mid;\n\n\t// if --machine-id flag is inactive, do nothing\n\tif (arg_machineid == 0)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Generating a new machine-id\\n\");\n\n\t// init random number generator\n\tsrand(time(NULL));\n\n\t// generate random id\n\tmid.u32[0] = rand();\n\tmid.u32[1] = rand();\n\tmid.u32[2] = rand();\n\tmid.u32[3] = rand();\n\n\t// UUID version 4 and DCE variant\n\tmid.u8[6] = (mid.u8[6] & 0x0F) | 0x40;\n\tmid.u8[8] = (mid.u8[8] & 0x3F) | 0x80;\n\n\t// write it in a file\n\tFILE *fp = fopen(RUN_MACHINEID, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%08x%08x%08x%08x\\n\", mid.u32[0], mid.u32[1], mid.u32[2], mid.u32[3]);\n\tfclose(fp);\n\tif (set_perms(RUN_MACHINEID, 0, 0, 0444))\n\t\terrExit(\"set_perms\");\n\n\n\tstruct stat s;\n\tif (stat(\"/etc/machine-id\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"installing a new /etc/machine-id\\n\");\n\n\t\tif (mount(RUN_MACHINEID, \"/etc/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n\tif (stat(\"/var/lib/dbus/machine-id\", &s) == 0) {\n\t\tif (mount(RUN_MACHINEID, \"/var/lib/dbus/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_machineid(void) {\n\tunion machineid_t {\n\t\tuint8_t u8[16];\n\t\tuint32_t u32[4];\n\t} mid;\n\n\t// if --machine-id flag is inactive, do nothing\n\tif (arg_machineid == 0)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Generating a new machine-id\\n\");\n\n\t// init random number generator\n\tsrand(time(NULL));\n\n\t// generate random id\n\tmid.u32[0] = rand();\n\tmid.u32[1] = rand();\n\tmid.u32[2] = rand();\n\tmid.u32[3] = rand();\n\n\t// UUID version 4 and DCE variant\n\tmid.u8[6] = (mid.u8[6] & 0x0F) | 0x40;\n\tmid.u8[8] = (mid.u8[8] & 0x3F) | 0x80;\n\n\t// write it in a file\n\tFILE *fp = fopen(RUN_MACHINEID, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%08x%08x%08x%08x\\n\", mid.u32[0], mid.u32[1], mid.u32[2], mid.u32[3]);\n\tfclose(fp);\n\tif (set_perms(RUN_MACHINEID, 0, 0, 0444))\n\t\terrExit(\"set_perms\");\n\n\n\tstruct stat s;\n\tif (stat(\"/etc/machine-id\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"installing a new /etc/machine-id\\n\");\n\n\t\tif (mount(RUN_MACHINEID, \"/etc/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n\tif (stat(\"/var/lib/dbus/machine-id\", &s) == 0) {\n\t\tif (mount(RUN_MACHINEID, \"/var/lib/dbus/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_utmp",
          "args": [],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_utmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "280-325",
          "snippet": "void fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfwarning(\"cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\n\t// save new utmp file\n\tint rv = fwrite(&u_boot, sizeof(u_boot), 1, fp);\n\t(void) rv;\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfwarning(\"cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\n\t// save new utmp file\n\tint rv = fwrite(&u_boot, sizeof(u_boot), 1, fp);\n\t(void) rv;\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_cache",
          "args": [],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "199-231",
          "snippet": "void fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/compress\", 0755, uid, gid);\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/uploads\", 0755, uid, gid);\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/compress\", 0755, uid, gid);\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/uploads\", 0755, uid, gid);\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lib",
          "args": [],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "149-197",
          "snippet": "void fs_var_lib(void) {\n\tstruct stat s;\n\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lib(void) {\n\tstruct stat s;\n\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_log",
          "args": [],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "106-147",
          "snippet": "void fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\n\t// note: /var/log is not created here, if it does not exist, this section fails.\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\n\t\tbuild_dirs();\n\t\trelease_all();\n\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfwarning(\"cannot hide /var/log directory\\n\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\n\t// note: /var/log is not created here, if it does not exist, this section fails.\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\n\t\tbuild_dirs();\n\t\trelease_all();\n\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfwarning(\"cannot hide /var/log directory\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_tmp",
          "args": [],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_tmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "263-278",
          "snippet": "void fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfwarning(\"/var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfwarning(\"/var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lock",
          "args": [],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "248-261",
          "snippet": "void fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tfwarning(\"/var/lock not mounted\\n\");\n\t\tdbg_test_dir(\"/var/lock\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tfwarning(\"/var/lock not mounted\\n\");\n\t\tdbg_test_dir(\"/var/lock\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "preproc_build_firejail_dir",
          "args": [],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "preproc_build_firejail_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/preproc.c",
          "lines": "29-75",
          "snippet": "void preproc_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_PROFILE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_PROFILE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_LIB_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_LIB_DIR, 0755);\n\t}\n\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\tcreate_empty_file_as_root(RUN_RO_FILE, S_IRUSR);\n\tcreate_empty_dir_as_root(RUN_RO_DIR, S_IRUSR);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid preproc_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_PROFILE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_PROFILE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_LIB_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_LIB_DIR, 0755);\n\t}\n\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\tcreate_empty_file_as_root(RUN_RO_FILE, S_IRUSR);\n\tcreate_empty_dir_as_root(RUN_RO_DIR, S_IRUSR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chroot\""
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "oroot"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "fs_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "1366-1497",
          "snippet": "void fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting rootdir oroot\""
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "rootdir",
            "oroot",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "oroot",
            "0755"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "382-389",
          "snippet": "int mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdir_t orig_mkdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Chrooting into %s\\n\"",
            "rootdir"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gcov_flush",
          "args": [],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"/etc/resolv.conf not initialized\\n\""
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_file",
          "args": [
            "\"/etc/resolv.conf\"",
            "fname",
            "0",
            "0",
            "0644"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_from_user_to_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "337-374",
          "snippet": "void copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\treturn;\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tint src = open(srcname, O_RDONLY);\n\t\tif (src < 0) {\n\t\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\t} else {\n\t\t\tif (copy_file_by_fd(src, dst)) {\n\t\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n\t\t\t}\n\t\t\tclose(src);\n\t\t}\n\t\tclose(dst);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tif (fchown(dst, uid, gid) == -1)\n\t\terrExit(\"fchown\");\n\tif (fchmod(dst, mode) == -1)\n\t\terrExit(\"fchmod\");\n\tclose(dst);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\treturn;\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tint src = open(srcname, O_RDONLY);\n\t\tif (src < 0) {\n\t\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\t} else {\n\t\t\tif (copy_file_by_fd(src, dst)) {\n\t\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n\t\t\t}\n\t\t\tclose(src);\n\t\t}\n\t\tclose(dst);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tif (fchown(dst, uid, gid) == -1)\n\t\terrExit(\"fchown\");\n\tif (fchmod(dst, mode) == -1)\n\t\terrExit(\"fchmod\");\n\tclose(dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "fname"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "359-366",
          "snippet": "int unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_unlink_t orig_unlink = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_unlink_t orig_unlink = NULL;\n\nint unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Updating /etc/resolv.conf in %s\\n\"",
            "fname"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/etc/resolv.conf\"",
            "rootdir"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rundir"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_MNT_DIR",
            "rundir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "rundir",
            "0",
            "0",
            "0755"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&rundir",
            "\"%s%s\"",
            "rootdir",
            "RUN_MNT_DIR"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rundir"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_FIREJAIL_LIB_DIR",
            "rundir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "rundir",
            "0",
            "0",
            "0755"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&rundir",
            "\"%s%s\"",
            "rootdir",
            "RUN_FIREJAIL_LIB_DIR"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rundir"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "rundir",
            "0",
            "0",
            "0755"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&rundir",
            "\"%s/run/firejail\"",
            "rootdir"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rundir"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "rundir",
            "0",
            "0",
            "0755"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only root user should be given write permission on chroot /run\\n\""
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: chroot /run should be a directory owned by root\\n\""
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: chroot /run is a symbolic link\\n\""
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "s.st_mode"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "rundir",
            "&s"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&rundir",
            "\"%s/run\"",
            "rootdir"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newx11"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /tmp/.X11-unix\""
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/tmp/.X11-unix\"",
            "newx11",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting /tmp/.X11-unix on %s\\n\"",
            "newx11"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&newx11",
            "\"%s/tmp/.X11-unix\"",
            "rootdir"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_X11\""
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newdev"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /dev\""
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/dev\"",
            "newdev",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting /dev on %s\\n\"",
            "newdev"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&newdev",
            "\"%s/dev\"",
            "rootdir"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "rootdir"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}"
  },
  {
    "function_name": "fs_check_chroot_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "1215-1363",
    "snippet": "void fs_check_chroot_dir(const char *rootdir) {\n\tEUID_ASSERT();\n\tassert(rootdir);\n\tchar *dir = EMPTY_STRING;\n\tstruct stat s;\n\n\tchar *overlay;\n\tif (asprintf(&overlay, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (strncmp(rootdir, overlay, strlen(overlay)) == 0) {\n\t\tfprintf(stderr, \"Error: invalid chroot directory: no directories in %s are allowed\\n\", overlay);\n\t\texit(1);\n\t}\n\tfree(overlay);\n\n\t// fails if there is any symlink or if rootdir is not a directory\n\tint parentfd = safe_fd(rootdir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (parentfd == -1) {\n\t\tfprintf(stderr, \"Error: invalid chroot directory %s\\n\", rootdir);\n\t\texit(1);\n\t}\n\t// rootdir has to be owned by root and is not allowed to be generally writable,\n\t// this also excludes /tmp, /var/tmp and such\n\tif (fstat(parentfd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: chroot directory should be owned by root\\n\");\n\t\texit(1);\n\t}\n\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot directory\\n\");\n\t\texit(1);\n\t}\n\n\t// check /dev\n\tdir = \"dev\";\n\tint fd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\tgoto error1;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\tgoto error2;\n\tclose(fd);\n\n\t// check /var/tmp\n\tdir = \"var/tmp\";\n\tfd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\tgoto error1;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\tgoto error2;\n\tclose(fd);\n\n\t// check /proc\n\tdir = \"proc\";\n\tfd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\tgoto error1;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\tgoto error2;\n\tclose(fd);\n\n\t// check /tmp\n\tdir = \"tmp\";\n\tfd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\tgoto error1;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\tgoto error2;\n\tclose(fd);\n\n\t// check /etc\n\tdir = \"etc\";\n\tfd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\tgoto error1;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\tgoto error2;\n\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /etc\\n\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\t// there should be no checking on <chrootdir>/etc/resolv.conf\n\t// the file is replaced with the real /etc/resolv.conf anyway\n#if 0\n\tif (asprintf(&name, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == 0) {\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /etc/resolv.conf should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: chroot /etc/resolv.conf not found\\n\");\n\t\texit(1);\n\t}\n\t// on Arch /etc/resolv.conf could be a symlink to /run/systemd/resolve/resolv.conf\n\t// on Ubuntu 17.04 /etc/resolv.conf could be a symlink to /run/resolveconf/resolv.conf\n\tif (is_link(name)) {\n\t\t// check the link points in chroot\n\t\tchar *rname = realpath(name, NULL);\n\t\tif (!rname || strncmp(rname, rootdir, strlen(rootdir)) != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /etc/resolv.conf is pointing outside chroot\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(name);\n#endif\n\n\t// check x11 socket directory\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tdir = \"tmp/.X11-unix\";\n\t\tfd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\tgoto error1;\n\t\tif (fstat(fd, &s) == -1)\n\t\t\terrExit(\"fstat\");\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\t\tgoto error2;\n\t\tclose(fd);\n\t}\n\n\tclose(parentfd);\n\treturn;\n\nerror1:\n\tif (errno == ENOENT)\n\t\tfprintf(stderr, \"Error: cannot find /%s in chroot directory\\n\", dir);\n\telse {\n\t\tperror(\"open\");\n\t\tfprintf(stderr, \"Error: cannot open /%s in chroot directory\\n\", dir);\n\t}\n\texit(1);\nerror2:\n\tfprintf(stderr, \"Error: chroot /%s should be a directory owned by root\\n\", dir);\n\texit(1);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define EMPTY_STRING (\"\")"
    ],
    "globals_used": [
      "static void fs_rdwr(const char *dir);",
      "static void fs_rdwr_rec(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: chroot /%s should be a directory owned by root\\n\"",
            "dir"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open /%s in chroot directory\\n\"",
            "dir"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"open\""
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find /%s in chroot directory\\n\"",
            "dir"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "parentfd"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&s"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "parentfd",
            "dir",
            "O_PATH|O_CLOEXEC"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_X11\""
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: chroot /etc/resolv.conf is pointing outside chroot\\n\""
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "rname",
            "rootdir",
            "strlen(rootdir)"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rootdir"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "name",
            "NULL"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "name"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "432-459",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: chroot /etc/resolv.conf not found\\n\""
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: chroot /etc/resolv.conf should be owned by root\\n\""
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "name",
            "&s"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&name",
            "\"%s/etc/resolv.conf\"",
            "rootdir"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only root user should be given write permission on chroot /etc\\n\""
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&s"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "parentfd",
            "dir",
            "O_PATH|O_CLOEXEC"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&s"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "parentfd",
            "dir",
            "O_PATH|O_CLOEXEC"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&s"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "parentfd",
            "dir",
            "O_PATH|O_CLOEXEC"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&s"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "parentfd",
            "dir",
            "O_PATH|O_CLOEXEC"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&s"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "parentfd",
            "dir",
            "O_PATH|O_CLOEXEC"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only root user should be given write permission on chroot directory\\n\""
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: chroot directory should be owned by root\\n\""
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "parentfd",
            "&s"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid chroot directory %s\\n\"",
            "rootdir"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_fd",
          "args": [
            "rootdir",
            "O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "safe_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1143-1209",
          "snippet": "int safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define EMPTY_STRING (\"\")"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nint safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "overlay"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid chroot directory: no directories in %s are allowed\\n\"",
            "overlay"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "rootdir",
            "overlay",
            "strlen(overlay)"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&overlay",
            "\"%s/.firejail\"",
            "cfg.homedir"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "rootdir"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_check_chroot_dir(const char *rootdir) {\n\tEUID_ASSERT();\n\tassert(rootdir);\n\tchar *dir = EMPTY_STRING;\n\tstruct stat s;\n\n\tchar *overlay;\n\tif (asprintf(&overlay, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (strncmp(rootdir, overlay, strlen(overlay)) == 0) {\n\t\tfprintf(stderr, \"Error: invalid chroot directory: no directories in %s are allowed\\n\", overlay);\n\t\texit(1);\n\t}\n\tfree(overlay);\n\n\t// fails if there is any symlink or if rootdir is not a directory\n\tint parentfd = safe_fd(rootdir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (parentfd == -1) {\n\t\tfprintf(stderr, \"Error: invalid chroot directory %s\\n\", rootdir);\n\t\texit(1);\n\t}\n\t// rootdir has to be owned by root and is not allowed to be generally writable,\n\t// this also excludes /tmp, /var/tmp and such\n\tif (fstat(parentfd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: chroot directory should be owned by root\\n\");\n\t\texit(1);\n\t}\n\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot directory\\n\");\n\t\texit(1);\n\t}\n\n\t// check /dev\n\tdir = \"dev\";\n\tint fd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\tgoto error1;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\tgoto error2;\n\tclose(fd);\n\n\t// check /var/tmp\n\tdir = \"var/tmp\";\n\tfd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\tgoto error1;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\tgoto error2;\n\tclose(fd);\n\n\t// check /proc\n\tdir = \"proc\";\n\tfd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\tgoto error1;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\tgoto error2;\n\tclose(fd);\n\n\t// check /tmp\n\tdir = \"tmp\";\n\tfd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\tgoto error1;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\tgoto error2;\n\tclose(fd);\n\n\t// check /etc\n\tdir = \"etc\";\n\tfd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\tgoto error1;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\tgoto error2;\n\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /etc\\n\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\t// there should be no checking on <chrootdir>/etc/resolv.conf\n\t// the file is replaced with the real /etc/resolv.conf anyway\n#if 0\n\tif (asprintf(&name, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == 0) {\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /etc/resolv.conf should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: chroot /etc/resolv.conf not found\\n\");\n\t\texit(1);\n\t}\n\t// on Arch /etc/resolv.conf could be a symlink to /run/systemd/resolve/resolv.conf\n\t// on Ubuntu 17.04 /etc/resolv.conf could be a symlink to /run/resolveconf/resolv.conf\n\tif (is_link(name)) {\n\t\t// check the link points in chroot\n\t\tchar *rname = realpath(name, NULL);\n\t\tif (!rname || strncmp(rname, rootdir, strlen(rootdir)) != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /etc/resolv.conf is pointing outside chroot\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(name);\n#endif\n\n\t// check x11 socket directory\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tdir = \"tmp/.X11-unix\";\n\t\tfd = openat(parentfd, dir, O_PATH|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\tgoto error1;\n\t\tif (fstat(fd, &s) == -1)\n\t\t\terrExit(\"fstat\");\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0)\n\t\t\tgoto error2;\n\t\tclose(fd);\n\t}\n\n\tclose(parentfd);\n\treturn;\n\nerror1:\n\tif (errno == ENOENT)\n\t\tfprintf(stderr, \"Error: cannot find /%s in chroot directory\\n\", dir);\n\telse {\n\t\tperror(\"open\");\n\t\tfprintf(stderr, \"Error: cannot open /%s in chroot directory\\n\", dir);\n\t}\n\texit(1);\nerror2:\n\tfprintf(stderr, \"Error: chroot /%s should be a directory owned by root\\n\", dir);\n\texit(1);\n}"
  },
  {
    "function_name": "fs_overlayfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "954-1209",
    "snippet": "void fs_overlayfs(void) {\n\tstruct stat s;\n\n\t// check kernel version\n\tstruct utsname u;\n\tint rv = uname(&u);\n\tif (rv != 0)\n\t\terrExit(\"uname\");\n\tint major;\n\tint minor;\n\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Linux kernel version %d.%d\\n\", major, minor);\n\tint oldkernel = 0;\n\tif (major < 3) {\n\t\tfprintf(stderr, \"Error: minimum kernel version required 3.x\\n\");\n\t\texit(1);\n\t}\n\tif (major == 3 && minor < 18)\n\t\toldkernel = 1;\n\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tmkdir_attr(oroot, 0755, 0, 0);\n\n\t// set base for working and diff directories\n\tchar *basedir = RUN_MNT_DIR;\n\tint basefd = -1;\n\n\tif (arg_overlay_keep) {\n\t\tbasedir = cfg.overlay_dir;\n\t\tassert(basedir);\n\t\t// get a file descriptor for ~/.firejail, fails if there is any symlink\n\t\tchar *firejail;\n\t\tif (asprintf(&firejail, \"%s/.firejail\", cfg.homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tint fd = safe_fd(firejail, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\terrExit(\"safe_fd\");\n\t\tfree(firejail);\n\t\t// create basedir if it doesn't exist\n\t\t// the new directory will be owned by root\n\t\tconst char *dirname = gnu_basename(basedir);\n\t\tif (mkdirat(fd, dirname, 0755) == -1 && errno != EEXIST) {\n\t\t\tperror(\"mkdir\");\n\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", basedir);\n\t\t\texit(1);\n\t\t}\n\t\t// open basedir\n\t\tbasefd = openat(fd, dirname, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tclose(fd);\n\t}\n\telse {\n\t\tbasefd = open(basedir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t}\n\tif (basefd == -1) {\n\t\tperror(\"open\");\n\t\tfprintf(stderr, \"Error: cannot open overlay directory %s\\n\", basedir);\n\t\texit(1);\n\t}\n\n\t// confirm once more base is owned by root\n\tif (fstat(basefd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: overlay directory %s is not owned by the root user\\n\", basedir);\n\t\texit(1);\n\t}\n\t// confirm permissions of base are 0755\n\tif (((S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) & s.st_mode) != (S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)) {\n\t\tfprintf(stderr, \"Error: invalid permissions on overlay directory %s\\n\", basedir);\n\t\texit(1);\n\t}\n\n\t// create diff and work directories inside base\n\t// no need to check arg_overlay_reuse\n\tchar *odiff;\n\tif (asprintf(&odiff, \"%s/odiff\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// the new directory will be owned by root\n\tif (mkdirat(basefd, \"odiff\", 0755) == -1 && errno != EEXIST) {\n\t\tperror(\"mkdir\");\n\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", odiff);\n\t\texit(1);\n\t}\n\tASSERT_PERMS(odiff, 0, 0, 0755);\n\n\tchar *owork;\n\tif (asprintf(&owork, \"%s/owork\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// the new directory will be owned by root\n\tif (mkdirat(basefd, \"owork\", 0755) == -1 && errno != EEXIST) {\n\t\tperror(\"mkdir\");\n\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", owork);\n\t\texit(1);\n\t}\n\tASSERT_PERMS(owork, 0, 0, 0755);\n\n\t// mount overlayfs\n\tif (arg_debug)\n\t\tprintf(\"Mounting OverlayFS\\n\");\n\tchar *option;\n\tif (oldkernel) { // old Ubuntu/OpenSUSE kernels\n\t\tif (arg_overlay_keep) {\n\t\t\tfprintf(stderr, \"Error: option --overlay= not available for kernels older than 3.18\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s\", odiff) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlayfs\", oroot, \"overlayfs\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t}\n\telse { // kernel 3.18 or newer\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s,workdir=%s\", odiff, owork) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlay\", oroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\n\t\t//***************************\n\t\t// issue #263 start code\n\t\t// My setup has a separate mount point for /home. When the overlay is mounted,\n\t\t// the overlay does not contain the original /home contents.\n\t\t// I added code to create a second overlay for /home if the overlay home dir is empty and this seems to work\n\t\t// @dshmgh, Jan 2016\n\t\t{\n\t\t\tchar *overlayhome;\n\t\t\tstruct stat s;\n\t\t\tchar *hroot;\n\t\t\tchar *hdiff;\n\t\t\tchar *hwork;\n\n\t\t\t// dons add debug\n\t\t\tif (arg_debug) printf (\"DEBUG: chroot dirs are oroot %s  odiff %s  owork %s\\n\",oroot,odiff,owork);\n\n\t\t\t// BEFORE NEXT, WE NEED TO TEST IF /home has any contents or do we need to mount it?\n\t\t\t// must create var for oroot/cfg.homedir\n\t\t\tif (asprintf(&overlayhome, \"%s%s\", oroot, cfg.homedir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug) printf (\"DEBUG: overlayhome var holds ##%s##\\n\", overlayhome);\n\n\t\t\t// if no homedir in overlay -- create another overlay for /home\n\t\t\tif (stat(cfg.homedir, &s) == 0 && stat(overlayhome, &s) == -1) {\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (asprintf(&hdiff, \"%s/hdiff\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t// the new directory will be owned by root\n\t\t\t\tif (mkdirat(basefd, \"hdiff\", 0755) == -1 && errno != EEXIST) {\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", hdiff);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tASSERT_PERMS(hdiff, 0, 0, 0755);\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (asprintf(&hwork, \"%s/hwork\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t// the new directory will be owned by root\n\t\t\t\tif (mkdirat(basefd, \"hwork\", 0755) == -1 && errno != EEXIST) {\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", hwork);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tASSERT_PERMS(hwork, 0, 0, 0755);\n\n\t\t\t\t// no homedir in overlay so now mount another overlay for /home\n\t\t\t\tif (asprintf(&hroot, \"%s/home\", oroot) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (asprintf(&option, \"lowerdir=/home,upperdir=%s,workdir=%s\", hdiff, hwork) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (mount(\"overlay\", hroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\t\t\terrExit(\"mounting overlayfs for mounted home directory\");\n\n\t\t\t\tprintf(\"OverlayFS for /home configured in %s directory\\n\", basedir);\n\t\t\t\tfree(hroot);\n\t\t\t\tfree(hdiff);\n\t\t\t\tfree(hwork);\n\n\t\t\t} // stat(overlayhome)\n\t\t\tfree(overlayhome);\n\t\t}\n\t\t// issue #263 end code\n\t\t//***************************\n\t}\n\tfmessage(\"OverlayFS configured in %s directory\\n\", basedir);\n\tclose(basefd);\n\n\t// /dev, /run and /tmp are not covered by the overlay\n\t// mount-bind dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev\\n\");\n\tchar *dev;\n\tif (asprintf(&dev, \"%s/dev\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/dev\", dev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"whitelist /dev\");\n\n\t// mount-bind run directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /run\\n\");\n\tchar *run;\n\tif (asprintf(&run, \"%s/run\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/run\", run, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /run\");\n\tfs_logger(\"whitelist /run\");\n\n\t// mount-bind tmp directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /tmp\\n\");\n\tchar *tmp;\n\tif (asprintf(&tmp, \"%s/tmp\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/tmp\", tmp, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /tmp\");\n\tfs_logger(\"whitelist /tmp\");\n\n\t// chroot in the new filesystem\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\tif (chroot(oroot) == -1)\n\t\terrExit(\"chroot\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\tif (!arg_private_dev)\n//\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t\tfs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n\n\t// cleanup and exit\n\tfree(option);\n\tfree(odiff);\n\tfree(owork);\n\tfree(dev);\n\tfree(run);\n\tfree(tmp);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);",
      "static void fs_rdwr_rec(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "run"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dev"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "owork"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "odiff"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "option"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_config",
          "args": [],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "disable_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "797-816",
          "snippet": "static void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restrict_users",
          "args": [],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "restrict_users",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
          "lines": "388-409",
          "snippet": "void restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_run();\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nvoid restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_run();\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_machineid",
          "args": [],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "fs_machineid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_etc.c",
          "lines": "28-75",
          "snippet": "void fs_machineid(void) {\n\tunion machineid_t {\n\t\tuint8_t u8[16];\n\t\tuint32_t u32[4];\n\t} mid;\n\n\t// if --machine-id flag is inactive, do nothing\n\tif (arg_machineid == 0)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Generating a new machine-id\\n\");\n\n\t// init random number generator\n\tsrand(time(NULL));\n\n\t// generate random id\n\tmid.u32[0] = rand();\n\tmid.u32[1] = rand();\n\tmid.u32[2] = rand();\n\tmid.u32[3] = rand();\n\n\t// UUID version 4 and DCE variant\n\tmid.u8[6] = (mid.u8[6] & 0x0F) | 0x40;\n\tmid.u8[8] = (mid.u8[8] & 0x3F) | 0x80;\n\n\t// write it in a file\n\tFILE *fp = fopen(RUN_MACHINEID, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%08x%08x%08x%08x\\n\", mid.u32[0], mid.u32[1], mid.u32[2], mid.u32[3]);\n\tfclose(fp);\n\tif (set_perms(RUN_MACHINEID, 0, 0, 0444))\n\t\terrExit(\"set_perms\");\n\n\n\tstruct stat s;\n\tif (stat(\"/etc/machine-id\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"installing a new /etc/machine-id\\n\");\n\n\t\tif (mount(RUN_MACHINEID, \"/etc/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n\tif (stat(\"/var/lib/dbus/machine-id\", &s) == 0) {\n\t\tif (mount(RUN_MACHINEID, \"/var/lib/dbus/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_machineid(void) {\n\tunion machineid_t {\n\t\tuint8_t u8[16];\n\t\tuint32_t u32[4];\n\t} mid;\n\n\t// if --machine-id flag is inactive, do nothing\n\tif (arg_machineid == 0)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Generating a new machine-id\\n\");\n\n\t// init random number generator\n\tsrand(time(NULL));\n\n\t// generate random id\n\tmid.u32[0] = rand();\n\tmid.u32[1] = rand();\n\tmid.u32[2] = rand();\n\tmid.u32[3] = rand();\n\n\t// UUID version 4 and DCE variant\n\tmid.u8[6] = (mid.u8[6] & 0x0F) | 0x40;\n\tmid.u8[8] = (mid.u8[8] & 0x3F) | 0x80;\n\n\t// write it in a file\n\tFILE *fp = fopen(RUN_MACHINEID, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%08x%08x%08x%08x\\n\", mid.u32[0], mid.u32[1], mid.u32[2], mid.u32[3]);\n\tfclose(fp);\n\tif (set_perms(RUN_MACHINEID, 0, 0, 0444))\n\t\terrExit(\"set_perms\");\n\n\n\tstruct stat s;\n\tif (stat(\"/etc/machine-id\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"installing a new /etc/machine-id\\n\");\n\n\t\tif (mount(RUN_MACHINEID, \"/etc/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n\tif (stat(\"/var/lib/dbus/machine-id\", &s) == 0) {\n\t\tif (mount(RUN_MACHINEID, \"/var/lib/dbus/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_utmp",
          "args": [],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_utmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "280-325",
          "snippet": "void fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfwarning(\"cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\n\t// save new utmp file\n\tint rv = fwrite(&u_boot, sizeof(u_boot), 1, fp);\n\t(void) rv;\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfwarning(\"cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\n\t// save new utmp file\n\tint rv = fwrite(&u_boot, sizeof(u_boot), 1, fp);\n\t(void) rv;\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_cache",
          "args": [],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "199-231",
          "snippet": "void fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/compress\", 0755, uid, gid);\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/uploads\", 0755, uid, gid);\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/compress\", 0755, uid, gid);\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/uploads\", 0755, uid, gid);\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lib",
          "args": [],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "149-197",
          "snippet": "void fs_var_lib(void) {\n\tstruct stat s;\n\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lib(void) {\n\tstruct stat s;\n\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_log",
          "args": [],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "106-147",
          "snippet": "void fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\n\t// note: /var/log is not created here, if it does not exist, this section fails.\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\n\t\tbuild_dirs();\n\t\trelease_all();\n\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfwarning(\"cannot hide /var/log directory\\n\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\n\t// note: /var/log is not created here, if it does not exist, this section fails.\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\n\t\tbuild_dirs();\n\t\trelease_all();\n\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfwarning(\"cannot hide /var/log directory\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_tmp",
          "args": [],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_tmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "263-278",
          "snippet": "void fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfwarning(\"/var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfwarning(\"/var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lock",
          "args": [],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "248-261",
          "snippet": "void fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tfwarning(\"/var/lock not mounted\\n\");\n\t\tdbg_test_dir(\"/var/lock\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tfwarning(\"/var/lock not mounted\\n\");\n\t\tdbg_test_dir(\"/var/lock\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chroot\""
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "oroot"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "fs_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "1366-1497",
          "snippet": "void fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gcov_flush",
          "args": [],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"whitelist /tmp\""
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /tmp\""
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/tmp\"",
            "tmp",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&tmp",
            "\"%s/tmp\"",
            "oroot"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting /tmp\\n\""
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /run\""
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/run\"",
            "run",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&run",
            "\"%s/run\"",
            "oroot"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting /run\\n\""
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /dev\""
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/dev\"",
            "dev",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dev",
            "\"%s/dev\"",
            "oroot"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting /dev\\n\""
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "basefd"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"OverlayFS configured in %s directory\\n\"",
            "basedir"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "189-198",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "overlayhome"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "hwork"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "hdiff"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "hroot"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"OverlayFS for /home configured in %s directory\\n\"",
            "basedir"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting overlayfs for mounted home directory\""
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"overlay\"",
            "hroot",
            "\"overlay\"",
            "MS_MGC_VAL",
            "option"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&option",
            "\"lowerdir=/home,upperdir=%s,workdir=%s\"",
            "hdiff",
            "hwork"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&hroot",
            "\"%s/home\"",
            "oroot"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "hwork",
            "0",
            "0",
            "0755"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create overlay directory %s\\n\"",
            "hwork"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"mkdir\""
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdirat",
          "args": [
            "basefd",
            "\"hwork\"",
            "0755"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "mkdirat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "393-400",
          "snippet": "int mkdirat(int dirfd, const char *pathname, mode_t mode) {\n\tif (!orig_mkdirat)\n\t\torig_mkdirat = (orig_mkdirat_t)dlsym(RTLD_NEXT, \"mkdirat\");\n\n\tint rv = orig_mkdirat(dirfd, pathname, mode);\n\tprintf(\"%u:%s:mkdirat %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdirat_t orig_mkdirat = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdirat_t orig_mkdirat = NULL;\n\nint mkdirat(int dirfd, const char *pathname, mode_t mode) {\n\tif (!orig_mkdirat)\n\t\torig_mkdirat = (orig_mkdirat_t)dlsym(RTLD_NEXT, \"mkdirat\");\n\n\tint rv = orig_mkdirat(dirfd, pathname, mode);\n\tprintf(\"%u:%s:mkdirat %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&hwork",
            "\"%s/hwork\"",
            "basedir"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "hdiff",
            "0",
            "0",
            "0755"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create overlay directory %s\\n\"",
            "hdiff"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"mkdir\""
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&hdiff",
            "\"%s/hdiff\"",
            "basedir"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "overlayhome",
            "&s"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DEBUG: overlayhome var holds ##%s##\\n\"",
            "overlayhome"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&overlayhome",
            "\"%s%s\"",
            "oroot",
            "cfg.homedir"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DEBUG: chroot dirs are oroot %s  odiff %s  owork %s\\n\"",
            "oroot",
            "odiff",
            "owork"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting overlayfs\""
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"overlay\"",
            "oroot",
            "\"overlay\"",
            "MS_MGC_VAL",
            "option"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&option",
            "\"lowerdir=/,upperdir=%s,workdir=%s\"",
            "odiff",
            "owork"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting overlayfs\""
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"overlayfs\"",
            "oroot",
            "\"overlayfs\"",
            "MS_MGC_VAL",
            "option"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&option",
            "\"lowerdir=/,upperdir=%s\"",
            "odiff"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: option --overlay= not available for kernels older than 3.18\\n\""
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting OverlayFS\\n\""
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "owork",
            "0",
            "0",
            "0755"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create overlay directory %s\\n\"",
            "owork"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"mkdir\""
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&owork",
            "\"%s/owork\"",
            "basedir"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "odiff",
            "0",
            "0",
            "0755"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create overlay directory %s\\n\"",
            "odiff"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"mkdir\""
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&odiff",
            "\"%s/odiff\"",
            "basedir"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid permissions on overlay directory %s\\n\"",
            "basedir"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: overlay directory %s is not owned by the root user\\n\"",
            "basedir"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "basefd",
            "&s"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open overlay directory %s\\n\"",
            "basedir"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"open\""
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "basedir",
            "O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "fd",
            "dirname",
            "O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create overlay directory %s\\n\"",
            "basedir"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"mkdir\""
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnu_basename",
          "args": [
            "basedir"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "gnu_basename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "815-820",
          "snippet": "const char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nconst char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "firejail"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"safe_fd\""
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_fd",
          "args": [
            "firejail",
            "O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "safe_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1143-1209",
          "snippet": "int safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define EMPTY_STRING (\"\")"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nint safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&firejail",
            "\"%s/.firejail\"",
            "cfg.homedir"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "basedir"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_attr",
          "args": [
            "oroot",
            "0755",
            "0",
            "0"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1056-1092",
          "snippet": "void mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid) {\n\tassert(fname);\n\tmode &= 07777;\n#if 0\n\tprintf(\"fname %s, uid %d, gid %d, mode %x - \", fname, uid, gid, (unsigned) mode);\n\tif (S_ISLNK(mode))\n\t\tprintf(\"l\");\n\telse if (S_ISDIR(mode))\n\t\tprintf(\"d\");\n\telse if (S_ISCHR(mode))\n\t\tprintf(\"c\");\n\telse if (S_ISBLK(mode))\n\t\tprintf(\"b\");\n\telse if (S_ISSOCK(mode))\n\t\tprintf(\"s\");\n\telse\n\t\tprintf(\"-\");\n\tprintf( (mode & S_IRUSR) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWUSR) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXUSR) ? \"x\" : \"-\");\n\tprintf( (mode & S_IRGRP) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWGRP) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXGRP) ? \"x\" : \"-\");\n\tprintf( (mode & S_IROTH) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWOTH) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXOTH) ? \"x\" : \"-\");\n\tprintf(\"\\n\");\n#endif\n\tif (mkdir(fname, mode) == -1 ||\n\t    chmod(fname, mode) == -1 ||\n\t    chown(fname, uid, gid)) {\n\t    \tfprintf(stderr, \"Error: failed to create %s directory\\n\", fname);\n\t\terrExit(\"mkdir/chmod\");\n\t}\n\n\tASSERT_PERMS(fname, uid, gid, mode);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid) {\n\tassert(fname);\n\tmode &= 07777;\n#if 0\n\tprintf(\"fname %s, uid %d, gid %d, mode %x - \", fname, uid, gid, (unsigned) mode);\n\tif (S_ISLNK(mode))\n\t\tprintf(\"l\");\n\telse if (S_ISDIR(mode))\n\t\tprintf(\"d\");\n\telse if (S_ISCHR(mode))\n\t\tprintf(\"c\");\n\telse if (S_ISBLK(mode))\n\t\tprintf(\"b\");\n\telse if (S_ISSOCK(mode))\n\t\tprintf(\"s\");\n\telse\n\t\tprintf(\"-\");\n\tprintf( (mode & S_IRUSR) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWUSR) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXUSR) ? \"x\" : \"-\");\n\tprintf( (mode & S_IRGRP) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWGRP) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXGRP) ? \"x\" : \"-\");\n\tprintf( (mode & S_IROTH) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWOTH) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXOTH) ? \"x\" : \"-\");\n\tprintf(\"\\n\");\n#endif\n\tif (mkdir(fname, mode) == -1 ||\n\t    chmod(fname, mode) == -1 ||\n\t    chown(fname, uid, gid)) {\n\t    \tfprintf(stderr, \"Error: failed to create %s directory\\n\", fname);\n\t\terrExit(\"mkdir/chmod\");\n\t}\n\n\tASSERT_PERMS(fname, uid, gid, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: minimum kernel version required 3.x\\n\""
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Linux kernel version %d.%d\\n\"",
            "major",
            "minor"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot extract Linux kernel version: %s\\n\"",
            "u.version"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "u.release",
            "\"%d.%d\"",
            "&major",
            "&minor"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"uname\""
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uname",
          "args": [
            "&u"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_overlayfs(void) {\n\tstruct stat s;\n\n\t// check kernel version\n\tstruct utsname u;\n\tint rv = uname(&u);\n\tif (rv != 0)\n\t\terrExit(\"uname\");\n\tint major;\n\tint minor;\n\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Linux kernel version %d.%d\\n\", major, minor);\n\tint oldkernel = 0;\n\tif (major < 3) {\n\t\tfprintf(stderr, \"Error: minimum kernel version required 3.x\\n\");\n\t\texit(1);\n\t}\n\tif (major == 3 && minor < 18)\n\t\toldkernel = 1;\n\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tmkdir_attr(oroot, 0755, 0, 0);\n\n\t// set base for working and diff directories\n\tchar *basedir = RUN_MNT_DIR;\n\tint basefd = -1;\n\n\tif (arg_overlay_keep) {\n\t\tbasedir = cfg.overlay_dir;\n\t\tassert(basedir);\n\t\t// get a file descriptor for ~/.firejail, fails if there is any symlink\n\t\tchar *firejail;\n\t\tif (asprintf(&firejail, \"%s/.firejail\", cfg.homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tint fd = safe_fd(firejail, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\terrExit(\"safe_fd\");\n\t\tfree(firejail);\n\t\t// create basedir if it doesn't exist\n\t\t// the new directory will be owned by root\n\t\tconst char *dirname = gnu_basename(basedir);\n\t\tif (mkdirat(fd, dirname, 0755) == -1 && errno != EEXIST) {\n\t\t\tperror(\"mkdir\");\n\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", basedir);\n\t\t\texit(1);\n\t\t}\n\t\t// open basedir\n\t\tbasefd = openat(fd, dirname, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tclose(fd);\n\t}\n\telse {\n\t\tbasefd = open(basedir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t}\n\tif (basefd == -1) {\n\t\tperror(\"open\");\n\t\tfprintf(stderr, \"Error: cannot open overlay directory %s\\n\", basedir);\n\t\texit(1);\n\t}\n\n\t// confirm once more base is owned by root\n\tif (fstat(basefd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: overlay directory %s is not owned by the root user\\n\", basedir);\n\t\texit(1);\n\t}\n\t// confirm permissions of base are 0755\n\tif (((S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) & s.st_mode) != (S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)) {\n\t\tfprintf(stderr, \"Error: invalid permissions on overlay directory %s\\n\", basedir);\n\t\texit(1);\n\t}\n\n\t// create diff and work directories inside base\n\t// no need to check arg_overlay_reuse\n\tchar *odiff;\n\tif (asprintf(&odiff, \"%s/odiff\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// the new directory will be owned by root\n\tif (mkdirat(basefd, \"odiff\", 0755) == -1 && errno != EEXIST) {\n\t\tperror(\"mkdir\");\n\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", odiff);\n\t\texit(1);\n\t}\n\tASSERT_PERMS(odiff, 0, 0, 0755);\n\n\tchar *owork;\n\tif (asprintf(&owork, \"%s/owork\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// the new directory will be owned by root\n\tif (mkdirat(basefd, \"owork\", 0755) == -1 && errno != EEXIST) {\n\t\tperror(\"mkdir\");\n\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", owork);\n\t\texit(1);\n\t}\n\tASSERT_PERMS(owork, 0, 0, 0755);\n\n\t// mount overlayfs\n\tif (arg_debug)\n\t\tprintf(\"Mounting OverlayFS\\n\");\n\tchar *option;\n\tif (oldkernel) { // old Ubuntu/OpenSUSE kernels\n\t\tif (arg_overlay_keep) {\n\t\t\tfprintf(stderr, \"Error: option --overlay= not available for kernels older than 3.18\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s\", odiff) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlayfs\", oroot, \"overlayfs\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t}\n\telse { // kernel 3.18 or newer\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s,workdir=%s\", odiff, owork) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlay\", oroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\n\t\t//***************************\n\t\t// issue #263 start code\n\t\t// My setup has a separate mount point for /home. When the overlay is mounted,\n\t\t// the overlay does not contain the original /home contents.\n\t\t// I added code to create a second overlay for /home if the overlay home dir is empty and this seems to work\n\t\t// @dshmgh, Jan 2016\n\t\t{\n\t\t\tchar *overlayhome;\n\t\t\tstruct stat s;\n\t\t\tchar *hroot;\n\t\t\tchar *hdiff;\n\t\t\tchar *hwork;\n\n\t\t\t// dons add debug\n\t\t\tif (arg_debug) printf (\"DEBUG: chroot dirs are oroot %s  odiff %s  owork %s\\n\",oroot,odiff,owork);\n\n\t\t\t// BEFORE NEXT, WE NEED TO TEST IF /home has any contents or do we need to mount it?\n\t\t\t// must create var for oroot/cfg.homedir\n\t\t\tif (asprintf(&overlayhome, \"%s%s\", oroot, cfg.homedir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug) printf (\"DEBUG: overlayhome var holds ##%s##\\n\", overlayhome);\n\n\t\t\t// if no homedir in overlay -- create another overlay for /home\n\t\t\tif (stat(cfg.homedir, &s) == 0 && stat(overlayhome, &s) == -1) {\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (asprintf(&hdiff, \"%s/hdiff\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t// the new directory will be owned by root\n\t\t\t\tif (mkdirat(basefd, \"hdiff\", 0755) == -1 && errno != EEXIST) {\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", hdiff);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tASSERT_PERMS(hdiff, 0, 0, 0755);\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (asprintf(&hwork, \"%s/hwork\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t// the new directory will be owned by root\n\t\t\t\tif (mkdirat(basefd, \"hwork\", 0755) == -1 && errno != EEXIST) {\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", hwork);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tASSERT_PERMS(hwork, 0, 0, 0755);\n\n\t\t\t\t// no homedir in overlay so now mount another overlay for /home\n\t\t\t\tif (asprintf(&hroot, \"%s/home\", oroot) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (asprintf(&option, \"lowerdir=/home,upperdir=%s,workdir=%s\", hdiff, hwork) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (mount(\"overlay\", hroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\t\t\terrExit(\"mounting overlayfs for mounted home directory\");\n\n\t\t\t\tprintf(\"OverlayFS for /home configured in %s directory\\n\", basedir);\n\t\t\t\tfree(hroot);\n\t\t\t\tfree(hdiff);\n\t\t\t\tfree(hwork);\n\n\t\t\t} // stat(overlayhome)\n\t\t\tfree(overlayhome);\n\t\t}\n\t\t// issue #263 end code\n\t\t//***************************\n\t}\n\tfmessage(\"OverlayFS configured in %s directory\\n\", basedir);\n\tclose(basefd);\n\n\t// /dev, /run and /tmp are not covered by the overlay\n\t// mount-bind dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev\\n\");\n\tchar *dev;\n\tif (asprintf(&dev, \"%s/dev\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/dev\", dev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"whitelist /dev\");\n\n\t// mount-bind run directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /run\\n\");\n\tchar *run;\n\tif (asprintf(&run, \"%s/run\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/run\", run, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /run\");\n\tfs_logger(\"whitelist /run\");\n\n\t// mount-bind tmp directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /tmp\\n\");\n\tchar *tmp;\n\tif (asprintf(&tmp, \"%s/tmp\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/tmp\", tmp, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /tmp\");\n\tfs_logger(\"whitelist /tmp\");\n\n\t// chroot in the new filesystem\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\tif (chroot(oroot) == -1)\n\t\terrExit(\"chroot\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\tif (!arg_private_dev)\n//\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t\tfs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n\n\t// cleanup and exit\n\tfree(option);\n\tfree(odiff);\n\tfree(owork);\n\tfree(dev);\n\tfree(run);\n\tfree(tmp);\n}"
  },
  {
    "function_name": "fs_check_overlay_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "868-921",
    "snippet": "char *fs_check_overlay_dir(const char *subdirname, int allow_reuse) {\n\tassert(subdirname);\n\tstruct stat s;\n\tchar *dirname;\n\n\tif (asprintf(&dirname, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// check if ~/.firejail already exists\n\tif (lstat(dirname, &s) == 0) {\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dirname);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// create ~/.firejail directory\n\t\tcreate_empty_dir_as_user(dirname, 0700);\n\t\tif (stat(dirname, &s) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot create directory %s\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(dirname);\n\n\t// check overlay directory\n\tif (asprintf(&dirname, \"%s/.firejail/%s\", cfg.homedir, subdirname) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(dirname, &s) == 0) {\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dirname);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: overlay directory %s is not owned by the root user\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (allow_reuse == 0) {\n\t\t\tfprintf(stderr, \"Error: overlay directory exists, but reuse is not allowed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn dirname;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: overlay directory exists, but reuse is not allowed\\n\""
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: overlay directory %s is not owned by the root user\\n\"",
            "dirname"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is not a directory\\n\"",
            "dirname"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is a symbolic link\\n\"",
            "dirname"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "s.st_mode"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "dirname",
            "&s"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dirname",
            "\"%s/.firejail/%s\"",
            "cfg.homedir",
            "subdirname"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dirname"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create directory %s\\n\"",
            "dirname"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_empty_dir_as_user",
          "args": [
            "dirname",
            "0700"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_dir_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "972-1007",
          "snippet": "int create_empty_dir_as_user(const char *dir, mode_t mode) {\n\tassert(dir);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(dir, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s directory\\n\", dir);\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\n\t\t\tif (mkdir(dir, mode) == 0) {\n\t\t\t\tif (chmod(dir, mode) == -1)\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\telse if (arg_debug) {\n\t\t\t\tchar *str;\n\t\t\t\tif (asprintf(&str, \"Directory %s not created\", dir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tperror(str);\n\t\t\t}\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\twaitpid(child, NULL, 0);\n\t\tif (stat(dir, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint create_empty_dir_as_user(const char *dir, mode_t mode) {\n\tassert(dir);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(dir, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s directory\\n\", dir);\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\n\t\t\tif (mkdir(dir, mode) == 0) {\n\t\t\t\tif (chmod(dir, mode) == -1)\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\telse if (arg_debug) {\n\t\t\t\tchar *str;\n\t\t\t\tif (asprintf(&str, \"Directory %s not created\", dir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tperror(str);\n\t\t\t}\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\twaitpid(child, NULL, 0);\n\t\tif (stat(dir, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is not owned by the current user\\n\"",
            "dirname"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is not a directory\\n\"",
            "dirname"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is a symbolic link\\n\"",
            "dirname"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "s.st_mode"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dirname",
            "\"%s/.firejail\"",
            "cfg.homedir"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "subdirname"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nchar *fs_check_overlay_dir(const char *subdirname, int allow_reuse) {\n\tassert(subdirname);\n\tstruct stat s;\n\tchar *dirname;\n\n\tif (asprintf(&dirname, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// check if ~/.firejail already exists\n\tif (lstat(dirname, &s) == 0) {\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dirname);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// create ~/.firejail directory\n\t\tcreate_empty_dir_as_user(dirname, 0700);\n\t\tif (stat(dirname, &s) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot create directory %s\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(dirname);\n\n\t// check overlay directory\n\tif (asprintf(&dirname, \"%s/.firejail/%s\", cfg.homedir, subdirname) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(dirname, &s) == 0) {\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dirname);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: overlay directory %s is not owned by the root user\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (allow_reuse == 0) {\n\t\t\tfprintf(stderr, \"Error: overlay directory exists, but reuse is not allowed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn dirname;\n}"
  },
  {
    "function_name": "fs_basic_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "820-863",
    "snippet": "void fs_basic_fs(void) {\n\tuid_t uid = getuid();\n\n\tif (arg_debug)\n\t\tprintf(\"Basic read-only filesystem:\\n\");\n\tif (!arg_writable_etc) {\n\t\tfs_rdonly(\"/etc\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/etc\");\n\t}\n\tif (!arg_writable_var) {\n\t\tfs_rdonly(\"/var\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/var\");\n\t}\n\tfs_rdonly(\"/bin\");\n\tfs_rdonly(\"/sbin\");\n\tfs_rdonly(\"/lib\");\n\tfs_rdonly(\"/lib64\");\n\tfs_rdonly(\"/lib32\");\n\tfs_rdonly(\"/libx32\");\n\tfs_rdonly(\"/usr\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t  fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\telse\n\t\tfs_rdwr(\"/var/log\");\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (uid)\n\t\tdisable_config();\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_config",
          "args": [],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "disable_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "797-816",
          "snippet": "static void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restrict_users",
          "args": [],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "restrict_users",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
          "lines": "388-409",
          "snippet": "void restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_run();\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nvoid restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_run();\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_machineid",
          "args": [],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "fs_machineid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_etc.c",
          "lines": "28-75",
          "snippet": "void fs_machineid(void) {\n\tunion machineid_t {\n\t\tuint8_t u8[16];\n\t\tuint32_t u32[4];\n\t} mid;\n\n\t// if --machine-id flag is inactive, do nothing\n\tif (arg_machineid == 0)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Generating a new machine-id\\n\");\n\n\t// init random number generator\n\tsrand(time(NULL));\n\n\t// generate random id\n\tmid.u32[0] = rand();\n\tmid.u32[1] = rand();\n\tmid.u32[2] = rand();\n\tmid.u32[3] = rand();\n\n\t// UUID version 4 and DCE variant\n\tmid.u8[6] = (mid.u8[6] & 0x0F) | 0x40;\n\tmid.u8[8] = (mid.u8[8] & 0x3F) | 0x80;\n\n\t// write it in a file\n\tFILE *fp = fopen(RUN_MACHINEID, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%08x%08x%08x%08x\\n\", mid.u32[0], mid.u32[1], mid.u32[2], mid.u32[3]);\n\tfclose(fp);\n\tif (set_perms(RUN_MACHINEID, 0, 0, 0444))\n\t\terrExit(\"set_perms\");\n\n\n\tstruct stat s;\n\tif (stat(\"/etc/machine-id\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"installing a new /etc/machine-id\\n\");\n\n\t\tif (mount(RUN_MACHINEID, \"/etc/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n\tif (stat(\"/var/lib/dbus/machine-id\", &s) == 0) {\n\t\tif (mount(RUN_MACHINEID, \"/var/lib/dbus/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_machineid(void) {\n\tunion machineid_t {\n\t\tuint8_t u8[16];\n\t\tuint32_t u32[4];\n\t} mid;\n\n\t// if --machine-id flag is inactive, do nothing\n\tif (arg_machineid == 0)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Generating a new machine-id\\n\");\n\n\t// init random number generator\n\tsrand(time(NULL));\n\n\t// generate random id\n\tmid.u32[0] = rand();\n\tmid.u32[1] = rand();\n\tmid.u32[2] = rand();\n\tmid.u32[3] = rand();\n\n\t// UUID version 4 and DCE variant\n\tmid.u8[6] = (mid.u8[6] & 0x0F) | 0x40;\n\tmid.u8[8] = (mid.u8[8] & 0x3F) | 0x80;\n\n\t// write it in a file\n\tFILE *fp = fopen(RUN_MACHINEID, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%08x%08x%08x%08x\\n\", mid.u32[0], mid.u32[1], mid.u32[2], mid.u32[3]);\n\tfclose(fp);\n\tif (set_perms(RUN_MACHINEID, 0, 0, 0444))\n\t\terrExit(\"set_perms\");\n\n\n\tstruct stat s;\n\tif (stat(\"/etc/machine-id\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"installing a new /etc/machine-id\\n\");\n\n\t\tif (mount(RUN_MACHINEID, \"/etc/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n\tif (stat(\"/var/lib/dbus/machine-id\", &s) == 0) {\n\t\tif (mount(RUN_MACHINEID, \"/var/lib/dbus/machine-id\", \"none\", MS_BIND, \"mode=444,gid=0\"))\n\t\t\terrExit(\"mount\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_utmp",
          "args": [],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_utmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "280-325",
          "snippet": "void fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfwarning(\"cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\n\t// save new utmp file\n\tint rv = fwrite(&u_boot, sizeof(u_boot), 1, fp);\n\t(void) rv;\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfwarning(\"cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\n\t// save new utmp file\n\tint rv = fwrite(&u_boot, sizeof(u_boot), 1, fp);\n\t(void) rv;\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_cache",
          "args": [],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "199-231",
          "snippet": "void fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/compress\", 0755, uid, gid);\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/uploads\", 0755, uid, gid);\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/compress\", 0755, uid, gid);\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\tmkdir_attr(\"/var/cache/lighttpd/uploads\", 0755, uid, gid);\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lib",
          "args": [],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "149-197",
          "snippet": "void fs_var_lib(void) {\n\tstruct stat s;\n\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lib(void) {\n\tstruct stat s;\n\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_rdwr",
          "args": [
            "\"/var/log\""
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdwr_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "579-604",
          "snippet": "static void fs_rdwr_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdwr(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdwr(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mount_warning = 0;",
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nstatic void fs_rdwr_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdwr(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdwr(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_log",
          "args": [],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "106-147",
          "snippet": "void fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\n\t// note: /var/log is not created here, if it does not exist, this section fails.\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\n\t\tbuild_dirs();\n\t\trelease_all();\n\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfwarning(\"cannot hide /var/log directory\\n\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\n\t// note: /var/log is not created here, if it does not exist, this section fails.\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\n\t\tbuild_dirs();\n\t\trelease_all();\n\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tif (fp) {\n\t\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\t\tfclose(fp);\n\t\t}\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfwarning(\"cannot hide /var/log directory\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_tmp",
          "args": [],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_tmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "263-278",
          "snippet": "void fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfwarning(\"/var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfwarning(\"/var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lock",
          "args": [],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_var.c",
          "lines": "248-261",
          "snippet": "void fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tfwarning(\"/var/lock not mounted\\n\");\n\t\tdbg_test_dir(\"/var/lock\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tfwarning(\"/var/lock not mounted\\n\");\n\t\tdbg_test_dir(\"/var/lock\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_rdonly",
          "args": [
            "\"/usr\""
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "516-541",
          "snippet": "void fs_rdonly_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdonly(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdonly(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mount_warning = 0;",
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_rdonly_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdonly(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdonly(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_noexec",
          "args": [
            "\"/var\""
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "fs_noexec_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "630-655",
          "snippet": "void fs_noexec_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_noexec(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_noexec(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mount_warning = 0;",
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_noexec_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_noexec(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_noexec(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Basic read-only filesystem:\\n\""
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_basic_fs(void) {\n\tuid_t uid = getuid();\n\n\tif (arg_debug)\n\t\tprintf(\"Basic read-only filesystem:\\n\");\n\tif (!arg_writable_etc) {\n\t\tfs_rdonly(\"/etc\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/etc\");\n\t}\n\tif (!arg_writable_var) {\n\t\tfs_rdonly(\"/var\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/var\");\n\t}\n\tfs_rdonly(\"/bin\");\n\tfs_rdonly(\"/sbin\");\n\tfs_rdonly(\"/lib\");\n\tfs_rdonly(\"/lib64\");\n\tfs_rdonly(\"/lib32\");\n\tfs_rdonly(\"/libx32\");\n\tfs_rdonly(\"/usr\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t  fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\telse\n\t\tfs_rdwr(\"/var/log\");\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (uid)\n\t\tdisable_config();\n}"
  },
  {
    "function_name": "disable_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "797-816",
    "snippet": "static void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_file",
          "args": [
            "BLACKLIST_FILE",
            "RUN_FIREJAIL_X11_DIR"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "disable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "63-176",
          "snippet": "static void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat functions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tfwarning(\"%s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode)) {\n\t\t\tfwarning(\"%s directory link was not blacklisted\\n\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug) {\n\t\t\t\tif (strcmp(filename, fname))\n\t\t\t\t\tprintf(\"Disable %s (requested %s)\\n\", fname, filename);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\t}\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tfs_rdonly_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tfs_rdwr_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tfs_noexec_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tfs_tmpfs(fname, 0);\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "LAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nLAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;\n\nstatic void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat functions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tfwarning(\"%s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode)) {\n\t\t\tfwarning(\"%s directory link was not blacklisted\\n\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug) {\n\t\t\t\tif (strcmp(filename, fname))\n\t\t\t\t\tprintf(\"Disable %s (requested %s)\\n\", fname, filename);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\t}\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tfs_rdonly_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tfs_rdwr_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tfs_noexec_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tfs_tmpfs(fname, 0);\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_X11_DIR",
            "&s"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/.config/firejail\"",
            "cfg.homedir"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}"
  },
  {
    "function_name": "fs_proc_sys_dev_boot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "679-794",
    "snippet": "void fs_proc_sys_dev_boot(void) {\n\n\tif (arg_debug)\n\t\tprintf(\"Remounting /proc and /proc/sys filesystems\\n\");\n\tif (mount(\"proc\", \"/proc\", \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc\");\n\tfs_logger(\"remount /proc\");\n\n\t// remount /proc/sys readonly\n\tif (mount(\"/proc/sys\", \"/proc/sys\", NULL, MS_BIND | MS_REC, NULL) < 0 ||\n\t    mount(NULL, \"/proc/sys\", NULL, MS_BIND | MS_REMOUNT | MS_RDONLY | MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\tfs_logger(\"read-only /proc/sys\");\n\n\n\t/* Mount a version of /sys that describes the network namespace */\n\tif (arg_debug)\n\t\tprintf(\"Remounting /sys directory\\n\");\n\t// if this is an overlay, don't try to unmount, just mount a new sysfs\n\tif (!arg_overlay) {\n\t\tif (umount2(\"/sys\", MNT_DETACH) < 0 && !cfg.chrootdir)\n\t\t\tfwarning(\"failed to unmount /sys\\n\");\n\t}\n\tif (mount(\"sysfs\", \"/sys\", \"sysfs\", MS_RDONLY|MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_REC, NULL) < 0)\n\t\tfwarning(\"failed to mount /sys\\n\");\n\telse\n\t\tfs_logger(\"remount /sys\");\n\n\tdisable_file(BLACKLIST_FILE, \"/sys/firmware\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/hypervisor\");\n\t{ // allow user access to some directories in /sys/ by specifying 'noblacklist' option\n\t\tEUID_USER();\n\t\tprofile_add(\"blacklist /sys/fs\");\n\t\tprofile_add(\"blacklist /sys/module\");\n\t\tEUID_ROOT();\n\t}\n\tdisable_file(BLACKLIST_FILE, \"/sys/power\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/debug\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/vmcoreinfo\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/uevent_helper\");\n\n\t// various /proc/sys files\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/security\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/efi/vars\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/fs/binfmt_misc\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/core_pattern\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/modprobe\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sysrq-trigger\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/hotplug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/vm/panic_on_oom\");\n\n\t// various /proc files\n\tdisable_file(BLACKLIST_FILE, \"/proc/irq\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/bus\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/config.gz\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sched_debug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_list\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_stats\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kcore\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kallsyms\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/mem\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kmem\");\n\n\t// remove kernel symbol information\n\tif (!arg_allow_debuggers) {\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/src/linux\");\n\t\tdisable_file(BLACKLIST_FILE, \"/lib/modules\");\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/lib/debug\");\n\t\tdisable_file(BLACKLIST_FILE, \"/boot\");\n\t}\n\n\t// disable /selinux\n\tdisable_file(BLACKLIST_FILE, \"/selinux\");\n\n\t// disable /dev/port\n\tdisable_file(BLACKLIST_FILE, \"/dev/port\");\n\n\n\n\t// disable various ipc sockets in /run/user\n\tif (!arg_writable_run_user) {\n\t\tstruct stat s;\n\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/run/user/%d\", getuid()) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (is_dir(fname)) { // older distros don't have this directory\n\t\t\t// disable /run/user/{uid}/gnupg\n\t\t\tchar *fnamegpg;\n\t\t\tif (asprintf(&fnamegpg, \"/run/user/%d/gnupg\", getuid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (create_empty_dir_as_user(fnamegpg, 0700))\n\t\t\t\tfs_logger2(\"create\", fnamegpg);\n\t\t\tif (stat(fnamegpg, &s) == 0)\n\t\t\t\tdisable_file(BLACKLIST_FILE, fnamegpg);\n\t\t\tfree(fnamegpg);\n\n\t\t\t// disable /run/user/{uid}/systemd\n\t\t\tchar *fnamesysd;\n\t\t\tif (asprintf(&fnamesysd, \"/run/user/%d/systemd\", getuid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (create_empty_dir_as_user(fnamesysd, 0755))\n\t\t\t\tfs_logger2(\"create\", fnamesysd);\n\t\t\tif (stat(fnamesysd, &s) == 0)\n\t\t\t\tdisable_file(BLACKLIST_FILE, fnamesysd);\n\t\t\tfree(fnamesysd);\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (getuid() != 0) {\n\t\t// disable /dev/kmsg and /proc/kmsg\n\t\tdisable_file(BLACKLIST_FILE, \"/dev/kmsg\");\n\t\tdisable_file(BLACKLIST_FILE, \"/proc/kmsg\");\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_file",
          "args": [
            "BLACKLIST_FILE",
            "\"/proc/kmsg\""
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "disable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "63-176",
          "snippet": "static void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat functions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tfwarning(\"%s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode)) {\n\t\t\tfwarning(\"%s directory link was not blacklisted\\n\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug) {\n\t\t\t\tif (strcmp(filename, fname))\n\t\t\t\t\tprintf(\"Disable %s (requested %s)\\n\", fname, filename);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\t}\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tfs_rdonly_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tfs_rdwr_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tfs_noexec_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tfs_tmpfs(fname, 0);\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "LAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nLAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;\n\nstatic void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat functions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tfwarning(\"%s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode)) {\n\t\t\tfwarning(\"%s directory link was not blacklisted\\n\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug) {\n\t\t\t\tif (strcmp(filename, fname))\n\t\t\t\t\tprintf(\"Disable %s (requested %s)\\n\", fname, filename);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\t}\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tfs_rdonly_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tfs_rdwr_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tfs_noexec_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tfs_tmpfs(fname, 0);\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fnamesysd"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fnamesysd",
            "&s"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"create\"",
            "fnamesysd"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_dir_as_user",
          "args": [
            "fnamesysd",
            "0755"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_dir_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "972-1007",
          "snippet": "int create_empty_dir_as_user(const char *dir, mode_t mode) {\n\tassert(dir);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(dir, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s directory\\n\", dir);\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\n\t\t\tif (mkdir(dir, mode) == 0) {\n\t\t\t\tif (chmod(dir, mode) == -1)\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\telse if (arg_debug) {\n\t\t\t\tchar *str;\n\t\t\t\tif (asprintf(&str, \"Directory %s not created\", dir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tperror(str);\n\t\t\t}\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\twaitpid(child, NULL, 0);\n\t\tif (stat(dir, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint create_empty_dir_as_user(const char *dir, mode_t mode) {\n\tassert(dir);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(dir, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s directory\\n\", dir);\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\n\t\t\tif (mkdir(dir, mode) == 0) {\n\t\t\t\tif (chmod(dir, mode) == -1)\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\telse if (arg_debug) {\n\t\t\t\tchar *str;\n\t\t\t\tif (asprintf(&str, \"Directory %s not created\", dir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tperror(str);\n\t\t\t}\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\twaitpid(child, NULL, 0);\n\t\tif (stat(dir, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fnamesysd",
            "\"/run/user/%d/systemd\"",
            "getuid()"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fnamegpg"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fnamegpg",
            "\"/run/user/%d/gnupg\"",
            "getuid()"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dir",
          "args": [
            "fname"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "401-428",
          "snippet": "int is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/run/user/%d\"",
            "getuid()"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_add",
          "args": [
            "\"blacklist /sys/module\""
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "1364-1383",
          "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"remount /sys\""
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"failed to mount /sys\\n\""
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"sysfs\"",
            "\"/sys\"",
            "\"sysfs\"",
            "MS_RDONLY|MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_REC",
            "NULL"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "\"/sys\"",
            "MNT_DETACH"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Remounting /sys directory\\n\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /proc/sys\""
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/proc/sys\"",
            "NULL",
            "MS_BIND | MS_REMOUNT | MS_RDONLY | MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC",
            "NULL"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/proc/sys\"",
            "\"/proc/sys\"",
            "NULL",
            "MS_BIND | MS_REC",
            "NULL"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /proc\""
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"proc\"",
            "\"/proc\"",
            "\"proc\"",
            "MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC",
            "NULL"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Remounting /proc and /proc/sys filesystems\\n\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_proc_sys_dev_boot(void) {\n\n\tif (arg_debug)\n\t\tprintf(\"Remounting /proc and /proc/sys filesystems\\n\");\n\tif (mount(\"proc\", \"/proc\", \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc\");\n\tfs_logger(\"remount /proc\");\n\n\t// remount /proc/sys readonly\n\tif (mount(\"/proc/sys\", \"/proc/sys\", NULL, MS_BIND | MS_REC, NULL) < 0 ||\n\t    mount(NULL, \"/proc/sys\", NULL, MS_BIND | MS_REMOUNT | MS_RDONLY | MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\tfs_logger(\"read-only /proc/sys\");\n\n\n\t/* Mount a version of /sys that describes the network namespace */\n\tif (arg_debug)\n\t\tprintf(\"Remounting /sys directory\\n\");\n\t// if this is an overlay, don't try to unmount, just mount a new sysfs\n\tif (!arg_overlay) {\n\t\tif (umount2(\"/sys\", MNT_DETACH) < 0 && !cfg.chrootdir)\n\t\t\tfwarning(\"failed to unmount /sys\\n\");\n\t}\n\tif (mount(\"sysfs\", \"/sys\", \"sysfs\", MS_RDONLY|MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_REC, NULL) < 0)\n\t\tfwarning(\"failed to mount /sys\\n\");\n\telse\n\t\tfs_logger(\"remount /sys\");\n\n\tdisable_file(BLACKLIST_FILE, \"/sys/firmware\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/hypervisor\");\n\t{ // allow user access to some directories in /sys/ by specifying 'noblacklist' option\n\t\tEUID_USER();\n\t\tprofile_add(\"blacklist /sys/fs\");\n\t\tprofile_add(\"blacklist /sys/module\");\n\t\tEUID_ROOT();\n\t}\n\tdisable_file(BLACKLIST_FILE, \"/sys/power\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/debug\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/vmcoreinfo\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/uevent_helper\");\n\n\t// various /proc/sys files\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/security\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/efi/vars\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/fs/binfmt_misc\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/core_pattern\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/modprobe\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sysrq-trigger\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/hotplug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/vm/panic_on_oom\");\n\n\t// various /proc files\n\tdisable_file(BLACKLIST_FILE, \"/proc/irq\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/bus\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/config.gz\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sched_debug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_list\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_stats\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kcore\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kallsyms\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/mem\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kmem\");\n\n\t// remove kernel symbol information\n\tif (!arg_allow_debuggers) {\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/src/linux\");\n\t\tdisable_file(BLACKLIST_FILE, \"/lib/modules\");\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/lib/debug\");\n\t\tdisable_file(BLACKLIST_FILE, \"/boot\");\n\t}\n\n\t// disable /selinux\n\tdisable_file(BLACKLIST_FILE, \"/selinux\");\n\n\t// disable /dev/port\n\tdisable_file(BLACKLIST_FILE, \"/dev/port\");\n\n\n\n\t// disable various ipc sockets in /run/user\n\tif (!arg_writable_run_user) {\n\t\tstruct stat s;\n\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/run/user/%d\", getuid()) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (is_dir(fname)) { // older distros don't have this directory\n\t\t\t// disable /run/user/{uid}/gnupg\n\t\t\tchar *fnamegpg;\n\t\t\tif (asprintf(&fnamegpg, \"/run/user/%d/gnupg\", getuid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (create_empty_dir_as_user(fnamegpg, 0700))\n\t\t\t\tfs_logger2(\"create\", fnamegpg);\n\t\t\tif (stat(fnamegpg, &s) == 0)\n\t\t\t\tdisable_file(BLACKLIST_FILE, fnamegpg);\n\t\t\tfree(fnamegpg);\n\n\t\t\t// disable /run/user/{uid}/systemd\n\t\t\tchar *fnamesysd;\n\t\t\tif (asprintf(&fnamesysd, \"/run/user/%d/systemd\", getuid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (create_empty_dir_as_user(fnamesysd, 0755))\n\t\t\t\tfs_logger2(\"create\", fnamesysd);\n\t\t\tif (stat(fnamesysd, &s) == 0)\n\t\t\t\tdisable_file(BLACKLIST_FILE, fnamesysd);\n\t\t\tfree(fnamesysd);\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (getuid() != 0) {\n\t\t// disable /dev/kmsg and /proc/kmsg\n\t\tdisable_file(BLACKLIST_FILE, \"/dev/kmsg\");\n\t\tdisable_file(BLACKLIST_FILE, \"/proc/kmsg\");\n\t}\n}"
  },
  {
    "function_name": "fs_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "658-675",
    "snippet": "void fs_mnt(const int enforce) {\n\tif (enforce) {\n\t\t// disable-mnt set in firejail.config\n\t\t// overriding with noblacklist is not possible in this case\n\t\tdisable_file(BLACKLIST_FILE, \"/mnt\");\n\t\tdisable_file(BLACKLIST_FILE, \"/media\");\n\t\tdisable_file(BLACKLIST_FILE, \"/run/mount\");\n\t\tdisable_file(BLACKLIST_FILE, \"/run/media\");\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tprofile_add(\"blacklist /mnt\");\n\t\tprofile_add(\"blacklist /media\");\n\t\tprofile_add(\"blacklist /run/mount\");\n\t\tprofile_add(\"blacklist /run/media\");\n\t\tEUID_ROOT();\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_add",
          "args": [
            "\"blacklist /run/media\""
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "1364-1383",
          "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_file",
          "args": [
            "BLACKLIST_FILE",
            "\"/run/media\""
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "disable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "63-176",
          "snippet": "static void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat functions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tfwarning(\"%s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode)) {\n\t\t\tfwarning(\"%s directory link was not blacklisted\\n\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug) {\n\t\t\t\tif (strcmp(filename, fname))\n\t\t\t\t\tprintf(\"Disable %s (requested %s)\\n\", fname, filename);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\t}\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tfs_rdonly_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tfs_rdwr_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tfs_noexec_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tfs_tmpfs(fname, 0);\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "LAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nLAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;\n\nstatic void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat functions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tfwarning(\"%s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode)) {\n\t\t\tfwarning(\"%s directory link was not blacklisted\\n\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug) {\n\t\t\t\tif (strcmp(filename, fname))\n\t\t\t\t\tprintf(\"Disable %s (requested %s)\\n\", fname, filename);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\t}\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tfs_rdonly_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tfs_rdwr_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tfs_noexec_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tfs_tmpfs(fname, 0);\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_mnt(const int enforce) {\n\tif (enforce) {\n\t\t// disable-mnt set in firejail.config\n\t\t// overriding with noblacklist is not possible in this case\n\t\tdisable_file(BLACKLIST_FILE, \"/mnt\");\n\t\tdisable_file(BLACKLIST_FILE, \"/media\");\n\t\tdisable_file(BLACKLIST_FILE, \"/run/mount\");\n\t\tdisable_file(BLACKLIST_FILE, \"/run/media\");\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tprofile_add(\"blacklist /mnt\");\n\t\tprofile_add(\"blacklist /media\");\n\t\tprofile_add(\"blacklist /run/mount\");\n\t\tprofile_add(\"blacklist /run/media\");\n\t\tEUID_ROOT();\n\t}\n}"
  },
  {
    "function_name": "fs_noexec_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "630-655",
    "snippet": "void fs_noexec_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_noexec(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_noexec(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int mount_warning = 0;",
      "static void fs_rdwr(const char *dir);",
      "static void fs_rdwr_rec(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "arr"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*tmp++"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_noexec",
          "args": [
            "*tmp"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "fs_noexec_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "630-655",
          "snippet": "void fs_noexec_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_noexec(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_noexec(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "arr"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_mount_array",
          "args": [
            "mountid",
            "dir"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "build_mount_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "204-285",
          "snippet": "char **build_mount_array(const int mount_id, const char *path) {\n\tassert(path);\n\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\t// array to be returned\n\tsize_t cnt = 0;\n\tsize_t size = 32;\n\tchar **rv = malloc(size * sizeof(*rv));\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\n\t// read /proc/self/mountinfo\n\tsize_t pathlen = strlen(path);\n\tchar buf[MAX_BUF];\n\tMountData mntp;\n\tint found = 0;\n\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\tdo {\n\t\t// find mount point with mount id\n\t\tif (!found) {\n\t\t\tparse_line(buf, &mntp);\n\t\t\tif (mntp.mountid == mount_id) {\n\t\t\t\t// give up if mount id has been reassigned,\n\t\t\t\t// don't remount blacklisted path\n\t\t\t\tif (strncmp(mntp.dir, path, strlen(mntp.dir)) ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.file\"))\n\t\t\t\t\t    break;\n\n\t\t\t\t*rv = strdup(path);\n\t\t\t\tif (*rv == NULL)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tcnt++;\n\t\t\t\tfound = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\t// from here on add all mount points below path,\n\t\t// don't remount blacklisted paths\n\t\tparse_line(buf, &mntp);\n\t\tif (strncmp(mntp.dir, path, pathlen) == 0 &&\n\t\t    mntp.dir[pathlen] == '/' &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") == NULL &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.file\") == NULL) {\n\n\t\t\tif (cnt == size) {\n\t\t\t\tsize *= 2;\n\t\t\t\trv = realloc(rv, size * sizeof(*rv));\n\t\t\t\tif (!rv)\n\t\t\t\t\terrExit(\"realloc\");\n\t\t\t}\n\t\t\trv[cnt] = strdup(mntp.dir);\n\t\t\tif (rv[cnt] == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcnt++;\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\tif (cnt == size) {\n\t\tsize++;\n\t\trv = realloc(rv, size * sizeof(*rv));\n\t\tif (!rv)\n\t\t\terrExit(\"realloc\");\n\t}\n\trv[cnt] = NULL; // end of the array\n\n\tfclose(fp);\n\treturn rv;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nchar **build_mount_array(const int mount_id, const char *path) {\n\tassert(path);\n\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\t// array to be returned\n\tsize_t cnt = 0;\n\tsize_t size = 32;\n\tchar **rv = malloc(size * sizeof(*rv));\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\n\t// read /proc/self/mountinfo\n\tsize_t pathlen = strlen(path);\n\tchar buf[MAX_BUF];\n\tMountData mntp;\n\tint found = 0;\n\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\tdo {\n\t\t// find mount point with mount id\n\t\tif (!found) {\n\t\t\tparse_line(buf, &mntp);\n\t\t\tif (mntp.mountid == mount_id) {\n\t\t\t\t// give up if mount id has been reassigned,\n\t\t\t\t// don't remount blacklisted path\n\t\t\t\tif (strncmp(mntp.dir, path, strlen(mntp.dir)) ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.file\"))\n\t\t\t\t\t    break;\n\n\t\t\t\t*rv = strdup(path);\n\t\t\t\tif (*rv == NULL)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tcnt++;\n\t\t\t\tfound = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\t// from here on add all mount points below path,\n\t\t// don't remount blacklisted paths\n\t\tparse_line(buf, &mntp);\n\t\tif (strncmp(mntp.dir, path, pathlen) == 0 &&\n\t\t    mntp.dir[pathlen] == '/' &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") == NULL &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.file\") == NULL) {\n\n\t\t\tif (cnt == size) {\n\t\t\t\tsize *= 2;\n\t\t\t\trv = realloc(rv, size * sizeof(*rv));\n\t\t\t\tif (!rv)\n\t\t\t\t\terrExit(\"realloc\");\n\t\t\t}\n\t\t\trv[cnt] = strdup(mntp.dir);\n\t\t\tif (rv[cnt] == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcnt++;\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\tif (cnt == size) {\n\t\tsize++;\n\t\trv = realloc(rv, size * sizeof(*rv));\n\t\tif (!rv)\n\t\t\terrExit(\"realloc\");\n\t}\n\trv[cnt] = NULL; // end of the array\n\n\tfclose(fp);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"read-only, read-write and noexec options are not applied recursively\\n\""
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mount_id",
          "args": [
            "dir"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "get_mount_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "155-200",
          "snippet": "int get_mount_id(const char *path) {\n\tassert(path);\n\n\tint fd = open(path, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tchar *fdinfo;\n\tif (asprintf(&fdinfo, \"/proc/self/fdinfo/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(fdinfo, \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\n\t// read the file\n\tchar buf[MAX_BUF];\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\tdo {\n\t\tif (strncmp(buf, \"mnt_id:\", 7) == 0) {\n\t\t\tchar *ptr = buf + 7;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\tclose(fd);\n\t\t\tfree(fdinfo);\n\t\t\treturn atoi(ptr);\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\t// fallback, kernels older than 3.15 don't expose the mount id in this place\n\tfclose(fp);\n\tclose(fd);\n\tfree(fdinfo);\n\treturn -2;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nint get_mount_id(const char *path) {\n\tassert(path);\n\n\tint fd = open(path, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tchar *fdinfo;\n\tif (asprintf(&fdinfo, \"/proc/self/fdinfo/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(fdinfo, \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\n\t// read the file\n\tchar buf[MAX_BUF];\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\tdo {\n\t\tif (strncmp(buf, \"mnt_id:\", 7) == 0) {\n\t\t\tchar *ptr = buf + 7;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\tclose(fd);\n\t\t\tfree(fdinfo);\n\t\t\treturn atoi(ptr);\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\t// fallback, kernels older than 3.15 don't expose the mount id in this place\n\tfclose(fp);\n\tclose(fd);\n\tfree(fdinfo);\n\treturn -2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_noexec_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_noexec(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_noexec(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
  },
  {
    "function_name": "fs_noexec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "607-627",
    "snippet": "void fs_noexec(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tunsigned long flags = 0;\n\t\tget_mount_flags(dir, &flags);\n\t\tif ((flags & (MS_NOEXEC|MS_NODEV|MS_NOSUID)) == (MS_NOEXEC|MS_NODEV|MS_NOSUID))\n\t\t\treturn;\n\t\tflags |= MS_NOEXEC|MS_NODEV|MS_NOSUID;\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting noexec %s\\n\", dir);\n\t\t// mount --bind /bin /bin\n\t\t// mount --bind -o remount,noexec /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t    mount(NULL, dir, NULL, flags|MS_BIND|MS_REMOUNT, NULL) < 0)\n\t\t\terrExit(\"mount noexec\");\n\t\tfs_logger2(\"noexec\", dir);\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);",
      "static void fs_rdwr_rec(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"noexec\"",
            "dir"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount noexec\""
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "dir",
            "NULL",
            "flags|MS_BIND|MS_REMOUNT",
            "NULL"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "dir",
            "dir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting noexec %s\\n\"",
            "dir"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mount_flags",
          "args": [
            "dir",
            "&flags"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "get_mount_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "436-443",
          "snippet": "static int get_mount_flags(const char *path, unsigned long *flags) {\n\tstruct statvfs buf;\n\n\tif (statvfs(path, &buf) < 0)\n\t\treturn -errno;\n\t*flags = buf.f_flag;\n\treturn 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int get_mount_flags(const char *path, unsigned long *flags) {\n\tstruct statvfs buf;\n\n\tif (statvfs(path, &buf) < 0)\n\t\treturn -errno;\n\t*flags = buf.f_flag;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir",
            "&s"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_noexec(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tunsigned long flags = 0;\n\t\tget_mount_flags(dir, &flags);\n\t\tif ((flags & (MS_NOEXEC|MS_NODEV|MS_NOSUID)) == (MS_NOEXEC|MS_NODEV|MS_NOSUID))\n\t\t\treturn;\n\t\tflags |= MS_NOEXEC|MS_NODEV|MS_NOSUID;\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting noexec %s\\n\", dir);\n\t\t// mount --bind /bin /bin\n\t\t// mount --bind -o remount,noexec /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t    mount(NULL, dir, NULL, flags|MS_BIND|MS_REMOUNT, NULL) < 0)\n\t\t\terrExit(\"mount noexec\");\n\t\tfs_logger2(\"noexec\", dir);\n\t}\n}"
  },
  {
    "function_name": "fs_rdwr_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "579-604",
    "snippet": "static void fs_rdwr_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdwr(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdwr(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int mount_warning = 0;",
      "static void fs_rdwr(const char *dir);",
      "static void fs_rdwr_rec(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "arr"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*tmp++"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_rdwr",
          "args": [
            "*tmp"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdwr_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "579-604",
          "snippet": "static void fs_rdwr_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdwr(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdwr(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "arr"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_mount_array",
          "args": [
            "mountid",
            "dir"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "build_mount_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "204-285",
          "snippet": "char **build_mount_array(const int mount_id, const char *path) {\n\tassert(path);\n\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\t// array to be returned\n\tsize_t cnt = 0;\n\tsize_t size = 32;\n\tchar **rv = malloc(size * sizeof(*rv));\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\n\t// read /proc/self/mountinfo\n\tsize_t pathlen = strlen(path);\n\tchar buf[MAX_BUF];\n\tMountData mntp;\n\tint found = 0;\n\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\tdo {\n\t\t// find mount point with mount id\n\t\tif (!found) {\n\t\t\tparse_line(buf, &mntp);\n\t\t\tif (mntp.mountid == mount_id) {\n\t\t\t\t// give up if mount id has been reassigned,\n\t\t\t\t// don't remount blacklisted path\n\t\t\t\tif (strncmp(mntp.dir, path, strlen(mntp.dir)) ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.file\"))\n\t\t\t\t\t    break;\n\n\t\t\t\t*rv = strdup(path);\n\t\t\t\tif (*rv == NULL)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tcnt++;\n\t\t\t\tfound = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\t// from here on add all mount points below path,\n\t\t// don't remount blacklisted paths\n\t\tparse_line(buf, &mntp);\n\t\tif (strncmp(mntp.dir, path, pathlen) == 0 &&\n\t\t    mntp.dir[pathlen] == '/' &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") == NULL &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.file\") == NULL) {\n\n\t\t\tif (cnt == size) {\n\t\t\t\tsize *= 2;\n\t\t\t\trv = realloc(rv, size * sizeof(*rv));\n\t\t\t\tif (!rv)\n\t\t\t\t\terrExit(\"realloc\");\n\t\t\t}\n\t\t\trv[cnt] = strdup(mntp.dir);\n\t\t\tif (rv[cnt] == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcnt++;\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\tif (cnt == size) {\n\t\tsize++;\n\t\trv = realloc(rv, size * sizeof(*rv));\n\t\tif (!rv)\n\t\t\terrExit(\"realloc\");\n\t}\n\trv[cnt] = NULL; // end of the array\n\n\tfclose(fp);\n\treturn rv;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nchar **build_mount_array(const int mount_id, const char *path) {\n\tassert(path);\n\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\t// array to be returned\n\tsize_t cnt = 0;\n\tsize_t size = 32;\n\tchar **rv = malloc(size * sizeof(*rv));\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\n\t// read /proc/self/mountinfo\n\tsize_t pathlen = strlen(path);\n\tchar buf[MAX_BUF];\n\tMountData mntp;\n\tint found = 0;\n\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\tdo {\n\t\t// find mount point with mount id\n\t\tif (!found) {\n\t\t\tparse_line(buf, &mntp);\n\t\t\tif (mntp.mountid == mount_id) {\n\t\t\t\t// give up if mount id has been reassigned,\n\t\t\t\t// don't remount blacklisted path\n\t\t\t\tif (strncmp(mntp.dir, path, strlen(mntp.dir)) ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.file\"))\n\t\t\t\t\t    break;\n\n\t\t\t\t*rv = strdup(path);\n\t\t\t\tif (*rv == NULL)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tcnt++;\n\t\t\t\tfound = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\t// from here on add all mount points below path,\n\t\t// don't remount blacklisted paths\n\t\tparse_line(buf, &mntp);\n\t\tif (strncmp(mntp.dir, path, pathlen) == 0 &&\n\t\t    mntp.dir[pathlen] == '/' &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") == NULL &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.file\") == NULL) {\n\n\t\t\tif (cnt == size) {\n\t\t\t\tsize *= 2;\n\t\t\t\trv = realloc(rv, size * sizeof(*rv));\n\t\t\t\tif (!rv)\n\t\t\t\t\terrExit(\"realloc\");\n\t\t\t}\n\t\t\trv[cnt] = strdup(mntp.dir);\n\t\t\tif (rv[cnt] == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcnt++;\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\tif (cnt == size) {\n\t\tsize++;\n\t\trv = realloc(rv, size * sizeof(*rv));\n\t\tif (!rv)\n\t\t\terrExit(\"realloc\");\n\t}\n\trv[cnt] = NULL; // end of the array\n\n\tfclose(fp);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"read-only, read-write and noexec options are not applied recursively\\n\""
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mount_id",
          "args": [
            "dir"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "get_mount_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "155-200",
          "snippet": "int get_mount_id(const char *path) {\n\tassert(path);\n\n\tint fd = open(path, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tchar *fdinfo;\n\tif (asprintf(&fdinfo, \"/proc/self/fdinfo/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(fdinfo, \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\n\t// read the file\n\tchar buf[MAX_BUF];\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\tdo {\n\t\tif (strncmp(buf, \"mnt_id:\", 7) == 0) {\n\t\t\tchar *ptr = buf + 7;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\tclose(fd);\n\t\t\tfree(fdinfo);\n\t\t\treturn atoi(ptr);\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\t// fallback, kernels older than 3.15 don't expose the mount id in this place\n\tfclose(fp);\n\tclose(fd);\n\tfree(fdinfo);\n\treturn -2;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nint get_mount_id(const char *path) {\n\tassert(path);\n\n\tint fd = open(path, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tchar *fdinfo;\n\tif (asprintf(&fdinfo, \"/proc/self/fdinfo/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(fdinfo, \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\n\t// read the file\n\tchar buf[MAX_BUF];\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\tdo {\n\t\tif (strncmp(buf, \"mnt_id:\", 7) == 0) {\n\t\t\tchar *ptr = buf + 7;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\tclose(fd);\n\t\t\tfree(fdinfo);\n\t\t\treturn atoi(ptr);\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\t// fallback, kernels older than 3.15 don't expose the mount id in this place\n\tfclose(fp);\n\tclose(fd);\n\tfree(fdinfo);\n\treturn -2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nstatic void fs_rdwr_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdwr(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdwr(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
  },
  {
    "function_name": "fs_rdwr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "544-576",
    "snippet": "static void fs_rdwr(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// allow only user owned directories, except the user is root\n\t\tuid_t u = getuid();\n\t\tif (u != 0 && s.st_uid != u) {\n\t\t\tfwarning(\"you are not allowed to change %s to read-write\\n\", dir);\n\t\t\treturn;\n\t\t}\n\t\tunsigned long flags = 0;\n\t\tget_mount_flags(dir, &flags);\n\t\tif ((flags & MS_RDONLY) == 0)\n\t\t\treturn;\n\t\tflags &= ~MS_RDONLY;\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-write %s\\n\", dir);\n\t\t// mount --bind /bin /bin\n\t\t// mount --bind -o remount,rw /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t    mount(NULL, dir, NULL, flags|MS_BIND|MS_REMOUNT, NULL) < 0)\n\t\t\terrExit(\"mount read-write\");\n\t\tfs_logger2(\"read-write\", dir);\n\t\t// run a sanity check on /proc/self/mountinfo\n\t\tMountData *mptr = get_last_mount();\n\t\tsize_t len = strlen(dir);\n\t\tif (strncmp(mptr->dir, dir, len) != 0 ||\n\t\t   (*(mptr->dir + len) != '\\0' && *(mptr->dir + len) != '/'))\n\t\t\terrLogExit(\"invalid read-write mount\");\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);",
      "static void fs_rdwr_rec(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errLogExit",
          "args": [
            "\"invalid read-write mount\""
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "errLogExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "40-57",
          "snippet": "void errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mptr->dir",
            "dir",
            "len"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dir"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "get_last_mount",
          "args": [],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "get_last_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "131-152",
          "snippet": "MountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [
            "static char mbuf[MAX_BUF];",
            "static MountData mdata;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nstatic char mbuf[MAX_BUF];\nstatic MountData mdata;\n\nMountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"read-write\"",
            "dir"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount read-write\""
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "dir",
            "NULL",
            "flags|MS_BIND|MS_REMOUNT",
            "NULL"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "dir",
            "dir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting read-write %s\\n\"",
            "dir"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mount_flags",
          "args": [
            "dir",
            "&flags"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "get_mount_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "436-443",
          "snippet": "static int get_mount_flags(const char *path, unsigned long *flags) {\n\tstruct statvfs buf;\n\n\tif (statvfs(path, &buf) < 0)\n\t\treturn -errno;\n\t*flags = buf.f_flag;\n\treturn 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int get_mount_flags(const char *path, unsigned long *flags) {\n\tstruct statvfs buf;\n\n\tif (statvfs(path, &buf) < 0)\n\t\treturn -errno;\n\t*flags = buf.f_flag;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"you are not allowed to change %s to read-write\\n\"",
            "dir"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir",
            "&s"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nstatic void fs_rdwr(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// allow only user owned directories, except the user is root\n\t\tuid_t u = getuid();\n\t\tif (u != 0 && s.st_uid != u) {\n\t\t\tfwarning(\"you are not allowed to change %s to read-write\\n\", dir);\n\t\t\treturn;\n\t\t}\n\t\tunsigned long flags = 0;\n\t\tget_mount_flags(dir, &flags);\n\t\tif ((flags & MS_RDONLY) == 0)\n\t\t\treturn;\n\t\tflags &= ~MS_RDONLY;\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-write %s\\n\", dir);\n\t\t// mount --bind /bin /bin\n\t\t// mount --bind -o remount,rw /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t    mount(NULL, dir, NULL, flags|MS_BIND|MS_REMOUNT, NULL) < 0)\n\t\t\terrExit(\"mount read-write\");\n\t\tfs_logger2(\"read-write\", dir);\n\t\t// run a sanity check on /proc/self/mountinfo\n\t\tMountData *mptr = get_last_mount();\n\t\tsize_t len = strlen(dir);\n\t\tif (strncmp(mptr->dir, dir, len) != 0 ||\n\t\t   (*(mptr->dir + len) != '\\0' && *(mptr->dir + len) != '/'))\n\t\t\terrLogExit(\"invalid read-write mount\");\n\t}\n}"
  },
  {
    "function_name": "fs_rdonly_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "516-541",
    "snippet": "void fs_rdonly_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdonly(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdonly(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int mount_warning = 0;",
      "static void fs_rdwr(const char *dir);",
      "static void fs_rdwr_rec(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "arr"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*tmp++"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_rdonly",
          "args": [
            "*tmp"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "516-541",
          "snippet": "void fs_rdonly_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdonly(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdonly(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "arr"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_mount_array",
          "args": [
            "mountid",
            "dir"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "build_mount_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "204-285",
          "snippet": "char **build_mount_array(const int mount_id, const char *path) {\n\tassert(path);\n\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\t// array to be returned\n\tsize_t cnt = 0;\n\tsize_t size = 32;\n\tchar **rv = malloc(size * sizeof(*rv));\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\n\t// read /proc/self/mountinfo\n\tsize_t pathlen = strlen(path);\n\tchar buf[MAX_BUF];\n\tMountData mntp;\n\tint found = 0;\n\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\tdo {\n\t\t// find mount point with mount id\n\t\tif (!found) {\n\t\t\tparse_line(buf, &mntp);\n\t\t\tif (mntp.mountid == mount_id) {\n\t\t\t\t// give up if mount id has been reassigned,\n\t\t\t\t// don't remount blacklisted path\n\t\t\t\tif (strncmp(mntp.dir, path, strlen(mntp.dir)) ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.file\"))\n\t\t\t\t\t    break;\n\n\t\t\t\t*rv = strdup(path);\n\t\t\t\tif (*rv == NULL)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tcnt++;\n\t\t\t\tfound = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\t// from here on add all mount points below path,\n\t\t// don't remount blacklisted paths\n\t\tparse_line(buf, &mntp);\n\t\tif (strncmp(mntp.dir, path, pathlen) == 0 &&\n\t\t    mntp.dir[pathlen] == '/' &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") == NULL &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.file\") == NULL) {\n\n\t\t\tif (cnt == size) {\n\t\t\t\tsize *= 2;\n\t\t\t\trv = realloc(rv, size * sizeof(*rv));\n\t\t\t\tif (!rv)\n\t\t\t\t\terrExit(\"realloc\");\n\t\t\t}\n\t\t\trv[cnt] = strdup(mntp.dir);\n\t\t\tif (rv[cnt] == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcnt++;\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\tif (cnt == size) {\n\t\tsize++;\n\t\trv = realloc(rv, size * sizeof(*rv));\n\t\tif (!rv)\n\t\t\terrExit(\"realloc\");\n\t}\n\trv[cnt] = NULL; // end of the array\n\n\tfclose(fp);\n\treturn rv;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nchar **build_mount_array(const int mount_id, const char *path) {\n\tassert(path);\n\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\t// array to be returned\n\tsize_t cnt = 0;\n\tsize_t size = 32;\n\tchar **rv = malloc(size * sizeof(*rv));\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\n\t// read /proc/self/mountinfo\n\tsize_t pathlen = strlen(path);\n\tchar buf[MAX_BUF];\n\tMountData mntp;\n\tint found = 0;\n\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\tdo {\n\t\t// find mount point with mount id\n\t\tif (!found) {\n\t\t\tparse_line(buf, &mntp);\n\t\t\tif (mntp.mountid == mount_id) {\n\t\t\t\t// give up if mount id has been reassigned,\n\t\t\t\t// don't remount blacklisted path\n\t\t\t\tif (strncmp(mntp.dir, path, strlen(mntp.dir)) ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") ||\n\t\t\t\t    strstr(mntp.fsname, \"firejail.ro.file\"))\n\t\t\t\t\t    break;\n\n\t\t\t\t*rv = strdup(path);\n\t\t\t\tif (*rv == NULL)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tcnt++;\n\t\t\t\tfound = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\t// from here on add all mount points below path,\n\t\t// don't remount blacklisted paths\n\t\tparse_line(buf, &mntp);\n\t\tif (strncmp(mntp.dir, path, pathlen) == 0 &&\n\t\t    mntp.dir[pathlen] == '/' &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.dir\") == NULL &&\n\t\t    strstr(mntp.fsname, \"firejail.ro.file\") == NULL) {\n\n\t\t\tif (cnt == size) {\n\t\t\t\tsize *= 2;\n\t\t\t\trv = realloc(rv, size * sizeof(*rv));\n\t\t\t\tif (!rv)\n\t\t\t\t\terrExit(\"realloc\");\n\t\t\t}\n\t\t\trv[cnt] = strdup(mntp.dir);\n\t\t\tif (rv[cnt] == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcnt++;\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\tif (cnt == size) {\n\t\tsize++;\n\t\trv = realloc(rv, size * sizeof(*rv));\n\t\tif (!rv)\n\t\t\terrExit(\"realloc\");\n\t}\n\trv[cnt] = NULL; // end of the array\n\n\tfclose(fp);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"read-only, read-write and noexec options are not applied recursively\\n\""
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mount_id",
          "args": [
            "dir"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "get_mount_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "155-200",
          "snippet": "int get_mount_id(const char *path) {\n\tassert(path);\n\n\tint fd = open(path, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tchar *fdinfo;\n\tif (asprintf(&fdinfo, \"/proc/self/fdinfo/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(fdinfo, \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\n\t// read the file\n\tchar buf[MAX_BUF];\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\tdo {\n\t\tif (strncmp(buf, \"mnt_id:\", 7) == 0) {\n\t\t\tchar *ptr = buf + 7;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\tclose(fd);\n\t\t\tfree(fdinfo);\n\t\t\treturn atoi(ptr);\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\t// fallback, kernels older than 3.15 don't expose the mount id in this place\n\tfclose(fp);\n\tclose(fd);\n\tfree(fdinfo);\n\treturn -2;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nint get_mount_id(const char *path) {\n\tassert(path);\n\n\tint fd = open(path, O_PATH|O_CLOEXEC);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tchar *fdinfo;\n\tif (asprintf(&fdinfo, \"/proc/self/fdinfo/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(fdinfo, \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\n\t// read the file\n\tchar buf[MAX_BUF];\n\tif (fgets(buf, MAX_BUF, fp) == NULL) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\texit(1);\n\t}\n\tdo {\n\t\tif (strncmp(buf, \"mnt_id:\", 7) == 0) {\n\t\t\tchar *ptr = buf + 7;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fdinfo);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\tclose(fd);\n\t\t\tfree(fdinfo);\n\t\t\treturn atoi(ptr);\n\t\t}\n\t} while (fgets(buf, MAX_BUF, fp));\n\n\t// fallback, kernels older than 3.15 don't expose the mount id in this place\n\tfclose(fp);\n\tclose(fd);\n\tfree(fdinfo);\n\treturn -2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_rdonly_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdonly(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdonly(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
  },
  {
    "function_name": "fs_rdonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "493-513",
    "snippet": "void fs_rdonly(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tunsigned long flags = 0;\n\t\tget_mount_flags(dir, &flags);\n\t\tif ((flags & MS_RDONLY) == MS_RDONLY)\n\t\t\treturn;\n\t\tflags |= MS_RDONLY;\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", dir);\n\t\t// mount --bind /bin /bin\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t    mount(NULL, dir, NULL, flags|MS_BIND|MS_REMOUNT, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\tfs_logger2(\"read-only\", dir);\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);",
      "static void fs_rdwr_rec(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"read-only\"",
            "dir"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount read-only\""
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "dir",
            "NULL",
            "flags|MS_BIND|MS_REMOUNT",
            "NULL"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "dir",
            "dir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting read-only %s\\n\"",
            "dir"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mount_flags",
          "args": [
            "dir",
            "&flags"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "get_mount_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "436-443",
          "snippet": "static int get_mount_flags(const char *path, unsigned long *flags) {\n\tstruct statvfs buf;\n\n\tif (statvfs(path, &buf) < 0)\n\t\treturn -errno;\n\t*flags = buf.f_flag;\n\treturn 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int get_mount_flags(const char *path, unsigned long *flags) {\n\tstruct statvfs buf;\n\n\tif (statvfs(path, &buf) < 0)\n\t\treturn -errno;\n\t*flags = buf.f_flag;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir",
            "&s"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_rdonly(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tunsigned long flags = 0;\n\t\tget_mount_flags(dir, &flags);\n\t\tif ((flags & MS_RDONLY) == MS_RDONLY)\n\t\t\treturn;\n\t\tflags |= MS_RDONLY;\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", dir);\n\t\t// mount --bind /bin /bin\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\t    mount(NULL, dir, NULL, flags|MS_BIND|MS_REMOUNT, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\tfs_logger2(\"read-only\", dir);\n\t}\n}"
  },
  {
    "function_name": "fs_tmpfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "451-490",
    "snippet": "void fs_tmpfs(const char *dir, unsigned check_owner) {\n\tassert(dir);\n\t// get a file descriptor for dir, fails if there is any symlink\n\tint fd = safe_fd(dir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (check_owner && s.st_uid != getuid()) {\n\t\tfwarning(\"no tmpfs mounted on %s: not owned by the current user\\n\", dir);\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on %s\\n\", dir);\n\t// preserve ownership, mode\n\tchar *options;\n\tif (asprintf(&options, \"mode=%o,uid=%u,gid=%u\", s.st_mode & 07777, s.st_uid, s.st_gid) == -1)\n\t\terrExit(\"asprintf\");\n\t// preserve mount flags, but remove read-only flag\n\tstruct statvfs buf;\n\tif (fstatvfs(fd, &buf) == -1)\n\t\terrExit(\"fstatvfs\");\n\tunsigned long flags = buf.f_flag & ~(MS_RDONLY|MS_BIND);\n\t// mount via the symbolic link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"tmpfs\", proc, \"tmpfs\", flags|MS_NOSUID|MS_NODEV, options) < 0)\n\t\terrExit(\"mounting tmpfs\");\n\t// check the last mount operation\n\tMountData *mdata = get_last_mount();\n\tif (strcmp(mdata->fstype, \"tmpfs\") != 0 || strcmp(mdata->dir, dir) != 0)\n\t\terrLogExit(\"invalid tmpfs mount\");\n\tfs_logger2(\"tmpfs\", dir);\n\tfree(options);\n\tfree(proc);\n\tclose(fd);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);",
      "static void fs_rdwr_rec(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "proc"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"tmpfs\"",
            "dir"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errLogExit",
          "args": [
            "\"invalid tmpfs mount\""
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "errLogExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "40-57",
          "snippet": "void errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mdata->dir",
            "dir"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mdata->fstype",
            "\"tmpfs\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_mount",
          "args": [],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "get_last_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "131-152",
          "snippet": "MountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [
            "static char mbuf[MAX_BUF];",
            "static MountData mdata;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nstatic char mbuf[MAX_BUF];\nstatic MountData mdata;\n\nMountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs\""
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "proc",
            "\"tmpfs\"",
            "flags|MS_NOSUID|MS_NODEV",
            "options"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&proc",
            "\"/proc/self/fd/%d\"",
            "fd"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstatvfs\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstatvfs",
          "args": [
            "fd",
            "&buf"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&options",
            "\"mode=%o,uid=%u,gid=%u\"",
            "s.st_mode & 07777",
            "s.st_uid",
            "s.st_gid"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on %s\\n\"",
            "dir"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"no tmpfs mounted on %s: not owned by the current user\\n\"",
            "dir"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&s"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"safe_fd\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_fd",
          "args": [
            "dir",
            "O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "safe_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1143-1209",
          "snippet": "int safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define EMPTY_STRING (\"\")"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nint safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_tmpfs(const char *dir, unsigned check_owner) {\n\tassert(dir);\n\t// get a file descriptor for dir, fails if there is any symlink\n\tint fd = safe_fd(dir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (check_owner && s.st_uid != getuid()) {\n\t\tfwarning(\"no tmpfs mounted on %s: not owned by the current user\\n\", dir);\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on %s\\n\", dir);\n\t// preserve ownership, mode\n\tchar *options;\n\tif (asprintf(&options, \"mode=%o,uid=%u,gid=%u\", s.st_mode & 07777, s.st_uid, s.st_gid) == -1)\n\t\terrExit(\"asprintf\");\n\t// preserve mount flags, but remove read-only flag\n\tstruct statvfs buf;\n\tif (fstatvfs(fd, &buf) == -1)\n\t\terrExit(\"fstatvfs\");\n\tunsigned long flags = buf.f_flag & ~(MS_RDONLY|MS_BIND);\n\t// mount via the symbolic link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"tmpfs\", proc, \"tmpfs\", flags|MS_NOSUID|MS_NODEV, options) < 0)\n\t\terrExit(\"mounting tmpfs\");\n\t// check the last mount operation\n\tMountData *mdata = get_last_mount();\n\tif (strcmp(mdata->fstype, \"tmpfs\") != 0 || strcmp(mdata->dir, dir) != 0)\n\t\terrLogExit(\"invalid tmpfs mount\");\n\tfs_logger2(\"tmpfs\", dir);\n\tfree(options);\n\tfree(proc);\n\tclose(fd);\n}"
  },
  {
    "function_name": "get_mount_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "436-443",
    "snippet": "static int get_mount_flags(const char *path, unsigned long *flags) {\n\tstruct statvfs buf;\n\n\tif (statvfs(path, &buf) < 0)\n\t\treturn -errno;\n\t*flags = buf.f_flag;\n\treturn 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "statvfs",
          "args": [
            "path",
            "&buf"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int get_mount_flags(const char *path, unsigned long *flags) {\n\tstruct statvfs buf;\n\n\tif (statvfs(path, &buf) < 0)\n\t\treturn -errno;\n\t*flags = buf.f_flag;\n\treturn 0;\n}"
  },
  {
    "function_name": "fs_blacklist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "246-434",
    "snippet": "void fs_blacklist(void) {\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\n\tsize_t noblacklist_c = 0;\n\tsize_t noblacklist_m = 32;\n\tchar **noblacklist = calloc(noblacklist_m, sizeof(*noblacklist));\n\n\tif (noblacklist == NULL)\n\t\terrExit(\"failed allocating memory for noblacklist entries\");\n\n\twhile (entry) {\n\t\tOPERATION op = OPERATION_MAX;\n\t\tchar *ptr;\n\n\t\t// whitelist commands handled by fs_whitelist()\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0 ||\n\t\t    strncmp(entry->data, \"nowhitelist \", 12) == 0 ||\n\t\t   *entry->data == '\\0') {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process bind command\n\t\tif (strncmp(entry->data, \"bind \", 5) == 0)  {\n\t\t\tstruct stat s;\n\t\t\tchar *dname1 = entry->data + 5;\n\t\t\tchar *dname2 = split_comma(dname1);\n\t\t\tif (dname2 == NULL ||\n\t\t\t    stat(dname1, &s) == -1 ||\n\t\t\t    stat(dname2, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: invalid bind command, directory missing\\n\");\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// mount --bind olddir newdir\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", dname1, dname2);\n\t\t\t// preserve dname2 mode and ownership\n\t\t\tif (mount(dname1, dname2, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (set_perms(dname2,  s.st_uid, s.st_gid,s.st_mode))\n\t\t\t\terrExit(\"set_perms\");\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Process noblacklist command\n\t\tif (strncmp(entry->data, \"noblacklist \", 12) == 0) {\n\t\t\tchar **enames;\n\t\t\tint i;\n\n\t\t\tif (strncmp(entry->data + 12, \"${PATH}\", 7) == 0) {\n\t\t\t\t// expand ${PATH} macro\n\t\t\t\tchar **paths = build_paths();\n\t\t\t\tunsigned int npaths = count_paths();\n\t\t\t\tenames = calloc(npaths, sizeof(char *));\n\t\t\t\tif (!enames)\n\t\t\t\t\terrExit(\"calloc\");\n\n\t\t\t\tfor (i = 0; paths[i]; i++) {\n\t\t\t\t\tif (asprintf(&enames[i], \"%s%s\", paths[i],\n\t\t\t\t\t\tentry->data + 19) == -1)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t}\n\t\t\t\tassert(enames[npaths-1] == 0);\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// expand ${HOME} macro if found or pass as is\n\t\t\t\tenames = calloc(2, sizeof(char *));\n\t\t\t\tif (!enames)\n\t\t\t\t\terrExit(\"calloc\");\n\t\t\t\tenames[0] = expand_macros(entry->data + 12);\n\t\t\t\tassert(enames[1] == 0);\n\t\t\t}\n\n\t\t\tfor (i = 0; enames[i]; i++) {\n\t\t\t\tif (noblacklist_c >= noblacklist_m) {\n\t\t\t\t\tnoblacklist_m *= 2;\n\t\t\t\t\tnoblacklist = realloc(noblacklist, sizeof(*noblacklist) * noblacklist_m);\n\t\t\t\t\tif (noblacklist == NULL)\n\t\t\t\t\t\terrExit(\"failed increasing memory for noblacklist entries\");\n\t\t\t\t}\n\t\t\t\tnoblacklist[noblacklist_c++] = enames[i];\n\t\t\t}\n\n\t\t\tfree(enames);\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process blacklist command\n\t\tif (strncmp(entry->data, \"blacklist \", 10) == 0)  {\n\t\t\tptr = entry->data + 10;\n\t\t\top = BLACKLIST_FILE;\n\t\t}\n\t\telse if (strncmp(entry->data, \"blacklist-nolog \", 16) == 0)  {\n\t\t\tptr = entry->data + 16;\n\t\t\top = BLACKLIST_NOLOG;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-only \", 10) == 0) {\n\t\t\tptr = entry->data + 10;\n\t\t\top = MOUNT_READONLY;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-write \", 11) == 0) {\n\t\t\tptr = entry->data + 11;\n\t\t\top = MOUNT_RDWR;\n\t\t}\n\t\telse if (strncmp(entry->data, \"noexec \", 7) == 0) {\n\t\t\tptr = entry->data + 7;\n\t\t\top = MOUNT_NOEXEC;\n\t\t}\n\t\telse if (strncmp(entry->data, \"tmpfs \", 6) == 0) {\n\t\t\tptr = entry->data + 6;\n\t\t\top = MOUNT_TMPFS;\n\t\t}\n\t\telse if (strncmp(entry->data, \"mkdir \", 6) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkdir(entry->data + 6);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (strncmp(entry->data, \"mkfile \", 7) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkfile(entry->data + 7);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid profile line %s\\n\", entry->data);\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replace home macro in blacklist array\n\t\tchar *new_name = expand_macros(ptr);\n\t\tptr = new_name;\n\n\t\t// expand path macro - look for the file in /usr/local/bin,  /usr/local/sbin, /bin, /usr/bin, /sbin and  /usr/sbin directories\n\t\tif (ptr) {\n\t\t\tif (strncmp(ptr, \"${PATH}\", 7) == 0) {\n\t\t\t\tchar *fname = ptr + 7;\n\t\t\t\tsize_t fname_len = strlen(fname);\n\t\t\t\tchar **paths = build_paths(); //{\"/usr/local/bin\", \"/usr/local/sbin\", \"/bin\", \"/usr/bin/\", \"/sbin\", \"/usr/sbin\", NULL};\n\t\t\t\tint i = 0;\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tchar *path = paths[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tchar newname[strlen(path) + fname_len + 1];\n\t\t\t\t\tsprintf(newname, \"%s%s\", path, fname);\n\t\t\t\t\tglobbing(op, newname, (const char**)noblacklist, noblacklist_c);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tglobbing(op, ptr, (const char**)noblacklist, noblacklist_c);\n\t\t}\n\n\t\tif (new_name)\n\t\t\tfree(new_name);\n\t\tentry = entry->next;\n\t}\n\n\tsize_t i;\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\t// noblacklist checking\n\tfor (i = 0; i < nbcheck_size; i++)\n\t\tif (!arg_quiet && !nbcheck[i])\n\t\t\tprintf(\"TESTING warning: noblacklist %s not matched by a proper blacklist command in disable*.inc\\n\",\n\t\t\t\t noblacklist[i]);\n\n\t// free memory\n\tif (nbcheck) {\n\t\tfree(nbcheck);\n\t\tnbcheck = NULL;\n\t\tnbcheck_size = 0;\n\t}\n#endif\n\tfor (i = 0; i < noblacklist_c; i++)\n\t\tfree(noblacklist[i]);\n\tfree(noblacklist);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "noblacklist"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "noblacklist[i]"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "nbcheck"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"TESTING warning: noblacklist %s not matched by a proper blacklist command in disable*.inc\\n\"",
            "noblacklist[i]"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_name"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "globbing",
          "args": [
            "op",
            "ptr",
            "(const char**)noblacklist",
            "noblacklist_c"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "globbing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "185-242",
          "snippet": "static void globbing(OPERATION op, const char *pattern, const char *noblacklist[], size_t noblacklist_len) {\n\tassert(pattern);\n\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\tif (nbcheck_start == 0) {\n\t\tnbcheck_start = 1;\n\t\tnbcheck_size = noblacklist_len;\n\t\tnbcheck = malloc(sizeof(int) * noblacklist_len);\n\t\tif (nbcheck == NULL)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(nbcheck, 0, sizeof(int) * noblacklist_len);\n\t}\n#endif\n\n\tglob_t globbuf;\n\t// Profiles contain blacklists for files that might not exist on a user's machine.\n\t// GLOB_NOCHECK makes that okay.\n\tint globerr = glob(pattern, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\tif (globerr) {\n\t\tfprintf(stderr, \"Error: failed to glob pattern %s\\n\", pattern);\n\t\texit(1);\n\t}\n\n\tsize_t i, j;\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\t// /home/me/.* can glob to /home/me/.. which would blacklist /home/\n\t\tconst char *base = gnu_basename(path);\n\t\tif (strcmp(base, \".\") == 0 || strcmp(base, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// noblacklist is expected to be short in normal cases, so stupid and correct brute force is okay\n\t\tbool okay_to_blacklist = true;\n\t\tfor (j = 0; j < noblacklist_len; j++) {\n\t\t\tint result = fnmatch(noblacklist[j], path, FNM_PATHNAME);\n\t\t\tif (result == FNM_NOMATCH)\n\t\t\t\tcontinue;\n\t\t\telse if (result == 0) {\n\t\t\t\tokay_to_blacklist = false;\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\t\t\t\tif (j < nbcheck_size)\t// noblacklist checking\n\t\t\t\t\tnbcheck[j] = 1;\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: failed to compare path %s with pattern %s\\n\", path, noblacklist[j]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (okay_to_blacklist)\n\t\t\tdisable_file(op, path);\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Not blacklist %s\\n\", path);\n\t}\n\tglobfree(&globbuf);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void globbing(OPERATION op, const char *pattern, const char *noblacklist[], size_t noblacklist_len) {\n\tassert(pattern);\n\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\tif (nbcheck_start == 0) {\n\t\tnbcheck_start = 1;\n\t\tnbcheck_size = noblacklist_len;\n\t\tnbcheck = malloc(sizeof(int) * noblacklist_len);\n\t\tif (nbcheck == NULL)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(nbcheck, 0, sizeof(int) * noblacklist_len);\n\t}\n#endif\n\n\tglob_t globbuf;\n\t// Profiles contain blacklists for files that might not exist on a user's machine.\n\t// GLOB_NOCHECK makes that okay.\n\tint globerr = glob(pattern, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\tif (globerr) {\n\t\tfprintf(stderr, \"Error: failed to glob pattern %s\\n\", pattern);\n\t\texit(1);\n\t}\n\n\tsize_t i, j;\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\t// /home/me/.* can glob to /home/me/.. which would blacklist /home/\n\t\tconst char *base = gnu_basename(path);\n\t\tif (strcmp(base, \".\") == 0 || strcmp(base, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// noblacklist is expected to be short in normal cases, so stupid and correct brute force is okay\n\t\tbool okay_to_blacklist = true;\n\t\tfor (j = 0; j < noblacklist_len; j++) {\n\t\t\tint result = fnmatch(noblacklist[j], path, FNM_PATHNAME);\n\t\t\tif (result == FNM_NOMATCH)\n\t\t\t\tcontinue;\n\t\t\telse if (result == 0) {\n\t\t\t\tokay_to_blacklist = false;\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\t\t\t\tif (j < nbcheck_size)\t// noblacklist checking\n\t\t\t\t\tnbcheck[j] = 1;\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: failed to compare path %s with pattern %s\\n\", path, noblacklist[j]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (okay_to_blacklist)\n\t\t\tdisable_file(op, path);\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Not blacklist %s\\n\", path);\n\t}\n\tglobfree(&globbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "newname",
            "\"%s%s\"",
            "path",
            "fname"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "build_paths",
          "args": [],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "build_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/paths.c",
          "lines": "82-87",
          "snippet": "char **build_paths(void) {\n\tif (!paths)\n\t\tinit_paths();\n\tassert(paths);\n\treturn paths;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char **paths = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic char **paths = 0;\n\nchar **build_paths(void) {\n\tif (!paths)\n\t\tinit_paths();\n\tassert(paths);\n\treturn paths;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"${PATH}\"",
            "7"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_macros",
          "args": [
            "ptr"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid profile line %s\\n\"",
            "entry->data"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_mkfile",
          "args": [
            "entry->data + 7"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "fs_mkfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_mkdir.c",
          "lines": "98-121",
          "snippet": "void fs_mkfile(const char *name) {\n\tEUID_ASSERT();\n\n\t// check file name\n\tinvalid_filename(name, 0); // no globbing\n\tchar *expanded = expand_macros(name);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0 &&\n\t    strncmp(expanded, \"/tmp\", 4) != 0) {\n\t\tfprintf(stderr, \"Error: only files in user home or /tmp are supported by mkfile\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create file\n\ttouch_file_as_user(expanded, 0600);\n\ndoexit:\n\tfree(expanded);\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/wait.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/wait.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_mkfile(const char *name) {\n\tEUID_ASSERT();\n\n\t// check file name\n\tinvalid_filename(name, 0); // no globbing\n\tchar *expanded = expand_macros(name);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0 &&\n\t    strncmp(expanded, \"/tmp\", 4) != 0) {\n\t\tfprintf(stderr, \"Error: only files in user home or /tmp are supported by mkfile\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create file\n\ttouch_file_as_user(expanded, 0600);\n\ndoexit:\n\tfree(expanded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"mkfile \"",
            "7"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_mkdir",
          "args": [
            "entry->data + 6"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "fs_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_mkdir.c",
          "lines": "58-96",
          "snippet": "void fs_mkdir(const char *name) {\n\tEUID_ASSERT();\n\n\t// check directory name\n\tinvalid_filename(name, 0); // no globbing\n\tchar *expanded = expand_macros(name);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0 &&\n\t    strncmp(expanded, \"/tmp\", 4) != 0) {\n\t\tfprintf(stderr, \"Error: only directories in user home or /tmp are supported by mkdir\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create directory\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// create directory\n\t\tmkdir_recursive(expanded);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/wait.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/wait.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_mkdir(const char *name) {\n\tEUID_ASSERT();\n\n\t// check directory name\n\tinvalid_filename(name, 0); // no globbing\n\tchar *expanded = expand_macros(name);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0 &&\n\t    strncmp(expanded, \"/tmp\", 4) != 0) {\n\t\tfprintf(stderr, \"Error: only directories in user home or /tmp are supported by mkdir\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create directory\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// create directory\n\t\tmkdir_recursive(expanded);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"mkdir \"",
            "6"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"tmpfs \"",
            "6"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"noexec \"",
            "7"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"read-write \"",
            "11"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"read-only \"",
            "10"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"blacklist-nolog \"",
            "16"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"blacklist \"",
            "10"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "enames"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"failed increasing memory for noblacklist entries\""
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "noblacklist",
            "sizeof(*noblacklist) * noblacklist_m"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "enames[1] == 0"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_macros",
          "args": [
            "entry->data + 12"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"calloc\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "2",
            "sizeof(char *)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "enames[npaths-1] == 0"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&enames[i]",
            "\"%s%s\"",
            "paths[i]",
            "entry->data + 19"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"calloc\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "npaths",
            "sizeof(char *)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_paths",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "count_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/paths.c",
          "lines": "90-95",
          "snippet": "unsigned int count_paths(void) {\n\tif (!path_cnt)\n\t\tinit_paths();\n\tassert(path_cnt);\n\treturn path_cnt;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int path_cnt = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic unsigned int path_cnt = 0;\n\nunsigned int count_paths(void) {\n\tif (!path_cnt)\n\t\tinit_paths();\n\tassert(path_cnt);\n\treturn path_cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data + 12",
            "\"${PATH}\"",
            "7"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"noblacklist \"",
            "12"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"set_perms\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_perms",
          "args": [
            "dname2",
            "s.st_uid",
            "s.st_gid",
            "s.st_mode"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "set_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1047-1054",
          "snippet": "int set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "dname1",
            "dname2",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mount-bind %s on top of %s\\n\"",
            "dname1",
            "dname2"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid bind command, directory missing\\n\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dname2",
            "&s"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_comma",
          "args": [
            "dname1"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "split_comma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "532-544",
          "snippet": "char *split_comma(char *str) {\n\tEUID_ASSERT();\n\tif (str == NULL || *str == '\\0')\n\t\treturn NULL;\n\tchar *ptr = strchr(str, ',');\n\tif (!ptr)\n\t\treturn NULL;\n\t*ptr = '\\0';\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn NULL;\n\treturn ptr;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *split_comma(char *str) {\n\tEUID_ASSERT();\n\tif (str == NULL || *str == '\\0')\n\t\treturn NULL;\n\tchar *ptr = strchr(str, ',');\n\tif (!ptr)\n\t\treturn NULL;\n\t*ptr = '\\0';\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn NULL;\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"bind \"",
            "5"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"nowhitelist \"",
            "12"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"whitelist \"",
            "10"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"failed allocating memory for noblacklist entries\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "noblacklist_m",
            "sizeof(*noblacklist)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_blacklist(void) {\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\n\tsize_t noblacklist_c = 0;\n\tsize_t noblacklist_m = 32;\n\tchar **noblacklist = calloc(noblacklist_m, sizeof(*noblacklist));\n\n\tif (noblacklist == NULL)\n\t\terrExit(\"failed allocating memory for noblacklist entries\");\n\n\twhile (entry) {\n\t\tOPERATION op = OPERATION_MAX;\n\t\tchar *ptr;\n\n\t\t// whitelist commands handled by fs_whitelist()\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0 ||\n\t\t    strncmp(entry->data, \"nowhitelist \", 12) == 0 ||\n\t\t   *entry->data == '\\0') {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process bind command\n\t\tif (strncmp(entry->data, \"bind \", 5) == 0)  {\n\t\t\tstruct stat s;\n\t\t\tchar *dname1 = entry->data + 5;\n\t\t\tchar *dname2 = split_comma(dname1);\n\t\t\tif (dname2 == NULL ||\n\t\t\t    stat(dname1, &s) == -1 ||\n\t\t\t    stat(dname2, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: invalid bind command, directory missing\\n\");\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// mount --bind olddir newdir\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", dname1, dname2);\n\t\t\t// preserve dname2 mode and ownership\n\t\t\tif (mount(dname1, dname2, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (set_perms(dname2,  s.st_uid, s.st_gid,s.st_mode))\n\t\t\t\terrExit(\"set_perms\");\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Process noblacklist command\n\t\tif (strncmp(entry->data, \"noblacklist \", 12) == 0) {\n\t\t\tchar **enames;\n\t\t\tint i;\n\n\t\t\tif (strncmp(entry->data + 12, \"${PATH}\", 7) == 0) {\n\t\t\t\t// expand ${PATH} macro\n\t\t\t\tchar **paths = build_paths();\n\t\t\t\tunsigned int npaths = count_paths();\n\t\t\t\tenames = calloc(npaths, sizeof(char *));\n\t\t\t\tif (!enames)\n\t\t\t\t\terrExit(\"calloc\");\n\n\t\t\t\tfor (i = 0; paths[i]; i++) {\n\t\t\t\t\tif (asprintf(&enames[i], \"%s%s\", paths[i],\n\t\t\t\t\t\tentry->data + 19) == -1)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t}\n\t\t\t\tassert(enames[npaths-1] == 0);\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// expand ${HOME} macro if found or pass as is\n\t\t\t\tenames = calloc(2, sizeof(char *));\n\t\t\t\tif (!enames)\n\t\t\t\t\terrExit(\"calloc\");\n\t\t\t\tenames[0] = expand_macros(entry->data + 12);\n\t\t\t\tassert(enames[1] == 0);\n\t\t\t}\n\n\t\t\tfor (i = 0; enames[i]; i++) {\n\t\t\t\tif (noblacklist_c >= noblacklist_m) {\n\t\t\t\t\tnoblacklist_m *= 2;\n\t\t\t\t\tnoblacklist = realloc(noblacklist, sizeof(*noblacklist) * noblacklist_m);\n\t\t\t\t\tif (noblacklist == NULL)\n\t\t\t\t\t\terrExit(\"failed increasing memory for noblacklist entries\");\n\t\t\t\t}\n\t\t\t\tnoblacklist[noblacklist_c++] = enames[i];\n\t\t\t}\n\n\t\t\tfree(enames);\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process blacklist command\n\t\tif (strncmp(entry->data, \"blacklist \", 10) == 0)  {\n\t\t\tptr = entry->data + 10;\n\t\t\top = BLACKLIST_FILE;\n\t\t}\n\t\telse if (strncmp(entry->data, \"blacklist-nolog \", 16) == 0)  {\n\t\t\tptr = entry->data + 16;\n\t\t\top = BLACKLIST_NOLOG;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-only \", 10) == 0) {\n\t\t\tptr = entry->data + 10;\n\t\t\top = MOUNT_READONLY;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-write \", 11) == 0) {\n\t\t\tptr = entry->data + 11;\n\t\t\top = MOUNT_RDWR;\n\t\t}\n\t\telse if (strncmp(entry->data, \"noexec \", 7) == 0) {\n\t\t\tptr = entry->data + 7;\n\t\t\top = MOUNT_NOEXEC;\n\t\t}\n\t\telse if (strncmp(entry->data, \"tmpfs \", 6) == 0) {\n\t\t\tptr = entry->data + 6;\n\t\t\top = MOUNT_TMPFS;\n\t\t}\n\t\telse if (strncmp(entry->data, \"mkdir \", 6) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkdir(entry->data + 6);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (strncmp(entry->data, \"mkfile \", 7) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkfile(entry->data + 7);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid profile line %s\\n\", entry->data);\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replace home macro in blacklist array\n\t\tchar *new_name = expand_macros(ptr);\n\t\tptr = new_name;\n\n\t\t// expand path macro - look for the file in /usr/local/bin,  /usr/local/sbin, /bin, /usr/bin, /sbin and  /usr/sbin directories\n\t\tif (ptr) {\n\t\t\tif (strncmp(ptr, \"${PATH}\", 7) == 0) {\n\t\t\t\tchar *fname = ptr + 7;\n\t\t\t\tsize_t fname_len = strlen(fname);\n\t\t\t\tchar **paths = build_paths(); //{\"/usr/local/bin\", \"/usr/local/sbin\", \"/bin\", \"/usr/bin/\", \"/sbin\", \"/usr/sbin\", NULL};\n\t\t\t\tint i = 0;\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tchar *path = paths[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tchar newname[strlen(path) + fname_len + 1];\n\t\t\t\t\tsprintf(newname, \"%s%s\", path, fname);\n\t\t\t\t\tglobbing(op, newname, (const char**)noblacklist, noblacklist_c);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tglobbing(op, ptr, (const char**)noblacklist, noblacklist_c);\n\t\t}\n\n\t\tif (new_name)\n\t\t\tfree(new_name);\n\t\tentry = entry->next;\n\t}\n\n\tsize_t i;\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\t// noblacklist checking\n\tfor (i = 0; i < nbcheck_size; i++)\n\t\tif (!arg_quiet && !nbcheck[i])\n\t\t\tprintf(\"TESTING warning: noblacklist %s not matched by a proper blacklist command in disable*.inc\\n\",\n\t\t\t\t noblacklist[i]);\n\n\t// free memory\n\tif (nbcheck) {\n\t\tfree(nbcheck);\n\t\tnbcheck = NULL;\n\t\tnbcheck_size = 0;\n\t}\n#endif\n\tfor (i = 0; i < noblacklist_c; i++)\n\t\tfree(noblacklist[i]);\n\tfree(noblacklist);\n}"
  },
  {
    "function_name": "globbing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "185-242",
    "snippet": "static void globbing(OPERATION op, const char *pattern, const char *noblacklist[], size_t noblacklist_len) {\n\tassert(pattern);\n\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\tif (nbcheck_start == 0) {\n\t\tnbcheck_start = 1;\n\t\tnbcheck_size = noblacklist_len;\n\t\tnbcheck = malloc(sizeof(int) * noblacklist_len);\n\t\tif (nbcheck == NULL)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(nbcheck, 0, sizeof(int) * noblacklist_len);\n\t}\n#endif\n\n\tglob_t globbuf;\n\t// Profiles contain blacklists for files that might not exist on a user's machine.\n\t// GLOB_NOCHECK makes that okay.\n\tint globerr = glob(pattern, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\tif (globerr) {\n\t\tfprintf(stderr, \"Error: failed to glob pattern %s\\n\", pattern);\n\t\texit(1);\n\t}\n\n\tsize_t i, j;\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\t// /home/me/.* can glob to /home/me/.. which would blacklist /home/\n\t\tconst char *base = gnu_basename(path);\n\t\tif (strcmp(base, \".\") == 0 || strcmp(base, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// noblacklist is expected to be short in normal cases, so stupid and correct brute force is okay\n\t\tbool okay_to_blacklist = true;\n\t\tfor (j = 0; j < noblacklist_len; j++) {\n\t\t\tint result = fnmatch(noblacklist[j], path, FNM_PATHNAME);\n\t\t\tif (result == FNM_NOMATCH)\n\t\t\t\tcontinue;\n\t\t\telse if (result == 0) {\n\t\t\t\tokay_to_blacklist = false;\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\t\t\t\tif (j < nbcheck_size)\t// noblacklist checking\n\t\t\t\t\tnbcheck[j] = 1;\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: failed to compare path %s with pattern %s\\n\", path, noblacklist[j]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (okay_to_blacklist)\n\t\t\tdisable_file(op, path);\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Not blacklist %s\\n\", path);\n\t}\n\tglobfree(&globbuf);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&globbuf"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Not blacklist %s\\n\"",
            "path"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_file",
          "args": [
            "op",
            "path"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "disable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "63-176",
          "snippet": "static void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat functions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tfwarning(\"%s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode)) {\n\t\t\tfwarning(\"%s directory link was not blacklisted\\n\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug) {\n\t\t\t\tif (strcmp(filename, fname))\n\t\t\t\t\tprintf(\"Disable %s (requested %s)\\n\", fname, filename);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\t}\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tfs_rdonly_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tfs_rdwr_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tfs_noexec_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tfs_tmpfs(fname, 0);\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "LAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nLAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;\n\nstatic void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat functions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tfwarning(\"%s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode)) {\n\t\t\tfwarning(\"%s directory link was not blacklisted\\n\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug) {\n\t\t\t\tif (strcmp(filename, fname))\n\t\t\t\t\tprintf(\"Disable %s (requested %s)\\n\", fname, filename);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\t}\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tfs_rdonly_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tfs_rdwr_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tfs_noexec_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tfs_tmpfs(fname, 0);\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: failed to compare path %s with pattern %s\\n\"",
            "path",
            "noblacklist[j]"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnmatch",
          "args": [
            "noblacklist[j]",
            "path",
            "FNM_PATHNAME"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "base",
            "\"..\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "base",
            "\".\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnu_basename",
          "args": [
            "path"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "gnu_basename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "815-820",
          "snippet": "const char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nconst char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: failed to glob pattern %s\\n\"",
            "pattern"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glob",
          "args": [
            "pattern",
            "GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD",
            "NULL",
            "&globbuf"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "globbing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "185-242",
          "snippet": "static void globbing(OPERATION op, const char *pattern, const char *noblacklist[], size_t noblacklist_len) {\n\tassert(pattern);\n\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\tif (nbcheck_start == 0) {\n\t\tnbcheck_start = 1;\n\t\tnbcheck_size = noblacklist_len;\n\t\tnbcheck = malloc(sizeof(int) * noblacklist_len);\n\t\tif (nbcheck == NULL)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(nbcheck, 0, sizeof(int) * noblacklist_len);\n\t}\n#endif\n\n\tglob_t globbuf;\n\t// Profiles contain blacklists for files that might not exist on a user's machine.\n\t// GLOB_NOCHECK makes that okay.\n\tint globerr = glob(pattern, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\tif (globerr) {\n\t\tfprintf(stderr, \"Error: failed to glob pattern %s\\n\", pattern);\n\t\texit(1);\n\t}\n\n\tsize_t i, j;\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\t// /home/me/.* can glob to /home/me/.. which would blacklist /home/\n\t\tconst char *base = gnu_basename(path);\n\t\tif (strcmp(base, \".\") == 0 || strcmp(base, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// noblacklist is expected to be short in normal cases, so stupid and correct brute force is okay\n\t\tbool okay_to_blacklist = true;\n\t\tfor (j = 0; j < noblacklist_len; j++) {\n\t\t\tint result = fnmatch(noblacklist[j], path, FNM_PATHNAME);\n\t\t\tif (result == FNM_NOMATCH)\n\t\t\t\tcontinue;\n\t\t\telse if (result == 0) {\n\t\t\t\tokay_to_blacklist = false;\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\t\t\t\tif (j < nbcheck_size)\t// noblacklist checking\n\t\t\t\t\tnbcheck[j] = 1;\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: failed to compare path %s with pattern %s\\n\", path, noblacklist[j]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (okay_to_blacklist)\n\t\t\tdisable_file(op, path);\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Not blacklist %s\\n\", path);\n\t}\n\tglobfree(&globbuf);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nbcheck",
            "0",
            "sizeof(int) * noblacklist_len"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(int) * noblacklist_len"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pattern"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void globbing(OPERATION op, const char *pattern, const char *noblacklist[], size_t noblacklist_len) {\n\tassert(pattern);\n\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\tif (nbcheck_start == 0) {\n\t\tnbcheck_start = 1;\n\t\tnbcheck_size = noblacklist_len;\n\t\tnbcheck = malloc(sizeof(int) * noblacklist_len);\n\t\tif (nbcheck == NULL)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(nbcheck, 0, sizeof(int) * noblacklist_len);\n\t}\n#endif\n\n\tglob_t globbuf;\n\t// Profiles contain blacklists for files that might not exist on a user's machine.\n\t// GLOB_NOCHECK makes that okay.\n\tint globerr = glob(pattern, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\tif (globerr) {\n\t\tfprintf(stderr, \"Error: failed to glob pattern %s\\n\", pattern);\n\t\texit(1);\n\t}\n\n\tsize_t i, j;\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\t// /home/me/.* can glob to /home/me/.. which would blacklist /home/\n\t\tconst char *base = gnu_basename(path);\n\t\tif (strcmp(base, \".\") == 0 || strcmp(base, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// noblacklist is expected to be short in normal cases, so stupid and correct brute force is okay\n\t\tbool okay_to_blacklist = true;\n\t\tfor (j = 0; j < noblacklist_len; j++) {\n\t\t\tint result = fnmatch(noblacklist[j], path, FNM_PATHNAME);\n\t\t\tif (result == FNM_NOMATCH)\n\t\t\t\tcontinue;\n\t\t\telse if (result == 0) {\n\t\t\t\tokay_to_blacklist = false;\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\t\t\t\tif (j < nbcheck_size)\t// noblacklist checking\n\t\t\t\t\tnbcheck[j] = 1;\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: failed to compare path %s with pattern %s\\n\", path, noblacklist[j]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (okay_to_blacklist)\n\t\t\tdisable_file(op, path);\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Not blacklist %s\\n\", path);\n\t}\n\tglobfree(&globbuf);\n}"
  },
  {
    "function_name": "disable_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
    "lines": "63-176",
    "snippet": "static void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat functions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tfwarning(\"%s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode)) {\n\t\t\tfwarning(\"%s directory link was not blacklisted\\n\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug) {\n\t\t\t\tif (strcmp(filename, fname))\n\t\t\t\t\tprintf(\"Disable %s (requested %s)\\n\", fname, filename);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\t}\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tfs_rdonly_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tfs_rdwr_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tfs_noexec_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tfs_tmpfs(fname, 0);\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/wait.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "LAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"%s is not a directory; cannot mount a tmpfs on top of it.\\n\"",
            "fname"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_tmpfs",
          "args": [
            "fname",
            "0"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "fs_tmpfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "451-490",
          "snippet": "void fs_tmpfs(const char *dir, unsigned check_owner) {\n\tassert(dir);\n\t// get a file descriptor for dir, fails if there is any symlink\n\tint fd = safe_fd(dir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (check_owner && s.st_uid != getuid()) {\n\t\tfwarning(\"no tmpfs mounted on %s: not owned by the current user\\n\", dir);\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on %s\\n\", dir);\n\t// preserve ownership, mode\n\tchar *options;\n\tif (asprintf(&options, \"mode=%o,uid=%u,gid=%u\", s.st_mode & 07777, s.st_uid, s.st_gid) == -1)\n\t\terrExit(\"asprintf\");\n\t// preserve mount flags, but remove read-only flag\n\tstruct statvfs buf;\n\tif (fstatvfs(fd, &buf) == -1)\n\t\terrExit(\"fstatvfs\");\n\tunsigned long flags = buf.f_flag & ~(MS_RDONLY|MS_BIND);\n\t// mount via the symbolic link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"tmpfs\", proc, \"tmpfs\", flags|MS_NOSUID|MS_NODEV, options) < 0)\n\t\terrExit(\"mounting tmpfs\");\n\t// check the last mount operation\n\tMountData *mdata = get_last_mount();\n\tif (strcmp(mdata->fstype, \"tmpfs\") != 0 || strcmp(mdata->dir, dir) != 0)\n\t\terrLogExit(\"invalid tmpfs mount\");\n\tfs_logger2(\"tmpfs\", dir);\n\tfree(options);\n\tfree(proc);\n\tclose(fd);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_tmpfs(const char *dir, unsigned check_owner) {\n\tassert(dir);\n\t// get a file descriptor for dir, fails if there is any symlink\n\tint fd = safe_fd(dir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (check_owner && s.st_uid != getuid()) {\n\t\tfwarning(\"no tmpfs mounted on %s: not owned by the current user\\n\", dir);\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on %s\\n\", dir);\n\t// preserve ownership, mode\n\tchar *options;\n\tif (asprintf(&options, \"mode=%o,uid=%u,gid=%u\", s.st_mode & 07777, s.st_uid, s.st_gid) == -1)\n\t\terrExit(\"asprintf\");\n\t// preserve mount flags, but remove read-only flag\n\tstruct statvfs buf;\n\tif (fstatvfs(fd, &buf) == -1)\n\t\terrExit(\"fstatvfs\");\n\tunsigned long flags = buf.f_flag & ~(MS_RDONLY|MS_BIND);\n\t// mount via the symbolic link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"tmpfs\", proc, \"tmpfs\", flags|MS_NOSUID|MS_NODEV, options) < 0)\n\t\terrExit(\"mounting tmpfs\");\n\t// check the last mount operation\n\tMountData *mdata = get_last_mount();\n\tif (strcmp(mdata->fstype, \"tmpfs\") != 0 || strcmp(mdata->dir, dir) != 0)\n\t\terrLogExit(\"invalid tmpfs mount\");\n\tfs_logger2(\"tmpfs\", dir);\n\tfree(options);\n\tfree(proc);\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_noexec_rec",
          "args": [
            "fname"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "fs_noexec_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "630-655",
          "snippet": "void fs_noexec_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_noexec(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_noexec(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mount_warning = 0;",
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_noexec_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_noexec(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_noexec(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_rdwr_rec",
          "args": [
            "fname"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdwr_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "579-604",
          "snippet": "static void fs_rdwr_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdwr(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdwr(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mount_warning = 0;",
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nstatic void fs_rdwr_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdwr(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdwr(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_rdonly_rec",
          "args": [
            "fname"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "516-541",
          "snippet": "void fs_rdonly_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdonly(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdonly(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mount_warning = 0;",
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_rdonly_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdonly(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdonly(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"blacklist-nolog\"",
            "fname"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"disable file\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_FILE",
            "fname",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"disable file\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_DIR",
            "fname",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" - no logging\\n\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Disable %s\"",
            "fname"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Disable %s\\n\"",
            "fname"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Disable %s (requested %s)\\n\"",
            "fname",
            "filename"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "filename",
            "fname"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "filename"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "432-459",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/usr/bin\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/bin\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning (blacklisting): %s is an invalid file, skipping...\\n\"",
            "filename"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Disable %s\\n\"",
            "filename"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_FILE",
            "filename",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_DIR",
            "filename",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Debug: no access to file %s, forcing mount\\n\"",
            "filename"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "filename",
            "NULL"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "op <OPERATION_MAX"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "filename"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nLAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;\n\nstatic void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat functions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tfwarning(\"%s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode)) {\n\t\t\tfwarning(\"%s directory link was not blacklisted\\n\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug) {\n\t\t\t\tif (strcmp(filename, fname))\n\t\t\t\t\tprintf(\"Disable %s (requested %s)\\n\", fname, filename);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\t}\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tfs_rdonly_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tfs_rdwr_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tfs_noexec_rec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tfs_tmpfs(fname, 0);\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}"
  }
]