[
  {
    "function_name": "syscall_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/syscall.c",
    "lines": "91-105",
    "snippet": "void syscall_run(const char *name) {\n\tassert(prog);\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\texecl(prog, prog, \"syscall\", name, NULL);\n\t\tperror(\"execl\");\n\t\t_exit(1);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/io.h>",
      "#include <sys/swap.h>",
      "#include <sys/ptrace.h>",
      "#include \"faudit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execl\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "prog",
            "prog",
            "\"syscall\"",
            "name",
            "NULL"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "prog"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/io.h>\n#include <sys/swap.h>\n#include <sys/ptrace.h>\n#include \"faudit.h\"\n\nvoid syscall_run(const char *name) {\n\tassert(prog);\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\texecl(prog, prog, \"syscall\", name, NULL);\n\t\tperror(\"execl\");\n\t\t_exit(1);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
  },
  {
    "function_name": "syscall_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/syscall.c",
    "lines": "34-82",
    "snippet": "void syscall_helper(int argc, char **argv) {\n\t(void) argc;\n\n\tif (argc < 3)\n\t\treturn;\n\n\tif (strcmp(argv[2], \"mount\") == 0) {\n\t\tint rv = mount(NULL, NULL, NULL, 0, NULL);\n\t\t(void) rv;\n\t\tprintf(\"\\nUGLY: mount syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"umount2\") == 0) {\n\t\tumount2(NULL, 0);\n\t\tprintf(\"\\nUGLY: umount2 syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"ptrace\") == 0) {\n\t\tptrace(0, 0, NULL, NULL);\n\t\tprintf(\"\\nUGLY: ptrace syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"swapon\") == 0) {\n\t\tswapon(NULL, 0);\n\t\tprintf(\"\\nUGLY: swapon syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"swapoff\") == 0) {\n\t\tswapoff(NULL);\n\t\tprintf(\"\\nUGLY: swapoff syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"init_module\") == 0) {\n\t\tinit_module(NULL, 0, NULL);\n\t\tprintf(\"\\nUGLY: init_module syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"delete_module\") == 0) {\n\t\tdelete_module(NULL, 0);\n\t\tprintf(\"\\nUGLY: delete_module syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"chroot\") == 0) {\n\t\tint rv = chroot(\"/blablabla-57281292\");\n\t\t(void) rv;\n\t\tprintf(\"\\nUGLY: chroot syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"pivot_root\") == 0) {\n\t\tpivot_root(NULL, NULL);\n\t\tprintf(\"\\nUGLY: pivot_root syscall permitted.\\n\");\n\t}\n#if defined(__i386__) || defined(__x86_64__)\n\telse if (strcmp(argv[2], \"iopl\") == 0) {\n\t\tiopl(0L);\n\t\tprintf(\"\\nUGLY: iopl syscall permitted.\\n\");\n\t}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/io.h>",
      "#include <sys/swap.h>",
      "#include <sys/ptrace.h>",
      "#include \"faudit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nUGLY: pivot_root syscall permitted.\\n\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pivot_root",
          "args": [
            "NULL",
            "NULL"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"pivot_root\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nUGLY: chroot syscall permitted.\\n\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "\"/blablabla-57281292\""
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "fs_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "1366-1497",
          "snippet": "void fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"chroot\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nUGLY: delete_module syscall permitted.\\n\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delete_module",
          "args": [
            "NULL",
            "0"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"delete_module\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nUGLY: init_module syscall permitted.\\n\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_module",
          "args": [
            "NULL",
            "0",
            "NULL"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"init_module\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nUGLY: swapoff syscall permitted.\\n\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swapoff",
          "args": [
            "NULL"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"swapoff\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nUGLY: swapon syscall permitted.\\n\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swapon",
          "args": [
            "NULL",
            "0"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"swapon\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nUGLY: ptrace syscall permitted.\\n\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace",
          "args": [
            "0",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"ptrace\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nUGLY: umount2 syscall permitted.\\n\""
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "NULL",
            "0"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"umount2\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nUGLY: mount syscall permitted.\\n\""
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"mount\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/io.h>\n#include <sys/swap.h>\n#include <sys/ptrace.h>\n#include \"faudit.h\"\n\nvoid syscall_helper(int argc, char **argv) {\n\t(void) argc;\n\n\tif (argc < 3)\n\t\treturn;\n\n\tif (strcmp(argv[2], \"mount\") == 0) {\n\t\tint rv = mount(NULL, NULL, NULL, 0, NULL);\n\t\t(void) rv;\n\t\tprintf(\"\\nUGLY: mount syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"umount2\") == 0) {\n\t\tumount2(NULL, 0);\n\t\tprintf(\"\\nUGLY: umount2 syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"ptrace\") == 0) {\n\t\tptrace(0, 0, NULL, NULL);\n\t\tprintf(\"\\nUGLY: ptrace syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"swapon\") == 0) {\n\t\tswapon(NULL, 0);\n\t\tprintf(\"\\nUGLY: swapon syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"swapoff\") == 0) {\n\t\tswapoff(NULL);\n\t\tprintf(\"\\nUGLY: swapoff syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"init_module\") == 0) {\n\t\tinit_module(NULL, 0, NULL);\n\t\tprintf(\"\\nUGLY: init_module syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"delete_module\") == 0) {\n\t\tdelete_module(NULL, 0);\n\t\tprintf(\"\\nUGLY: delete_module syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"chroot\") == 0) {\n\t\tint rv = chroot(\"/blablabla-57281292\");\n\t\t(void) rv;\n\t\tprintf(\"\\nUGLY: chroot syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"pivot_root\") == 0) {\n\t\tpivot_root(NULL, NULL);\n\t\tprintf(\"\\nUGLY: pivot_root syscall permitted.\\n\");\n\t}\n#if defined(__i386__) || defined(__x86_64__)\n\telse if (strcmp(argv[2], \"iopl\") == 0) {\n\t\tiopl(0L);\n\t\tprintf(\"\\nUGLY: iopl syscall permitted.\\n\");\n\t}"
  }
]