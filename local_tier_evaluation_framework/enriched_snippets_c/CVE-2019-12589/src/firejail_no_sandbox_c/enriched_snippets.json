[
  {
    "function_name": "run_no_sandbox",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/no_sandbox.c",
    "lines": "162-234",
    "snippet": "void run_no_sandbox(int argc, char **argv) {\n\tEUID_ASSERT();\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\t// process limited subset of options\n\tint i;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--debug\") == 0)\n\t\t\targ_debug = 1;\n\t\telse if (strncmp(argv[i], \"--shell=\", 8) == 0)\n\t\t\tfwarning(\"shell-related command line options are disregarded - using SHELL environment variable\\n\");\n\t}\n\n\t// use $SHELL to get shell used in sandbox, guess shell otherwise\n\tcfg.shell = guess_shell();\n\tif (!cfg.shell) {\n\t\tfprintf(stderr, \"Error: unable to guess your shell, please set SHELL environment variable\\n\");\n\t\texit(1);\n\t}\n\telse if (arg_debug)\n\t\tprintf(\"Selecting %s as shell\\n\", cfg.shell);\n\n\tint prog_index = 0;\n\t// find first non option arg:\n\t//\t- first argument not starting with --,\n\t//\t- whatever follows after -c (example: firejail -c ls)\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-c\") == 0) {\n\t\t\tprog_index = i + 1;\n\t\t\tif (prog_index == argc) {\n\t\t\t\tfprintf(stderr, \"Error: option -c requires an argument\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t// check first argument not starting with --\n\t\tif (strncmp(argv[i],\"--\",2) != 0) {\n\t\t\tprog_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// if shell is /usr/bin/firejail, replace it with /bin/bash\n\tif (strcmp(cfg.shell, PATH_FIREJAIL) == 0) {\n\t\tcfg.shell = \"/bin/bash\";\n\t\tprog_index = 0;\n\t}\n\n\tif (prog_index == 0) {\n\t\tcfg.command_line = cfg.shell;\n\t\tcfg.window_title = cfg.shell;\n\t} else {\n\t\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, prog_index);\n\t}\n\n\tcfg.original_argv = argv;\n\tcfg.original_program_index = prog_index;\n\n\tchar *command;\n\tif (prog_index == 0)\n\t\tcommand = cfg.shell;\n\telse\n\t\tcommand = argv[prog_index];\n\tfwarning(\"an existing sandbox was detected. \"\n\t\t\"%s will run without any additional sandboxing features\\n\", command);\n\n\targ_quiet = 1;\n\n\tstart_application(1, NULL);\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_application",
          "args": [
            "1",
            "NULL"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "start_application",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "432-566",
          "snippet": "void start_application(int no_sandbox, FILE *fp) {\n\t// set environment\n\tif (no_sandbox == 0) {\n\t\tenv_defaults();\n\t\tenv_apply();\n\t}\n\t// restore original umask\n\tumask(orig_umask);\n\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tint rv = ok_to_run(cfg.original_argv[cfg.original_program_index]);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\tif (rv)\n\t\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: no suitable %s executable found\\n\", cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid start_application(int no_sandbox, FILE *fp) {\n\t// set environment\n\tif (no_sandbox == 0) {\n\t\tenv_defaults();\n\t\tenv_apply();\n\t}\n\t// restore original umask\n\tumask(orig_umask);\n\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tint rv = ok_to_run(cfg.original_argv[cfg.original_program_index]);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\tif (rv)\n\t\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: no suitable %s executable found\\n\", cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"an existing sandbox was detected. \"\n\t\t\"%s will run without any additional sandboxing features\\n\"",
            "command"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_cmdline",
          "args": [
            "&cfg.command_line",
            "&cfg.window_title",
            "argc",
            "argv",
            "prog_index"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "build_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cmdline.c",
          "lines": "137-162",
          "snippet": "void build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tif (arg_debug)\n\t\tprintf(\"Building quoted command line: %s\\n\", *command_line);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <assert.h>",
            "#include <linux/limits.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <string.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nvoid build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tif (arg_debug)\n\t\tprintf(\"Building quoted command line: %s\\n\", *command_line);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cfg.shell",
            "PATH_FIREJAIL"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--\"",
            "2"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: option -c requires an argument\\n\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-c\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Selecting %s as shell\\n\"",
            "cfg.shell"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: unable to guess your shell, please set SHELL environment variable\\n\""
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_shell",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "guess_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "810-835",
          "snippet": "char *guess_shell(void) {\n\tchar *shell = NULL;\n\tstruct stat s;\n\n\tshell = getenv(\"SHELL\");\n\tif (shell) {\n\t\tinvalid_filename(shell, 0); // no globbing\n\t\tif (!is_dir(shell) && strstr(shell, \"..\") == NULL && stat(shell, &s) == 0 && access(shell, X_OK) == 0)\n\t\t\treturn shell;\n\t}\n\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], X_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nchar *guess_shell(void) {\n\tchar *shell = NULL;\n\tstruct stat s;\n\n\tshell = getenv(\"SHELL\");\n\tif (shell) {\n\t\tinvalid_filename(shell, 0); // no globbing\n\t\tif (!is_dir(shell) && strstr(shell, \"..\") == NULL && stat(shell, &s) == 0 && access(shell, X_OK) == 0)\n\t\t\treturn shell;\n\t}\n\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], X_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--shell=\"",
            "8"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--debug\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setresuid\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "-1",
            "getuid()",
            "getuid()"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "setresuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "658-666",
          "snippet": "int setresuid(uid_t ruid, uid_t euid, uid_t suid) {\n\tif (!orig_setresuid)\n\t\torig_setresuid = (orig_setresuid_t)dlsym(RTLD_NEXT, \"setresuid\");\n\n\tint rv = orig_setresuid(ruid, euid, suid);\n\tprintf(\"%u:%s:setresuid %d %d %d:%d\\n\", pid(), name(), ruid, euid, suid, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_setresuid_t orig_setresuid = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_setresuid_t orig_setresuid = NULL;\n\nint setresuid(uid_t ruid, uid_t euid, uid_t suid) {\n\tif (!orig_setresuid)\n\t\torig_setresuid = (orig_setresuid_t)dlsym(RTLD_NEXT, \"setresuid\");\n\n\tint rv = orig_setresuid(ruid, euid, suid);\n\tprintf(\"%u:%s:setresuid %d %d %d:%d\\n\", pid(), name(), ruid, euid, suid, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setresgid\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "-1",
            "getgid()",
            "getgid()"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "setresgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "670-678",
          "snippet": "int setresgid(gid_t rgid, gid_t egid, gid_t sgid) {\n\tif (!orig_setresgid)\n\t\torig_setresgid = (orig_setresgid_t)dlsym(RTLD_NEXT, \"setresgid\");\n\n\tint rv = orig_setresgid(rgid, egid, sgid);\n\tprintf(\"%u:%s:setresgid %d %d %d:%d\\n\", pid(), name(), rgid, egid, sgid, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_setresgid_t orig_setresgid = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_setresgid_t orig_setresgid = NULL;\n\nint setresgid(gid_t rgid, gid_t egid, gid_t sgid) {\n\tif (!orig_setresgid)\n\t\torig_setresgid = (orig_setresgid_t)dlsym(RTLD_NEXT, \"setresgid\");\n\n\tint rv = orig_setresgid(rgid, egid, sgid);\n\tprintf(\"%u:%s:setresgid %d %d %d:%d\\n\", pid(), name(), rgid, egid, sgid, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid run_no_sandbox(int argc, char **argv) {\n\tEUID_ASSERT();\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\t// process limited subset of options\n\tint i;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--debug\") == 0)\n\t\t\targ_debug = 1;\n\t\telse if (strncmp(argv[i], \"--shell=\", 8) == 0)\n\t\t\tfwarning(\"shell-related command line options are disregarded - using SHELL environment variable\\n\");\n\t}\n\n\t// use $SHELL to get shell used in sandbox, guess shell otherwise\n\tcfg.shell = guess_shell();\n\tif (!cfg.shell) {\n\t\tfprintf(stderr, \"Error: unable to guess your shell, please set SHELL environment variable\\n\");\n\t\texit(1);\n\t}\n\telse if (arg_debug)\n\t\tprintf(\"Selecting %s as shell\\n\", cfg.shell);\n\n\tint prog_index = 0;\n\t// find first non option arg:\n\t//\t- first argument not starting with --,\n\t//\t- whatever follows after -c (example: firejail -c ls)\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-c\") == 0) {\n\t\t\tprog_index = i + 1;\n\t\t\tif (prog_index == argc) {\n\t\t\t\tfprintf(stderr, \"Error: option -c requires an argument\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t// check first argument not starting with --\n\t\tif (strncmp(argv[i],\"--\",2) != 0) {\n\t\t\tprog_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// if shell is /usr/bin/firejail, replace it with /bin/bash\n\tif (strcmp(cfg.shell, PATH_FIREJAIL) == 0) {\n\t\tcfg.shell = \"/bin/bash\";\n\t\tprog_index = 0;\n\t}\n\n\tif (prog_index == 0) {\n\t\tcfg.command_line = cfg.shell;\n\t\tcfg.window_title = cfg.shell;\n\t} else {\n\t\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, prog_index);\n\t}\n\n\tcfg.original_argv = argv;\n\tcfg.original_program_index = prog_index;\n\n\tchar *command;\n\tif (prog_index == 0)\n\t\tcommand = cfg.shell;\n\telse\n\t\tcommand = argv[prog_index];\n\tfwarning(\"an existing sandbox was detected. \"\n\t\t\"%s will run without any additional sandboxing features\\n\", command);\n\n\targ_quiet = 1;\n\n\tstart_application(1, NULL);\n}"
  },
  {
    "function_name": "check_kernel_procs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/no_sandbox.c",
    "lines": "87-160",
    "snippet": "int check_kernel_procs(void) {\n\t// we run this function with EUID set in order to detect grsecurity\n\t// only user processes are available in /proc when running grsecurity\n\t// EUID_ASSERT();\n\n\tchar *kern_proc[] = {\n\t\t\"kthreadd\",\n\t\t\"ksoftirqd\",\n\t\t\"kworker\",\n\t\t\"rcu_sched\",\n\t\t\"rcu_bh\",\n\t\tNULL\t// NULL terminated list\n\t};\n\tint i;\n\n\tif (arg_debug)\n\t\tprintf(\"Looking for kernel processes\\n\");\n\n\t// look at the first 10 processes\n\t// if a kernel process is found, return 1\n\tfor (i = 1; i <= 10; i++) {\n\t\tstruct stat s;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/comm\", i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// open file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfwarning(\"cannot open %s\\n\", fname);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// read file\n\t\tchar buf[100];\n\t\tif (fgets(buf, 10, fp) == NULL) {\n\t\t\tfwarning(\"cannot read %s\\n\", fname);\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\t// clean /n\n\t\tchar *ptr;\n\t\tif ((ptr = strchr(buf, '\\n')) != NULL)\n\t\t\t*ptr = '\\0';\n\n\t\t// check process name against the kernel list\n\t\tint j = 0;\n\t\twhile (kern_proc[j] != NULL) {\n\t\t\tif (strncmp(buf, kern_proc[j], strlen(kern_proc[j])) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s process, we are not running in a sandbox\\n\", buf);\n\t\t\t\tfclose(fp);\n\t\t\t\tfree(fname);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"No kernel processes found, we are already running in a sandbox\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No kernel processes found, we are already running in a sandbox\\n\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Found %s process, we are not running in a sandbox\\n\"",
            "buf"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "kern_proc[j]",
            "strlen(kern_proc[j])"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kern_proc[j]"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"cannot read %s\\n\"",
            "fname"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "10",
            "fp"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/comm\"",
            "i"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Looking for kernel processes\\n\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint check_kernel_procs(void) {\n\t// we run this function with EUID set in order to detect grsecurity\n\t// only user processes are available in /proc when running grsecurity\n\t// EUID_ASSERT();\n\n\tchar *kern_proc[] = {\n\t\t\"kthreadd\",\n\t\t\"ksoftirqd\",\n\t\t\"kworker\",\n\t\t\"rcu_sched\",\n\t\t\"rcu_bh\",\n\t\tNULL\t// NULL terminated list\n\t};\n\tint i;\n\n\tif (arg_debug)\n\t\tprintf(\"Looking for kernel processes\\n\");\n\n\t// look at the first 10 processes\n\t// if a kernel process is found, return 1\n\tfor (i = 1; i <= 10; i++) {\n\t\tstruct stat s;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/comm\", i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// open file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfwarning(\"cannot open %s\\n\", fname);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// read file\n\t\tchar buf[100];\n\t\tif (fgets(buf, 10, fp) == NULL) {\n\t\t\tfwarning(\"cannot read %s\\n\", fname);\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\t// clean /n\n\t\tchar *ptr;\n\t\tif ((ptr = strchr(buf, '\\n')) != NULL)\n\t\t\t*ptr = '\\0';\n\n\t\t// check process name against the kernel list\n\t\tint j = 0;\n\t\twhile (kern_proc[j] != NULL) {\n\t\t\tif (strncmp(buf, kern_proc[j], strlen(kern_proc[j])) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s process, we are not running in a sandbox\\n\", buf);\n\t\t\t\tfclose(fp);\n\t\t\t\tfree(fname);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"No kernel processes found, we are already running in a sandbox\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_namespace_virt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/no_sandbox.c",
    "lines": "40-83",
    "snippet": "int check_namespace_virt(void) {\n\tEUID_ASSERT();\n\n\t// check container environment variable\n\tchar *str = getenv(\"container\");\n\tif (str && is_container(str))\n\t\treturn 1;\n\n\t// check PID 1 container environment variable\n\tEUID_ROOT();\n\tFILE *fp = fopen(\"/proc/1/environ\", \"r\");\n\tif (fp) {\n\t\tint c = 0;\n\t\twhile (c != EOF) {\n\t\t\t// read one line\n\t\t\tchar buf[MAX_BUF];\n\t\t\tint i = 0;\n\t\t\twhile ((c = fgetc(fp)) != EOF) {\n\t\t\t\tif (c == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[i] = (char) c;\n\t\t\t\tif (++i == (MAX_BUF - 1))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf[i] = '\\0';\n\n\t\t\t// check env var name\n\t\t\tif (strncmp(buf, \"container=\", 10) == 0) {\n\t\t\t\t// found it\n\t\t\t\tif (is_container(buf + 10)) {\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tEUID_USER();\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"i %d c %d, buf #%s#\\n\", i, c, buf);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tEUID_USER();\n\treturn 0;\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAX_BUF 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_container",
          "args": [
            "buf + 10"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "is_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/no_sandbox.c",
          "lines": "28-37",
          "snippet": "int is_container(const char *str) {\n\tassert(str);\n\tif (strcmp(str, \"lxc\") == 0 ||\n\t     strcmp(str, \"docker\") == 0 ||\n\t     strcmp(str, \"lxc-libvirt\") == 0 ||\n\t     strcmp(str, \"systemd-nspawn\") == 0 ||\n\t     strcmp(str, \"rkt\") == 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint is_container(const char *str) {\n\tassert(str);\n\tif (strcmp(str, \"lxc\") == 0 ||\n\t     strcmp(str, \"docker\") == 0 ||\n\t     strcmp(str, \"lxc-libvirt\") == 0 ||\n\t     strcmp(str, \"systemd-nspawn\") == 0 ||\n\t     strcmp(str, \"rkt\") == 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"container=\"",
            "10"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "fp"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/1/environ\"",
            "\"r\""
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"container\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nint check_namespace_virt(void) {\n\tEUID_ASSERT();\n\n\t// check container environment variable\n\tchar *str = getenv(\"container\");\n\tif (str && is_container(str))\n\t\treturn 1;\n\n\t// check PID 1 container environment variable\n\tEUID_ROOT();\n\tFILE *fp = fopen(\"/proc/1/environ\", \"r\");\n\tif (fp) {\n\t\tint c = 0;\n\t\twhile (c != EOF) {\n\t\t\t// read one line\n\t\t\tchar buf[MAX_BUF];\n\t\t\tint i = 0;\n\t\t\twhile ((c = fgetc(fp)) != EOF) {\n\t\t\t\tif (c == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[i] = (char) c;\n\t\t\t\tif (++i == (MAX_BUF - 1))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf[i] = '\\0';\n\n\t\t\t// check env var name\n\t\t\tif (strncmp(buf, \"container=\", 10) == 0) {\n\t\t\t\t// found it\n\t\t\t\tif (is_container(buf + 10)) {\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tEUID_USER();\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"i %d c %d, buf #%s#\\n\", i, c, buf);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tEUID_USER();\n\treturn 0;\n}"
  },
  {
    "function_name": "is_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/no_sandbox.c",
    "lines": "28-37",
    "snippet": "int is_container(const char *str) {\n\tassert(str);\n\tif (strcmp(str, \"lxc\") == 0 ||\n\t     strcmp(str, \"docker\") == 0 ||\n\t     strcmp(str, \"lxc-libvirt\") == 0 ||\n\t     strcmp(str, \"systemd-nspawn\") == 0 ||\n\t     strcmp(str, \"rkt\") == 0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"rkt\""
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"systemd-nspawn\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"lxc-libvirt\""
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"docker\""
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"lxc\""
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint is_container(const char *str) {\n\tassert(str);\n\tif (strcmp(str, \"lxc\") == 0 ||\n\t     strcmp(str, \"docker\") == 0 ||\n\t     strcmp(str, \"lxc-libvirt\") == 0 ||\n\t     strcmp(str, \"systemd-nspawn\") == 0 ||\n\t     strcmp(str, \"rkt\") == 0)\n\t\treturn 1;\n\treturn 0;\n}"
  }
]