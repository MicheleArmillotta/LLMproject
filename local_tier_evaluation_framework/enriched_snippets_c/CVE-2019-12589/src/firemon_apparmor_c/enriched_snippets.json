[
  {
    "function_name": "apparmor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/apparmor.c",
    "lines": "58-62",
    "snippet": "void apparmor(pid_t pid, int print_procs) {\n\t(void) pid;\n\t(void) print_procs;\n\tprintf(\"AppArmor support not available\\n\");\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"AppArmor support not available\\n\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include \"firemon.h\"\n\nvoid apparmor(pid_t pid, int print_procs) {\n\t(void) pid;\n\t(void) print_procs;\n\tprintf(\"AppArmor support not available\\n\");\n}"
  },
  {
    "function_name": "apparmor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/apparmor.c",
    "lines": "39-54",
    "snippet": "void apparmor(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_apparmor(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_apparmor",
          "args": [
            "child"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "print_apparmor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/apparmor.c",
          "lines": "25-37",
          "snippet": "static void print_apparmor(int pid) {\n\tchar *label = NULL;\n\tchar *mode = NULL;\n\tint rv = aa_gettaskcon(pid, &label, &mode);\n\tif (rv != -1) {\n\t\tprintf(\"  AppArmor: \");\n\t\tif (label)\n\t\t\tprintf(\"%s \", label);\n\t\tif (mode)\n\t\t\tprintf(\"%s\", mode);\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <sys/apparmor.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/apparmor.h>\n#include \"firemon.h\"\n\nstatic void print_apparmor(int pid) {\n\tchar *label = NULL;\n\tchar *mode = NULL;\n\tint rv = aa_gettaskcon(pid, &label, &mode);\n\tif (rv != -1) {\n\t\tprintf(\"  AppArmor: \");\n\t\tif (label)\n\t\t\tprintf(\"%s \", label);\n\t\tif (mode)\n\t\t\tprintf(\"%s\", mode);\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_child",
          "args": [
            "i"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "65-87",
          "snippet": "int find_child(int id) {\n\tint i;\n\tint first_child = -1;\n\n\t// find the first child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 2 && pids[i].parent == id) {\n\t\t\tfirst_child = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (first_child == -1)\n\t\treturn -1;\n\n\t// find the second child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 3 && pids[i].parent == first_child)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nint find_child(int id) {\n\tint i;\n\tint first_child = -1;\n\n\t// find the first child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 2 && pids[i].parent == id) {\n\t\t\tfirst_child = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (first_child == -1)\n\t\treturn -1;\n\n\t// find the second child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 3 && pids[i].parent == first_child)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_print_list",
          "args": [
            "i",
            "arg_nowrap"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "pid_print_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "271-273",
          "snippet": "void pid_print_list(unsigned index, int nowrap) {\n\tprint_elem(index, nowrap);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\nvoid pid_print_list(unsigned index, int nowrap) {\n\tprint_elem(index, nowrap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_read",
          "args": [
            "pid"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "pid_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "304-428",
          "snippet": "void pid_read(pid_t mon_pid) {\n\tif (pids == NULL) {\n\t\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\t\tif (fp) {\n\t\t\tint val;\n\t\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\t\tif (val >= max_pids)\n\t\t\t\t\tmax_pids = val + 1;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tpids = malloc(sizeof(Process) * max_pids);\n\t\tif (pids == NULL)\n\t\t\terrExit(\"malloc\");\n\t}\n\tmemset(pids, 0, sizeof(Process) * max_pids);\n\tpid_t mypid = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpid_t child = -1;\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (child < 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == mypid)\n\t\t\tcontinue;\n\n\t\t// skip PID 1 just in case we run a sandbox-in-sandbox\n\t\tif (pid == 1)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[PIDS_BUFLEN];\n\t\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"Name:\", 5) == 0) {\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif ((strcmp(ptr, \"firejail\") == 0) && (mon_pid == 0 || mon_pid == pid)) {\n\t\t\t\t\tif (pid_proc_cmdline_x11_xpra_xephyr(pid))\n\t\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t}\n\t\t\tif (strncmp(buf, \"State:\", 6) == 0) {\n\t\t\t\tif (strstr(buf, \"(zombie)\"))\n\t\t\t\t\tpids[pid].zombie = 1;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tunsigned parent = atoi(ptr);\n\t\t\t\tparent %= max_pids;\n\t\t\t\tif (pids[parent].level > 0) {\n\t\t\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t\t\t}\n\t\t\t\tpids[pid].parent = parent;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\t\tchar *ptr = buf + 4;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tpids[pid].uid = atoi(ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\n\tpid_t pid;\n\tfor (pid = 0; pid < max_pids; pid++) {\n\t\tint parent = pids[pid].parent;\n\t\tif (pids[parent].level > 0) {\n\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [
            "#define PIDS_BUFLEN 4096"
          ],
          "globals_used": [
            "Process *pids = NULL;",
            "int max_pids=32769;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\n#define PIDS_BUFLEN 4096\n\nProcess *pids = NULL;\nint max_pids=32769;\n\nvoid pid_read(pid_t mon_pid) {\n\tif (pids == NULL) {\n\t\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\t\tif (fp) {\n\t\t\tint val;\n\t\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\t\tif (val >= max_pids)\n\t\t\t\t\tmax_pids = val + 1;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tpids = malloc(sizeof(Process) * max_pids);\n\t\tif (pids == NULL)\n\t\t\terrExit(\"malloc\");\n\t}\n\tmemset(pids, 0, sizeof(Process) * max_pids);\n\tpid_t mypid = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpid_t child = -1;\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (child < 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == mypid)\n\t\t\tcontinue;\n\n\t\t// skip PID 1 just in case we run a sandbox-in-sandbox\n\t\tif (pid == 1)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[PIDS_BUFLEN];\n\t\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"Name:\", 5) == 0) {\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif ((strcmp(ptr, \"firejail\") == 0) && (mon_pid == 0 || mon_pid == pid)) {\n\t\t\t\t\tif (pid_proc_cmdline_x11_xpra_xephyr(pid))\n\t\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t}\n\t\t\tif (strncmp(buf, \"State:\", 6) == 0) {\n\t\t\t\tif (strstr(buf, \"(zombie)\"))\n\t\t\t\t\tpids[pid].zombie = 1;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tunsigned parent = atoi(ptr);\n\t\t\t\tparent %= max_pids;\n\t\t\t\tif (pids[parent].level > 0) {\n\t\t\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t\t\t}\n\t\t\t\tpids[pid].parent = parent;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\t\tchar *ptr = buf + 4;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tpids[pid].uid = atoi(ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\n\tpid_t pid;\n\tfor (pid = 0; pid < max_pids; pid++) {\n\t\tint parent = pids[pid].parent;\n\t\tif (pids[parent].level > 0) {\n\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include \"firemon.h\"\n\nvoid apparmor(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_apparmor(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "print_apparmor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/apparmor.c",
    "lines": "25-37",
    "snippet": "static void print_apparmor(int pid) {\n\tchar *label = NULL;\n\tchar *mode = NULL;\n\tint rv = aa_gettaskcon(pid, &label, &mode);\n\tif (rv != -1) {\n\t\tprintf(\"  AppArmor: \");\n\t\tif (label)\n\t\t\tprintf(\"%s \", label);\n\t\tif (mode)\n\t\t\tprintf(\"%s\", mode);\n\t\tprintf(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\"",
            "mode"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s \"",
            "label"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  AppArmor: \""
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_gettaskcon",
          "args": [
            "pid",
            "&label",
            "&mode"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include \"firemon.h\"\n\nstatic void print_apparmor(int pid) {\n\tchar *label = NULL;\n\tchar *mode = NULL;\n\tint rv = aa_gettaskcon(pid, &label, &mode);\n\tif (rv != -1) {\n\t\tprintf(\"  AppArmor: \");\n\t\tif (label)\n\t\t\tprintf(\"%s \", label);\n\t\tif (mode)\n\t\t\tprintf(\"%s\", mode);\n\t\tprintf(\"\\n\");\n\t}\n}"
  }
]