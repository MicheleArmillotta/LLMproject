[
  {
    "function_name": "appimage2_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
    "lines": "135-178",
    "snippet": "long unsigned int appimage2_size(const char *fname) {\n\tssize_t ret;\n\tint fd;\n\tlong unsigned int size = 0;\n\n\tfd = open(fname, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tret = pread(fd, ehdr.e_ident, EI_NIDENT, 0);\n\tif (ret != EI_NIDENT)\n\t\tgoto getout;\n\n\tif ((ehdr.e_ident[EI_DATA] != ELFDATA2LSB) &&\n\t     (ehdr.e_ident[EI_DATA] != ELFDATA2MSB))\n\t\tgoto getout;\n\n\tif(ehdr.e_ident[EI_CLASS] == ELFCLASS32) {\n\t\tsize = read_elf32(fd);\n\t}\n\telse if(ehdr.e_ident[EI_CLASS] == ELFCLASS64) {\n\t\tsize = read_elf64(fd);\n\t}\n\telse {\n\t\tgoto getout;\n\t}\n\tif (size == 0)\n\t\tgoto getout;\n\n\n\t// look for a LZMA header at this location\n\tunsigned char buf[4];\n\tret = pread(fd, buf, 4, size);\n\tif (ret != 4) {\n\t\tsize = 0;\n\t\tgoto getout;\n\t}\n\tif (memcmp(buf, \"hsqs\", 4) != 0)\n\t\tsize = 0;\n\ngetout:\n\tclose(fd);\n\treturn size;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <byteswap.h>",
      "#include <elf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static Elf64_Ehdr ehdr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buf",
            "\"hsqs\"",
            "4"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pread",
          "args": [
            "fd",
            "buf",
            "4",
            "size"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_elf64",
          "args": [
            "fd"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "read_elf64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
          "lines": "106-130",
          "snippet": "static long unsigned int read_elf64(int fd) {\n\tElf64_Ehdr ehdr64;\n\tElf64_Shdr shdr64;\n\toff_t last_shdr_offset;\n\tssize_t ret;\n\tunsigned long sht_end, last_section_end;\n\n\tret = pread(fd, &ehdr64, sizeof(ehdr64), 0);\n\tif (ret < 0 || (size_t)ret != sizeof(ehdr))\n\t\treturn 0;\n\n\tehdr.e_shoff            = file64_to_cpu(ehdr64.e_shoff);\n\tehdr.e_shentsize        = file16_to_cpu(ehdr64.e_shentsize);\n\tehdr.e_shnum            = file16_to_cpu(ehdr64.e_shnum);\n\n\tlast_shdr_offset = ehdr.e_shoff + (ehdr.e_shentsize * (ehdr.e_shnum - 1));\n\tret = pread(fd, &shdr64, sizeof(shdr64), last_shdr_offset);\n\tif (ret < 0 || (size_t)ret != sizeof(shdr64))\n\t\treturn 0;\n\n\t/* ELF ends either with the table of section headers (SHT) or with a section. */\n\tsht_end = ehdr.e_shoff + (ehdr.e_shentsize * ehdr.e_shnum);\n\tlast_section_end = file64_to_cpu(shdr64.sh_offset) + file64_to_cpu(shdr64.sh_size);\n\treturn sht_end > last_section_end ? sht_end : last_section_end;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <byteswap.h>",
            "#include <elf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static Elf64_Ehdr ehdr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\nstatic Elf64_Ehdr ehdr;\n\nstatic long unsigned int read_elf64(int fd) {\n\tElf64_Ehdr ehdr64;\n\tElf64_Shdr shdr64;\n\toff_t last_shdr_offset;\n\tssize_t ret;\n\tunsigned long sht_end, last_section_end;\n\n\tret = pread(fd, &ehdr64, sizeof(ehdr64), 0);\n\tif (ret < 0 || (size_t)ret != sizeof(ehdr))\n\t\treturn 0;\n\n\tehdr.e_shoff            = file64_to_cpu(ehdr64.e_shoff);\n\tehdr.e_shentsize        = file16_to_cpu(ehdr64.e_shentsize);\n\tehdr.e_shnum            = file16_to_cpu(ehdr64.e_shnum);\n\n\tlast_shdr_offset = ehdr.e_shoff + (ehdr.e_shentsize * (ehdr.e_shnum - 1));\n\tret = pread(fd, &shdr64, sizeof(shdr64), last_shdr_offset);\n\tif (ret < 0 || (size_t)ret != sizeof(shdr64))\n\t\treturn 0;\n\n\t/* ELF ends either with the table of section headers (SHT) or with a section. */\n\tsht_end = ehdr.e_shoff + (ehdr.e_shentsize * ehdr.e_shnum);\n\tlast_section_end = file64_to_cpu(shdr64.sh_offset) + file64_to_cpu(shdr64.sh_size);\n\treturn sht_end > last_section_end ? sht_end : last_section_end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_elf32",
          "args": [
            "fd"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "read_elf32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
          "lines": "78-102",
          "snippet": "static long unsigned int read_elf32(int fd) {\n\tElf32_Ehdr ehdr32;\n\tElf32_Shdr shdr32;\n\toff_t last_shdr_offset;\n\tssize_t ret;\n\tunsigned long sht_end, last_section_end;\n\n\tret = pread(fd, &ehdr32, sizeof(ehdr32), 0);\n\tif (ret < 0 || (size_t)ret != sizeof(ehdr))\n\t\treturn 0;\n\n\tehdr.e_shoff            = file32_to_cpu(ehdr32.e_shoff);\n\tehdr.e_shentsize        = file16_to_cpu(ehdr32.e_shentsize);\n\tehdr.e_shnum            = file16_to_cpu(ehdr32.e_shnum);\n\n\tlast_shdr_offset = ehdr.e_shoff + (ehdr.e_shentsize * (ehdr.e_shnum - 1));\n\tret = pread(fd, &shdr32, sizeof(shdr32), last_shdr_offset);\n\tif (ret < 0 || (size_t)ret != sizeof(shdr32))\n\t\treturn 0;\n\n\t/* ELF ends either with the table of section headers (SHT) or with a section. */\n\tsht_end = ehdr.e_shoff + (ehdr.e_shentsize * ehdr.e_shnum);\n\tlast_section_end = file64_to_cpu(shdr32.sh_offset) + file64_to_cpu(shdr32.sh_size);\n\treturn sht_end > last_section_end ? sht_end : last_section_end;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <byteswap.h>",
            "#include <elf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static Elf64_Ehdr ehdr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\nstatic Elf64_Ehdr ehdr;\n\nstatic long unsigned int read_elf32(int fd) {\n\tElf32_Ehdr ehdr32;\n\tElf32_Shdr shdr32;\n\toff_t last_shdr_offset;\n\tssize_t ret;\n\tunsigned long sht_end, last_section_end;\n\n\tret = pread(fd, &ehdr32, sizeof(ehdr32), 0);\n\tif (ret < 0 || (size_t)ret != sizeof(ehdr))\n\t\treturn 0;\n\n\tehdr.e_shoff            = file32_to_cpu(ehdr32.e_shoff);\n\tehdr.e_shentsize        = file16_to_cpu(ehdr32.e_shentsize);\n\tehdr.e_shnum            = file16_to_cpu(ehdr32.e_shnum);\n\n\tlast_shdr_offset = ehdr.e_shoff + (ehdr.e_shentsize * (ehdr.e_shnum - 1));\n\tret = pread(fd, &shdr32, sizeof(shdr32), last_shdr_offset);\n\tif (ret < 0 || (size_t)ret != sizeof(shdr32))\n\t\treturn 0;\n\n\t/* ELF ends either with the table of section headers (SHT) or with a section. */\n\tsht_end = ehdr.e_shoff + (ehdr.e_shentsize * ehdr.e_shnum);\n\tlast_section_end = file64_to_cpu(shdr32.sh_offset) + file64_to_cpu(shdr32.sh_size);\n\treturn sht_end > last_section_end ? sht_end : last_section_end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pread",
          "args": [
            "fd",
            "ehdr.e_ident",
            "EI_NIDENT",
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "fname",
            "O_RDONLY"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\nstatic Elf64_Ehdr ehdr;\n\nlong unsigned int appimage2_size(const char *fname) {\n\tssize_t ret;\n\tint fd;\n\tlong unsigned int size = 0;\n\n\tfd = open(fname, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tret = pread(fd, ehdr.e_ident, EI_NIDENT, 0);\n\tif (ret != EI_NIDENT)\n\t\tgoto getout;\n\n\tif ((ehdr.e_ident[EI_DATA] != ELFDATA2LSB) &&\n\t     (ehdr.e_ident[EI_DATA] != ELFDATA2MSB))\n\t\tgoto getout;\n\n\tif(ehdr.e_ident[EI_CLASS] == ELFCLASS32) {\n\t\tsize = read_elf32(fd);\n\t}\n\telse if(ehdr.e_ident[EI_CLASS] == ELFCLASS64) {\n\t\tsize = read_elf64(fd);\n\t}\n\telse {\n\t\tgoto getout;\n\t}\n\tif (size == 0)\n\t\tgoto getout;\n\n\n\t// look for a LZMA header at this location\n\tunsigned char buf[4];\n\tret = pread(fd, buf, 4, size);\n\tif (ret != 4) {\n\t\tsize = 0;\n\t\tgoto getout;\n\t}\n\tif (memcmp(buf, \"hsqs\", 4) != 0)\n\t\tsize = 0;\n\ngetout:\n\tclose(fd);\n\treturn size;\n}"
  },
  {
    "function_name": "read_elf64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
    "lines": "106-130",
    "snippet": "static long unsigned int read_elf64(int fd) {\n\tElf64_Ehdr ehdr64;\n\tElf64_Shdr shdr64;\n\toff_t last_shdr_offset;\n\tssize_t ret;\n\tunsigned long sht_end, last_section_end;\n\n\tret = pread(fd, &ehdr64, sizeof(ehdr64), 0);\n\tif (ret < 0 || (size_t)ret != sizeof(ehdr))\n\t\treturn 0;\n\n\tehdr.e_shoff            = file64_to_cpu(ehdr64.e_shoff);\n\tehdr.e_shentsize        = file16_to_cpu(ehdr64.e_shentsize);\n\tehdr.e_shnum            = file16_to_cpu(ehdr64.e_shnum);\n\n\tlast_shdr_offset = ehdr.e_shoff + (ehdr.e_shentsize * (ehdr.e_shnum - 1));\n\tret = pread(fd, &shdr64, sizeof(shdr64), last_shdr_offset);\n\tif (ret < 0 || (size_t)ret != sizeof(shdr64))\n\t\treturn 0;\n\n\t/* ELF ends either with the table of section headers (SHT) or with a section. */\n\tsht_end = ehdr.e_shoff + (ehdr.e_shentsize * ehdr.e_shnum);\n\tlast_section_end = file64_to_cpu(shdr64.sh_offset) + file64_to_cpu(shdr64.sh_size);\n\treturn sht_end > last_section_end ? sht_end : last_section_end;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <byteswap.h>",
      "#include <elf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static Elf64_Ehdr ehdr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file64_to_cpu",
          "args": [
            "shdr64.sh_size"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "file64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
          "lines": "70-74",
          "snippet": "static uint64_t file64_to_cpu(uint64_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_64(val);\n\treturn val;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <byteswap.h>",
            "#include <elf.h>"
          ],
          "macros_used": [
            "#define ELFDATANATIVE ELFDATA2MSB",
            "#define ELFDATANATIVE ELFDATA2LSB"
          ],
          "globals_used": [
            "static Elf64_Ehdr ehdr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\n#define ELFDATANATIVE ELFDATA2MSB\n#define ELFDATANATIVE ELFDATA2LSB\n\nstatic Elf64_Ehdr ehdr;\n\nstatic uint64_t file64_to_cpu(uint64_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_64(val);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pread",
          "args": [
            "fd",
            "&shdr64",
            "sizeof(shdr64)",
            "last_shdr_offset"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file16_to_cpu",
          "args": [
            "ehdr64.e_shnum"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "file16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
          "lines": "56-60",
          "snippet": "static uint16_t file16_to_cpu(uint16_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_16(val);\n\treturn val;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <byteswap.h>",
            "#include <elf.h>"
          ],
          "macros_used": [
            "#define ELFDATANATIVE ELFDATA2MSB",
            "#define ELFDATANATIVE ELFDATA2LSB"
          ],
          "globals_used": [
            "static Elf64_Ehdr ehdr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\n#define ELFDATANATIVE ELFDATA2MSB\n#define ELFDATANATIVE ELFDATA2LSB\n\nstatic Elf64_Ehdr ehdr;\n\nstatic uint16_t file16_to_cpu(uint16_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_16(val);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pread",
          "args": [
            "fd",
            "&ehdr64",
            "sizeof(ehdr64)",
            "0"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\nstatic Elf64_Ehdr ehdr;\n\nstatic long unsigned int read_elf64(int fd) {\n\tElf64_Ehdr ehdr64;\n\tElf64_Shdr shdr64;\n\toff_t last_shdr_offset;\n\tssize_t ret;\n\tunsigned long sht_end, last_section_end;\n\n\tret = pread(fd, &ehdr64, sizeof(ehdr64), 0);\n\tif (ret < 0 || (size_t)ret != sizeof(ehdr))\n\t\treturn 0;\n\n\tehdr.e_shoff            = file64_to_cpu(ehdr64.e_shoff);\n\tehdr.e_shentsize        = file16_to_cpu(ehdr64.e_shentsize);\n\tehdr.e_shnum            = file16_to_cpu(ehdr64.e_shnum);\n\n\tlast_shdr_offset = ehdr.e_shoff + (ehdr.e_shentsize * (ehdr.e_shnum - 1));\n\tret = pread(fd, &shdr64, sizeof(shdr64), last_shdr_offset);\n\tif (ret < 0 || (size_t)ret != sizeof(shdr64))\n\t\treturn 0;\n\n\t/* ELF ends either with the table of section headers (SHT) or with a section. */\n\tsht_end = ehdr.e_shoff + (ehdr.e_shentsize * ehdr.e_shnum);\n\tlast_section_end = file64_to_cpu(shdr64.sh_offset) + file64_to_cpu(shdr64.sh_size);\n\treturn sht_end > last_section_end ? sht_end : last_section_end;\n}"
  },
  {
    "function_name": "read_elf32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
    "lines": "78-102",
    "snippet": "static long unsigned int read_elf32(int fd) {\n\tElf32_Ehdr ehdr32;\n\tElf32_Shdr shdr32;\n\toff_t last_shdr_offset;\n\tssize_t ret;\n\tunsigned long sht_end, last_section_end;\n\n\tret = pread(fd, &ehdr32, sizeof(ehdr32), 0);\n\tif (ret < 0 || (size_t)ret != sizeof(ehdr))\n\t\treturn 0;\n\n\tehdr.e_shoff            = file32_to_cpu(ehdr32.e_shoff);\n\tehdr.e_shentsize        = file16_to_cpu(ehdr32.e_shentsize);\n\tehdr.e_shnum            = file16_to_cpu(ehdr32.e_shnum);\n\n\tlast_shdr_offset = ehdr.e_shoff + (ehdr.e_shentsize * (ehdr.e_shnum - 1));\n\tret = pread(fd, &shdr32, sizeof(shdr32), last_shdr_offset);\n\tif (ret < 0 || (size_t)ret != sizeof(shdr32))\n\t\treturn 0;\n\n\t/* ELF ends either with the table of section headers (SHT) or with a section. */\n\tsht_end = ehdr.e_shoff + (ehdr.e_shentsize * ehdr.e_shnum);\n\tlast_section_end = file64_to_cpu(shdr32.sh_offset) + file64_to_cpu(shdr32.sh_size);\n\treturn sht_end > last_section_end ? sht_end : last_section_end;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <byteswap.h>",
      "#include <elf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static Elf64_Ehdr ehdr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file64_to_cpu",
          "args": [
            "shdr32.sh_size"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "file64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
          "lines": "70-74",
          "snippet": "static uint64_t file64_to_cpu(uint64_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_64(val);\n\treturn val;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <byteswap.h>",
            "#include <elf.h>"
          ],
          "macros_used": [
            "#define ELFDATANATIVE ELFDATA2MSB",
            "#define ELFDATANATIVE ELFDATA2LSB"
          ],
          "globals_used": [
            "static Elf64_Ehdr ehdr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\n#define ELFDATANATIVE ELFDATA2MSB\n#define ELFDATANATIVE ELFDATA2LSB\n\nstatic Elf64_Ehdr ehdr;\n\nstatic uint64_t file64_to_cpu(uint64_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_64(val);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pread",
          "args": [
            "fd",
            "&shdr32",
            "sizeof(shdr32)",
            "last_shdr_offset"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file16_to_cpu",
          "args": [
            "ehdr32.e_shnum"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "file16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
          "lines": "56-60",
          "snippet": "static uint16_t file16_to_cpu(uint16_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_16(val);\n\treturn val;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <byteswap.h>",
            "#include <elf.h>"
          ],
          "macros_used": [
            "#define ELFDATANATIVE ELFDATA2MSB",
            "#define ELFDATANATIVE ELFDATA2LSB"
          ],
          "globals_used": [
            "static Elf64_Ehdr ehdr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\n#define ELFDATANATIVE ELFDATA2MSB\n#define ELFDATANATIVE ELFDATA2LSB\n\nstatic Elf64_Ehdr ehdr;\n\nstatic uint16_t file16_to_cpu(uint16_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_16(val);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file32_to_cpu",
          "args": [
            "ehdr32.e_shoff"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "file32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
          "lines": "63-67",
          "snippet": "static uint32_t file32_to_cpu(uint32_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_32(val);\n\treturn val;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <byteswap.h>",
            "#include <elf.h>"
          ],
          "macros_used": [
            "#define ELFDATANATIVE ELFDATA2MSB",
            "#define ELFDATANATIVE ELFDATA2LSB"
          ],
          "globals_used": [
            "static Elf64_Ehdr ehdr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\n#define ELFDATANATIVE ELFDATA2MSB\n#define ELFDATANATIVE ELFDATA2LSB\n\nstatic Elf64_Ehdr ehdr;\n\nstatic uint32_t file32_to_cpu(uint32_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_32(val);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pread",
          "args": [
            "fd",
            "&ehdr32",
            "sizeof(ehdr32)",
            "0"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\nstatic Elf64_Ehdr ehdr;\n\nstatic long unsigned int read_elf32(int fd) {\n\tElf32_Ehdr ehdr32;\n\tElf32_Shdr shdr32;\n\toff_t last_shdr_offset;\n\tssize_t ret;\n\tunsigned long sht_end, last_section_end;\n\n\tret = pread(fd, &ehdr32, sizeof(ehdr32), 0);\n\tif (ret < 0 || (size_t)ret != sizeof(ehdr))\n\t\treturn 0;\n\n\tehdr.e_shoff            = file32_to_cpu(ehdr32.e_shoff);\n\tehdr.e_shentsize        = file16_to_cpu(ehdr32.e_shentsize);\n\tehdr.e_shnum            = file16_to_cpu(ehdr32.e_shnum);\n\n\tlast_shdr_offset = ehdr.e_shoff + (ehdr.e_shentsize * (ehdr.e_shnum - 1));\n\tret = pread(fd, &shdr32, sizeof(shdr32), last_shdr_offset);\n\tif (ret < 0 || (size_t)ret != sizeof(shdr32))\n\t\treturn 0;\n\n\t/* ELF ends either with the table of section headers (SHT) or with a section. */\n\tsht_end = ehdr.e_shoff + (ehdr.e_shentsize * ehdr.e_shnum);\n\tlast_section_end = file64_to_cpu(shdr32.sh_offset) + file64_to_cpu(shdr32.sh_size);\n\treturn sht_end > last_section_end ? sht_end : last_section_end;\n}"
  },
  {
    "function_name": "file64_to_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
    "lines": "70-74",
    "snippet": "static uint64_t file64_to_cpu(uint64_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_64(val);\n\treturn val;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <byteswap.h>",
      "#include <elf.h>"
    ],
    "macros_used": [
      "#define ELFDATANATIVE ELFDATA2MSB",
      "#define ELFDATANATIVE ELFDATA2LSB"
    ],
    "globals_used": [
      "static Elf64_Ehdr ehdr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bswap_64",
          "args": [
            "val"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\n#define ELFDATANATIVE ELFDATA2MSB\n#define ELFDATANATIVE ELFDATA2LSB\n\nstatic Elf64_Ehdr ehdr;\n\nstatic uint64_t file64_to_cpu(uint64_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_64(val);\n\treturn val;\n}"
  },
  {
    "function_name": "file32_to_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
    "lines": "63-67",
    "snippet": "static uint32_t file32_to_cpu(uint32_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_32(val);\n\treturn val;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <byteswap.h>",
      "#include <elf.h>"
    ],
    "macros_used": [
      "#define ELFDATANATIVE ELFDATA2MSB",
      "#define ELFDATANATIVE ELFDATA2LSB"
    ],
    "globals_used": [
      "static Elf64_Ehdr ehdr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bswap_32",
          "args": [
            "val"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\n#define ELFDATANATIVE ELFDATA2MSB\n#define ELFDATANATIVE ELFDATA2LSB\n\nstatic Elf64_Ehdr ehdr;\n\nstatic uint32_t file32_to_cpu(uint32_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_32(val);\n\treturn val;\n}"
  },
  {
    "function_name": "file16_to_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage_size.c",
    "lines": "56-60",
    "snippet": "static uint16_t file16_to_cpu(uint16_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_16(val);\n\treturn val;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <byteswap.h>",
      "#include <elf.h>"
    ],
    "macros_used": [
      "#define ELFDATANATIVE ELFDATA2MSB",
      "#define ELFDATANATIVE ELFDATA2LSB"
    ],
    "globals_used": [
      "static Elf64_Ehdr ehdr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bswap_16",
          "args": [
            "val"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <byteswap.h>\n#include <elf.h>\n\n#define ELFDATANATIVE ELFDATA2MSB\n#define ELFDATANATIVE ELFDATA2LSB\n\nstatic Elf64_Ehdr ehdr;\n\nstatic uint16_t file16_to_cpu(uint16_t val) {\n\tif (ehdr.e_ident[EI_DATA] != ELFDATANATIVE)\n\t\tval = bswap_16(val);\n\treturn val;\n}"
  }
]