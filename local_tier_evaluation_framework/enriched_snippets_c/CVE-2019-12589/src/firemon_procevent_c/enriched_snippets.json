[
  {
    "function_name": "procevent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/procevent.c",
    "lines": "484-501",
    "snippet": "void procevent(pid_t pid) {\n\t// need to be root for this\n\tif (getuid() != 0) {\n\t\tfprintf(stderr, \"Error: you need to be root to get process events\\n\");\n\t\texit(1);\n\t}\n\n\t// monitor using netlink\n\tint sock = procevent_netlink_setup();\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error: cannot open netlink socket\\n\");\n\t\texit(1);\n\t}\n\n\tprocevent_monitor(sock, pid); // it will never return from here\n\tassert(0);\n\tclose(sock); // quiet static analyzers\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <time.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/netlink.h>",
      "#include <linux/connector.h>",
      "#include <sys/socket.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "procevent_monitor",
          "args": [
            "sock",
            "pid"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "procevent_monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/procevent.c",
          "lines": "209-482",
          "snippet": "static int procevent_monitor(const int sock, pid_t mypid) {\n\tssize_t len;\n\tstruct nlmsghdr *nlmsghdr;\n\n\t// timeout in order to re-enable firejail module trace\n\tstruct timeval tv;\n\ttv.tv_sec = 30;\n\ttv.tv_usec = 0;\n\n\twhile (1) {\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\n#define BUFFSIZE 4096\n\t\tchar __attribute__ ((aligned(NLMSG_ALIGNTO)))buf[BUFFSIZE];\n\n\t\tfd_set readfds;\n\t\tint max;\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(sock, &readfds);\n\t\tmax = sock;\n\t\tmax++;\n\n\t\tint rv = select(max, &readfds, NULL, NULL, &tv);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"recv: %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\t// timeout\n\t\tif (rv == 0) {\n\t\t\ttv.tv_sec = 30;\n\t\t\ttv.tv_usec = 0;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif ((len = recv(sock, buf, sizeof(buf), 0)) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (len == -1) {\n\t\t\tif (errno == EINTR) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\"recv: %s\\n\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (nlmsghdr = (struct nlmsghdr *)buf;\n\t\t\tNLMSG_OK (nlmsghdr, (unsigned) len);\n\t\t\tnlmsghdr = NLMSG_NEXT (nlmsghdr, len)) {\n\n\t\t\tstruct cn_msg *cn_msg;\n\t\t\tstruct proc_event *proc_ev;\n\t\t\tstruct tm tm;\n\t\t\ttime_t now;\n\n\t\t\tif ((nlmsghdr->nlmsg_type == NLMSG_ERROR) ||\n\t\t\t    (nlmsghdr->nlmsg_type == NLMSG_NOOP))\n\t\t\t\tcontinue;\n\n\t\t\tcn_msg = NLMSG_DATA(nlmsghdr);\n\t\t\tif ((cn_msg->id.idx != CN_IDX_PROC) ||\n\t\t\t    (cn_msg->id.val != CN_VAL_PROC))\n\t\t\t\tcontinue;\n\n\t\t\t(void)time(&now);\n\t\t\t(void)localtime_r(&now, &tm);\n\t\t\tchar line[PIDS_BUFLEN];\n\t\t\tchar *lineptr = line;\n\t\t\tsprintf(lineptr, \"%2.2d:%2.2d:%2.2d\", tm.tm_hour, tm.tm_min, tm.tm_sec);\n\t\t\tlineptr += strlen(lineptr);\n\n\t\t\tproc_ev = (struct proc_event *)cn_msg->data;\n\t\t\tpid_t pid = 0;\n\t\t\tpid_t child = 0;\n\t\t\tint remove_pid = 0;\n\t\t\tswitch (proc_ev->what) {\n\t\t\t\tcase PROC_EVENT_FORK:\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event fork\\n\", __FUNCTION__, __LINE__);\n#endif\n\t\t\t\t\tif (proc_ev->event_data.fork.child_pid !=\n\t\t\t\t\t    proc_ev->event_data.fork.child_tgid)\n\t\t\t\t\t    \tcontinue; // this is a thread, not a process\n\t\t\t\t\tpid = proc_ev->event_data.fork.parent_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event fork, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level > 0) {\n\t\t\t\t\t\tchild = proc_ev->event_data.fork.child_tgid;\n\t\t\t\t\t\tchild %= max_pids;\n\t\t\t\t\t\tpids[child].level = pids[pid].level + 1;\n\t\t\t\t\t\tpids[child].uid = pid_get_uid(child);\n\t\t\t\t\t\tpids[child].parent = pid;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf(lineptr, \" fork\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase PROC_EVENT_EXEC:\n\t\t\t\t\tpid = proc_ev->event_data.exec.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event exec, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == -1) {\n\t\t\t\t\t\tpids[pid].level = 0; // start tracking\n\t\t\t\t\t}\n\t\t\t\t\tsprintf(lineptr, \" exec\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PROC_EVENT_EXIT:\n\t\t\t\t\tif (proc_ev->event_data.exit.process_pid !=\n\t\t\t\t\t    proc_ev->event_data.exit.process_tgid)\n\t\t\t\t\t\tcontinue; // this is a thread, not a process\n\n\t\t\t\t\tpid = proc_ev->event_data.exit.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event exit, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tremove_pid = 1;\n\t\t\t\t\tsprintf(lineptr, \" exit\");\n\t\t\t\t\tbreak;\n\n\n\n\t\t\t\tcase PROC_EVENT_UID:\n\t\t\t\t\tpid = proc_ev->event_data.id.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event uid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == 1 ||\n\t\t\t\t\t    pids[pids[pid].parent].level == 1) {\n\t\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(lineptr, \" uid (%d:%d)\",\n\t\t\t\t\t\t\tproc_ev->event_data.id.r.ruid,\n\t\t\t\t\t\t\tproc_ev->event_data.id.e.euid);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PROC_EVENT_GID:\n\t\t\t\t\tpid = proc_ev->event_data.id.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event gid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == 1 ||\n\t\t\t\t\t    pids[pids[pid].parent].level == 1) {\n\t\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(lineptr, \" gid (%d:%d)\",\n\t\t\t\t\t\t\tproc_ev->event_data.id.r.rgid,\n\t\t\t\t\t\t\tproc_ev->event_data.id.e.egid);\n\t\t\t\t\tbreak;\n\n\n\n\t\t\t\tcase PROC_EVENT_SID:\n\t\t\t\t\tpid = proc_ev->event_data.sid.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event sid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tsprintf(lineptr, \" sid \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event unknown\\n\", __FUNCTION__, __LINE__);\n#endif\n\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint add_new = 0;\n\t\t\tif (pids[pid].level < 0)\t// not a firejail process\n\t\t\t\tcontinue;\n\t\t\telse if (pids[pid].level == 0) { // new process, do we track it?\n\t\t\t\tif (pid_is_firejail(pid) && mypid == 0) {\n\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t\tadd_new = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlineptr += strlen(lineptr);\n\t\t\tsprintf(lineptr, \" %u\", pid);\n\t\t\tlineptr += strlen(lineptr);\n\n\t\t\tchar *user = pids[pid].user;\n\t\t\tif (!user)\n\t\t\t\tuser = pid_get_user_name(pids[pid].uid);\n\t\t\tif (user) {\n\t\t\t\tpids[pid].user = user;\n\t\t\t\tsprintf(lineptr, \" (%s)\", user);\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\n\n\t\t\tint sandbox_closed = 0; // exit sandbox flag\n\t\t\tchar *cmd = pids[pid].cmd;\n\t\t\tif (!cmd) {\n\t\t\t\tcmd = pid_proc_cmdline(pid);\n\t\t\t}\n\t\t\tif (add_new) {\n\t\t\t\tif (!cmd)\n\t\t\t\t\tsprintf(lineptr, \" NEW SANDBOX\\n\");\n\t\t\t\telse\n\t\t\t\t\tsprintf(lineptr, \" NEW SANDBOX: %s\\n\", cmd);\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\t\t\telse if (proc_ev->what == PROC_EVENT_EXIT && pids[pid].level == 1) {\n\t\t\t\tsprintf(lineptr, \" EXIT SANDBOX\\n\");\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t\tif (mypid == pid)\n\t\t\t\t\tsandbox_closed = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!cmd) {\n\t\t\t\t\tcmd = pid_proc_cmdline(pid);\n\t\t\t\t}\n\t\t\t\tif (cmd == NULL)\n\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\telse {\n\t\t\t\t\tsprintf(lineptr, \" %s\\n\", cmd);\n\t\t\t\t\tfree(cmd);\n\t\t\t\t}\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\t\t\t(void) lineptr;\n\n\t\t\t// print the event\n\t\t\tprintf(\"%s\", line);\n\t\t\tfflush(0);\n\n\t\t\t// unflag pid for exit events\n\t\t\tif (remove_pid) {\n\t\t\t\tif (pids[pid].user)\n\t\t\t\t\tfree(pids[pid].user);\n\t\t\t\tif (pids[pid].cmd)\n\t\t\t\t\tfree(pids[pid].cmd);\n\t\t\t\tmemset(&pids[pid], 0, sizeof(Process));\n\t\t\t}\n\n\t\t\t// print forked child\n\t\t\tif (child) {\n\t\t\t\tcmd = pid_proc_cmdline(child);\n\t\t\t\tif (cmd) {\n\t\t\t\t\tprintf(\"\\tchild %u %s\\n\", child, cmd);\n\t\t\t\t\tfree(cmd);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tprintf(\"\\tchild %u\\n\", child);\n\t\t\t}\n\n\t\t\t// on uid events the uid is changing\n\t\t\tif (proc_ev->what == PROC_EVENT_UID) {\n\t\t\t\tif (pids[pid].user)\n\t\t\t\t\tfree(pids[pid].user);\n\t\t\t\tpids[pid].user = 0;\n\t\t\t\tpids[pid].uid = pid_get_uid(pid);\n\t\t\t}\n\n\t\t\tif (sandbox_closed)\n\t\t\t\texit(0);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <time.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/netlink.h>",
            "#include <linux/connector.h>",
            "#include <sys/socket.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [
            "#define BUFFSIZE 4096",
            "#define PIDS_BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <time.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <linux/cn_proc.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <sys/socket.h>\n#include \"firemon.h\"\n\n#define BUFFSIZE 4096\n#define PIDS_BUFLEN 4096\n\nstatic int procevent_monitor(const int sock, pid_t mypid) {\n\tssize_t len;\n\tstruct nlmsghdr *nlmsghdr;\n\n\t// timeout in order to re-enable firejail module trace\n\tstruct timeval tv;\n\ttv.tv_sec = 30;\n\ttv.tv_usec = 0;\n\n\twhile (1) {\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\n#define BUFFSIZE 4096\n\t\tchar __attribute__ ((aligned(NLMSG_ALIGNTO)))buf[BUFFSIZE];\n\n\t\tfd_set readfds;\n\t\tint max;\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(sock, &readfds);\n\t\tmax = sock;\n\t\tmax++;\n\n\t\tint rv = select(max, &readfds, NULL, NULL, &tv);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"recv: %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\t// timeout\n\t\tif (rv == 0) {\n\t\t\ttv.tv_sec = 30;\n\t\t\ttv.tv_usec = 0;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif ((len = recv(sock, buf, sizeof(buf), 0)) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (len == -1) {\n\t\t\tif (errno == EINTR) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\"recv: %s\\n\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (nlmsghdr = (struct nlmsghdr *)buf;\n\t\t\tNLMSG_OK (nlmsghdr, (unsigned) len);\n\t\t\tnlmsghdr = NLMSG_NEXT (nlmsghdr, len)) {\n\n\t\t\tstruct cn_msg *cn_msg;\n\t\t\tstruct proc_event *proc_ev;\n\t\t\tstruct tm tm;\n\t\t\ttime_t now;\n\n\t\t\tif ((nlmsghdr->nlmsg_type == NLMSG_ERROR) ||\n\t\t\t    (nlmsghdr->nlmsg_type == NLMSG_NOOP))\n\t\t\t\tcontinue;\n\n\t\t\tcn_msg = NLMSG_DATA(nlmsghdr);\n\t\t\tif ((cn_msg->id.idx != CN_IDX_PROC) ||\n\t\t\t    (cn_msg->id.val != CN_VAL_PROC))\n\t\t\t\tcontinue;\n\n\t\t\t(void)time(&now);\n\t\t\t(void)localtime_r(&now, &tm);\n\t\t\tchar line[PIDS_BUFLEN];\n\t\t\tchar *lineptr = line;\n\t\t\tsprintf(lineptr, \"%2.2d:%2.2d:%2.2d\", tm.tm_hour, tm.tm_min, tm.tm_sec);\n\t\t\tlineptr += strlen(lineptr);\n\n\t\t\tproc_ev = (struct proc_event *)cn_msg->data;\n\t\t\tpid_t pid = 0;\n\t\t\tpid_t child = 0;\n\t\t\tint remove_pid = 0;\n\t\t\tswitch (proc_ev->what) {\n\t\t\t\tcase PROC_EVENT_FORK:\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event fork\\n\", __FUNCTION__, __LINE__);\n#endif\n\t\t\t\t\tif (proc_ev->event_data.fork.child_pid !=\n\t\t\t\t\t    proc_ev->event_data.fork.child_tgid)\n\t\t\t\t\t    \tcontinue; // this is a thread, not a process\n\t\t\t\t\tpid = proc_ev->event_data.fork.parent_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event fork, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level > 0) {\n\t\t\t\t\t\tchild = proc_ev->event_data.fork.child_tgid;\n\t\t\t\t\t\tchild %= max_pids;\n\t\t\t\t\t\tpids[child].level = pids[pid].level + 1;\n\t\t\t\t\t\tpids[child].uid = pid_get_uid(child);\n\t\t\t\t\t\tpids[child].parent = pid;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf(lineptr, \" fork\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase PROC_EVENT_EXEC:\n\t\t\t\t\tpid = proc_ev->event_data.exec.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event exec, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == -1) {\n\t\t\t\t\t\tpids[pid].level = 0; // start tracking\n\t\t\t\t\t}\n\t\t\t\t\tsprintf(lineptr, \" exec\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PROC_EVENT_EXIT:\n\t\t\t\t\tif (proc_ev->event_data.exit.process_pid !=\n\t\t\t\t\t    proc_ev->event_data.exit.process_tgid)\n\t\t\t\t\t\tcontinue; // this is a thread, not a process\n\n\t\t\t\t\tpid = proc_ev->event_data.exit.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event exit, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tremove_pid = 1;\n\t\t\t\t\tsprintf(lineptr, \" exit\");\n\t\t\t\t\tbreak;\n\n\n\n\t\t\t\tcase PROC_EVENT_UID:\n\t\t\t\t\tpid = proc_ev->event_data.id.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event uid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == 1 ||\n\t\t\t\t\t    pids[pids[pid].parent].level == 1) {\n\t\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(lineptr, \" uid (%d:%d)\",\n\t\t\t\t\t\t\tproc_ev->event_data.id.r.ruid,\n\t\t\t\t\t\t\tproc_ev->event_data.id.e.euid);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PROC_EVENT_GID:\n\t\t\t\t\tpid = proc_ev->event_data.id.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event gid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == 1 ||\n\t\t\t\t\t    pids[pids[pid].parent].level == 1) {\n\t\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(lineptr, \" gid (%d:%d)\",\n\t\t\t\t\t\t\tproc_ev->event_data.id.r.rgid,\n\t\t\t\t\t\t\tproc_ev->event_data.id.e.egid);\n\t\t\t\t\tbreak;\n\n\n\n\t\t\t\tcase PROC_EVENT_SID:\n\t\t\t\t\tpid = proc_ev->event_data.sid.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event sid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tsprintf(lineptr, \" sid \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event unknown\\n\", __FUNCTION__, __LINE__);\n#endif\n\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint add_new = 0;\n\t\t\tif (pids[pid].level < 0)\t// not a firejail process\n\t\t\t\tcontinue;\n\t\t\telse if (pids[pid].level == 0) { // new process, do we track it?\n\t\t\t\tif (pid_is_firejail(pid) && mypid == 0) {\n\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t\tadd_new = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlineptr += strlen(lineptr);\n\t\t\tsprintf(lineptr, \" %u\", pid);\n\t\t\tlineptr += strlen(lineptr);\n\n\t\t\tchar *user = pids[pid].user;\n\t\t\tif (!user)\n\t\t\t\tuser = pid_get_user_name(pids[pid].uid);\n\t\t\tif (user) {\n\t\t\t\tpids[pid].user = user;\n\t\t\t\tsprintf(lineptr, \" (%s)\", user);\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\n\n\t\t\tint sandbox_closed = 0; // exit sandbox flag\n\t\t\tchar *cmd = pids[pid].cmd;\n\t\t\tif (!cmd) {\n\t\t\t\tcmd = pid_proc_cmdline(pid);\n\t\t\t}\n\t\t\tif (add_new) {\n\t\t\t\tif (!cmd)\n\t\t\t\t\tsprintf(lineptr, \" NEW SANDBOX\\n\");\n\t\t\t\telse\n\t\t\t\t\tsprintf(lineptr, \" NEW SANDBOX: %s\\n\", cmd);\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\t\t\telse if (proc_ev->what == PROC_EVENT_EXIT && pids[pid].level == 1) {\n\t\t\t\tsprintf(lineptr, \" EXIT SANDBOX\\n\");\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t\tif (mypid == pid)\n\t\t\t\t\tsandbox_closed = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!cmd) {\n\t\t\t\t\tcmd = pid_proc_cmdline(pid);\n\t\t\t\t}\n\t\t\t\tif (cmd == NULL)\n\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\telse {\n\t\t\t\t\tsprintf(lineptr, \" %s\\n\", cmd);\n\t\t\t\t\tfree(cmd);\n\t\t\t\t}\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\t\t\t(void) lineptr;\n\n\t\t\t// print the event\n\t\t\tprintf(\"%s\", line);\n\t\t\tfflush(0);\n\n\t\t\t// unflag pid for exit events\n\t\t\tif (remove_pid) {\n\t\t\t\tif (pids[pid].user)\n\t\t\t\t\tfree(pids[pid].user);\n\t\t\t\tif (pids[pid].cmd)\n\t\t\t\t\tfree(pids[pid].cmd);\n\t\t\t\tmemset(&pids[pid], 0, sizeof(Process));\n\t\t\t}\n\n\t\t\t// print forked child\n\t\t\tif (child) {\n\t\t\t\tcmd = pid_proc_cmdline(child);\n\t\t\t\tif (cmd) {\n\t\t\t\t\tprintf(\"\\tchild %u %s\\n\", child, cmd);\n\t\t\t\t\tfree(cmd);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tprintf(\"\\tchild %u\\n\", child);\n\t\t\t}\n\n\t\t\t// on uid events the uid is changing\n\t\t\tif (proc_ev->what == PROC_EVENT_UID) {\n\t\t\t\tif (pids[pid].user)\n\t\t\t\t\tfree(pids[pid].user);\n\t\t\t\tpids[pid].user = 0;\n\t\t\t\tpids[pid].uid = pid_get_uid(pid);\n\t\t\t}\n\n\t\t\tif (sandbox_closed)\n\t\t\t\texit(0);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open netlink socket\\n\""
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "procevent_netlink_setup",
          "args": [],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "procevent_netlink_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/procevent.c",
          "lines": "161-206",
          "snippet": "static int procevent_netlink_setup(void) {\n\t// open socket for process event connector\n\tint sock;\n\tif ((sock = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR)) < 0)\n\t\tgoto errexit;\n\n\t// bind socket\n\tstruct sockaddr_nl addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.nl_pid = getpid();\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_groups = CN_IDX_PROC;\n\tif (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0)\n\t\tgoto errexit;\n\n\t// send monitoring message\n\tstruct nlmsghdr nlmsghdr;\n\tmemset(&nlmsghdr, 0, sizeof(nlmsghdr));\n\tnlmsghdr.nlmsg_len = NLMSG_LENGTH(sizeof(struct cn_msg) + sizeof(enum proc_cn_mcast_op));\n\tnlmsghdr.nlmsg_pid = getpid();\n\tnlmsghdr.nlmsg_type = NLMSG_DONE;\n\n\tstruct cn_msg cn_msg;\n\tmemset(&cn_msg, 0, sizeof(cn_msg));\n\tcn_msg.id.idx = CN_IDX_PROC;\n\tcn_msg.id.val = CN_VAL_PROC;\n\tcn_msg.len = sizeof(enum proc_cn_mcast_op);\n\n\tstruct iovec iov[3];\n\tiov[0].iov_base = &nlmsghdr;\n\tiov[0].iov_len = sizeof(nlmsghdr);\n\tiov[1].iov_base = &cn_msg;\n\tiov[1].iov_len = sizeof(cn_msg);\n\n\tenum proc_cn_mcast_op op = PROC_CN_MCAST_LISTEN;\n\tiov[2].iov_base = &op;\n\tiov[2].iov_len = sizeof(op);\n\n\tif (writev(sock, iov, 3) == -1)\n\t\tgoto errexit;\n\n\treturn sock;\nerrexit:\n\tfprintf(stderr, \"Error: netlink socket problem\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <time.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/netlink.h>",
            "#include <linux/connector.h>",
            "#include <sys/socket.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <time.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <linux/cn_proc.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <sys/socket.h>\n#include \"firemon.h\"\n\nstatic int procevent_netlink_setup(void) {\n\t// open socket for process event connector\n\tint sock;\n\tif ((sock = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR)) < 0)\n\t\tgoto errexit;\n\n\t// bind socket\n\tstruct sockaddr_nl addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.nl_pid = getpid();\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_groups = CN_IDX_PROC;\n\tif (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0)\n\t\tgoto errexit;\n\n\t// send monitoring message\n\tstruct nlmsghdr nlmsghdr;\n\tmemset(&nlmsghdr, 0, sizeof(nlmsghdr));\n\tnlmsghdr.nlmsg_len = NLMSG_LENGTH(sizeof(struct cn_msg) + sizeof(enum proc_cn_mcast_op));\n\tnlmsghdr.nlmsg_pid = getpid();\n\tnlmsghdr.nlmsg_type = NLMSG_DONE;\n\n\tstruct cn_msg cn_msg;\n\tmemset(&cn_msg, 0, sizeof(cn_msg));\n\tcn_msg.id.idx = CN_IDX_PROC;\n\tcn_msg.id.val = CN_VAL_PROC;\n\tcn_msg.len = sizeof(enum proc_cn_mcast_op);\n\n\tstruct iovec iov[3];\n\tiov[0].iov_base = &nlmsghdr;\n\tiov[0].iov_len = sizeof(nlmsghdr);\n\tiov[1].iov_base = &cn_msg;\n\tiov[1].iov_len = sizeof(cn_msg);\n\n\tenum proc_cn_mcast_op op = PROC_CN_MCAST_LISTEN;\n\tiov[2].iov_base = &op;\n\tiov[2].iov_len = sizeof(op);\n\n\tif (writev(sock, iov, 3) == -1)\n\t\tgoto errexit;\n\n\treturn sock;\nerrexit:\n\tfprintf(stderr, \"Error: netlink socket problem\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: you need to be root to get process events\\n\""
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <time.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <linux/cn_proc.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <sys/socket.h>\n#include \"firemon.h\"\n\nvoid procevent(pid_t pid) {\n\t// need to be root for this\n\tif (getuid() != 0) {\n\t\tfprintf(stderr, \"Error: you need to be root to get process events\\n\");\n\t\texit(1);\n\t}\n\n\t// monitor using netlink\n\tint sock = procevent_netlink_setup();\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error: cannot open netlink socket\\n\");\n\t\texit(1);\n\t}\n\n\tprocevent_monitor(sock, pid); // it will never return from here\n\tassert(0);\n\tclose(sock); // quiet static analyzers\n}"
  },
  {
    "function_name": "procevent_monitor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/procevent.c",
    "lines": "209-482",
    "snippet": "static int procevent_monitor(const int sock, pid_t mypid) {\n\tssize_t len;\n\tstruct nlmsghdr *nlmsghdr;\n\n\t// timeout in order to re-enable firejail module trace\n\tstruct timeval tv;\n\ttv.tv_sec = 30;\n\ttv.tv_usec = 0;\n\n\twhile (1) {\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\n#define BUFFSIZE 4096\n\t\tchar __attribute__ ((aligned(NLMSG_ALIGNTO)))buf[BUFFSIZE];\n\n\t\tfd_set readfds;\n\t\tint max;\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(sock, &readfds);\n\t\tmax = sock;\n\t\tmax++;\n\n\t\tint rv = select(max, &readfds, NULL, NULL, &tv);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"recv: %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\t// timeout\n\t\tif (rv == 0) {\n\t\t\ttv.tv_sec = 30;\n\t\t\ttv.tv_usec = 0;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif ((len = recv(sock, buf, sizeof(buf), 0)) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (len == -1) {\n\t\t\tif (errno == EINTR) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\"recv: %s\\n\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (nlmsghdr = (struct nlmsghdr *)buf;\n\t\t\tNLMSG_OK (nlmsghdr, (unsigned) len);\n\t\t\tnlmsghdr = NLMSG_NEXT (nlmsghdr, len)) {\n\n\t\t\tstruct cn_msg *cn_msg;\n\t\t\tstruct proc_event *proc_ev;\n\t\t\tstruct tm tm;\n\t\t\ttime_t now;\n\n\t\t\tif ((nlmsghdr->nlmsg_type == NLMSG_ERROR) ||\n\t\t\t    (nlmsghdr->nlmsg_type == NLMSG_NOOP))\n\t\t\t\tcontinue;\n\n\t\t\tcn_msg = NLMSG_DATA(nlmsghdr);\n\t\t\tif ((cn_msg->id.idx != CN_IDX_PROC) ||\n\t\t\t    (cn_msg->id.val != CN_VAL_PROC))\n\t\t\t\tcontinue;\n\n\t\t\t(void)time(&now);\n\t\t\t(void)localtime_r(&now, &tm);\n\t\t\tchar line[PIDS_BUFLEN];\n\t\t\tchar *lineptr = line;\n\t\t\tsprintf(lineptr, \"%2.2d:%2.2d:%2.2d\", tm.tm_hour, tm.tm_min, tm.tm_sec);\n\t\t\tlineptr += strlen(lineptr);\n\n\t\t\tproc_ev = (struct proc_event *)cn_msg->data;\n\t\t\tpid_t pid = 0;\n\t\t\tpid_t child = 0;\n\t\t\tint remove_pid = 0;\n\t\t\tswitch (proc_ev->what) {\n\t\t\t\tcase PROC_EVENT_FORK:\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event fork\\n\", __FUNCTION__, __LINE__);\n#endif\n\t\t\t\t\tif (proc_ev->event_data.fork.child_pid !=\n\t\t\t\t\t    proc_ev->event_data.fork.child_tgid)\n\t\t\t\t\t    \tcontinue; // this is a thread, not a process\n\t\t\t\t\tpid = proc_ev->event_data.fork.parent_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event fork, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level > 0) {\n\t\t\t\t\t\tchild = proc_ev->event_data.fork.child_tgid;\n\t\t\t\t\t\tchild %= max_pids;\n\t\t\t\t\t\tpids[child].level = pids[pid].level + 1;\n\t\t\t\t\t\tpids[child].uid = pid_get_uid(child);\n\t\t\t\t\t\tpids[child].parent = pid;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf(lineptr, \" fork\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase PROC_EVENT_EXEC:\n\t\t\t\t\tpid = proc_ev->event_data.exec.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event exec, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == -1) {\n\t\t\t\t\t\tpids[pid].level = 0; // start tracking\n\t\t\t\t\t}\n\t\t\t\t\tsprintf(lineptr, \" exec\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PROC_EVENT_EXIT:\n\t\t\t\t\tif (proc_ev->event_data.exit.process_pid !=\n\t\t\t\t\t    proc_ev->event_data.exit.process_tgid)\n\t\t\t\t\t\tcontinue; // this is a thread, not a process\n\n\t\t\t\t\tpid = proc_ev->event_data.exit.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event exit, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tremove_pid = 1;\n\t\t\t\t\tsprintf(lineptr, \" exit\");\n\t\t\t\t\tbreak;\n\n\n\n\t\t\t\tcase PROC_EVENT_UID:\n\t\t\t\t\tpid = proc_ev->event_data.id.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event uid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == 1 ||\n\t\t\t\t\t    pids[pids[pid].parent].level == 1) {\n\t\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(lineptr, \" uid (%d:%d)\",\n\t\t\t\t\t\t\tproc_ev->event_data.id.r.ruid,\n\t\t\t\t\t\t\tproc_ev->event_data.id.e.euid);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PROC_EVENT_GID:\n\t\t\t\t\tpid = proc_ev->event_data.id.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event gid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == 1 ||\n\t\t\t\t\t    pids[pids[pid].parent].level == 1) {\n\t\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(lineptr, \" gid (%d:%d)\",\n\t\t\t\t\t\t\tproc_ev->event_data.id.r.rgid,\n\t\t\t\t\t\t\tproc_ev->event_data.id.e.egid);\n\t\t\t\t\tbreak;\n\n\n\n\t\t\t\tcase PROC_EVENT_SID:\n\t\t\t\t\tpid = proc_ev->event_data.sid.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event sid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tsprintf(lineptr, \" sid \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event unknown\\n\", __FUNCTION__, __LINE__);\n#endif\n\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint add_new = 0;\n\t\t\tif (pids[pid].level < 0)\t// not a firejail process\n\t\t\t\tcontinue;\n\t\t\telse if (pids[pid].level == 0) { // new process, do we track it?\n\t\t\t\tif (pid_is_firejail(pid) && mypid == 0) {\n\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t\tadd_new = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlineptr += strlen(lineptr);\n\t\t\tsprintf(lineptr, \" %u\", pid);\n\t\t\tlineptr += strlen(lineptr);\n\n\t\t\tchar *user = pids[pid].user;\n\t\t\tif (!user)\n\t\t\t\tuser = pid_get_user_name(pids[pid].uid);\n\t\t\tif (user) {\n\t\t\t\tpids[pid].user = user;\n\t\t\t\tsprintf(lineptr, \" (%s)\", user);\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\n\n\t\t\tint sandbox_closed = 0; // exit sandbox flag\n\t\t\tchar *cmd = pids[pid].cmd;\n\t\t\tif (!cmd) {\n\t\t\t\tcmd = pid_proc_cmdline(pid);\n\t\t\t}\n\t\t\tif (add_new) {\n\t\t\t\tif (!cmd)\n\t\t\t\t\tsprintf(lineptr, \" NEW SANDBOX\\n\");\n\t\t\t\telse\n\t\t\t\t\tsprintf(lineptr, \" NEW SANDBOX: %s\\n\", cmd);\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\t\t\telse if (proc_ev->what == PROC_EVENT_EXIT && pids[pid].level == 1) {\n\t\t\t\tsprintf(lineptr, \" EXIT SANDBOX\\n\");\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t\tif (mypid == pid)\n\t\t\t\t\tsandbox_closed = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!cmd) {\n\t\t\t\t\tcmd = pid_proc_cmdline(pid);\n\t\t\t\t}\n\t\t\t\tif (cmd == NULL)\n\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\telse {\n\t\t\t\t\tsprintf(lineptr, \" %s\\n\", cmd);\n\t\t\t\t\tfree(cmd);\n\t\t\t\t}\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\t\t\t(void) lineptr;\n\n\t\t\t// print the event\n\t\t\tprintf(\"%s\", line);\n\t\t\tfflush(0);\n\n\t\t\t// unflag pid for exit events\n\t\t\tif (remove_pid) {\n\t\t\t\tif (pids[pid].user)\n\t\t\t\t\tfree(pids[pid].user);\n\t\t\t\tif (pids[pid].cmd)\n\t\t\t\t\tfree(pids[pid].cmd);\n\t\t\t\tmemset(&pids[pid], 0, sizeof(Process));\n\t\t\t}\n\n\t\t\t// print forked child\n\t\t\tif (child) {\n\t\t\t\tcmd = pid_proc_cmdline(child);\n\t\t\t\tif (cmd) {\n\t\t\t\t\tprintf(\"\\tchild %u %s\\n\", child, cmd);\n\t\t\t\t\tfree(cmd);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tprintf(\"\\tchild %u\\n\", child);\n\t\t\t}\n\n\t\t\t// on uid events the uid is changing\n\t\t\tif (proc_ev->what == PROC_EVENT_UID) {\n\t\t\t\tif (pids[pid].user)\n\t\t\t\t\tfree(pids[pid].user);\n\t\t\t\tpids[pid].user = 0;\n\t\t\t\tpids[pid].uid = pid_get_uid(pid);\n\t\t\t}\n\n\t\t\tif (sandbox_closed)\n\t\t\t\texit(0);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <time.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/netlink.h>",
      "#include <linux/connector.h>",
      "#include <sys/socket.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [
      "#define BUFFSIZE 4096",
      "#define PIDS_BUFLEN 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_get_uid",
          "args": [
            "pid"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "pid_get_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "134-167",
          "snippet": "uid_t pid_get_uid(pid_t pid) {\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\treturn 0;\n\t}\n\n\t// extract uid\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 4;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0')\n\t\t\t\tgoto doexit;\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak; // break regardless!\n\t\t}\n\t}\ndoexit:\n\tfclose(fp);\n\tfree(file);\n\treturn rv;\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [
            "#define PIDS_BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\n#define PIDS_BUFLEN 4096\n\nuid_t pid_get_uid(pid_t pid) {\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\treturn 0;\n\t}\n\n\t// extract uid\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 4;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0')\n\t\t\t\tgoto doexit;\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak; // break regardless!\n\t\t}\n\t}\ndoexit:\n\tfclose(fp);\n\tfree(file);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pids[pid].user"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tchild %u\\n\"",
            "child"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tchild %u %s\\n\"",
            "child",
            "cmd"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_proc_cmdline",
          "args": [
            "child"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "pid_proc_cmdline_x11_xpra_xephyr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "207-266",
          "snippet": "int pid_proc_cmdline_x11_xpra_xephyr(const pid_t pid) {\n\t// if comm is not firejail return 0\n\tchar *comm = pid_proc_comm(pid);\n\tif (comm == NULL)\n\t\treturn 0;\n\tif (strcmp(comm, \"firejail\") != 0) {\n\t\tfree(comm);\n\t\treturn 0;\n\t}\n\tfree(comm);\n\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/cmdline\", pid) == -1)\n\t\treturn 0;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn 0;\n\t}\n\tfree(fname);\n\n\t// read file\n\tunsigned char buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// skip the first argument\n\tint i;\n\tfor (i = 0; buffer[i] != '\\0'; i++);\n\n\t// parse remaining command line options\n\twhile (1) {\n\t\t// extract argument\n\t\ti++;\n\t\tif (i >= len)\n\t\t\tbreak;\n\t\tchar *arg = (char *)buffer + i;\n\n\t\t// detect the last command line option\n\t\tif (strcmp(arg, \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(arg, \"--\", 2) != 0)\n\t\t\tbreak;\n\n\t\tif (strcmp(arg, \"--x11=xorg\") == 0 || strcmp(arg, \"--x11=none\") == 0)\n\t\t\treturn 0;\n\n\t\t// check x11 xpra or xephyr\n\t\tif (strncmp(arg, \"--x11\", 5) == 0)\n\t\t\treturn 1;\n\t\ti += strlen(arg);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define BUFLEN 4096",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define BUFLEN 4096\n#define BUFLEN 4096\n\nint pid_proc_cmdline_x11_xpra_xephyr(const pid_t pid) {\n\t// if comm is not firejail return 0\n\tchar *comm = pid_proc_comm(pid);\n\tif (comm == NULL)\n\t\treturn 0;\n\tif (strcmp(comm, \"firejail\") != 0) {\n\t\tfree(comm);\n\t\treturn 0;\n\t}\n\tfree(comm);\n\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/cmdline\", pid) == -1)\n\t\treturn 0;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn 0;\n\t}\n\tfree(fname);\n\n\t// read file\n\tunsigned char buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// skip the first argument\n\tint i;\n\tfor (i = 0; buffer[i] != '\\0'; i++);\n\n\t// parse remaining command line options\n\twhile (1) {\n\t\t// extract argument\n\t\ti++;\n\t\tif (i >= len)\n\t\t\tbreak;\n\t\tchar *arg = (char *)buffer + i;\n\n\t\t// detect the last command line option\n\t\tif (strcmp(arg, \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(arg, \"--\", 2) != 0)\n\t\t\tbreak;\n\n\t\tif (strcmp(arg, \"--x11=xorg\") == 0 || strcmp(arg, \"--x11=none\") == 0)\n\t\t\treturn 0;\n\n\t\t// check x11 xpra or xephyr\n\t\tif (strncmp(arg, \"--x11\", 5) == 0)\n\t\t\treturn 1;\n\t\ti += strlen(arg);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&pids[pid]",
            "0",
            "sizeof(Process)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pids[pid].cmd"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pids[pid].user"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\"",
            "line"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lineptr"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" %s\\n\"",
            "cmd"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\"\\n\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" EXIT SANDBOX\\n\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" NEW SANDBOX: %s\\n\"",
            "cmd"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" NEW SANDBOX\\n\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" (%s)\"",
            "user"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_get_user_name",
          "args": [
            "pids[pid].uid"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "pid_get_user_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "127-132",
          "snippet": "char *pid_get_user_name(uid_t uid) {\n\tstruct passwd *pw = getpwuid(uid);\n\tif (pw)\n\t\treturn strdup(pw->pw_name);\n\treturn NULL;\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\nchar *pid_get_user_name(uid_t uid) {\n\tstruct passwd *pw = getpwuid(uid);\n\tif (pw)\n\t\treturn strdup(pw->pw_name);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" %u\"",
            "pid"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_is_firejail",
          "args": [
            "pid"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "pid_is_firejail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/procevent.c",
          "lines": "38-158",
          "snippet": "static int pid_is_firejail(pid_t pid) {\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\tuid_t rv = 0;\n\n\t// open /proc/self/comm\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/comm\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\treturn 0;\n\t}\n\n\t// look for firejail executable name\n\tchar buf[PIDS_BUFLEN];\n\tif (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"firejail\", 8) == 0)\n\t\t\trv = 1;\n\t}\n\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\tif (rv) {\n\t\t// open /proc/pid/cmdline file\n\t\tchar *fname;\n\t\tint fd;\n\t\tif (asprintf(&fname, \"/proc/%d/cmdline\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\t\tfree(fname);\n#ifdef DEBUG_PRCTL\n\t\t\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\t\t\tgoto doexit;\n\t\t}\n\t\tfree(fname);\n\n\t\t// read file\n#define BUFLEN 4096\n\t\tunsigned char buffer[BUFLEN];\n\t\tssize_t len;\n\t\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\t\tclose(fd);\n#ifdef DEBUG_PRCTL\n\t\t\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\t\t\tgoto doexit;\n\t\t}\n\t\tbuffer[len] = '\\0';\n\t\tclose(fd);\n\n\t\t// list of firejail arguments that don't trigger sandbox creation\n\t\t// the initial -- is not included\n\t\tchar *exclude_args[] = {\n\t\t\t// all print options\n\t\t\t\"apparmor.print\", \"caps.print\", \"cpu.print\", \"dns.print\", \"fs.print\", \"netfilter.print\",\n\t\t\t\"netfilter6.print\", \"profile.print\", \"protocol.print\", \"seccomp.print\",\n\t\t\t// debug\n\t\t\t\"debug-caps\", \"debug-errnos\", \"debug-protocols\", \"debug-syscalls\",\n\t\t\t// file transfer\n\t\t\t\"ls\", \"get\", \"put\",\n\t\t\t// stats\n\t\t\t\"tree\", \"list\", \"top\",\n\t\t\t// network\n\t\t\t\"netstats\", \"bandwidth\",\n\t\t\t// etc\n\t\t\t\"help\", \"version\", \"overlay-clean\",\n\n\t\t\tNULL // end of list marker\n\t\t};\n\n\t\tint i;\n\t\tchar *start;\n\t\tint first = 1;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (buffer[i] != '\\0')\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\tfirst = 0;\n\t\t\t\tstart = (char *) buffer + i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strncmp(start, \"--\", 2) != 0)\n\t\t\t\tbreak;\n\t\t\tstart += 2;\n\n\t\t\t// clan starting with =\n\t\t\tchar *ptr = strchr(start, '=');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\n\t\t\t// look into exclude list\n\t\t\tint j = 0;\n\t\t\twhile (exclude_args[j] != NULL) {\n\t\t\t\tif (strcmp(start, exclude_args[j]) == 0) {\n\t\t\t\t\trv = 0;\n#ifdef DEBUG_PRCTL\nprintf(\"start=#%s#,  ptr=#%s#, flip rv %d\\n\", start, ptr, rv);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tstart = (char *) buffer + i + 1;\n\t\t}\n\t}\n\ndoexit:\n\tfclose(fp);\n\tfree(file);\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d: return %d\\n\", __FUNCTION__, __LINE__, rv);\n#endif\n\treturn rv;\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <time.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/netlink.h>",
            "#include <linux/connector.h>",
            "#include <sys/socket.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096",
            "#define PIDS_BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <time.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <linux/cn_proc.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <sys/socket.h>\n#include \"firemon.h\"\n\n#define BUFLEN 4096\n#define PIDS_BUFLEN 4096\n\nstatic int pid_is_firejail(pid_t pid) {\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\tuid_t rv = 0;\n\n\t// open /proc/self/comm\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/comm\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\treturn 0;\n\t}\n\n\t// look for firejail executable name\n\tchar buf[PIDS_BUFLEN];\n\tif (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"firejail\", 8) == 0)\n\t\t\trv = 1;\n\t}\n\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\tif (rv) {\n\t\t// open /proc/pid/cmdline file\n\t\tchar *fname;\n\t\tint fd;\n\t\tif (asprintf(&fname, \"/proc/%d/cmdline\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\t\tfree(fname);\n#ifdef DEBUG_PRCTL\n\t\t\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\t\t\tgoto doexit;\n\t\t}\n\t\tfree(fname);\n\n\t\t// read file\n#define BUFLEN 4096\n\t\tunsigned char buffer[BUFLEN];\n\t\tssize_t len;\n\t\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\t\tclose(fd);\n#ifdef DEBUG_PRCTL\n\t\t\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\t\t\tgoto doexit;\n\t\t}\n\t\tbuffer[len] = '\\0';\n\t\tclose(fd);\n\n\t\t// list of firejail arguments that don't trigger sandbox creation\n\t\t// the initial -- is not included\n\t\tchar *exclude_args[] = {\n\t\t\t// all print options\n\t\t\t\"apparmor.print\", \"caps.print\", \"cpu.print\", \"dns.print\", \"fs.print\", \"netfilter.print\",\n\t\t\t\"netfilter6.print\", \"profile.print\", \"protocol.print\", \"seccomp.print\",\n\t\t\t// debug\n\t\t\t\"debug-caps\", \"debug-errnos\", \"debug-protocols\", \"debug-syscalls\",\n\t\t\t// file transfer\n\t\t\t\"ls\", \"get\", \"put\",\n\t\t\t// stats\n\t\t\t\"tree\", \"list\", \"top\",\n\t\t\t// network\n\t\t\t\"netstats\", \"bandwidth\",\n\t\t\t// etc\n\t\t\t\"help\", \"version\", \"overlay-clean\",\n\n\t\t\tNULL // end of list marker\n\t\t};\n\n\t\tint i;\n\t\tchar *start;\n\t\tint first = 1;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (buffer[i] != '\\0')\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\tfirst = 0;\n\t\t\t\tstart = (char *) buffer + i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strncmp(start, \"--\", 2) != 0)\n\t\t\t\tbreak;\n\t\t\tstart += 2;\n\n\t\t\t// clan starting with =\n\t\t\tchar *ptr = strchr(start, '=');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\n\t\t\t// look into exclude list\n\t\t\tint j = 0;\n\t\t\twhile (exclude_args[j] != NULL) {\n\t\t\t\tif (strcmp(start, exclude_args[j]) == 0) {\n\t\t\t\t\trv = 0;\n#ifdef DEBUG_PRCTL\nprintf(\"start=#%s#,  ptr=#%s#, flip rv %d\\n\", start, ptr, rv);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tstart = (char *) buffer + i + 1;\n\t\t}\n\t}\n\ndoexit:\n\tfclose(fp);\n\tfree(file);\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d: return %d\\n\", __FUNCTION__, __LINE__, rv);\n#endif\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\"\\n\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, event unknown\\n\"",
            "__FUNCTION__",
            "__LINE__"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" sid \""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, event sid, pid %d\\n\"",
            "__FUNCTION__",
            "__LINE__",
            "pid"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" gid (%d:%d)\"",
            "proc_ev->event_data.id.r.rgid",
            "proc_ev->event_data.id.e.egid"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\"\\n\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, event gid, pid %d\\n\"",
            "__FUNCTION__",
            "__LINE__",
            "pid"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" uid (%d:%d)\"",
            "proc_ev->event_data.id.r.ruid",
            "proc_ev->event_data.id.e.euid"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\"\\n\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, event uid, pid %d\\n\"",
            "__FUNCTION__",
            "__LINE__",
            "pid"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" exit\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, event exit, pid %d\\n\"",
            "__FUNCTION__",
            "__LINE__",
            "pid"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" exec\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, event exec, pid %d\\n\"",
            "__FUNCTION__",
            "__LINE__",
            "pid"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\" fork\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, event fork, pid %d\\n\"",
            "__FUNCTION__",
            "__LINE__",
            "pid"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, event fork\\n\"",
            "__FUNCTION__",
            "__LINE__"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "lineptr",
            "\"%2.2d:%2.2d:%2.2d\"",
            "tm.tm_hour",
            "tm.tm_min",
            "tm.tm_sec"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime_r",
          "args": [
            "&now",
            "&tm"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "&now"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "pid_get_start_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "92-125",
          "snippet": "unsigned long long pid_get_start_time(unsigned pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/stat\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\treturn 0;\n\t}\n\tfree(file);\n\n\tchar line[PIDS_BUFLEN];\n\tunsigned long long retval = 0;\n\tif (fgets(line, PIDS_BUFLEN - 1, fp)) {\n\t\tchar *ptr = line;\n\t\t// jump 21 fields\n\t\tint i;\n\t\tfor (i = 0; i < 21; i++) {\n\t\t\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0')\n\t\t\t\tptr++;\n\t\t\tif (*ptr == '\\0')\n\t\t\t\tgoto myexit;\n\t\t\tptr++;\n\t\t}\n\t\tif (1 != sscanf(ptr, \"%llu\", &retval))\n\t\t\tgoto myexit;\n\t}\n\nmyexit:\n\tfclose(fp);\n\treturn retval;\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [
            "#define PIDS_BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\n#define PIDS_BUFLEN 4096\n\nunsigned long long pid_get_start_time(unsigned pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/stat\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\treturn 0;\n\t}\n\tfree(file);\n\n\tchar line[PIDS_BUFLEN];\n\tunsigned long long retval = 0;\n\tif (fgets(line, PIDS_BUFLEN - 1, fp)) {\n\t\tchar *ptr = line;\n\t\t// jump 21 fields\n\t\tint i;\n\t\tfor (i = 0; i < 21; i++) {\n\t\t\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0')\n\t\t\t\tptr++;\n\t\t\tif (*ptr == '\\0')\n\t\t\t\tgoto myexit;\n\t\t\tptr++;\n\t\t}\n\t\tif (1 != sscanf(ptr, \"%llu\", &retval))\n\t\t\tgoto myexit;\n\t}\n\nmyexit:\n\tfclose(fp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "nlmsghdr"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_NEXT",
          "args": [
            "nlmsghdr",
            "len"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_OK",
          "args": [
            "nlmsghdr",
            "(unsigned) len"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"recv: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "sock",
            "buf",
            "sizeof(buf)",
            "0"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"recv: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "max",
            "&readfds",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "sock",
            "&readfds"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&readfds"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aligned",
          "args": [
            "NLMSG_ALIGNTO"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gcov_flush",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <time.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <linux/cn_proc.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <sys/socket.h>\n#include \"firemon.h\"\n\n#define BUFFSIZE 4096\n#define PIDS_BUFLEN 4096\n\nstatic int procevent_monitor(const int sock, pid_t mypid) {\n\tssize_t len;\n\tstruct nlmsghdr *nlmsghdr;\n\n\t// timeout in order to re-enable firejail module trace\n\tstruct timeval tv;\n\ttv.tv_sec = 30;\n\ttv.tv_usec = 0;\n\n\twhile (1) {\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\n#define BUFFSIZE 4096\n\t\tchar __attribute__ ((aligned(NLMSG_ALIGNTO)))buf[BUFFSIZE];\n\n\t\tfd_set readfds;\n\t\tint max;\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(sock, &readfds);\n\t\tmax = sock;\n\t\tmax++;\n\n\t\tint rv = select(max, &readfds, NULL, NULL, &tv);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"recv: %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\t// timeout\n\t\tif (rv == 0) {\n\t\t\ttv.tv_sec = 30;\n\t\t\ttv.tv_usec = 0;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif ((len = recv(sock, buf, sizeof(buf), 0)) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (len == -1) {\n\t\t\tif (errno == EINTR) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\"recv: %s\\n\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (nlmsghdr = (struct nlmsghdr *)buf;\n\t\t\tNLMSG_OK (nlmsghdr, (unsigned) len);\n\t\t\tnlmsghdr = NLMSG_NEXT (nlmsghdr, len)) {\n\n\t\t\tstruct cn_msg *cn_msg;\n\t\t\tstruct proc_event *proc_ev;\n\t\t\tstruct tm tm;\n\t\t\ttime_t now;\n\n\t\t\tif ((nlmsghdr->nlmsg_type == NLMSG_ERROR) ||\n\t\t\t    (nlmsghdr->nlmsg_type == NLMSG_NOOP))\n\t\t\t\tcontinue;\n\n\t\t\tcn_msg = NLMSG_DATA(nlmsghdr);\n\t\t\tif ((cn_msg->id.idx != CN_IDX_PROC) ||\n\t\t\t    (cn_msg->id.val != CN_VAL_PROC))\n\t\t\t\tcontinue;\n\n\t\t\t(void)time(&now);\n\t\t\t(void)localtime_r(&now, &tm);\n\t\t\tchar line[PIDS_BUFLEN];\n\t\t\tchar *lineptr = line;\n\t\t\tsprintf(lineptr, \"%2.2d:%2.2d:%2.2d\", tm.tm_hour, tm.tm_min, tm.tm_sec);\n\t\t\tlineptr += strlen(lineptr);\n\n\t\t\tproc_ev = (struct proc_event *)cn_msg->data;\n\t\t\tpid_t pid = 0;\n\t\t\tpid_t child = 0;\n\t\t\tint remove_pid = 0;\n\t\t\tswitch (proc_ev->what) {\n\t\t\t\tcase PROC_EVENT_FORK:\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event fork\\n\", __FUNCTION__, __LINE__);\n#endif\n\t\t\t\t\tif (proc_ev->event_data.fork.child_pid !=\n\t\t\t\t\t    proc_ev->event_data.fork.child_tgid)\n\t\t\t\t\t    \tcontinue; // this is a thread, not a process\n\t\t\t\t\tpid = proc_ev->event_data.fork.parent_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event fork, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level > 0) {\n\t\t\t\t\t\tchild = proc_ev->event_data.fork.child_tgid;\n\t\t\t\t\t\tchild %= max_pids;\n\t\t\t\t\t\tpids[child].level = pids[pid].level + 1;\n\t\t\t\t\t\tpids[child].uid = pid_get_uid(child);\n\t\t\t\t\t\tpids[child].parent = pid;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf(lineptr, \" fork\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase PROC_EVENT_EXEC:\n\t\t\t\t\tpid = proc_ev->event_data.exec.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event exec, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == -1) {\n\t\t\t\t\t\tpids[pid].level = 0; // start tracking\n\t\t\t\t\t}\n\t\t\t\t\tsprintf(lineptr, \" exec\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PROC_EVENT_EXIT:\n\t\t\t\t\tif (proc_ev->event_data.exit.process_pid !=\n\t\t\t\t\t    proc_ev->event_data.exit.process_tgid)\n\t\t\t\t\t\tcontinue; // this is a thread, not a process\n\n\t\t\t\t\tpid = proc_ev->event_data.exit.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event exit, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tremove_pid = 1;\n\t\t\t\t\tsprintf(lineptr, \" exit\");\n\t\t\t\t\tbreak;\n\n\n\n\t\t\t\tcase PROC_EVENT_UID:\n\t\t\t\t\tpid = proc_ev->event_data.id.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event uid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == 1 ||\n\t\t\t\t\t    pids[pids[pid].parent].level == 1) {\n\t\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(lineptr, \" uid (%d:%d)\",\n\t\t\t\t\t\t\tproc_ev->event_data.id.r.ruid,\n\t\t\t\t\t\t\tproc_ev->event_data.id.e.euid);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PROC_EVENT_GID:\n\t\t\t\t\tpid = proc_ev->event_data.id.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event gid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tif (pids[pid].level == 1 ||\n\t\t\t\t\t    pids[pids[pid].parent].level == 1) {\n\t\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(lineptr, \" gid (%d:%d)\",\n\t\t\t\t\t\t\tproc_ev->event_data.id.r.rgid,\n\t\t\t\t\t\t\tproc_ev->event_data.id.e.egid);\n\t\t\t\t\tbreak;\n\n\n\n\t\t\t\tcase PROC_EVENT_SID:\n\t\t\t\t\tpid = proc_ev->event_data.sid.process_tgid;\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event sid, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\t\t\t\t\tsprintf(lineptr, \" sid \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, event unknown\\n\", __FUNCTION__, __LINE__);\n#endif\n\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint add_new = 0;\n\t\t\tif (pids[pid].level < 0)\t// not a firejail process\n\t\t\t\tcontinue;\n\t\t\telse if (pids[pid].level == 0) { // new process, do we track it?\n\t\t\t\tif (pid_is_firejail(pid) && mypid == 0) {\n\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t\tadd_new = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlineptr += strlen(lineptr);\n\t\t\tsprintf(lineptr, \" %u\", pid);\n\t\t\tlineptr += strlen(lineptr);\n\n\t\t\tchar *user = pids[pid].user;\n\t\t\tif (!user)\n\t\t\t\tuser = pid_get_user_name(pids[pid].uid);\n\t\t\tif (user) {\n\t\t\t\tpids[pid].user = user;\n\t\t\t\tsprintf(lineptr, \" (%s)\", user);\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\n\n\t\t\tint sandbox_closed = 0; // exit sandbox flag\n\t\t\tchar *cmd = pids[pid].cmd;\n\t\t\tif (!cmd) {\n\t\t\t\tcmd = pid_proc_cmdline(pid);\n\t\t\t}\n\t\t\tif (add_new) {\n\t\t\t\tif (!cmd)\n\t\t\t\t\tsprintf(lineptr, \" NEW SANDBOX\\n\");\n\t\t\t\telse\n\t\t\t\t\tsprintf(lineptr, \" NEW SANDBOX: %s\\n\", cmd);\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\t\t\telse if (proc_ev->what == PROC_EVENT_EXIT && pids[pid].level == 1) {\n\t\t\t\tsprintf(lineptr, \" EXIT SANDBOX\\n\");\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t\tif (mypid == pid)\n\t\t\t\t\tsandbox_closed = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!cmd) {\n\t\t\t\t\tcmd = pid_proc_cmdline(pid);\n\t\t\t\t}\n\t\t\t\tif (cmd == NULL)\n\t\t\t\t\tsprintf(lineptr, \"\\n\");\n\t\t\t\telse {\n\t\t\t\t\tsprintf(lineptr, \" %s\\n\", cmd);\n\t\t\t\t\tfree(cmd);\n\t\t\t\t}\n\t\t\t\tlineptr += strlen(lineptr);\n\t\t\t}\n\t\t\t(void) lineptr;\n\n\t\t\t// print the event\n\t\t\tprintf(\"%s\", line);\n\t\t\tfflush(0);\n\n\t\t\t// unflag pid for exit events\n\t\t\tif (remove_pid) {\n\t\t\t\tif (pids[pid].user)\n\t\t\t\t\tfree(pids[pid].user);\n\t\t\t\tif (pids[pid].cmd)\n\t\t\t\t\tfree(pids[pid].cmd);\n\t\t\t\tmemset(&pids[pid], 0, sizeof(Process));\n\t\t\t}\n\n\t\t\t// print forked child\n\t\t\tif (child) {\n\t\t\t\tcmd = pid_proc_cmdline(child);\n\t\t\t\tif (cmd) {\n\t\t\t\t\tprintf(\"\\tchild %u %s\\n\", child, cmd);\n\t\t\t\t\tfree(cmd);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tprintf(\"\\tchild %u\\n\", child);\n\t\t\t}\n\n\t\t\t// on uid events the uid is changing\n\t\t\tif (proc_ev->what == PROC_EVENT_UID) {\n\t\t\t\tif (pids[pid].user)\n\t\t\t\t\tfree(pids[pid].user);\n\t\t\t\tpids[pid].user = 0;\n\t\t\t\tpids[pid].uid = pid_get_uid(pid);\n\t\t\t}\n\n\t\t\tif (sandbox_closed)\n\t\t\t\texit(0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "procevent_netlink_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/procevent.c",
    "lines": "161-206",
    "snippet": "static int procevent_netlink_setup(void) {\n\t// open socket for process event connector\n\tint sock;\n\tif ((sock = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR)) < 0)\n\t\tgoto errexit;\n\n\t// bind socket\n\tstruct sockaddr_nl addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.nl_pid = getpid();\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_groups = CN_IDX_PROC;\n\tif (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0)\n\t\tgoto errexit;\n\n\t// send monitoring message\n\tstruct nlmsghdr nlmsghdr;\n\tmemset(&nlmsghdr, 0, sizeof(nlmsghdr));\n\tnlmsghdr.nlmsg_len = NLMSG_LENGTH(sizeof(struct cn_msg) + sizeof(enum proc_cn_mcast_op));\n\tnlmsghdr.nlmsg_pid = getpid();\n\tnlmsghdr.nlmsg_type = NLMSG_DONE;\n\n\tstruct cn_msg cn_msg;\n\tmemset(&cn_msg, 0, sizeof(cn_msg));\n\tcn_msg.id.idx = CN_IDX_PROC;\n\tcn_msg.id.val = CN_VAL_PROC;\n\tcn_msg.len = sizeof(enum proc_cn_mcast_op);\n\n\tstruct iovec iov[3];\n\tiov[0].iov_base = &nlmsghdr;\n\tiov[0].iov_len = sizeof(nlmsghdr);\n\tiov[1].iov_base = &cn_msg;\n\tiov[1].iov_len = sizeof(cn_msg);\n\n\tenum proc_cn_mcast_op op = PROC_CN_MCAST_LISTEN;\n\tiov[2].iov_base = &op;\n\tiov[2].iov_len = sizeof(op);\n\n\tif (writev(sock, iov, 3) == -1)\n\t\tgoto errexit;\n\n\treturn sock;\nerrexit:\n\tfprintf(stderr, \"Error: netlink socket problem\\n\");\n\texit(1);\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <time.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/netlink.h>",
      "#include <linux/connector.h>",
      "#include <sys/socket.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: netlink socket problem\\n\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writev",
          "args": [
            "sock",
            "iov",
            "3"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cn_msg",
            "0",
            "sizeof(cn_msg)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(struct cn_msg) + sizeof(enum proc_cn_mcast_op)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&nlmsghdr",
            "0",
            "sizeof(nlmsghdr)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "sock",
            "(struct sockaddr *)&addr",
            "sizeof(addr)"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "bind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "548-556",
          "snippet": "int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {\n\tif (!orig_bind)\n\t\torig_bind = (orig_bind_t)dlsym(RTLD_NEXT, \"bind\");\n\n\tint rv = orig_bind(sockfd, addr, addrlen);\n\tprint_sockaddr(sockfd, \"bind\", addr, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_bind_t orig_bind = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_bind_t orig_bind = NULL;\n\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {\n\tif (!orig_bind)\n\t\torig_bind = (orig_bind_t)dlsym(RTLD_NEXT, \"bind\");\n\n\tint rv = orig_bind(sockfd, addr, addrlen);\n\tprint_sockaddr(sockfd, \"bind\", addr, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_NETLINK",
            "SOCK_DGRAM",
            "NETLINK_CONNECTOR"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <time.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <linux/cn_proc.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <sys/socket.h>\n#include \"firemon.h\"\n\nstatic int procevent_netlink_setup(void) {\n\t// open socket for process event connector\n\tint sock;\n\tif ((sock = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR)) < 0)\n\t\tgoto errexit;\n\n\t// bind socket\n\tstruct sockaddr_nl addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.nl_pid = getpid();\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_groups = CN_IDX_PROC;\n\tif (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0)\n\t\tgoto errexit;\n\n\t// send monitoring message\n\tstruct nlmsghdr nlmsghdr;\n\tmemset(&nlmsghdr, 0, sizeof(nlmsghdr));\n\tnlmsghdr.nlmsg_len = NLMSG_LENGTH(sizeof(struct cn_msg) + sizeof(enum proc_cn_mcast_op));\n\tnlmsghdr.nlmsg_pid = getpid();\n\tnlmsghdr.nlmsg_type = NLMSG_DONE;\n\n\tstruct cn_msg cn_msg;\n\tmemset(&cn_msg, 0, sizeof(cn_msg));\n\tcn_msg.id.idx = CN_IDX_PROC;\n\tcn_msg.id.val = CN_VAL_PROC;\n\tcn_msg.len = sizeof(enum proc_cn_mcast_op);\n\n\tstruct iovec iov[3];\n\tiov[0].iov_base = &nlmsghdr;\n\tiov[0].iov_len = sizeof(nlmsghdr);\n\tiov[1].iov_base = &cn_msg;\n\tiov[1].iov_len = sizeof(cn_msg);\n\n\tenum proc_cn_mcast_op op = PROC_CN_MCAST_LISTEN;\n\tiov[2].iov_base = &op;\n\tiov[2].iov_len = sizeof(op);\n\n\tif (writev(sock, iov, 3) == -1)\n\t\tgoto errexit;\n\n\treturn sock;\nerrexit:\n\tfprintf(stderr, \"Error: netlink socket problem\\n\");\n\texit(1);\n}"
  },
  {
    "function_name": "pid_is_firejail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/procevent.c",
    "lines": "38-158",
    "snippet": "static int pid_is_firejail(pid_t pid) {\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\tuid_t rv = 0;\n\n\t// open /proc/self/comm\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/comm\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\treturn 0;\n\t}\n\n\t// look for firejail executable name\n\tchar buf[PIDS_BUFLEN];\n\tif (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"firejail\", 8) == 0)\n\t\t\trv = 1;\n\t}\n\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\tif (rv) {\n\t\t// open /proc/pid/cmdline file\n\t\tchar *fname;\n\t\tint fd;\n\t\tif (asprintf(&fname, \"/proc/%d/cmdline\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\t\tfree(fname);\n#ifdef DEBUG_PRCTL\n\t\t\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\t\t\tgoto doexit;\n\t\t}\n\t\tfree(fname);\n\n\t\t// read file\n#define BUFLEN 4096\n\t\tunsigned char buffer[BUFLEN];\n\t\tssize_t len;\n\t\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\t\tclose(fd);\n#ifdef DEBUG_PRCTL\n\t\t\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\t\t\tgoto doexit;\n\t\t}\n\t\tbuffer[len] = '\\0';\n\t\tclose(fd);\n\n\t\t// list of firejail arguments that don't trigger sandbox creation\n\t\t// the initial -- is not included\n\t\tchar *exclude_args[] = {\n\t\t\t// all print options\n\t\t\t\"apparmor.print\", \"caps.print\", \"cpu.print\", \"dns.print\", \"fs.print\", \"netfilter.print\",\n\t\t\t\"netfilter6.print\", \"profile.print\", \"protocol.print\", \"seccomp.print\",\n\t\t\t// debug\n\t\t\t\"debug-caps\", \"debug-errnos\", \"debug-protocols\", \"debug-syscalls\",\n\t\t\t// file transfer\n\t\t\t\"ls\", \"get\", \"put\",\n\t\t\t// stats\n\t\t\t\"tree\", \"list\", \"top\",\n\t\t\t// network\n\t\t\t\"netstats\", \"bandwidth\",\n\t\t\t// etc\n\t\t\t\"help\", \"version\", \"overlay-clean\",\n\n\t\t\tNULL // end of list marker\n\t\t};\n\n\t\tint i;\n\t\tchar *start;\n\t\tint first = 1;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (buffer[i] != '\\0')\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\tfirst = 0;\n\t\t\t\tstart = (char *) buffer + i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strncmp(start, \"--\", 2) != 0)\n\t\t\t\tbreak;\n\t\t\tstart += 2;\n\n\t\t\t// clan starting with =\n\t\t\tchar *ptr = strchr(start, '=');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\n\t\t\t// look into exclude list\n\t\t\tint j = 0;\n\t\t\twhile (exclude_args[j] != NULL) {\n\t\t\t\tif (strcmp(start, exclude_args[j]) == 0) {\n\t\t\t\t\trv = 0;\n#ifdef DEBUG_PRCTL\nprintf(\"start=#%s#,  ptr=#%s#, flip rv %d\\n\", start, ptr, rv);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tstart = (char *) buffer + i + 1;\n\t\t}\n\t}\n\ndoexit:\n\tfclose(fp);\n\tfree(file);\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d: return %d\\n\", __FUNCTION__, __LINE__, rv);\n#endif\n\treturn rv;\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <time.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/netlink.h>",
      "#include <linux/connector.h>",
      "#include <sys/socket.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [
      "#define BUFLEN 4096",
      "#define PIDS_BUFLEN 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d: return %d\\n\"",
            "__FUNCTION__",
            "__LINE__",
            "rv"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"start=#%s#,  ptr=#%s#, flip rv %d\\n\"",
            "start",
            "ptr",
            "rv"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "start",
            "exclude_args[j]"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "start",
            "'='"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "start",
            "\"--\"",
            "2"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, comm %s, rv %d\\n\"",
            "__FUNCTION__",
            "__LINE__",
            "buf",
            "rv"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buffer",
            "sizeof(buffer) - 1"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, comm %s, rv %d\\n\"",
            "__FUNCTION__",
            "__LINE__",
            "buf",
            "rv"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "fname",
            "O_RDONLY"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/cmdline\"",
            "pid"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, comm %s, rv %d\\n\"",
            "__FUNCTION__",
            "__LINE__",
            "buf",
            "rv"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"firejail\"",
            "8"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "PIDS_BUFLEN - 1",
            "fp"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&file",
            "\"/proc/%u/comm\"",
            "pid"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %d, pid %d\\n\"",
            "__FUNCTION__",
            "__LINE__",
            "pid"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <time.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <linux/cn_proc.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <sys/socket.h>\n#include \"firemon.h\"\n\n#define BUFLEN 4096\n#define PIDS_BUFLEN 4096\n\nstatic int pid_is_firejail(pid_t pid) {\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, pid %d\\n\", __FUNCTION__, __LINE__, pid);\n#endif\n\tuid_t rv = 0;\n\n\t// open /proc/self/comm\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/comm\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\treturn 0;\n\t}\n\n\t// look for firejail executable name\n\tchar buf[PIDS_BUFLEN];\n\tif (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"firejail\", 8) == 0)\n\t\t\trv = 1;\n\t}\n\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\tif (rv) {\n\t\t// open /proc/pid/cmdline file\n\t\tchar *fname;\n\t\tint fd;\n\t\tif (asprintf(&fname, \"/proc/%d/cmdline\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\t\tfree(fname);\n#ifdef DEBUG_PRCTL\n\t\t\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\t\t\tgoto doexit;\n\t\t}\n\t\tfree(fname);\n\n\t\t// read file\n#define BUFLEN 4096\n\t\tunsigned char buffer[BUFLEN];\n\t\tssize_t len;\n\t\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\t\tclose(fd);\n#ifdef DEBUG_PRCTL\n\t\t\tprintf(\"%s: %d, comm %s, rv %d\\n\", __FUNCTION__, __LINE__, buf, rv);\n#endif\n\t\t\tgoto doexit;\n\t\t}\n\t\tbuffer[len] = '\\0';\n\t\tclose(fd);\n\n\t\t// list of firejail arguments that don't trigger sandbox creation\n\t\t// the initial -- is not included\n\t\tchar *exclude_args[] = {\n\t\t\t// all print options\n\t\t\t\"apparmor.print\", \"caps.print\", \"cpu.print\", \"dns.print\", \"fs.print\", \"netfilter.print\",\n\t\t\t\"netfilter6.print\", \"profile.print\", \"protocol.print\", \"seccomp.print\",\n\t\t\t// debug\n\t\t\t\"debug-caps\", \"debug-errnos\", \"debug-protocols\", \"debug-syscalls\",\n\t\t\t// file transfer\n\t\t\t\"ls\", \"get\", \"put\",\n\t\t\t// stats\n\t\t\t\"tree\", \"list\", \"top\",\n\t\t\t// network\n\t\t\t\"netstats\", \"bandwidth\",\n\t\t\t// etc\n\t\t\t\"help\", \"version\", \"overlay-clean\",\n\n\t\t\tNULL // end of list marker\n\t\t};\n\n\t\tint i;\n\t\tchar *start;\n\t\tint first = 1;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (buffer[i] != '\\0')\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\tfirst = 0;\n\t\t\t\tstart = (char *) buffer + i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strncmp(start, \"--\", 2) != 0)\n\t\t\t\tbreak;\n\t\t\tstart += 2;\n\n\t\t\t// clan starting with =\n\t\t\tchar *ptr = strchr(start, '=');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\n\t\t\t// look into exclude list\n\t\t\tint j = 0;\n\t\t\twhile (exclude_args[j] != NULL) {\n\t\t\t\tif (strcmp(start, exclude_args[j]) == 0) {\n\t\t\t\t\trv = 0;\n#ifdef DEBUG_PRCTL\nprintf(\"start=#%s#,  ptr=#%s#, flip rv %d\\n\", start, ptr, rv);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tstart = (char *) buffer + i + 1;\n\t\t}\n\t}\n\ndoexit:\n\tfclose(fp);\n\tfree(file);\n#ifdef DEBUG_PRCTL\n\tprintf(\"%s: %d: return %d\\n\", __FUNCTION__, __LINE__, rv);\n#endif\n\treturn rv;\n}"
  }
]