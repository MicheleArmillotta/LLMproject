[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
    "lines": "319-475",
    "snippet": "int main(int argc, char **argv) {\n\tint i;\n\tint bindir_set = 0;\n\n\t// user setup\n\tchar *user = get_user();\n\tassert(user);\n\tuid_t uid;\n\tgid_t gid;\n\tchar *home = get_homedir(user, &uid, &gid);\n\n\n\t// check for --bindir\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--bindir=\", 9) == 0) {\n\t\t\tif (strncmp(argv[i] + 9, \"~/\", 2) == 0) {\n\t\t\t\tif (asprintf(&arg_bindir, \"%s/%s\", home, argv[i] + 11) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\t\telse\n\t\t\t\targ_bindir = argv[i] + 9;\n\t\t\tbindir_set = 1;\n\n\t\t\t// exit if the directory does not exist, or if we don't have access to it\n\t\t\tif (access(arg_bindir, R_OK | W_OK | X_OK)) {\n\t\t\t\tif (errno == EACCES)\n\t\t\t\t\tfprintf(stderr, \"Error: firecfg needs full permissions on directory %s\\n\", arg_bindir);\n\t\t\t\telse {\n\t\t\t\t\tperror(\"access\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot access directory %s\\n\", arg_bindir);\n\t\t\t\t}\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 1; i < argc; i++) {\n\t\t// default options\n\t\tif (strcmp(argv[i], \"--help\") == 0 ||\n\t\t    strcmp(argv[i], \"-?\") == 0) {\n\t\t\tusage();\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--debug\") == 0)\n\t\t\targ_debug = 1;\n\t\telse if (strcmp(argv[i], \"--version\") == 0) {\n\t\t\tprintf(\"firecfg version %s\\n\\n\", VERSION);\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--clean\") == 0) {\n\t\t\tclean();\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--fix\") == 0) {\n\t\t\tfix_desktop_files(home);\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--list\") == 0) {\n\t\t\tlist();\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--fix-sound\") == 0) {\n\t\t\tsound();\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--add-users\") == 0) {\n\t\t\tint j;\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: you need to be root to use this option\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// set umask, access database must be world-readable\n\t\t\tumask(022);\n\t\t\tfor (j = i + 1; j < argc; j++) {\n\t\t\t\tprintf(\"Adding user %s to Firejail access database in %s/firejail.users\\n\", argv[j], SYSCONFDIR);\n\t\t\t\tfirejail_user_add(argv[j]);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tif (strncmp(argv[i], \"--bindir=\", 9) != 0) { // already handled\n\t\t\t\tfprintf(stderr, \"Error: invalid command line option\\n\");\n\t\t\t\tusage();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"%s %d %d %d %d\\n\", user, getuid(), getgid(), geteuid(), getegid());\n\n\t// set symlinks in /usr/local/bin\n\tif (bindir_set == 0 && getuid() != 0) {\n\t\tfprintf(stderr, \"Error: cannot set the symbolic links in %s\\n\", arg_bindir);\n\t\tfprintf(stderr, \"The proper way to run this command is \\\"sudo firecfg\\\".\\n\");\n\t\treturn 1;\n\t}\n\telse if (bindir_set == 0) {\n\t\t// create /usr/local directory if it doesn't exist (Solus distro)\n\t\tmode_t orig_umask = umask(022); // temporarily set the umask\n\t\tstruct stat s;\n\t\tif (stat(\"/usr/local\", &s) != 0) {\n\t\t\tprintf(\"Creating /usr/local directory\\n\");\n\t\t\tint rv = mkdir(\"/usr/local\", 0755);\n\t\t\tif (rv != 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot create /usr/local directory\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (stat(arg_bindir, &s) != 0) {\n\t\t\tprintf(\"Creating %s directory\\n\", arg_bindir);\n\t\t\tint rv = mkdir(arg_bindir, 0755);\n\t\t\tif (rv != 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot create %s directory\\n\", arg_bindir);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tumask(orig_umask);\n\t}\n\n\t// clear all symlinks\n\tclean();\n\n\t// set new symlinks based on /usr/lib/firejail/firecfg.cfg\n\tset_links_firecfg();\n\n\t// add user to firejail access database - only for root\n\tif (getuid() == 0) {\n\t\tprintf(\"\\nAdding user %s to Firejail access database in %s/firejail.users\\n\", user, SYSCONFDIR);\n\t\t// temporarily set the umask, access database must be world-readable\n\t\tmode_t orig_umask = umask(022);\n\t\tfirejail_user_add(user);\n\t\tumask(orig_umask);\n\t}\n\n\t// set new symlinks based on ~/.config/firejail directory\n\tset_links_homedir(home);\n\n\t// drop permissions\n\tif (getuid() == 0) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (setgid(gid) < 0)\n\t\t\terrExit(\"setgid\");\n\t\tif (setuid(uid) < 0)\n\t\t\terrExit(\"setuid\");\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"%s %d %d %d %d\\n\", user, getuid(), getgid(), geteuid(), getegid());\n\n\t// fix .desktop files in ~/.local/share/applications directory\n\tfix_desktop_files(home);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../include/firejail_user.h\"",
      "#include \"firecfg.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int arg_debug = 0;",
      "char *arg_bindir = \"/usr/local/bin\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fix_desktop_files",
          "args": [
            "home"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "fix_desktop_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/desktop_files.c",
          "lines": "100-324",
          "snippet": "void fix_desktop_files(char *homedir) {\n\tassert(homedir);\n\tstruct stat sb;\n\n\t// check user\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: this option is not supported for root user; please run as a regular user.\\n\");\n\t\texit(1);\n\t}\n\n\t// destination\n\t// create ~/.local/share/applications directory if necessary\n\tchar *user_apps_dir;\n\tif (asprintf(&user_apps_dir, \"%s/.local/share/applications\", homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tprintf(\"\\nFixing desktop files in %s\\n\", user_apps_dir);\n\tif (stat(user_apps_dir, &sb) == -1) {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/.local\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tint rv = mkdir(tmp, 0755);\n\t\t(void) rv;\n\t\tfree(tmp);\n\n\t\tif (asprintf(&tmp, \"%s/.local/share\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\trv = mkdir(tmp, 0755);\n\t\t(void) rv;\n\t\tfree(tmp);\n\n\t\trv = mkdir(user_apps_dir, 0700);\n\t\tif (rv) {\n\t\t\tperror(\"mkdir\");\n\t\t\tfprintf(stderr, \"Warning: cannot create ~/.local/share/application directory, desktop files fixing skipped...\\n\");\n\t\t\tfree(user_apps_dir);\n\t\t\treturn;\n\t\t}\n\t\trv = chmod(user_apps_dir, 0700);\n\t\t(void) rv;\n\t}\n\n\t// source\n\tDIR *dir = opendir(\"/usr/share/applications\");\n\tif (!dir || chdir(\"/usr/share/applications\")) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Warning: cannot access /usr/share/applications directory, desktop files fixing skipped...\\n\");\n\t\tfree(user_apps_dir);\n\t\tif (dir)\n\t\t\tclosedir(dir);\n\t\treturn;\n\t}\n\n\t// copy\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\t// skip if not regular file or link\n\t\t// d_type is not available on some file systems\n\t\tif (entry->d_type != DT_REG && entry->d_type != DT_LNK && entry->d_type != DT_UNKNOWN)\n\t\t\tcontinue;\n\n\t\t// skip if not .desktop file\n\t\tif (strstr(entry->d_name,\".desktop\") != (entry->d_name+strlen(entry->d_name)-8))\n\t\t\tcontinue;\n\n\t\tchar *filename = entry->d_name;\n\n\t\t// skip links\n\t\tif (is_link(filename))\n\t\t\tcontinue;\n\n\t\t// no profile in /etc/firejail, no desktop file fixing\n\t\tif (!have_profile(filename, homedir))\n\t\t\tcontinue;\n\n\t\t//****************************************************\n\t\t// load the file in memory and do some basic checking\n\t\t//****************************************************\n\t\tFILE *fp = fopen(filename, \"r\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Warning: cannot open /usr/share/applications/%s\\n\", filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfseek(fp, 0, SEEK_END);\n\t\tlong size = ftell(fp);\n\t\tif (size == -1)\n\t\t\terrExit(\"ftell\");\n\t\tfseek(fp, 0, SEEK_SET);\n\t\tchar *buf = malloc(size + 1);\n\t\tif (!buf)\n\t\t\terrExit(\"malloc\");\n\n\t\tsize_t loaded = fread(buf, size, 1, fp);\n\t\tfclose(fp);\n\t\tif (loaded != 1) {\n\t\t\tfprintf(stderr, \"Warning: cannot read /usr/share/applications/%s\\n\", filename);\n\t\t\tfree(buf);\n\t\t\tcontinue;\n\t\t}\n\t\tbuf[size] = '\\0';\n\n\t\t// check format\n\t\tif (strstr(buf, \"[Desktop Entry]\\n\") == NULL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"   %s - skipped: wrong format?\\n\", filename);\n\t\t\tfree(buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// get executable name\n\t\tchar *ptr = strstr(buf,\"\\nExec=\");\n\t\tif (!ptr || strlen(ptr) < 7) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"   %s - skipped: wrong format?\\n\", filename);\n\t\t\tfree(buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *execname = ptr + 6;\n\t\t// executable name can be quoted, this is rare and currently unsupported, TODO\n\t\tif (execname[0] == '\"') {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"   %s - skipped: path quoting unsupported\\n\", filename);\n\t\t\tfree(buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// try to decide if we need to convert this file\n\t\tchar *change_exec = NULL;\n\t\tint change_dbus = 0;\n\n\t\tif (strstr(buf, \"\\nDBusActivatable=true\"))\n\t\t\tchange_dbus = 1;\n\n\t\t// https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html\n\t\t// The executable program can either be specified with its full path\n\t\t// or with the name of the executable only\n\t\tif (execname[0] == '/') {\n\t\t\t// mark end of line\n\t\t\tchar *end = strchr(execname, '\\n');\n\t\t\tif (end)\n\t\t\t\t*end = '\\0';\n\t\t\tend = strchr(execname, ' ');\n\t\t\tif (end)\n\t\t\t\t*end = '\\0';\n\t\t\tchar *start_name = strrchr(execname, '/');\n\t\t\tif (start_name) {\n\t\t\t\tstart_name++;\n\t\t\t\t// check if we have the executable on the regular path\n\t\t\t\tif (which(start_name)) {\n\t\t\t\t\tchange_exec = strdup(start_name);\n\t\t\t\t\tif (!change_exec)\n\t\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree(buf);\n\t\tif (change_exec == NULL && change_dbus == 0)\n\t\t\tcontinue;\n\n\t\t//****************************************************\n\t\t// generate output file\n\t\t//****************************************************\n\t\tchar *outname;\n\t\tif (asprintf(&outname ,\"%s/%s\", user_apps_dir, filename) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tif (stat(outname, &sb) == 0) {\n\t\t\tprintf(\"   %s skipped: file exists\\n\", filename);\n\t\t\tif (change_exec)\n\t\t\t\tfree(change_exec);\n\t\t\tcontinue;\n\t\t}\n\n\t\tFILE *fpin = fopen(filename, \"r\");\n\t\tif (!fpin) {\n\t\t\tfprintf(stderr, \"Warning: cannot open /usr/share/applications/%s\\n\", filename);\n\t\t\tif (change_exec)\n\t\t\t\tfree(change_exec);\n\t\t\tcontinue;\n\t\t}\n\n\t\tFILE *fpout = fopen(outname, \"w\");\n\t\tif (!fpout) {\n\t\t\tfprintf(stderr, \"Warning: cannot open ~/.local/share/applications/%s\\n\", outname);\n\t\t\tfclose(fpin);\n\t\t\tif (change_exec)\n\t\t\t\tfree(change_exec);\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(fpout, \"# converted by firecfg\\n\");\n\t\tfree(outname);\n\n\t\tchar fbuf[MAX_BUF];\n\t\twhile (fgets(fbuf, MAX_BUF, fpin)) {\n\t\t\tif (change_dbus && strcmp(fbuf, \"DBusActivatable=true\\n\") == 0)\n\t\t\t\tfprintf(fpout, \"DBusActivatable=false\\n\");\n\t\t\telse if (change_exec && strncmp(fbuf, \"Exec=\", 5) == 0) {\n\t\t\t\tchar *start_params = strchr(fbuf + 5, ' ');\n\t\t\t\tif (start_params) {\n\t\t\t\t\tstart_params++;\n\t\t\t\t\tfprintf(fpout, \"Exec=%s %s\", change_exec, start_params);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfprintf(fpout, \"Exec=%s\\n\", change_exec);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfprintf(fpout, \"%s\", fbuf);\n\t\t}\n\n\t\tif (change_exec)\n\t\t\tfree(change_exec);\n\t\tfclose(fpin);\n\t\tfclose(fpout);\n\t\tprintf(\"   %s created\\n\", filename);\n\n\t}\n\n\tclosedir(dir);\n\tfree(user_apps_dir);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"firecfg.h\"\n\nvoid fix_desktop_files(char *homedir) {\n\tassert(homedir);\n\tstruct stat sb;\n\n\t// check user\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: this option is not supported for root user; please run as a regular user.\\n\");\n\t\texit(1);\n\t}\n\n\t// destination\n\t// create ~/.local/share/applications directory if necessary\n\tchar *user_apps_dir;\n\tif (asprintf(&user_apps_dir, \"%s/.local/share/applications\", homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tprintf(\"\\nFixing desktop files in %s\\n\", user_apps_dir);\n\tif (stat(user_apps_dir, &sb) == -1) {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/.local\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tint rv = mkdir(tmp, 0755);\n\t\t(void) rv;\n\t\tfree(tmp);\n\n\t\tif (asprintf(&tmp, \"%s/.local/share\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\trv = mkdir(tmp, 0755);\n\t\t(void) rv;\n\t\tfree(tmp);\n\n\t\trv = mkdir(user_apps_dir, 0700);\n\t\tif (rv) {\n\t\t\tperror(\"mkdir\");\n\t\t\tfprintf(stderr, \"Warning: cannot create ~/.local/share/application directory, desktop files fixing skipped...\\n\");\n\t\t\tfree(user_apps_dir);\n\t\t\treturn;\n\t\t}\n\t\trv = chmod(user_apps_dir, 0700);\n\t\t(void) rv;\n\t}\n\n\t// source\n\tDIR *dir = opendir(\"/usr/share/applications\");\n\tif (!dir || chdir(\"/usr/share/applications\")) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Warning: cannot access /usr/share/applications directory, desktop files fixing skipped...\\n\");\n\t\tfree(user_apps_dir);\n\t\tif (dir)\n\t\t\tclosedir(dir);\n\t\treturn;\n\t}\n\n\t// copy\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\t// skip if not regular file or link\n\t\t// d_type is not available on some file systems\n\t\tif (entry->d_type != DT_REG && entry->d_type != DT_LNK && entry->d_type != DT_UNKNOWN)\n\t\t\tcontinue;\n\n\t\t// skip if not .desktop file\n\t\tif (strstr(entry->d_name,\".desktop\") != (entry->d_name+strlen(entry->d_name)-8))\n\t\t\tcontinue;\n\n\t\tchar *filename = entry->d_name;\n\n\t\t// skip links\n\t\tif (is_link(filename))\n\t\t\tcontinue;\n\n\t\t// no profile in /etc/firejail, no desktop file fixing\n\t\tif (!have_profile(filename, homedir))\n\t\t\tcontinue;\n\n\t\t//****************************************************\n\t\t// load the file in memory and do some basic checking\n\t\t//****************************************************\n\t\tFILE *fp = fopen(filename, \"r\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Warning: cannot open /usr/share/applications/%s\\n\", filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfseek(fp, 0, SEEK_END);\n\t\tlong size = ftell(fp);\n\t\tif (size == -1)\n\t\t\terrExit(\"ftell\");\n\t\tfseek(fp, 0, SEEK_SET);\n\t\tchar *buf = malloc(size + 1);\n\t\tif (!buf)\n\t\t\terrExit(\"malloc\");\n\n\t\tsize_t loaded = fread(buf, size, 1, fp);\n\t\tfclose(fp);\n\t\tif (loaded != 1) {\n\t\t\tfprintf(stderr, \"Warning: cannot read /usr/share/applications/%s\\n\", filename);\n\t\t\tfree(buf);\n\t\t\tcontinue;\n\t\t}\n\t\tbuf[size] = '\\0';\n\n\t\t// check format\n\t\tif (strstr(buf, \"[Desktop Entry]\\n\") == NULL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"   %s - skipped: wrong format?\\n\", filename);\n\t\t\tfree(buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// get executable name\n\t\tchar *ptr = strstr(buf,\"\\nExec=\");\n\t\tif (!ptr || strlen(ptr) < 7) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"   %s - skipped: wrong format?\\n\", filename);\n\t\t\tfree(buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *execname = ptr + 6;\n\t\t// executable name can be quoted, this is rare and currently unsupported, TODO\n\t\tif (execname[0] == '\"') {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"   %s - skipped: path quoting unsupported\\n\", filename);\n\t\t\tfree(buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// try to decide if we need to convert this file\n\t\tchar *change_exec = NULL;\n\t\tint change_dbus = 0;\n\n\t\tif (strstr(buf, \"\\nDBusActivatable=true\"))\n\t\t\tchange_dbus = 1;\n\n\t\t// https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html\n\t\t// The executable program can either be specified with its full path\n\t\t// or with the name of the executable only\n\t\tif (execname[0] == '/') {\n\t\t\t// mark end of line\n\t\t\tchar *end = strchr(execname, '\\n');\n\t\t\tif (end)\n\t\t\t\t*end = '\\0';\n\t\t\tend = strchr(execname, ' ');\n\t\t\tif (end)\n\t\t\t\t*end = '\\0';\n\t\t\tchar *start_name = strrchr(execname, '/');\n\t\t\tif (start_name) {\n\t\t\t\tstart_name++;\n\t\t\t\t// check if we have the executable on the regular path\n\t\t\t\tif (which(start_name)) {\n\t\t\t\t\tchange_exec = strdup(start_name);\n\t\t\t\t\tif (!change_exec)\n\t\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree(buf);\n\t\tif (change_exec == NULL && change_dbus == 0)\n\t\t\tcontinue;\n\n\t\t//****************************************************\n\t\t// generate output file\n\t\t//****************************************************\n\t\tchar *outname;\n\t\tif (asprintf(&outname ,\"%s/%s\", user_apps_dir, filename) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tif (stat(outname, &sb) == 0) {\n\t\t\tprintf(\"   %s skipped: file exists\\n\", filename);\n\t\t\tif (change_exec)\n\t\t\t\tfree(change_exec);\n\t\t\tcontinue;\n\t\t}\n\n\t\tFILE *fpin = fopen(filename, \"r\");\n\t\tif (!fpin) {\n\t\t\tfprintf(stderr, \"Warning: cannot open /usr/share/applications/%s\\n\", filename);\n\t\t\tif (change_exec)\n\t\t\t\tfree(change_exec);\n\t\t\tcontinue;\n\t\t}\n\n\t\tFILE *fpout = fopen(outname, \"w\");\n\t\tif (!fpout) {\n\t\t\tfprintf(stderr, \"Warning: cannot open ~/.local/share/applications/%s\\n\", outname);\n\t\t\tfclose(fpin);\n\t\t\tif (change_exec)\n\t\t\t\tfree(change_exec);\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(fpout, \"# converted by firecfg\\n\");\n\t\tfree(outname);\n\n\t\tchar fbuf[MAX_BUF];\n\t\twhile (fgets(fbuf, MAX_BUF, fpin)) {\n\t\t\tif (change_dbus && strcmp(fbuf, \"DBusActivatable=true\\n\") == 0)\n\t\t\t\tfprintf(fpout, \"DBusActivatable=false\\n\");\n\t\t\telse if (change_exec && strncmp(fbuf, \"Exec=\", 5) == 0) {\n\t\t\t\tchar *start_params = strchr(fbuf + 5, ' ');\n\t\t\t\tif (start_params) {\n\t\t\t\t\tstart_params++;\n\t\t\t\t\tfprintf(fpout, \"Exec=%s %s\", change_exec, start_params);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfprintf(fpout, \"Exec=%s\\n\", change_exec);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfprintf(fpout, \"%s\", fbuf);\n\t\t}\n\n\t\tif (change_exec)\n\t\t\tfree(change_exec);\n\t\tfclose(fpin);\n\t\tfclose(fpout);\n\t\tprintf(\"   %s created\\n\", filename);\n\n\t}\n\n\tclosedir(dir);\n\tfree(user_apps_dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %d %d %d %d\\n\"",
            "user",
            "getuid()",
            "getgid()",
            "geteuid()",
            "getegid()"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setuid\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "uid"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "setuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "586-594",
          "snippet": "int setuid(uid_t uid) {\n\tif (!orig_setuid)\n\t\torig_setuid = (orig_setuid_t)dlsym(RTLD_NEXT, \"setuid\");\n\n\tint rv = orig_setuid(uid);\n\tprintf(\"%u:%s:setuid %d:%d\\n\", pid(), name(), uid, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_setuid_t orig_setuid = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_setuid_t orig_setuid = NULL;\n\nint setuid(uid_t uid) {\n\tif (!orig_setuid)\n\t\torig_setuid = (orig_setuid_t)dlsym(RTLD_NEXT, \"setuid\");\n\n\tint rv = orig_setuid(uid);\n\tprintf(\"%u:%s:setuid %d:%d\\n\", pid(), name(), uid, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setgid\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "gid"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "setgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "598-606",
          "snippet": "int setgid(gid_t gid) {\n\tif (!orig_setgid)\n\t\torig_setgid = (orig_setgid_t)dlsym(RTLD_NEXT, \"setgid\");\n\n\tint rv = orig_setgid(gid);\n\tprintf(\"%u:%s:setgid %d:%d\\n\", pid(), name(), gid, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_setgid_t orig_setgid = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_setgid_t orig_setgid = NULL;\n\nint setgid(gid_t gid) {\n\tif (!orig_setgid)\n\t\torig_setgid = (orig_setgid_t)dlsym(RTLD_NEXT, \"setgid\");\n\n\tint rv = orig_setgid(gid);\n\tprintf(\"%u:%s:setgid %d:%d\\n\", pid(), name(), gid, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setgroups\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_links_homedir",
          "args": [
            "home"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "set_links_homedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
          "lines": "231-284",
          "snippet": "static void set_links_homedir(const char *homedir) {\n\tassert(homedir);\n\n\t// check firejail config directory\n\tchar *dirname;\n\tif (asprintf(&dirname, \"%s/.config/firejail\", homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(dirname, &s) != 0) {\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// parse ~/.config/firejail/ directory\n\tprintf(\"\\nConfiguring symlinks in %s based on local firejail config directory\\n\", arg_bindir);\n\n\tDIR *dir = opendir(dirname);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", dirname);\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *exec = strdup(entry->d_name);\n\t\tif (!exec)\n\t\t\terrExit(\"strdup\");\n\t\tchar *ptr = strrchr(exec, '.');\n\t\tif (!ptr) {\n\t\t\tfree(exec);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(ptr, \".profile\") != 0) {\n\t\t\tfree(exec);\n\t\t\tcontinue;\n\t\t}\n\n\t\t*ptr = '\\0';\n\t\tset_file(exec, firejail_exec);\n\t\tfree(exec);\n\t}\n\tclosedir(dir);\n\n\tfree(firejail_exec);\n}",
          "includes": [
            "#include \"../include/firejail_user.h\"",
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *arg_bindir = \"/usr/local/bin\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nchar *arg_bindir = \"/usr/local/bin\";\n\nstatic void set_links_homedir(const char *homedir) {\n\tassert(homedir);\n\n\t// check firejail config directory\n\tchar *dirname;\n\tif (asprintf(&dirname, \"%s/.config/firejail\", homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(dirname, &s) != 0) {\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// parse ~/.config/firejail/ directory\n\tprintf(\"\\nConfiguring symlinks in %s based on local firejail config directory\\n\", arg_bindir);\n\n\tDIR *dir = opendir(dirname);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", dirname);\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *exec = strdup(entry->d_name);\n\t\tif (!exec)\n\t\t\terrExit(\"strdup\");\n\t\tchar *ptr = strrchr(exec, '.');\n\t\tif (!ptr) {\n\t\t\tfree(exec);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(ptr, \".profile\") != 0) {\n\t\t\tfree(exec);\n\t\t\tcontinue;\n\t\t}\n\n\t\t*ptr = '\\0';\n\t\tset_file(exec, firejail_exec);\n\t\tfree(exec);\n\t}\n\tclosedir(dir);\n\n\tfree(firejail_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "orig_umask"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "extract_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "240-256",
          "snippet": "static void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "firejail_user_add",
          "args": [
            "user"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "firejail_user_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/firejail_user.c",
          "lines": "155-189",
          "snippet": "void firejail_user_add(const char *name) {\n\tassert(name);\n\n\t// is this a real user?\n\tstruct passwd *pw = getpwnam(name);\n\tif (!pw) {\n\t\tfprintf(stderr, \"Error: user %s not found on this system.\\n\", name);\n\t\texit(1);\n\t}\n\n\t// check the user is not already in the database\n\tchar *fname = get_fname();\n\tassert(fname);\n\tif (access(fname, F_OK) == 0) {\n\t\tif (firejail_user_check(name)) {\n\t\t\tprintf(\"User %s already in the database\\n\", name);\n\t\t\tfree(fname);\n\t\t\treturn;\n\t\t}\n\t}\n\telse\n\t\tprintf(\"Creating %s\\n\", fname);\n\n\tFILE *fp = fopen(fname, \"a+\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fname);\n\t\tperror(\"fopen\");\n\t\tfree(fname);\n\t\treturn;\n\t}\n\tfree(fname);\n\n\tfprintf(fp, \"%s\\n\", name);\n\tfclose(fp);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/common.h\"\n\nvoid firejail_user_add(const char *name) {\n\tassert(name);\n\n\t// is this a real user?\n\tstruct passwd *pw = getpwnam(name);\n\tif (!pw) {\n\t\tfprintf(stderr, \"Error: user %s not found on this system.\\n\", name);\n\t\texit(1);\n\t}\n\n\t// check the user is not already in the database\n\tchar *fname = get_fname();\n\tassert(fname);\n\tif (access(fname, F_OK) == 0) {\n\t\tif (firejail_user_check(name)) {\n\t\t\tprintf(\"User %s already in the database\\n\", name);\n\t\t\tfree(fname);\n\t\t\treturn;\n\t\t}\n\t}\n\telse\n\t\tprintf(\"Creating %s\\n\", fname);\n\n\tFILE *fp = fopen(fname, \"a+\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fname);\n\t\tperror(\"fopen\");\n\t\tfree(fname);\n\t\treturn;\n\t}\n\tfree(fname);\n\n\tfprintf(fp, \"%s\\n\", name);\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nAdding user %s to Firejail access database in %s/firejail.users\\n\"",
            "user",
            "SYSCONFDIR"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_links_firecfg",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "set_links_firecfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
          "lines": "175-228",
          "snippet": "static void set_links_firecfg(void) {\n\tchar *cfgfile;\n\tif (asprintf(&cfgfile, \"%s/firejail/firecfg.config\", LIBDIR) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// parse /usr/lib/firejail/firecfg.cfg file\n\tFILE *fp = fopen(cfgfile, \"r\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", cfgfile);\n\t\texit(1);\n\t}\n\tprintf(\"Configuring symlinks in %s based on firecfg.config\\n\", arg_bindir);\n\n\tchar buf[MAX_BUF];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_BUF,fp)) {\n\t\tlineno++;\n\t\tif (*buf == '#') // comments\n\t\t\tcontinue;\n\n\t\t// do not accept .. and/or / in file name\n\t\tif (strstr(buf, \"..\") || strchr(buf, '/')) {\n\t\t\tfprintf(stderr, \"Error: invalid line %d in %s\\n\", lineno, cfgfile);\n\t\t\texit(1);\n\t\t}\n\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// trim spaces\n\t\tptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\n\t\t// empty line\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\n\t\t// set link\n\t\tset_file(start, firejail_exec);\n\t}\n\n\tfclose(fp);\n\tfree(cfgfile);\n\tfree(firejail_exec);\n}",
          "includes": [
            "#include \"../include/firejail_user.h\"",
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *arg_bindir = \"/usr/local/bin\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nchar *arg_bindir = \"/usr/local/bin\";\n\nstatic void set_links_firecfg(void) {\n\tchar *cfgfile;\n\tif (asprintf(&cfgfile, \"%s/firejail/firecfg.config\", LIBDIR) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// parse /usr/lib/firejail/firecfg.cfg file\n\tFILE *fp = fopen(cfgfile, \"r\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", cfgfile);\n\t\texit(1);\n\t}\n\tprintf(\"Configuring symlinks in %s based on firecfg.config\\n\", arg_bindir);\n\n\tchar buf[MAX_BUF];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_BUF,fp)) {\n\t\tlineno++;\n\t\tif (*buf == '#') // comments\n\t\t\tcontinue;\n\n\t\t// do not accept .. and/or / in file name\n\t\tif (strstr(buf, \"..\") || strchr(buf, '/')) {\n\t\t\tfprintf(stderr, \"Error: invalid line %d in %s\\n\", lineno, cfgfile);\n\t\t\texit(1);\n\t\t}\n\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// trim spaces\n\t\tptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\n\t\t// empty line\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\n\t\t// set link\n\t\tset_file(start, firejail_exec);\n\t}\n\n\tfclose(fp);\n\tfree(cfgfile);\n\tfree(firejail_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean",
          "args": [],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
          "lines": "102-147",
          "snippet": "static void clean(void) {\n\tprintf(\"Removing all firejail symlinks:\\n\");\n\n\tDIR *dir = opendir(arg_bindir);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", arg_bindir);\n\t\texit(1);\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *fullname;\n\t\tif (asprintf(&fullname, \"%s/%s\", arg_bindir, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tif (is_link(fullname)) {\n\t\t\tchar* fname = realpath(fullname, NULL);\n\t\t\tif (fname) {\n\t\t\t\tif (strcmp(fname, firejail_exec) == 0) {\n\t\t\t\t\tchar *ptr = strrchr(fullname, '/');\n\t\t\t\t\tassert(ptr);\n\t\t\t\t\tptr++;\n\t\t\t\t\tint rv = unlink(fullname);\n\t\t\t\t\tif (rv)\n\t\t\t\t\t\tfprintf(stderr, \"Warning: cannot remove %s\\n\", fullname);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"   %s removed\\n\", ptr);\n\t\t\t\t}\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t\tfree(fullname);\n\t}\n\n\tclosedir(dir);\n\tfree(firejail_exec);\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"../include/firejail_user.h\"",
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *arg_bindir = \"/usr/local/bin\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nchar *arg_bindir = \"/usr/local/bin\";\n\nstatic void clean(void) {\n\tprintf(\"Removing all firejail symlinks:\\n\");\n\n\tDIR *dir = opendir(arg_bindir);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", arg_bindir);\n\t\texit(1);\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *fullname;\n\t\tif (asprintf(&fullname, \"%s/%s\", arg_bindir, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tif (is_link(fullname)) {\n\t\t\tchar* fname = realpath(fullname, NULL);\n\t\t\tif (fname) {\n\t\t\t\tif (strcmp(fname, firejail_exec) == 0) {\n\t\t\t\t\tchar *ptr = strrchr(fullname, '/');\n\t\t\t\t\tassert(ptr);\n\t\t\t\t\tptr++;\n\t\t\t\t\tint rv = unlink(fullname);\n\t\t\t\t\tif (rv)\n\t\t\t\t\t\tfprintf(stderr, \"Warning: cannot remove %s\\n\", fullname);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"   %s removed\\n\", ptr);\n\t\t\t\t}\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t\tfree(fullname);\n\t}\n\n\tclosedir(dir);\n\tfree(firejail_exec);\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create %s directory\\n\"",
            "arg_bindir"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "arg_bindir",
            "0755"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "382-389",
          "snippet": "int mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdir_t orig_mkdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Creating %s directory\\n\"",
            "arg_bindir"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "arg_bindir",
            "&s"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create /usr/local directory\\n\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Creating /usr/local directory\\n\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"The proper way to run this command is \\\"sudo firecfg\\\".\\n\""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot set the symbolic links in %s\\n\"",
            "arg_bindir"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %d %d %d %d\\n\"",
            "user",
            "getuid()",
            "getgid()",
            "geteuid()",
            "getegid()"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
          "lines": "60-63",
          "snippet": "static void usage(void) {\n\tprintf(\"firecfg - version %s\\n\\n\", VERSION);\n\tputs(usage_str);\n}",
          "includes": [
            "#include \"../include/firejail_user.h\"",
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *usage_str =\n\t\"Firecfg is the desktop configuration utility for Firejail software. The utility\\n\"\n\t\"creates several symbolic links to firejail executable. This allows the user to\\n\"\n\t\"sandbox applications automatically, just by clicking on a regular desktop\\n\"\n\t\"menus and icons.\\n\\n\"\n\t\"The symbolic links are placed in /usr/local/bin. For more information, see\\n\"\n\t\"DESKTOP INTEGRATION section in man 1 firejail.\\n\\n\"\n\t\"Usage: firecfg [OPTIONS]\\n\\n\"\n\t\"   --add-users user [user] - add the users to Firejail user access database.\\n\\n\"\n\t\"   --bindir=directory - install in directory instead of /usr/local/bin.\\n\\n\"\n\t\"   --clean - remove all firejail symbolic links.\\n\\n\"\n\t\"   --debug - print debug messages.\\n\\n\"\n\t\"   --fix - fix .desktop files.\\n\\n\"\n\t\"   --fix-sound - create ~/.config/pulse/client.conf file.\\n\\n\"\n\t\"   --help, -? - this help screen.\\n\\n\"\n\t\"   --list - list all firejail symbolic links.\\n\\n\"\n\t\"   --version - print program version and exit.\\n\\n\"\n\t\"Example:\\n\\n\"\n\t\"   $ sudo firecfg\\n\"\n\t\"   /usr/local/bin/firefox created\\n\"\n\t\"   /usr/local/bin/vlc created\\n\"\n\t\"   [...]\\n\"\n\t\"   $ firecfg --list\\n\"\n\t\"   /usr/local/bin/firefox\\n\"\n\t\"   /usr/local/bin/vlc\\n\"\n\t\"   [...]\\n\"\n\t\"   $ sudo firecfg --clean\\n\"\n\t\"   /usr/local/bin/firefox removed\\n\"\n\t\"   /usr/local/bin/vlc removed\\n\"\n\t\"   [...]\\n\"\n\t\"\\n\"\n\t\"License GPL version 2 or later\\n\"\n\t\"Homepage: https://firejail.wordpress.com\\n\\n\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nstatic char *usage_str =\n\t\"Firecfg is the desktop configuration utility for Firejail software. The utility\\n\"\n\t\"creates several symbolic links to firejail executable. This allows the user to\\n\"\n\t\"sandbox applications automatically, just by clicking on a regular desktop\\n\"\n\t\"menus and icons.\\n\\n\"\n\t\"The symbolic links are placed in /usr/local/bin. For more information, see\\n\"\n\t\"DESKTOP INTEGRATION section in man 1 firejail.\\n\\n\"\n\t\"Usage: firecfg [OPTIONS]\\n\\n\"\n\t\"   --add-users user [user] - add the users to Firejail user access database.\\n\\n\"\n\t\"   --bindir=directory - install in directory instead of /usr/local/bin.\\n\\n\"\n\t\"   --clean - remove all firejail symbolic links.\\n\\n\"\n\t\"   --debug - print debug messages.\\n\\n\"\n\t\"   --fix - fix .desktop files.\\n\\n\"\n\t\"   --fix-sound - create ~/.config/pulse/client.conf file.\\n\\n\"\n\t\"   --help, -? - this help screen.\\n\\n\"\n\t\"   --list - list all firejail symbolic links.\\n\\n\"\n\t\"   --version - print program version and exit.\\n\\n\"\n\t\"Example:\\n\\n\"\n\t\"   $ sudo firecfg\\n\"\n\t\"   /usr/local/bin/firefox created\\n\"\n\t\"   /usr/local/bin/vlc created\\n\"\n\t\"   [...]\\n\"\n\t\"   $ firecfg --list\\n\"\n\t\"   /usr/local/bin/firefox\\n\"\n\t\"   /usr/local/bin/vlc\\n\"\n\t\"   [...]\\n\"\n\t\"   $ sudo firecfg --clean\\n\"\n\t\"   /usr/local/bin/firefox removed\\n\"\n\t\"   /usr/local/bin/vlc removed\\n\"\n\t\"   [...]\\n\"\n\t\"\\n\"\n\t\"License GPL version 2 or later\\n\"\n\t\"Homepage: https://firejail.wordpress.com\\n\\n\";\n\nstatic void usage(void) {\n\tprintf(\"firecfg - version %s\\n\\n\", VERSION);\n\tputs(usage_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid command line option\\n\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--bindir=\"",
            "9"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Adding user %s to Firejail access database in %s/firejail.users\\n\"",
            "argv[j]",
            "SYSCONFDIR"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: you need to be root to use this option\\n\""
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--add-users\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sound",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "sound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/sound.c",
          "lines": "23-67",
          "snippet": "void sound(void) {\n\tstruct passwd *pw = getpwuid(getuid());\n\tif (!pw) {\n\t\tgoto errexit;\n\t}\n\tchar *home = pw->pw_dir;\n\tif (!home) {\n\t\tgoto errexit;\n\t}\n\n\t// the input file is /etc/pulse/client.conf\n\tFILE *fpin = fopen(\"/etc/pulse/client.conf\", \"r\");\n\tif (!fpin) {\n\t\tfprintf(stderr, \"PulseAudio is not available on this platform, there is nothing to fix...\\n\");\n\t\treturn;\n\t}\n\n\t// the dest is PulseAudio user config file\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/pulse/client.conf\", home) == -1)\n\t\terrExit(\"asprintf\");\n\tprintf(\"Writing file %s\\n\", fname);\n\tFILE *fpout = fopen(fname, \"w\");\n\tif (!fpout) {\n\t\tperror(\"fopen\");\n\t\tgoto errexit;\n\t}\n\tfree(fname);\n\n\t// copy default config\n\tchar buf[MAX_BUF];\n\twhile (fgets(buf, MAX_BUF, fpin))\n\t\tfputs(buf, fpout);\n\n\t// disable shm\n\tfprintf(fpout, \"\\nenable-shm = no\\n\");\n\tfclose(fpin);\n\tfclose(fpout);\n\tprintf(\"PulseAudio configured, please logout and login back again\\n\");\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot configure sound file\\n\");\n\texit(1);\n}",
          "includes": [
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firecfg.h\"\n\nvoid sound(void) {\n\tstruct passwd *pw = getpwuid(getuid());\n\tif (!pw) {\n\t\tgoto errexit;\n\t}\n\tchar *home = pw->pw_dir;\n\tif (!home) {\n\t\tgoto errexit;\n\t}\n\n\t// the input file is /etc/pulse/client.conf\n\tFILE *fpin = fopen(\"/etc/pulse/client.conf\", \"r\");\n\tif (!fpin) {\n\t\tfprintf(stderr, \"PulseAudio is not available on this platform, there is nothing to fix...\\n\");\n\t\treturn;\n\t}\n\n\t// the dest is PulseAudio user config file\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/pulse/client.conf\", home) == -1)\n\t\terrExit(\"asprintf\");\n\tprintf(\"Writing file %s\\n\", fname);\n\tFILE *fpout = fopen(fname, \"w\");\n\tif (!fpout) {\n\t\tperror(\"fopen\");\n\t\tgoto errexit;\n\t}\n\tfree(fname);\n\n\t// copy default config\n\tchar buf[MAX_BUF];\n\twhile (fgets(buf, MAX_BUF, fpin))\n\t\tfputs(buf, fpout);\n\n\t// disable shm\n\tfprintf(fpout, \"\\nenable-shm = no\\n\");\n\tfclose(fpin);\n\tfclose(fpout);\n\tprintf(\"PulseAudio configured, please logout and login back again\\n\");\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot configure sound file\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--fix-sound\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
          "lines": "66-100",
          "snippet": "static void list(void) {\n\tDIR *dir = opendir(arg_bindir);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", arg_bindir);\n\t\texit(1);\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *fullname;\n\t\tif (asprintf(&fullname, \"%s/%s\", arg_bindir, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tif (is_link(fullname)) {\n\t\t\tchar* fname = realpath(fullname, NULL);\n\t\t\tif (fname) {\n\t\t\t\tif (strcmp(fname, firejail_exec) == 0)\n\t\t\t\t\tprintf(\"%s\\n\", fullname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t\tfree(fullname);\n\t}\n\n\tclosedir(dir);\n\tfree(firejail_exec);\n}",
          "includes": [
            "#include \"../include/firejail_user.h\"",
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *arg_bindir = \"/usr/local/bin\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nchar *arg_bindir = \"/usr/local/bin\";\n\nstatic void list(void) {\n\tDIR *dir = opendir(arg_bindir);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", arg_bindir);\n\t\texit(1);\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *fullname;\n\t\tif (asprintf(&fullname, \"%s/%s\", arg_bindir, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tif (is_link(fullname)) {\n\t\t\tchar* fname = realpath(fullname, NULL);\n\t\t\tif (fname) {\n\t\t\t\tif (strcmp(fname, firejail_exec) == 0)\n\t\t\t\t\tprintf(\"%s\\n\", fullname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t\tfree(fullname);\n\t}\n\n\tclosedir(dir);\n\tfree(firejail_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--list\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--fix\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--clean\""
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"firecfg version %s\\n\\n\"",
            "VERSION"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--version\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--debug\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-?\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--help\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot access directory %s\\n\"",
            "arg_bindir"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"access\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: firecfg needs full permissions on directory %s\\n\"",
            "arg_bindir"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "arg_bindir",
            "R_OK | W_OK | X_OK"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "478-485",
          "snippet": "int access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_access_t orig_access = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_access_t orig_access = NULL;\n\nint access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&arg_bindir",
            "\"%s/%s\"",
            "home",
            "argv[i] + 11"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i] + 9",
            "\"~/\"",
            "2"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--bindir=\"",
            "9"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_homedir",
          "args": [
            "user",
            "&uid",
            "&gid"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "get_homedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
          "lines": "299-317",
          "snippet": "static char *get_homedir(const char *user, uid_t *uid, gid_t *gid) {\n\t// find home directory\n\tstruct passwd *pw = getpwnam(user);\n\tif (!pw)\n\t\tgoto errexit;\n\n\tchar *home = pw->pw_dir;\n\tif (!home)\n\t\tgoto errexit;\n\n\t*uid = pw->pw_uid;\n\t*gid = pw->pw_gid;\n\n\treturn home;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot find home directory for user %s\\n\", user);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/firejail_user.h\"",
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nstatic char *get_homedir(const char *user, uid_t *uid, gid_t *gid) {\n\t// find home directory\n\tstruct passwd *pw = getpwnam(user);\n\tif (!pw)\n\t\tgoto errexit;\n\n\tchar *home = pw->pw_dir;\n\tif (!home)\n\t\tgoto errexit;\n\n\t*uid = pw->pw_uid;\n\t*gid = pw->pw_gid;\n\n\treturn home;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot find home directory for user %s\\n\", user);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "user"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
          "lines": "286-297",
          "snippet": "static char *get_user(void) {\n\tchar *user = getlogin();\n\tif (!user) {\n\t\tuser = getenv(\"SUDO_USER\");\n\t\tif (!user) {\n\t\t\tfprintf(stderr, \"Error: cannot detect login user\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn user;\n}",
          "includes": [
            "#include \"../include/firejail_user.h\"",
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nstatic char *get_user(void) {\n\tchar *user = getlogin();\n\tif (!user) {\n\t\tuser = getenv(\"SUDO_USER\");\n\t\tif (!user) {\n\t\t\tfprintf(stderr, \"Error: cannot detect login user\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn user;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nint arg_debug = 0;\nchar *arg_bindir = \"/usr/local/bin\";\n\nint main(int argc, char **argv) {\n\tint i;\n\tint bindir_set = 0;\n\n\t// user setup\n\tchar *user = get_user();\n\tassert(user);\n\tuid_t uid;\n\tgid_t gid;\n\tchar *home = get_homedir(user, &uid, &gid);\n\n\n\t// check for --bindir\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--bindir=\", 9) == 0) {\n\t\t\tif (strncmp(argv[i] + 9, \"~/\", 2) == 0) {\n\t\t\t\tif (asprintf(&arg_bindir, \"%s/%s\", home, argv[i] + 11) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\t\telse\n\t\t\t\targ_bindir = argv[i] + 9;\n\t\t\tbindir_set = 1;\n\n\t\t\t// exit if the directory does not exist, or if we don't have access to it\n\t\t\tif (access(arg_bindir, R_OK | W_OK | X_OK)) {\n\t\t\t\tif (errno == EACCES)\n\t\t\t\t\tfprintf(stderr, \"Error: firecfg needs full permissions on directory %s\\n\", arg_bindir);\n\t\t\t\telse {\n\t\t\t\t\tperror(\"access\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot access directory %s\\n\", arg_bindir);\n\t\t\t\t}\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 1; i < argc; i++) {\n\t\t// default options\n\t\tif (strcmp(argv[i], \"--help\") == 0 ||\n\t\t    strcmp(argv[i], \"-?\") == 0) {\n\t\t\tusage();\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--debug\") == 0)\n\t\t\targ_debug = 1;\n\t\telse if (strcmp(argv[i], \"--version\") == 0) {\n\t\t\tprintf(\"firecfg version %s\\n\\n\", VERSION);\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--clean\") == 0) {\n\t\t\tclean();\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--fix\") == 0) {\n\t\t\tfix_desktop_files(home);\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--list\") == 0) {\n\t\t\tlist();\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--fix-sound\") == 0) {\n\t\t\tsound();\n\t\t\treturn 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--add-users\") == 0) {\n\t\t\tint j;\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: you need to be root to use this option\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// set umask, access database must be world-readable\n\t\t\tumask(022);\n\t\t\tfor (j = i + 1; j < argc; j++) {\n\t\t\t\tprintf(\"Adding user %s to Firejail access database in %s/firejail.users\\n\", argv[j], SYSCONFDIR);\n\t\t\t\tfirejail_user_add(argv[j]);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tif (strncmp(argv[i], \"--bindir=\", 9) != 0) { // already handled\n\t\t\t\tfprintf(stderr, \"Error: invalid command line option\\n\");\n\t\t\t\tusage();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"%s %d %d %d %d\\n\", user, getuid(), getgid(), geteuid(), getegid());\n\n\t// set symlinks in /usr/local/bin\n\tif (bindir_set == 0 && getuid() != 0) {\n\t\tfprintf(stderr, \"Error: cannot set the symbolic links in %s\\n\", arg_bindir);\n\t\tfprintf(stderr, \"The proper way to run this command is \\\"sudo firecfg\\\".\\n\");\n\t\treturn 1;\n\t}\n\telse if (bindir_set == 0) {\n\t\t// create /usr/local directory if it doesn't exist (Solus distro)\n\t\tmode_t orig_umask = umask(022); // temporarily set the umask\n\t\tstruct stat s;\n\t\tif (stat(\"/usr/local\", &s) != 0) {\n\t\t\tprintf(\"Creating /usr/local directory\\n\");\n\t\t\tint rv = mkdir(\"/usr/local\", 0755);\n\t\t\tif (rv != 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot create /usr/local directory\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (stat(arg_bindir, &s) != 0) {\n\t\t\tprintf(\"Creating %s directory\\n\", arg_bindir);\n\t\t\tint rv = mkdir(arg_bindir, 0755);\n\t\t\tif (rv != 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot create %s directory\\n\", arg_bindir);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tumask(orig_umask);\n\t}\n\n\t// clear all symlinks\n\tclean();\n\n\t// set new symlinks based on /usr/lib/firejail/firecfg.cfg\n\tset_links_firecfg();\n\n\t// add user to firejail access database - only for root\n\tif (getuid() == 0) {\n\t\tprintf(\"\\nAdding user %s to Firejail access database in %s/firejail.users\\n\", user, SYSCONFDIR);\n\t\t// temporarily set the umask, access database must be world-readable\n\t\tmode_t orig_umask = umask(022);\n\t\tfirejail_user_add(user);\n\t\tumask(orig_umask);\n\t}\n\n\t// set new symlinks based on ~/.config/firejail directory\n\tset_links_homedir(home);\n\n\t// drop permissions\n\tif (getuid() == 0) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (setgid(gid) < 0)\n\t\t\terrExit(\"setgid\");\n\t\tif (setuid(uid) < 0)\n\t\t\terrExit(\"setuid\");\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"%s %d %d %d %d\\n\", user, getuid(), getgid(), geteuid(), getegid());\n\n\t// fix .desktop files in ~/.local/share/applications directory\n\tfix_desktop_files(home);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_homedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
    "lines": "299-317",
    "snippet": "static char *get_homedir(const char *user, uid_t *uid, gid_t *gid) {\n\t// find home directory\n\tstruct passwd *pw = getpwnam(user);\n\tif (!pw)\n\t\tgoto errexit;\n\n\tchar *home = pw->pw_dir;\n\tif (!home)\n\t\tgoto errexit;\n\n\t*uid = pw->pw_uid;\n\t*gid = pw->pw_gid;\n\n\treturn home;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot find home directory for user %s\\n\", user);\n\texit(1);\n}",
    "includes": [
      "#include \"../include/firejail_user.h\"",
      "#include \"firecfg.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find home directory for user %s\\n\"",
            "user"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "user"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nstatic char *get_homedir(const char *user, uid_t *uid, gid_t *gid) {\n\t// find home directory\n\tstruct passwd *pw = getpwnam(user);\n\tif (!pw)\n\t\tgoto errexit;\n\n\tchar *home = pw->pw_dir;\n\tif (!home)\n\t\tgoto errexit;\n\n\t*uid = pw->pw_uid;\n\t*gid = pw->pw_gid;\n\n\treturn home;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot find home directory for user %s\\n\", user);\n\texit(1);\n}"
  },
  {
    "function_name": "get_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
    "lines": "286-297",
    "snippet": "static char *get_user(void) {\n\tchar *user = getlogin();\n\tif (!user) {\n\t\tuser = getenv(\"SUDO_USER\");\n\t\tif (!user) {\n\t\t\tfprintf(stderr, \"Error: cannot detect login user\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn user;\n}",
    "includes": [
      "#include \"../include/firejail_user.h\"",
      "#include \"firecfg.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot detect login user\\n\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SUDO_USER\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getlogin",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nstatic char *get_user(void) {\n\tchar *user = getlogin();\n\tif (!user) {\n\t\tuser = getenv(\"SUDO_USER\");\n\t\tif (!user) {\n\t\t\tfprintf(stderr, \"Error: cannot detect login user\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn user;\n}"
  },
  {
    "function_name": "set_links_homedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
    "lines": "231-284",
    "snippet": "static void set_links_homedir(const char *homedir) {\n\tassert(homedir);\n\n\t// check firejail config directory\n\tchar *dirname;\n\tif (asprintf(&dirname, \"%s/.config/firejail\", homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(dirname, &s) != 0) {\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// parse ~/.config/firejail/ directory\n\tprintf(\"\\nConfiguring symlinks in %s based on local firejail config directory\\n\", arg_bindir);\n\n\tDIR *dir = opendir(dirname);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", dirname);\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *exec = strdup(entry->d_name);\n\t\tif (!exec)\n\t\t\terrExit(\"strdup\");\n\t\tchar *ptr = strrchr(exec, '.');\n\t\tif (!ptr) {\n\t\t\tfree(exec);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(ptr, \".profile\") != 0) {\n\t\t\tfree(exec);\n\t\t\tcontinue;\n\t\t}\n\n\t\t*ptr = '\\0';\n\t\tset_file(exec, firejail_exec);\n\t\tfree(exec);\n\t}\n\tclosedir(dir);\n\n\tfree(firejail_exec);\n}",
    "includes": [
      "#include \"../include/firejail_user.h\"",
      "#include \"firecfg.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *arg_bindir = \"/usr/local/bin\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "firejail_exec"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "exec"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_file",
          "args": [
            "exec",
            "firejail_exec"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "set_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
          "lines": "149-172",
          "snippet": "static void set_file(const char *name, const char *firejail_exec) {\n\tif (which(name) == 0)\n\t\treturn;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%s\", arg_bindir, name) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) != 0) {\n\t\tint rv = symlink(firejail_exec, fname);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s symbolic link\\n\", fname);\n\t\t\tperror(\"symlink\");\n\t\t}\n\t\telse\n\t\t\tprintf(\"   %s created\\n\", name);\n\t}\n\telse {\n\t  fprintf(stderr, \"Warning: cannot create %s - already exists! Skipping...\\n\", fname);\n\t}\n\n\tfree(fname);\n}",
          "includes": [
            "#include \"../include/firejail_user.h\"",
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *arg_bindir = \"/usr/local/bin\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nchar *arg_bindir = \"/usr/local/bin\";\n\nstatic void set_file(const char *name, const char *firejail_exec) {\n\tif (which(name) == 0)\n\t\treturn;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%s\", arg_bindir, name) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) != 0) {\n\t\tint rv = symlink(firejail_exec, fname);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s symbolic link\\n\", fname);\n\t\t\tperror(\"symlink\");\n\t\t}\n\t\telse\n\t\t\tprintf(\"   %s created\\n\", name);\n\t}\n\telse {\n\t  fprintf(stderr, \"Warning: cannot create %s - already exists! Skipping...\\n\", fname);\n\t}\n\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "exec"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\".profile\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "exec"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "exec",
            "'.'"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "entry->d_name"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\"..\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\".\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dirname"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open %s directory\\n\"",
            "dirname"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"opendir\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "dirname"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "466-473",
          "snippet": "DIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_opendir_t orig_opendir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nConfiguring symlinks in %s based on local firejail config directory\\n\"",
            "arg_bindir"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&firejail_exec",
            "\"%s/bin/firejail\"",
            "PREFIX"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dirname"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dirname",
            "&s"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dirname",
            "\"%s/.config/firejail\"",
            "homedir"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "homedir"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nchar *arg_bindir = \"/usr/local/bin\";\n\nstatic void set_links_homedir(const char *homedir) {\n\tassert(homedir);\n\n\t// check firejail config directory\n\tchar *dirname;\n\tif (asprintf(&dirname, \"%s/.config/firejail\", homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(dirname, &s) != 0) {\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// parse ~/.config/firejail/ directory\n\tprintf(\"\\nConfiguring symlinks in %s based on local firejail config directory\\n\", arg_bindir);\n\n\tDIR *dir = opendir(dirname);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", dirname);\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *exec = strdup(entry->d_name);\n\t\tif (!exec)\n\t\t\terrExit(\"strdup\");\n\t\tchar *ptr = strrchr(exec, '.');\n\t\tif (!ptr) {\n\t\t\tfree(exec);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(ptr, \".profile\") != 0) {\n\t\t\tfree(exec);\n\t\t\tcontinue;\n\t\t}\n\n\t\t*ptr = '\\0';\n\t\tset_file(exec, firejail_exec);\n\t\tfree(exec);\n\t}\n\tclosedir(dir);\n\n\tfree(firejail_exec);\n}"
  },
  {
    "function_name": "set_links_firecfg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
    "lines": "175-228",
    "snippet": "static void set_links_firecfg(void) {\n\tchar *cfgfile;\n\tif (asprintf(&cfgfile, \"%s/firejail/firecfg.config\", LIBDIR) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// parse /usr/lib/firejail/firecfg.cfg file\n\tFILE *fp = fopen(cfgfile, \"r\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", cfgfile);\n\t\texit(1);\n\t}\n\tprintf(\"Configuring symlinks in %s based on firecfg.config\\n\", arg_bindir);\n\n\tchar buf[MAX_BUF];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_BUF,fp)) {\n\t\tlineno++;\n\t\tif (*buf == '#') // comments\n\t\t\tcontinue;\n\n\t\t// do not accept .. and/or / in file name\n\t\tif (strstr(buf, \"..\") || strchr(buf, '/')) {\n\t\t\tfprintf(stderr, \"Error: invalid line %d in %s\\n\", lineno, cfgfile);\n\t\t\texit(1);\n\t\t}\n\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// trim spaces\n\t\tptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\n\t\t// empty line\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\n\t\t// set link\n\t\tset_file(start, firejail_exec);\n\t}\n\n\tfclose(fp);\n\tfree(cfgfile);\n\tfree(firejail_exec);\n}",
    "includes": [
      "#include \"../include/firejail_user.h\"",
      "#include \"firecfg.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *arg_bindir = \"/usr/local/bin\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "firejail_exec"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cfgfile"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_file",
          "args": [
            "start",
            "firejail_exec"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "set_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
          "lines": "149-172",
          "snippet": "static void set_file(const char *name, const char *firejail_exec) {\n\tif (which(name) == 0)\n\t\treturn;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%s\", arg_bindir, name) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) != 0) {\n\t\tint rv = symlink(firejail_exec, fname);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s symbolic link\\n\", fname);\n\t\t\tperror(\"symlink\");\n\t\t}\n\t\telse\n\t\t\tprintf(\"   %s created\\n\", name);\n\t}\n\telse {\n\t  fprintf(stderr, \"Warning: cannot create %s - already exists! Skipping...\\n\", fname);\n\t}\n\n\tfree(fname);\n}",
          "includes": [
            "#include \"../include/firejail_user.h\"",
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *arg_bindir = \"/usr/local/bin\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nchar *arg_bindir = \"/usr/local/bin\";\n\nstatic void set_file(const char *name, const char *firejail_exec) {\n\tif (which(name) == 0)\n\t\treturn;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%s\", arg_bindir, name) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) != 0) {\n\t\tint rv = symlink(firejail_exec, fname);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s symbolic link\\n\", fname);\n\t\t\tperror(\"symlink\");\n\t\t}\n\t\telse\n\t\t\tprintf(\"   %s created\\n\", name);\n\t}\n\telse {\n\t  fprintf(stderr, \"Warning: cannot create %s - already exists! Skipping...\\n\", fname);\n\t}\n\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid line %d in %s\\n\"",
            "lineno",
            "cfgfile"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'/'"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "\"..\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAX_BUF",
            "fp"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring symlinks in %s based on firecfg.config\\n\"",
            "arg_bindir"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open %s\\n\"",
            "cfgfile"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fopen\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "cfgfile",
            "\"r\""
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&firejail_exec",
            "\"%s/bin/firejail\"",
            "PREFIX"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cfgfile",
            "\"%s/firejail/firecfg.config\"",
            "LIBDIR"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nchar *arg_bindir = \"/usr/local/bin\";\n\nstatic void set_links_firecfg(void) {\n\tchar *cfgfile;\n\tif (asprintf(&cfgfile, \"%s/firejail/firecfg.config\", LIBDIR) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// parse /usr/lib/firejail/firecfg.cfg file\n\tFILE *fp = fopen(cfgfile, \"r\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", cfgfile);\n\t\texit(1);\n\t}\n\tprintf(\"Configuring symlinks in %s based on firecfg.config\\n\", arg_bindir);\n\n\tchar buf[MAX_BUF];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_BUF,fp)) {\n\t\tlineno++;\n\t\tif (*buf == '#') // comments\n\t\t\tcontinue;\n\n\t\t// do not accept .. and/or / in file name\n\t\tif (strstr(buf, \"..\") || strchr(buf, '/')) {\n\t\t\tfprintf(stderr, \"Error: invalid line %d in %s\\n\", lineno, cfgfile);\n\t\t\texit(1);\n\t\t}\n\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// trim spaces\n\t\tptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\n\t\t// empty line\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\n\t\t// set link\n\t\tset_file(start, firejail_exec);\n\t}\n\n\tfclose(fp);\n\tfree(cfgfile);\n\tfree(firejail_exec);\n}"
  },
  {
    "function_name": "set_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
    "lines": "149-172",
    "snippet": "static void set_file(const char *name, const char *firejail_exec) {\n\tif (which(name) == 0)\n\t\treturn;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%s\", arg_bindir, name) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) != 0) {\n\t\tint rv = symlink(firejail_exec, fname);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s symbolic link\\n\", fname);\n\t\t\tperror(\"symlink\");\n\t\t}\n\t\telse\n\t\t\tprintf(\"   %s created\\n\", name);\n\t}\n\telse {\n\t  fprintf(stderr, \"Warning: cannot create %s - already exists! Skipping...\\n\", fname);\n\t}\n\n\tfree(fname);\n}",
    "includes": [
      "#include \"../include/firejail_user.h\"",
      "#include \"firecfg.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *arg_bindir = \"/usr/local/bin\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot create %s - already exists! Skipping...\\n\"",
            "fname"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"   %s created\\n\"",
            "name"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"symlink\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create %s symbolic link\\n\"",
            "fname"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink",
          "args": [
            "firejail_exec",
            "fname"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/%s\"",
            "arg_bindir",
            "name"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "which",
          "args": [
            "name"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "which",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/util.c",
          "lines": "44-77",
          "snippet": "int which(const char *program) {\n\t// check some well-known paths\n\tif (find(program, \"/bin\") || find(program, \"/usr/bin\") ||\n\t     find(program, \"/sbin\") || find(program, \"/usr/sbin\") ||\n\t     find(program, \"/usr/games\"))\n\t\treturn 1;\n\n\t// check environment\n\tchar *path1 = getenv(\"PATH\");\n\tif (path1) {\n\t\tchar *path2 = strdup(path1);\n\t\tif (!path2)\n\t\t\terrExit(\"strdup\");\n\n\t\t// use path2 to count the entries\n\t\tchar *ptr = strtok(path2, \":\");\n\t\twhile (ptr) {\n\t\t\t// Ubuntu 18.04 is adding  /snap/bin to PATH;\n\t\t\t// they populate /snap/bin with simbolic links to /usr/bin/ programs;\n\t\t\t// most simlinked programs are not installed by default.\n\t\t\t// Removing /snap/bin from our search\n\t\t\tif (strcmp(ptr, \"/snap/bin\") != 0) {\n\t\t\t\tif (find(program, ptr)) {\n\t\t\t\t\tfree(path2);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr = strtok(NULL, \":\");\n\t\t}\n\t\tfree(path2);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firecfg.h\"\n\nint which(const char *program) {\n\t// check some well-known paths\n\tif (find(program, \"/bin\") || find(program, \"/usr/bin\") ||\n\t     find(program, \"/sbin\") || find(program, \"/usr/sbin\") ||\n\t     find(program, \"/usr/games\"))\n\t\treturn 1;\n\n\t// check environment\n\tchar *path1 = getenv(\"PATH\");\n\tif (path1) {\n\t\tchar *path2 = strdup(path1);\n\t\tif (!path2)\n\t\t\terrExit(\"strdup\");\n\n\t\t// use path2 to count the entries\n\t\tchar *ptr = strtok(path2, \":\");\n\t\twhile (ptr) {\n\t\t\t// Ubuntu 18.04 is adding  /snap/bin to PATH;\n\t\t\t// they populate /snap/bin with simbolic links to /usr/bin/ programs;\n\t\t\t// most simlinked programs are not installed by default.\n\t\t\t// Removing /snap/bin from our search\n\t\t\tif (strcmp(ptr, \"/snap/bin\") != 0) {\n\t\t\t\tif (find(program, ptr)) {\n\t\t\t\t\tfree(path2);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr = strtok(NULL, \":\");\n\t\t}\n\t\tfree(path2);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nchar *arg_bindir = \"/usr/local/bin\";\n\nstatic void set_file(const char *name, const char *firejail_exec) {\n\tif (which(name) == 0)\n\t\treturn;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%s\", arg_bindir, name) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) != 0) {\n\t\tint rv = symlink(firejail_exec, fname);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s symbolic link\\n\", fname);\n\t\t\tperror(\"symlink\");\n\t\t}\n\t\telse\n\t\t\tprintf(\"   %s created\\n\", name);\n\t}\n\telse {\n\t  fprintf(stderr, \"Warning: cannot create %s - already exists! Skipping...\\n\", fname);\n\t}\n\n\tfree(fname);\n}"
  },
  {
    "function_name": "clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
    "lines": "102-147",
    "snippet": "static void clean(void) {\n\tprintf(\"Removing all firejail symlinks:\\n\");\n\n\tDIR *dir = opendir(arg_bindir);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", arg_bindir);\n\t\texit(1);\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *fullname;\n\t\tif (asprintf(&fullname, \"%s/%s\", arg_bindir, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tif (is_link(fullname)) {\n\t\t\tchar* fname = realpath(fullname, NULL);\n\t\t\tif (fname) {\n\t\t\t\tif (strcmp(fname, firejail_exec) == 0) {\n\t\t\t\t\tchar *ptr = strrchr(fullname, '/');\n\t\t\t\t\tassert(ptr);\n\t\t\t\t\tptr++;\n\t\t\t\t\tint rv = unlink(fullname);\n\t\t\t\t\tif (rv)\n\t\t\t\t\t\tfprintf(stderr, \"Warning: cannot remove %s\\n\", fullname);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"   %s removed\\n\", ptr);\n\t\t\t\t}\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t\tfree(fullname);\n\t}\n\n\tclosedir(dir);\n\tfree(firejail_exec);\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include \"../include/firejail_user.h\"",
      "#include \"firecfg.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *arg_bindir = \"/usr/local/bin\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "firejail_exec"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fullname"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"   %s removed\\n\"",
            "ptr"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot remove %s\\n\"",
            "fullname"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "fullname"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "359-366",
          "snippet": "int unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_unlink_t orig_unlink = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_unlink_t orig_unlink = NULL;\n\nint unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ptr"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "fullname",
            "'/'"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "firejail_exec"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "fullname",
            "NULL"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "fullname"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/ftee/main.c",
          "lines": "169-181",
          "snippet": "static int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"ftee.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"ftee.h\"\n\nstatic int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fullname",
            "\"%s/%s\"",
            "arg_bindir",
            "entry->d_name"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\"..\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\".\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&firejail_exec",
            "\"%s/bin/firejail\"",
            "PREFIX"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open %s directory\\n\"",
            "arg_bindir"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"opendir\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "arg_bindir"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "466-473",
          "snippet": "DIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_opendir_t orig_opendir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Removing all firejail symlinks:\\n\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nchar *arg_bindir = \"/usr/local/bin\";\n\nstatic void clean(void) {\n\tprintf(\"Removing all firejail symlinks:\\n\");\n\n\tDIR *dir = opendir(arg_bindir);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", arg_bindir);\n\t\texit(1);\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *fullname;\n\t\tif (asprintf(&fullname, \"%s/%s\", arg_bindir, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tif (is_link(fullname)) {\n\t\t\tchar* fname = realpath(fullname, NULL);\n\t\t\tif (fname) {\n\t\t\t\tif (strcmp(fname, firejail_exec) == 0) {\n\t\t\t\t\tchar *ptr = strrchr(fullname, '/');\n\t\t\t\t\tassert(ptr);\n\t\t\t\t\tptr++;\n\t\t\t\t\tint rv = unlink(fullname);\n\t\t\t\t\tif (rv)\n\t\t\t\t\t\tfprintf(stderr, \"Warning: cannot remove %s\\n\", fullname);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"   %s removed\\n\", ptr);\n\t\t\t\t}\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t\tfree(fullname);\n\t}\n\n\tclosedir(dir);\n\tfree(firejail_exec);\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
    "lines": "66-100",
    "snippet": "static void list(void) {\n\tDIR *dir = opendir(arg_bindir);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", arg_bindir);\n\t\texit(1);\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *fullname;\n\t\tif (asprintf(&fullname, \"%s/%s\", arg_bindir, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tif (is_link(fullname)) {\n\t\t\tchar* fname = realpath(fullname, NULL);\n\t\t\tif (fname) {\n\t\t\t\tif (strcmp(fname, firejail_exec) == 0)\n\t\t\t\t\tprintf(\"%s\\n\", fullname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t\tfree(fullname);\n\t}\n\n\tclosedir(dir);\n\tfree(firejail_exec);\n}",
    "includes": [
      "#include \"../include/firejail_user.h\"",
      "#include \"firecfg.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *arg_bindir = \"/usr/local/bin\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "firejail_exec"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fullname"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "fullname"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "firejail_exec"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "fullname",
            "NULL"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "fullname"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/ftee/main.c",
          "lines": "169-181",
          "snippet": "static int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"ftee.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"ftee.h\"\n\nstatic int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fullname",
            "\"%s/%s\"",
            "arg_bindir",
            "entry->d_name"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\"..\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\".\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&firejail_exec",
            "\"%s/bin/firejail\"",
            "PREFIX"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open %s directory\\n\"",
            "arg_bindir"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"opendir\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "arg_bindir"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "466-473",
          "snippet": "DIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_opendir_t orig_opendir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nchar *arg_bindir = \"/usr/local/bin\";\n\nstatic void list(void) {\n\tDIR *dir = opendir(arg_bindir);\n\tif (!dir) {\n\t\tperror(\"opendir\");\n\t\tfprintf(stderr, \"Error: cannot open %s directory\\n\", arg_bindir);\n\t\texit(1);\n\t}\n\n\tchar *firejail_exec;\n\tif (asprintf(&firejail_exec, \"%s/bin/firejail\", PREFIX) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *fullname;\n\t\tif (asprintf(&fullname, \"%s/%s\", arg_bindir, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tif (is_link(fullname)) {\n\t\t\tchar* fname = realpath(fullname, NULL);\n\t\t\tif (fname) {\n\t\t\t\tif (strcmp(fname, firejail_exec) == 0)\n\t\t\t\t\tprintf(\"%s\\n\", fullname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t\tfree(fullname);\n\t}\n\n\tclosedir(dir);\n\tfree(firejail_exec);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
    "lines": "60-63",
    "snippet": "static void usage(void) {\n\tprintf(\"firecfg - version %s\\n\\n\", VERSION);\n\tputs(usage_str);\n}",
    "includes": [
      "#include \"../include/firejail_user.h\"",
      "#include \"firecfg.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *usage_str =\n\t\"Firecfg is the desktop configuration utility for Firejail software. The utility\\n\"\n\t\"creates several symbolic links to firejail executable. This allows the user to\\n\"\n\t\"sandbox applications automatically, just by clicking on a regular desktop\\n\"\n\t\"menus and icons.\\n\\n\"\n\t\"The symbolic links are placed in /usr/local/bin. For more information, see\\n\"\n\t\"DESKTOP INTEGRATION section in man 1 firejail.\\n\\n\"\n\t\"Usage: firecfg [OPTIONS]\\n\\n\"\n\t\"   --add-users user [user] - add the users to Firejail user access database.\\n\\n\"\n\t\"   --bindir=directory - install in directory instead of /usr/local/bin.\\n\\n\"\n\t\"   --clean - remove all firejail symbolic links.\\n\\n\"\n\t\"   --debug - print debug messages.\\n\\n\"\n\t\"   --fix - fix .desktop files.\\n\\n\"\n\t\"   --fix-sound - create ~/.config/pulse/client.conf file.\\n\\n\"\n\t\"   --help, -? - this help screen.\\n\\n\"\n\t\"   --list - list all firejail symbolic links.\\n\\n\"\n\t\"   --version - print program version and exit.\\n\\n\"\n\t\"Example:\\n\\n\"\n\t\"   $ sudo firecfg\\n\"\n\t\"   /usr/local/bin/firefox created\\n\"\n\t\"   /usr/local/bin/vlc created\\n\"\n\t\"   [...]\\n\"\n\t\"   $ firecfg --list\\n\"\n\t\"   /usr/local/bin/firefox\\n\"\n\t\"   /usr/local/bin/vlc\\n\"\n\t\"   [...]\\n\"\n\t\"   $ sudo firecfg --clean\\n\"\n\t\"   /usr/local/bin/firefox removed\\n\"\n\t\"   /usr/local/bin/vlc removed\\n\"\n\t\"   [...]\\n\"\n\t\"\\n\"\n\t\"License GPL version 2 or later\\n\"\n\t\"Homepage: https://firejail.wordpress.com\\n\\n\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "puts",
          "args": [
            "usage_str"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"firecfg - version %s\\n\\n\"",
            "VERSION"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nstatic char *usage_str =\n\t\"Firecfg is the desktop configuration utility for Firejail software. The utility\\n\"\n\t\"creates several symbolic links to firejail executable. This allows the user to\\n\"\n\t\"sandbox applications automatically, just by clicking on a regular desktop\\n\"\n\t\"menus and icons.\\n\\n\"\n\t\"The symbolic links are placed in /usr/local/bin. For more information, see\\n\"\n\t\"DESKTOP INTEGRATION section in man 1 firejail.\\n\\n\"\n\t\"Usage: firecfg [OPTIONS]\\n\\n\"\n\t\"   --add-users user [user] - add the users to Firejail user access database.\\n\\n\"\n\t\"   --bindir=directory - install in directory instead of /usr/local/bin.\\n\\n\"\n\t\"   --clean - remove all firejail symbolic links.\\n\\n\"\n\t\"   --debug - print debug messages.\\n\\n\"\n\t\"   --fix - fix .desktop files.\\n\\n\"\n\t\"   --fix-sound - create ~/.config/pulse/client.conf file.\\n\\n\"\n\t\"   --help, -? - this help screen.\\n\\n\"\n\t\"   --list - list all firejail symbolic links.\\n\\n\"\n\t\"   --version - print program version and exit.\\n\\n\"\n\t\"Example:\\n\\n\"\n\t\"   $ sudo firecfg\\n\"\n\t\"   /usr/local/bin/firefox created\\n\"\n\t\"   /usr/local/bin/vlc created\\n\"\n\t\"   [...]\\n\"\n\t\"   $ firecfg --list\\n\"\n\t\"   /usr/local/bin/firefox\\n\"\n\t\"   /usr/local/bin/vlc\\n\"\n\t\"   [...]\\n\"\n\t\"   $ sudo firecfg --clean\\n\"\n\t\"   /usr/local/bin/firefox removed\\n\"\n\t\"   /usr/local/bin/vlc removed\\n\"\n\t\"   [...]\\n\"\n\t\"\\n\"\n\t\"License GPL version 2 or later\\n\"\n\t\"Homepage: https://firejail.wordpress.com\\n\\n\";\n\nstatic void usage(void) {\n\tprintf(\"firecfg - version %s\\n\\n\", VERSION);\n\tputs(usage_str);\n}"
  }
]