[
  {
    "function_name": "duplicate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-optimize/optimizer.c",
    "lines": "125-135",
    "snippet": "struct sock_filter *duplicate(struct sock_filter *filter, int entries) {\n\tint len = sizeof(struct sock_filter) * entries;\n\tstruct sock_filter *rv = malloc(len);\n\tif (!rv) {\n\t\terrExit(\"malloc\");\n\t\texit(1);\n\t}\n\n\tmemcpy(rv, filter, len);\n\treturn rv;\n}",
    "includes": [
      "#include \"fsec_optimize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rv",
            "filter",
            "len"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsec_optimize.h\"\n\nstruct sock_filter *duplicate(struct sock_filter *filter, int entries) {\n\tint len = sizeof(struct sock_filter) * entries;\n\tstruct sock_filter *rv = malloc(len);\n\tif (!rv) {\n\t\terrExit(\"malloc\");\n\t\texit(1);\n\t}\n\n\tmemcpy(rv, filter, len);\n\treturn rv;\n}"
  },
  {
    "function_name": "optimize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-optimize/optimizer.c",
    "lines": "111-123",
    "snippet": "int optimize(struct sock_filter *filter, int entries) {\n\tassert(filter);\n\tassert(entries);\n\n\t//**********************************\n\t// optimize blacklist statements\n\t//**********************************\n\t// count \"ret KILL\"\n\tint cnt = count_blacklists(filter, entries);\n\tif (cnt > LIMIT_BLACKLISTS)\n\t\tentries = optimize_blacklists(filter, entries);\n\treturn entries;\n}",
    "includes": [
      "#include \"fsec_optimize.h\""
    ],
    "macros_used": [
      "#define LIMIT_BLACKLISTS 4\t// we optimize blacklists only if we have more than"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "optimize_blacklists",
          "args": [
            "filter",
            "entries"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "optimize_blacklists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-optimize/optimizer.c",
          "lines": "58-109",
          "snippet": "static int optimize_blacklists(struct sock_filter *filter, int entries) {\n\tassert(entries);\n\tassert(filter);\n\tint i;\n\tint j;\n\n\t// step1: extract information\n\tAction action[entries];\n\tmemset(&action[0], 0, sizeof(Action) * entries);\n\tint remove_cnt = 0;\n\tfor (i = 0; i < (entries - 1); i++) { // is_blacklist works on two consecutive lines; using entries - 1\n\t\tif (is_blacklist(filter + i)) {\n\t\t\taction[i]. to_fix_jumps = 1;\n\t\t\ti++;\n\t\t\taction[i].to_remove = 1;\n\t\t\tremove_cnt++;\n\t\t}\n\t}\n\n\t// step2: remove lines\n\tstruct sock_filter *filter_step2 = duplicate(filter, entries);\n\tAction action_step2[entries];\n\tmemset(&action_step2[0], 0, sizeof(Action) * entries);\n\tfor (i = 0, j = 0; i < entries; i++) {\n\t\tif (!action[i].to_remove) {\n\t\t\tmemcpy(&filter_step2[j], &filter[i], sizeof(struct sock_filter));\n\t\t\tmemcpy(&action_step2[j], &action[i], sizeof(Action));\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\t// do nothing, we are removing this line\n\t\t}\n\t}\n\n\t// step 3: add the new ret KILL, and recalculate entries\n\tfilter_step2[j].code = BPF_RET + BPF_K;\n\tfilter_step2[j].k = SECCOMP_RET_KILL;\n\tentries = j + 1;\n\n\t// step 4: recalculate jumps\n\tfor (i = 0; i < entries; i++) {\n\t\tif (action_step2[i].to_fix_jumps) {\n\t\t\tfilter_step2[i].jt = entries - i - 2;\n\t\t\tfilter_step2[i].jf = 0;\n\t\t}\n\t}\n\n\t// update\n\tmemcpy(filter, filter_step2, entries * sizeof(struct sock_filter));\n\tfree(filter_step2);\n\treturn entries;\n}",
          "includes": [
            "#include \"fsec_optimize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsec_optimize.h\"\n\nstatic int optimize_blacklists(struct sock_filter *filter, int entries) {\n\tassert(entries);\n\tassert(filter);\n\tint i;\n\tint j;\n\n\t// step1: extract information\n\tAction action[entries];\n\tmemset(&action[0], 0, sizeof(Action) * entries);\n\tint remove_cnt = 0;\n\tfor (i = 0; i < (entries - 1); i++) { // is_blacklist works on two consecutive lines; using entries - 1\n\t\tif (is_blacklist(filter + i)) {\n\t\t\taction[i]. to_fix_jumps = 1;\n\t\t\ti++;\n\t\t\taction[i].to_remove = 1;\n\t\t\tremove_cnt++;\n\t\t}\n\t}\n\n\t// step2: remove lines\n\tstruct sock_filter *filter_step2 = duplicate(filter, entries);\n\tAction action_step2[entries];\n\tmemset(&action_step2[0], 0, sizeof(Action) * entries);\n\tfor (i = 0, j = 0; i < entries; i++) {\n\t\tif (!action[i].to_remove) {\n\t\t\tmemcpy(&filter_step2[j], &filter[i], sizeof(struct sock_filter));\n\t\t\tmemcpy(&action_step2[j], &action[i], sizeof(Action));\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\t// do nothing, we are removing this line\n\t\t}\n\t}\n\n\t// step 3: add the new ret KILL, and recalculate entries\n\tfilter_step2[j].code = BPF_RET + BPF_K;\n\tfilter_step2[j].k = SECCOMP_RET_KILL;\n\tentries = j + 1;\n\n\t// step 4: recalculate jumps\n\tfor (i = 0; i < entries; i++) {\n\t\tif (action_step2[i].to_fix_jumps) {\n\t\t\tfilter_step2[i].jt = entries - i - 2;\n\t\t\tfilter_step2[i].jf = 0;\n\t\t}\n\t}\n\n\t// update\n\tmemcpy(filter, filter_step2, entries * sizeof(struct sock_filter));\n\tfree(filter_step2);\n\treturn entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_blacklists",
          "args": [
            "filter",
            "entries"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "count_blacklists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-optimize/optimizer.c",
          "lines": "41-51",
          "snippet": "static int count_blacklists(struct sock_filter *filter, int entries) {\n\tint cnt = 0;\n\tint i;\n\n\tfor (i = 0; i < (entries - 1); i++, filter++) { // is_blacklist works on two consecutive lines; using entries - 1\n\t\tif (is_blacklist(filter))\n\t\t\tcnt++;\n\t}\n\n\treturn cnt;\n}",
          "includes": [
            "#include \"fsec_optimize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsec_optimize.h\"\n\nstatic int count_blacklists(struct sock_filter *filter, int entries) {\n\tint cnt = 0;\n\tint i;\n\n\tfor (i = 0; i < (entries - 1); i++, filter++) { // is_blacklist works on two consecutive lines; using entries - 1\n\t\tif (is_blacklist(filter))\n\t\t\tcnt++;\n\t}\n\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "entries"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "filter"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsec_optimize.h\"\n\n#define LIMIT_BLACKLISTS 4\t// we optimize blacklists only if we have more than\n\nint optimize(struct sock_filter *filter, int entries) {\n\tassert(filter);\n\tassert(entries);\n\n\t//**********************************\n\t// optimize blacklist statements\n\t//**********************************\n\t// count \"ret KILL\"\n\tint cnt = count_blacklists(filter, entries);\n\tif (cnt > LIMIT_BLACKLISTS)\n\t\tentries = optimize_blacklists(filter, entries);\n\treturn entries;\n}"
  },
  {
    "function_name": "optimize_blacklists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-optimize/optimizer.c",
    "lines": "58-109",
    "snippet": "static int optimize_blacklists(struct sock_filter *filter, int entries) {\n\tassert(entries);\n\tassert(filter);\n\tint i;\n\tint j;\n\n\t// step1: extract information\n\tAction action[entries];\n\tmemset(&action[0], 0, sizeof(Action) * entries);\n\tint remove_cnt = 0;\n\tfor (i = 0; i < (entries - 1); i++) { // is_blacklist works on two consecutive lines; using entries - 1\n\t\tif (is_blacklist(filter + i)) {\n\t\t\taction[i]. to_fix_jumps = 1;\n\t\t\ti++;\n\t\t\taction[i].to_remove = 1;\n\t\t\tremove_cnt++;\n\t\t}\n\t}\n\n\t// step2: remove lines\n\tstruct sock_filter *filter_step2 = duplicate(filter, entries);\n\tAction action_step2[entries];\n\tmemset(&action_step2[0], 0, sizeof(Action) * entries);\n\tfor (i = 0, j = 0; i < entries; i++) {\n\t\tif (!action[i].to_remove) {\n\t\t\tmemcpy(&filter_step2[j], &filter[i], sizeof(struct sock_filter));\n\t\t\tmemcpy(&action_step2[j], &action[i], sizeof(Action));\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\t// do nothing, we are removing this line\n\t\t}\n\t}\n\n\t// step 3: add the new ret KILL, and recalculate entries\n\tfilter_step2[j].code = BPF_RET + BPF_K;\n\tfilter_step2[j].k = SECCOMP_RET_KILL;\n\tentries = j + 1;\n\n\t// step 4: recalculate jumps\n\tfor (i = 0; i < entries; i++) {\n\t\tif (action_step2[i].to_fix_jumps) {\n\t\t\tfilter_step2[i].jt = entries - i - 2;\n\t\t\tfilter_step2[i].jf = 0;\n\t\t}\n\t}\n\n\t// update\n\tmemcpy(filter, filter_step2, entries * sizeof(struct sock_filter));\n\tfree(filter_step2);\n\treturn entries;\n}",
    "includes": [
      "#include \"fsec_optimize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "filter_step2"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "filter",
            "filter_step2",
            "entries * sizeof(struct sock_filter)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&action_step2[j]",
            "&action[i]",
            "sizeof(Action)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&filter_step2[j]",
            "&filter[i]",
            "sizeof(struct sock_filter)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&action_step2[0]",
            "0",
            "sizeof(Action) * entries"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "duplicate",
          "args": [
            "filter",
            "entries"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "duplicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-optimize/optimizer.c",
          "lines": "125-135",
          "snippet": "struct sock_filter *duplicate(struct sock_filter *filter, int entries) {\n\tint len = sizeof(struct sock_filter) * entries;\n\tstruct sock_filter *rv = malloc(len);\n\tif (!rv) {\n\t\terrExit(\"malloc\");\n\t\texit(1);\n\t}\n\n\tmemcpy(rv, filter, len);\n\treturn rv;\n}",
          "includes": [
            "#include \"fsec_optimize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsec_optimize.h\"\n\nstruct sock_filter *duplicate(struct sock_filter *filter, int entries) {\n\tint len = sizeof(struct sock_filter) * entries;\n\tstruct sock_filter *rv = malloc(len);\n\tif (!rv) {\n\t\terrExit(\"malloc\");\n\t\texit(1);\n\t}\n\n\tmemcpy(rv, filter, len);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_blacklist",
          "args": [
            "filter + i"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "is_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-optimize/optimizer.c",
          "lines": "33-39",
          "snippet": "static inline int is_blacklist(struct sock_filter *bpf) {\n\tif (bpf->code == BPF_JMP + BPF_JEQ + BPF_K &&\n\t    (bpf + 1)->code == BPF_RET + BPF_K &&\n\t    (bpf + 1)->k == SECCOMP_RET_KILL )\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"fsec_optimize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsec_optimize.h\"\n\nstatic inline int is_blacklist(struct sock_filter *bpf) {\n\tif (bpf->code == BPF_JMP + BPF_JEQ + BPF_K &&\n\t    (bpf + 1)->code == BPF_RET + BPF_K &&\n\t    (bpf + 1)->k == SECCOMP_RET_KILL )\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&action[0]",
            "0",
            "sizeof(Action) * entries"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "filter"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "entries"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsec_optimize.h\"\n\nstatic int optimize_blacklists(struct sock_filter *filter, int entries) {\n\tassert(entries);\n\tassert(filter);\n\tint i;\n\tint j;\n\n\t// step1: extract information\n\tAction action[entries];\n\tmemset(&action[0], 0, sizeof(Action) * entries);\n\tint remove_cnt = 0;\n\tfor (i = 0; i < (entries - 1); i++) { // is_blacklist works on two consecutive lines; using entries - 1\n\t\tif (is_blacklist(filter + i)) {\n\t\t\taction[i]. to_fix_jumps = 1;\n\t\t\ti++;\n\t\t\taction[i].to_remove = 1;\n\t\t\tremove_cnt++;\n\t\t}\n\t}\n\n\t// step2: remove lines\n\tstruct sock_filter *filter_step2 = duplicate(filter, entries);\n\tAction action_step2[entries];\n\tmemset(&action_step2[0], 0, sizeof(Action) * entries);\n\tfor (i = 0, j = 0; i < entries; i++) {\n\t\tif (!action[i].to_remove) {\n\t\t\tmemcpy(&filter_step2[j], &filter[i], sizeof(struct sock_filter));\n\t\t\tmemcpy(&action_step2[j], &action[i], sizeof(Action));\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\t// do nothing, we are removing this line\n\t\t}\n\t}\n\n\t// step 3: add the new ret KILL, and recalculate entries\n\tfilter_step2[j].code = BPF_RET + BPF_K;\n\tfilter_step2[j].k = SECCOMP_RET_KILL;\n\tentries = j + 1;\n\n\t// step 4: recalculate jumps\n\tfor (i = 0; i < entries; i++) {\n\t\tif (action_step2[i].to_fix_jumps) {\n\t\t\tfilter_step2[i].jt = entries - i - 2;\n\t\t\tfilter_step2[i].jf = 0;\n\t\t}\n\t}\n\n\t// update\n\tmemcpy(filter, filter_step2, entries * sizeof(struct sock_filter));\n\tfree(filter_step2);\n\treturn entries;\n}"
  },
  {
    "function_name": "count_blacklists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-optimize/optimizer.c",
    "lines": "41-51",
    "snippet": "static int count_blacklists(struct sock_filter *filter, int entries) {\n\tint cnt = 0;\n\tint i;\n\n\tfor (i = 0; i < (entries - 1); i++, filter++) { // is_blacklist works on two consecutive lines; using entries - 1\n\t\tif (is_blacklist(filter))\n\t\t\tcnt++;\n\t}\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"fsec_optimize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_blacklist",
          "args": [
            "filter"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "is_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-optimize/optimizer.c",
          "lines": "33-39",
          "snippet": "static inline int is_blacklist(struct sock_filter *bpf) {\n\tif (bpf->code == BPF_JMP + BPF_JEQ + BPF_K &&\n\t    (bpf + 1)->code == BPF_RET + BPF_K &&\n\t    (bpf + 1)->k == SECCOMP_RET_KILL )\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"fsec_optimize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsec_optimize.h\"\n\nstatic inline int is_blacklist(struct sock_filter *bpf) {\n\tif (bpf->code == BPF_JMP + BPF_JEQ + BPF_K &&\n\t    (bpf + 1)->code == BPF_RET + BPF_K &&\n\t    (bpf + 1)->k == SECCOMP_RET_KILL )\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fsec_optimize.h\"\n\nstatic int count_blacklists(struct sock_filter *filter, int entries) {\n\tint cnt = 0;\n\tint i;\n\n\tfor (i = 0; i < (entries - 1); i++, filter++) { // is_blacklist works on two consecutive lines; using entries - 1\n\t\tif (is_blacklist(filter))\n\t\t\tcnt++;\n\t}\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "is_blacklist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-optimize/optimizer.c",
    "lines": "33-39",
    "snippet": "static inline int is_blacklist(struct sock_filter *bpf) {\n\tif (bpf->code == BPF_JMP + BPF_JEQ + BPF_K &&\n\t    (bpf + 1)->code == BPF_RET + BPF_K &&\n\t    (bpf + 1)->k == SECCOMP_RET_KILL )\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"fsec_optimize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fsec_optimize.h\"\n\nstatic inline int is_blacklist(struct sock_filter *bpf) {\n\tif (bpf->code == BPF_JMP + BPF_JEQ + BPF_K &&\n\t    (bpf + 1)->code == BPF_RET + BPF_K &&\n\t    (bpf + 1)->k == SECCOMP_RET_KILL )\n\t\treturn 1;\n\treturn 0;\n}"
  }
]