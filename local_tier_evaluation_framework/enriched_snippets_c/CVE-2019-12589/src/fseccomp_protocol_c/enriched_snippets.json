[
  {
    "function_name": "protocol_build_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/protocol.c",
    "lines": "109-224",
    "snippet": "void protocol_build_filter(const char *prlist, const char *fname) {\n\tassert(prlist);\n\tassert(fname);\n\n#ifndef SYS_socket\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fseccomp: --protocol not supported on this platform\\n\");\n\treturn;\n#else\n\t// build the filter\n\tstruct sock_filter filter[32];\t// big enough\n\tmemset(&filter[0], 0, sizeof(filter));\n\tuint8_t *ptr = (uint8_t *) &filter[0];\n\n\t// header\n\tstruct sock_filter filter_start[] = {\n\t\tVALIDATE_ARCHITECTURE,\n\t\tEXAMINE_SYSCALL,\n\t\tONLY(SYS_socket),\n\t\tEXAMINE_ARGUMENT(0)\n\t};\n\tmemcpy(ptr, &filter_start[0], sizeof(filter_start));\n\tptr += sizeof(filter_start);\n\n#if 0\nprintf(\"entries %u\\n\", (unsigned) (sizeof(filter_start) / sizeof(struct sock_filter)));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\nprintf(\"whitelist_len %u, struct sock_filter len %u\\n\", whitelist_len, (unsigned) sizeof(struct sock_filter));\n#endif\n\n\n\t// parse list and add commands\n\tchar *tmplist = strdup(prlist);\n\tif (!tmplist)\n\t\terrExit(\"strdup\");\n\tchar *token = strtok(tmplist, \",\");\n\tif (!token)\n\t\terrExit(\"strtok\");\n\n\twhile (token) {\n\t\tstruct sock_filter *domain = find_protocol_domain(token);\n\t\tif (domain == NULL) {\n\t\t\tfprintf(stderr, \"Error fseccomp: %s is not a valid protocol\\n\", token);\n\t\t\texit(1);\n\t\t}\n\t\tmemcpy(ptr, domain, whitelist_len * sizeof(struct sock_filter));\n\t\tptr += whitelist_len * sizeof(struct sock_filter);\n\t\ttoken = strtok(NULL, \",\");\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\n\n\n\t}\n\tfree(tmplist);\n\n\t// add end of filter\n\tstruct sock_filter filter_end[] = {\n\t\tRETURN_ERRNO(ENOTSUP)\n\t};\n\tmemcpy(ptr, &filter_end[0], sizeof(filter_end));\n\tptr += sizeof(filter_end);\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\n\t// save filter to file\n\tint dst = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\tint size = (int) ((uintptr_t) ptr - (uintptr_t) (filter));\n\tint written = 0;\n\twhile (written < size) {\n\t\tint rv = write(dst, (unsigned char *) filter + written, size - written);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot write %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\twritten += rv;\n\t}\n\tclose(dst);\n#endif // SYS_socket\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include \"../include/seccomp.h\"",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};",
      "unsigned whitelist_len = sizeof(whitelist) / sizeof(struct sock_filter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "dst"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot write %s file\\n\"",
            "fname"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "dst",
            "(unsigned char *) filter + written",
            "size - written"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "24-37",
          "snippet": "void write_to_file(int fd, const void *data, int size) {\n\tassert(data);\n\tassert(size);\n\n\tint written = 0;\n\twhile (written < size) {\n\t\tint rv = write(fd, (unsigned char *) data + written, size - written);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot write seccomp file\\n\");\n\t\t\texit(1);\n\t\t}\n\t\twritten += rv;\n\t}\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid write_to_file(int fd, const void *data, int size) {\n\tassert(data);\n\tassert(size);\n\n\tint written = 0;\n\twhile (written < size) {\n\t\tint rv = write(fd, (unsigned char *) data + written, size - written);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot write seccomp file\\n\");\n\t\t\texit(1);\n\t\t}\n\t\twritten += rv;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot open %s file\\n\"",
            "fname"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "fname",
            "O_CREAT|O_WRONLY|O_TRUNC",
            "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "freopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "346-353",
          "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%02x, \"",
            "(*ptr2) & 0xff"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n%u: \"",
            "1 + (unsigned) (j / (sizeof(struct sock_filter)))"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"entries %u\\n\"",
            "(unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "&filter_end[0]",
            "sizeof(filter_end)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RETURN_ERRNO",
          "args": [
            "ENOTSUP"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmplist"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%02x, \"",
            "(*ptr2) & 0xff"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n%u: \"",
            "1 + (unsigned) (j / (sizeof(struct sock_filter)))"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"entries %u\\n\"",
            "(unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "domain",
            "whitelist_len * sizeof(struct sock_filter)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: %s is not a valid protocol\\n\"",
            "token"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_protocol_domain",
          "args": [
            "token"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "find_protocol_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/protocol.c",
          "lines": "81-90",
          "snippet": "static struct sock_filter *find_protocol_domain(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn &protocol_filter_command[i * whitelist_len];\n\t\ti++;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};",
            "unsigned whitelist_len = sizeof(whitelist) / sizeof(struct sock_filter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nstatic char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};\nunsigned whitelist_len = sizeof(whitelist) / sizeof(struct sock_filter);\n\nstatic struct sock_filter *find_protocol_domain(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn &protocol_filter_command[i * whitelist_len];\n\t\ti++;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strtok\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "tmplist",
            "\",\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "prlist"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"whitelist_len %u, struct sock_filter len %u\\n\"",
            "whitelist_len",
            "(unsigned) sizeof(struct sock_filter)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%02x, \"",
            "(*ptr2) & 0xff"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n%u: \"",
            "1 + (unsigned) (j / (sizeof(struct sock_filter)))"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"entries %u\\n\"",
            "(unsigned) (sizeof(filter_start) / sizeof(struct sock_filter))"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "&filter_start[0]",
            "sizeof(filter_start)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXAMINE_ARGUMENT",
          "args": [
            "0"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ONLY",
          "args": [
            "SYS_socket"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&filter[0]",
            "0",
            "sizeof(filter)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning fseccomp: --protocol not supported on this platform\\n\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "prlist"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nstatic char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};\nunsigned whitelist_len = sizeof(whitelist) / sizeof(struct sock_filter);\n\nvoid protocol_build_filter(const char *prlist, const char *fname) {\n\tassert(prlist);\n\tassert(fname);\n\n#ifndef SYS_socket\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fseccomp: --protocol not supported on this platform\\n\");\n\treturn;\n#else\n\t// build the filter\n\tstruct sock_filter filter[32];\t// big enough\n\tmemset(&filter[0], 0, sizeof(filter));\n\tuint8_t *ptr = (uint8_t *) &filter[0];\n\n\t// header\n\tstruct sock_filter filter_start[] = {\n\t\tVALIDATE_ARCHITECTURE,\n\t\tEXAMINE_SYSCALL,\n\t\tONLY(SYS_socket),\n\t\tEXAMINE_ARGUMENT(0)\n\t};\n\tmemcpy(ptr, &filter_start[0], sizeof(filter_start));\n\tptr += sizeof(filter_start);\n\n#if 0\nprintf(\"entries %u\\n\", (unsigned) (sizeof(filter_start) / sizeof(struct sock_filter)));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\nprintf(\"whitelist_len %u, struct sock_filter len %u\\n\", whitelist_len, (unsigned) sizeof(struct sock_filter));\n#endif\n\n\n\t// parse list and add commands\n\tchar *tmplist = strdup(prlist);\n\tif (!tmplist)\n\t\terrExit(\"strdup\");\n\tchar *token = strtok(tmplist, \",\");\n\tif (!token)\n\t\terrExit(\"strtok\");\n\n\twhile (token) {\n\t\tstruct sock_filter *domain = find_protocol_domain(token);\n\t\tif (domain == NULL) {\n\t\t\tfprintf(stderr, \"Error fseccomp: %s is not a valid protocol\\n\", token);\n\t\t\texit(1);\n\t\t}\n\t\tmemcpy(ptr, domain, whitelist_len * sizeof(struct sock_filter));\n\t\tptr += whitelist_len * sizeof(struct sock_filter);\n\t\ttoken = strtok(NULL, \",\");\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\n\n\n\t}\n\tfree(tmplist);\n\n\t// add end of filter\n\tstruct sock_filter filter_end[] = {\n\t\tRETURN_ERRNO(ENOTSUP)\n\t};\n\tmemcpy(ptr, &filter_end[0], sizeof(filter_end));\n\tptr += sizeof(filter_end);\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\n\t// save filter to file\n\tint dst = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\tint size = (int) ((uintptr_t) ptr - (uintptr_t) (filter));\n\tint written = 0;\n\twhile (written < size) {\n\t\tint rv = write(dst, (unsigned char *) filter + written, size - written);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot write %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\twritten += rv;\n\t}\n\tclose(dst);\n#endif // SYS_socket\n}"
  },
  {
    "function_name": "protocol_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/protocol.c",
    "lines": "93-106",
    "snippet": "void protocol_print(void) {\n#ifndef SYS_socket\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fseccomp: firejail --protocol not supported on this platform\\n\");\n\treturn;\n#endif\n\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tprintf(\"%s, \", protocol[i]);\n\t\ti++;\n\t}\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include \"../include/seccomp.h\"",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s, \"",
            "protocol[i]"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning fseccomp: firejail --protocol not supported on this platform\\n\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nstatic char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};\n\nvoid protocol_print(void) {\n#ifndef SYS_socket\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fseccomp: firejail --protocol not supported on this platform\\n\");\n\treturn;\n#endif\n\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tprintf(\"%s, \", protocol[i]);\n\t\ti++;\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "find_protocol_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/protocol.c",
    "lines": "81-90",
    "snippet": "static struct sock_filter *find_protocol_domain(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn &protocol_filter_command[i * whitelist_len];\n\t\ti++;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include \"../include/seccomp.h\"",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};",
      "unsigned whitelist_len = sizeof(whitelist) / sizeof(struct sock_filter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "protocol[i]",
            "p"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nstatic char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};\nunsigned whitelist_len = sizeof(whitelist) / sizeof(struct sock_filter);\n\nstatic struct sock_filter *find_protocol_domain(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn &protocol_filter_command[i * whitelist_len];\n\t\ti++;\n\t}\n\n\treturn NULL;\n}"
  }
]