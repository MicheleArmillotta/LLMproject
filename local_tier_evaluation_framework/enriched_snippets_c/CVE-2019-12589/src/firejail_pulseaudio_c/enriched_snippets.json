[
  {
    "function_name": "pulseaudio_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/pulseaudio.c",
    "lines": "73-184",
    "snippet": "void pulseaudio_init(void) {\n\tstruct stat s;\n\n\t// do we have pulseaudio in the system?\n\tif (stat(\"/etc/pulse/client.conf\", &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"/etc/pulse/client.conf not found\\n\");\n\t\treturn;\n\t}\n\n\t// create the new user pulseaudio directory\n\tif (mkdir(RUN_PULSE_DIR, 0700) == -1)\n\t\terrExit(\"mkdir\");\n\t// mount it nosuid, noexec, nodev\n\tfs_noexec(RUN_PULSE_DIR);\n\n\t// create the new client.conf file\n\tchar *pulsecfg = NULL;\n\tif (asprintf(&pulsecfg, \"%s/client.conf\", RUN_PULSE_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (copy_file(\"/etc/pulse/client.conf\", pulsecfg, -1, -1, 0644)) // root needed\n\t\terrExit(\"copy_file\");\n\tFILE *fp = fopen(pulsecfg, \"a\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\", \"\\nenable-shm = no\\n\");\n\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\tfclose(fp);\n\t// hand over the directory to the user\n\tif (set_perms(RUN_PULSE_DIR, getuid(), getgid(), 0700))\n\t\terrExit(\"set_perms\");\n\n\t// create ~/.config/pulse directory if not present\n\tchar *homeusercfg;\n\tif (asprintf(&homeusercfg, \"%s/.config\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(homeusercfg, &s) == -1) {\n\t\tif (create_empty_dir_as_user(homeusercfg, 0700))\n\t\t\tfs_logger2(\"create\", homeusercfg);\n\t}\n\telse if (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", homeusercfg);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", homeusercfg);\n\t\texit(1);\n\t}\n\tfree(homeusercfg);\n\n\tif (asprintf(&homeusercfg, \"%s/.config/pulse\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(homeusercfg, &s) == -1) {\n\t\tif (create_empty_dir_as_user(homeusercfg, 0700))\n\t\t\tfs_logger2(\"create\", homeusercfg);\n\t}\n\telse if (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", homeusercfg);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", homeusercfg);\n\t\texit(1);\n\t}\n\n\t// if we have ~/.config/pulse mount the new directory, else set environment variable.\n\tif (stat(homeusercfg, &s) == 0) {\n\t\t// get a file descriptor for ~/.config/pulse, fails if there is any symlink\n\t\tint fd = safe_fd(homeusercfg, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\terrExit(\"safe_fd\");\n\t\t// confirm the actual mount destination is owned by the user\n\t\tif (fstat(fd, &s) == -1)\n\t\t\terrExit(\"fstat\");\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", homeusercfg);\n\t\t\texit(1);\n\t\t}\n\t\t// preserve a read-only mount\n\t\tstruct statvfs vfs;\n\t\tif (fstatvfs(fd, &vfs) == -1)\n\t\t\terrExit(\"fstatvfs\");\n\t\tif ((vfs.f_flag & MS_RDONLY) == MS_RDONLY)\n\t\t\tfs_rdonly(RUN_PULSE_DIR);\n\t\t// mount via the link in /proc/self/fd\n\t\tchar *proc;\n\t\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(RUN_PULSE_DIR, proc, \"none\", MS_BIND, NULL) < 0)\n\t\t\terrExit(\"mount pulseaudio\");\n\t\tfs_logger2(\"tmpfs\", homeusercfg);\n\t\tfree(proc);\n\t\tclose(fd);\n\t\t// check /proc/self/mountinfo to confirm the mount is ok\n\t\tMountData *mptr = get_last_mount();\n\t\tif (strcmp(mptr->dir, homeusercfg) != 0 || strcmp(mptr->fstype, \"tmpfs\") != 0)\n\t\t\terrLogExit(\"invalid pulseaudio mount\");\n\n\t\tchar *p;\n\t\tif (asprintf(&p, \"%s/client.conf\", homeusercfg) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tfs_logger2(\"create\", p);\n\t\tfree(p);\n\t}\n\n\telse {\n\t\t// set environment\n\t\tif (setenv(\"PULSE_CLIENTCONFIG\", pulsecfg, 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\n\tfree(pulsecfg);\n\tfree(homeusercfg);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <dirent.h>",
      "#include <sys/mount.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "homeusercfg"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pulsecfg"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"PULSE_CLIENTCONFIG\"",
            "pulsecfg",
            "1"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"create\"",
            "p"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&p",
            "\"%s/client.conf\"",
            "homeusercfg"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errLogExit",
          "args": [
            "\"invalid pulseaudio mount\""
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "errLogExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "40-57",
          "snippet": "void errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mptr->fstype",
            "\"tmpfs\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mptr->dir",
            "homeusercfg"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_mount",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "get_last_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "131-152",
          "snippet": "MountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [
            "static char mbuf[MAX_BUF];",
            "static MountData mdata;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nstatic char mbuf[MAX_BUF];\nstatic MountData mdata;\n\nMountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "proc"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount pulseaudio\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_PULSE_DIR",
            "proc",
            "\"none\"",
            "MS_BIND",
            "NULL"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&proc",
            "\"/proc/self/fd/%d\"",
            "fd"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_rdonly",
          "args": [
            "RUN_PULSE_DIR"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "516-541",
          "snippet": "void fs_rdonly_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdonly(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdonly(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mount_warning = 0;",
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_rdonly_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdonly(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdonly(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstatvfs\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstatvfs",
          "args": [
            "fd",
            "&vfs"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is not owned by the current user\\n\"",
            "homeusercfg"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&s"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"safe_fd\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_fd",
          "args": [
            "homeusercfg",
            "O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "safe_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1143-1209",
          "snippet": "int safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define EMPTY_STRING (\"\")"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nint safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "homeusercfg",
            "&s"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is not a directory\\n\"",
            "homeusercfg"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is a symbolic link\\n\"",
            "homeusercfg"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "s.st_mode"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_empty_dir_as_user",
          "args": [
            "homeusercfg",
            "0700"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_dir_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "972-1007",
          "snippet": "int create_empty_dir_as_user(const char *dir, mode_t mode) {\n\tassert(dir);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(dir, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s directory\\n\", dir);\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\n\t\t\tif (mkdir(dir, mode) == 0) {\n\t\t\t\tif (chmod(dir, mode) == -1)\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\telse if (arg_debug) {\n\t\t\t\tchar *str;\n\t\t\t\tif (asprintf(&str, \"Directory %s not created\", dir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tperror(str);\n\t\t\t}\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\twaitpid(child, NULL, 0);\n\t\tif (stat(dir, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint create_empty_dir_as_user(const char *dir, mode_t mode) {\n\tassert(dir);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(dir, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s directory\\n\", dir);\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\n\t\t\tif (mkdir(dir, mode) == 0) {\n\t\t\t\tif (chmod(dir, mode) == -1)\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\telse if (arg_debug) {\n\t\t\t\tchar *str;\n\t\t\t\tif (asprintf(&str, \"Directory %s not created\", dir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tperror(str);\n\t\t\t}\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\twaitpid(child, NULL, 0);\n\t\tif (stat(dir, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&homeusercfg",
            "\"%s/.config/pulse\"",
            "cfg.homedir"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "homeusercfg"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is not a directory\\n\"",
            "homeusercfg"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is a symbolic link\\n\"",
            "homeusercfg"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "s.st_mode"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&homeusercfg",
            "\"%s/.config\"",
            "cfg.homedir"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"set_perms\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_perms",
          "args": [
            "RUN_PULSE_DIR",
            "getuid()",
            "getgid()",
            "0700"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "set_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1047-1054",
          "snippet": "int set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "getuid()",
            "getgid()",
            "0644"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"%s\"",
            "\"\\nenable-shm = no\\n\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fopen\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "pulsecfg",
            "\"a\""
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"copy_file\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_file",
          "args": [
            "\"/etc/pulse/client.conf\"",
            "pulsecfg",
            "-1",
            "-1",
            "0644"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_from_user_to_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "337-374",
          "snippet": "void copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\treturn;\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tint src = open(srcname, O_RDONLY);\n\t\tif (src < 0) {\n\t\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\t} else {\n\t\t\tif (copy_file_by_fd(src, dst)) {\n\t\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n\t\t\t}\n\t\t\tclose(src);\n\t\t}\n\t\tclose(dst);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tif (fchown(dst, uid, gid) == -1)\n\t\terrExit(\"fchown\");\n\tif (fchmod(dst, mode) == -1)\n\t\terrExit(\"fchmod\");\n\tclose(dst);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\treturn;\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tint src = open(srcname, O_RDONLY);\n\t\tif (src < 0) {\n\t\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\t} else {\n\t\t\tif (copy_file_by_fd(src, dst)) {\n\t\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n\t\t\t}\n\t\t\tclose(src);\n\t\t}\n\t\tclose(dst);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tif (fchown(dst, uid, gid) == -1)\n\t\terrExit(\"fchown\");\n\tif (fchmod(dst, mode) == -1)\n\t\terrExit(\"fchmod\");\n\tclose(dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&pulsecfg",
            "\"%s/client.conf\"",
            "RUN_PULSE_DIR"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_noexec",
          "args": [
            "RUN_PULSE_DIR"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "fs_noexec_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "630-655",
          "snippet": "void fs_noexec_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_noexec(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_noexec(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mount_warning = 0;",
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_noexec_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_noexec(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_noexec(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "RUN_PULSE_DIR",
            "0700"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "382-389",
          "snippet": "int mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdir_t orig_mkdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"/etc/pulse/client.conf not found\\n\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid pulseaudio_init(void) {\n\tstruct stat s;\n\n\t// do we have pulseaudio in the system?\n\tif (stat(\"/etc/pulse/client.conf\", &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"/etc/pulse/client.conf not found\\n\");\n\t\treturn;\n\t}\n\n\t// create the new user pulseaudio directory\n\tif (mkdir(RUN_PULSE_DIR, 0700) == -1)\n\t\terrExit(\"mkdir\");\n\t// mount it nosuid, noexec, nodev\n\tfs_noexec(RUN_PULSE_DIR);\n\n\t// create the new client.conf file\n\tchar *pulsecfg = NULL;\n\tif (asprintf(&pulsecfg, \"%s/client.conf\", RUN_PULSE_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (copy_file(\"/etc/pulse/client.conf\", pulsecfg, -1, -1, 0644)) // root needed\n\t\terrExit(\"copy_file\");\n\tFILE *fp = fopen(pulsecfg, \"a\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\", \"\\nenable-shm = no\\n\");\n\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\tfclose(fp);\n\t// hand over the directory to the user\n\tif (set_perms(RUN_PULSE_DIR, getuid(), getgid(), 0700))\n\t\terrExit(\"set_perms\");\n\n\t// create ~/.config/pulse directory if not present\n\tchar *homeusercfg;\n\tif (asprintf(&homeusercfg, \"%s/.config\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(homeusercfg, &s) == -1) {\n\t\tif (create_empty_dir_as_user(homeusercfg, 0700))\n\t\t\tfs_logger2(\"create\", homeusercfg);\n\t}\n\telse if (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", homeusercfg);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", homeusercfg);\n\t\texit(1);\n\t}\n\tfree(homeusercfg);\n\n\tif (asprintf(&homeusercfg, \"%s/.config/pulse\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(homeusercfg, &s) == -1) {\n\t\tif (create_empty_dir_as_user(homeusercfg, 0700))\n\t\t\tfs_logger2(\"create\", homeusercfg);\n\t}\n\telse if (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", homeusercfg);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", homeusercfg);\n\t\texit(1);\n\t}\n\n\t// if we have ~/.config/pulse mount the new directory, else set environment variable.\n\tif (stat(homeusercfg, &s) == 0) {\n\t\t// get a file descriptor for ~/.config/pulse, fails if there is any symlink\n\t\tint fd = safe_fd(homeusercfg, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\terrExit(\"safe_fd\");\n\t\t// confirm the actual mount destination is owned by the user\n\t\tif (fstat(fd, &s) == -1)\n\t\t\terrExit(\"fstat\");\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", homeusercfg);\n\t\t\texit(1);\n\t\t}\n\t\t// preserve a read-only mount\n\t\tstruct statvfs vfs;\n\t\tif (fstatvfs(fd, &vfs) == -1)\n\t\t\terrExit(\"fstatvfs\");\n\t\tif ((vfs.f_flag & MS_RDONLY) == MS_RDONLY)\n\t\t\tfs_rdonly(RUN_PULSE_DIR);\n\t\t// mount via the link in /proc/self/fd\n\t\tchar *proc;\n\t\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(RUN_PULSE_DIR, proc, \"none\", MS_BIND, NULL) < 0)\n\t\t\terrExit(\"mount pulseaudio\");\n\t\tfs_logger2(\"tmpfs\", homeusercfg);\n\t\tfree(proc);\n\t\tclose(fd);\n\t\t// check /proc/self/mountinfo to confirm the mount is ok\n\t\tMountData *mptr = get_last_mount();\n\t\tif (strcmp(mptr->dir, homeusercfg) != 0 || strcmp(mptr->fstype, \"tmpfs\") != 0)\n\t\t\terrLogExit(\"invalid pulseaudio mount\");\n\n\t\tchar *p;\n\t\tif (asprintf(&p, \"%s/client.conf\", homeusercfg) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tfs_logger2(\"create\", p);\n\t\tfree(p);\n\t}\n\n\telse {\n\t\t// set environment\n\t\tif (setenv(\"PULSE_CLIENTCONFIG\", pulsecfg, 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\n\tfree(pulsecfg);\n\tfree(homeusercfg);\n}"
  },
  {
    "function_name": "pulseaudio_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/pulseaudio.c",
    "lines": "30-69",
    "snippet": "void pulseaudio_disable(void) {\n\tif (arg_debug)\n\t\tprintf(\"disable pulseaudio\\n\");\n\t// blacklist user config directory\n\tdisable_file_path(cfg.homedir, \".config/pulse\");\n\n\n\t// blacklist pulseaudio socket in XDG_RUNTIME_DIR\n\tchar *name = getenv(\"XDG_RUNTIME_DIR\");\n\tif (name)\n\t\tdisable_file_path(name, \"pulse/native\");\n\n\t// try the default location anyway\n\tchar *path;\n\tif (asprintf(&path, \"/run/user/%d\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\tdisable_file_path(path, \"pulse/native\");\n\tfree(path);\n\n\n\n\t// blacklist any pulse* file in /tmp directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tdisable_file_path(\"/tmp\", entry->d_name);\n\t\t}\n\t}\n\n\tclosedir(dir);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <dirent.h>",
      "#include <sys/mount.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_file_path",
          "args": [
            "\"/tmp\"",
            "entry->d_name"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "disable_file_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1129-1139",
          "snippet": "void disable_file_path(const char *path, const char *file) {\n\tassert(file);\n\tassert(path);\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%s\", path, file) == -1)\n\t\terrExit(\"asprintf\");\n\n\tdisable_file_or_dir(fname);\n\tfree(fname);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid disable_file_path(const char *path, const char *file) {\n\tassert(file);\n\tassert(path);\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%s\", path, file) == -1)\n\t\terrExit(\"asprintf\");\n\n\tdisable_file_or_dir(fname);\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->d_name",
            "\"pulse-\"",
            "6"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/tmp\""
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "466-473",
          "snippet": "DIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_opendir_t orig_opendir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "firemon_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "90-121",
          "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios tlocal;",
            "static struct termios twait;",
            "static int terminal_set = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&path",
            "\"/run/user/%d\"",
            "getuid()"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XDG_RUNTIME_DIR\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"disable pulseaudio\\n\""
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid pulseaudio_disable(void) {\n\tif (arg_debug)\n\t\tprintf(\"disable pulseaudio\\n\");\n\t// blacklist user config directory\n\tdisable_file_path(cfg.homedir, \".config/pulse\");\n\n\n\t// blacklist pulseaudio socket in XDG_RUNTIME_DIR\n\tchar *name = getenv(\"XDG_RUNTIME_DIR\");\n\tif (name)\n\t\tdisable_file_path(name, \"pulse/native\");\n\n\t// try the default location anyway\n\tchar *path;\n\tif (asprintf(&path, \"/run/user/%d\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\tdisable_file_path(path, \"pulse/native\");\n\tfree(path);\n\n\n\n\t// blacklist any pulse* file in /tmp directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tdisable_file_path(\"/tmp\", entry->d_name);\n\t\t}\n\t}\n\n\tclosedir(dir);\n}"
  }
]