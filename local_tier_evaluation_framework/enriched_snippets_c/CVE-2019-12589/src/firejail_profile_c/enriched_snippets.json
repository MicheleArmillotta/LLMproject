[
  {
    "function_name": "profile_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "1387-1509",
    "snippet": "void profile_read(const char *fname) {\n\tEUID_ASSERT();\n\n\t// exit program if maximum include level was reached\n\tif (include_level > MAX_INCLUDE_LEVEL) {\n\t\tfprintf(stderr, \"Error: maximum profile include level was reached\\n\");\n\t\texit(1);\n\t}\n\n\t// check file\n\tinvalid_filename(fname, 0); // no globbing\n\tif (strlen(fname) == 0 || is_dir(fname)) {\n\t\tfprintf(stderr, \"Error: invalid profile file\\n\");\n\t\texit(1);\n\t}\n\tif (access(fname, R_OK)) {\n\t\t// if the file ends in \".local\", do not exit\n\t\tconst char *base = gnu_basename(fname);\n\t\tchar *ptr = strstr(base, \".local\");\n\t\tif (ptr && strlen(ptr) == 6)\n\t\t\treturn;\n\n\t\tfprintf(stderr, \"Error: cannot access profile file: %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// allow debuggers\n\tif (arg_allow_debuggers) {\n\t\tchar *tmp = strrchr(fname, '/');\n\t\tif (tmp && *(tmp + 1) != '\\0') {\n\t\t\ttmp++;\n\t\t\tif (strcmp(tmp, \"disable-devel.inc\") == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// open profile file:\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"Error: cannot open profile file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// save the name of the file for --profile.print option\n\tif (include_level == 0)\n\t\tset_profile_run_file(getpid(), fname);\n\n\tint msg_printed = 0;\n\n\t// read the file line by line\n\tchar buf[MAX_READ + 1];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\t++lineno;\n\t\t// remove empty space - ptr in allocated memory\n\t\tchar *ptr = line_remove_spaces(buf);\n\t\tif (ptr == NULL)\n\t\t\tcontinue;\n\n\t\t// comments\n\t\tif (*ptr == '#' || *ptr == '\\0') {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process quiet\n\t\t// todo: a quiet in the profile file cannot be disabled by --ignore on command line\n\t\tif (strcmp(ptr, \"quiet\") == 0) {\n\t\t\tif (is_in_ignore_list(ptr))\n\t\t\t\targ_quiet = 0;\n\t\t\telse\n\t\t\t\targ_quiet = 1;\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!msg_printed) {\n\t\t\tfmessage(\"Reading profile %s\\n\", fname);\n\t\t\tmsg_printed = 1;\n\t\t}\n\n\t\t// process include\n\t\tif (strncmp(ptr, \"include \", 8) == 0) {\n\t\t\tinclude_level++;\n\n\t\t\t// expand macros in front of the include profile file\n\t\t\tchar *newprofile = expand_macros(ptr + 8);\n\n\t\t\tchar *ptr2 = newprofile;\n\t\t\twhile (*ptr2 != '/' && *ptr2 != '\\0')\n\t\t\t\tptr2++;\n\t\t\t// profile path contains no / chars, do a search\n\t\t\tif (*ptr2 == '\\0') {\n\t\t\t\tint rv = profile_find_firejail(newprofile, 0); // returns 1 if a profile was found in sysconfig directory\n\t\t\t\tif (!rv) {\n\t\t\t\t\t// maybe this is a file in the local working directory?\n\t\t\t\t\t// it will stop the sandbox if not!\n\t\t\t\t\t// Note: if the file ends in .local it will not stop the program\n\t\t\t\t\tprofile_read(newprofile);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprofile_read(newprofile);\n\t\t\t}\n\n\t\t\tinclude_level--;\n\t\t\tfree(newprofile);\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// verify syntax, exit in case of error\n\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\tprofile_add(ptr);\n// we cannot free ptr here, data is extracted from ptr and linked as a pointer in cfg structure\n//\t\telse {\n//\t\t\tfree(ptr);\n//\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t}\n\tfclose(fp);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
    ],
    "globals_used": [
      "static int include_level = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gcov_flush",
          "args": [],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_add",
          "args": [
            "ptr"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "1364-1383",
          "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_check_line",
          "args": [
            "ptr",
            "lineno",
            "fname"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "profile_check_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "243-1361",
          "snippet": "int profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\n\t// check and process conditional profile lines\n\tif (profile_check_conditional(ptr, lineno, fname) == 0)\n\t\treturn 0;\n\n\t// check ignore list\n\tif (is_in_ignore_list(ptr))\n\t\treturn 0;\n\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tprofile_add_ignore(ptr + 7);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\txephyr_screen = ptr + 14;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\t// mkdir\n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\t// process mkdir again while applying blacklists\n\t}\n\t// mkfile\n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\t// process mkfile again while applying blacklists\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse\n\t\t\twarning_feature_disabled(\"noroot\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tif (cfg.home_private_keep) {\n\t\t\t\tif ( asprintf(&cfg.home_private_keep, \"%s,%s\", cfg.home_private_keep, ptr + 13) < 0 )\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t} else\n\t\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\targ_private = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-home\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-cache\") == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_CACHE))\n\t\t\targ_private_cache = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"private-cache\");\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"keep-dev-shm\") == 0) {\n\t\targ_keep_dev_shm = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"noautopulse\") == 0) {\n\t\targ_noautopulse = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"notv\") == 0) {\n\t\targ_notv = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodvd\") == 0) {\n\t\targ_nodvd = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"novideo\") == 0) {\n\t\targ_novideo = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodbus\") == 0) {\n\t\targ_nodbus = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nou2f\") == 0) {\n\t        arg_nou2f = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n\t\targ_nonetwork  = 1;\n\t\tcfg.bridge0.configured = 0;\n\t\tcfg.bridge1.configured = 0;\n\t\tcfg.bridge2.configured = 0;\n\t\tcfg.bridge3.configured = 0;\n\t\tcfg.interface0.configured = 0;\n\t\tcfg.interface1.configured = 0;\n\t\tcfg.interface2.configured = 0;\n\t\tcfg.interface3.configured = 0;\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbr->dev = ptr + 4;\n\t\t\tbr->configured = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"netmask \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->masksandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the network mask twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this network mask for the last bridge defined\n\t\t\tif (atoip(ptr + 8, &br->masksandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid  network mask\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// if the bridge is not configured, use this mask as the bridge mask\n\t\t\tif (br->mask == 0)\n\t\t\t\tbr->mask = br->masksandbox;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: interface %s already has a network mask defined; \"\n\t\t\t\t\t\"please remove --netmask\\n\",\n\t\t\t\t\tbr->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IPv6 address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->ip6sandbox = strdup(ptr + 4);\n\t\t\tif (br->ip6sandbox == NULL)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\tif (cfg.protocol) {\n\t\t\t\tfwarning(\"two protocol lists are present, \\\"%s\\\" will be installed\\n\", cfg.protocol);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// store list\n\t\t\tcfg.protocol = strdup(ptr + 9);\n\t\t\tif (!cfg.protocol)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = seccomp_check_list(ptr + 8);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"seccomp.block-secondary\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp_block_secondary = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// memory deny write&execute\n\tif (strcmp(ptr, \"memory-deny-write-execute\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_memory_deny_write_execute = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\n\t// hosts-file\n\tif (strncmp(ptr, \"hosts-file \", 11) == 0) {\n\t\tcfg.hosts_file = fs_check_hosts_file(ptr + 11);\n\t\treturn 0;\n\t}\n\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\n\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IPv4 or IPv6 address\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tchar *dns = strdup(ptr + 4);\n\t\tif (!dns)\n\t\t\terrExit(\"strdup\");\n\n\t\tif (cfg.dns1 == NULL)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == NULL)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == NULL)\n\t\t\tcfg.dns3 = dns;\n\t\telse if (cfg.dns4 == NULL)\n\t\t\tcfg.dns4 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 4 DNS servers can be specified\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 5) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tif (checkcfg(CFG_CGROUP))\n\t\t\tset_cgroup(ptr + 7);\n\t\telse\n\t\t\twarning_feature_disabled(\"cgroup\");\n\t\treturn 0;\n\t}\n\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"machine-id\") == 0) {\n\t\targ_machineid = 1;\n\t\treturn 0;\n\t}\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t// don't overwrite /var/tmp\n\tif (strcmp(ptr, \"keep-var-tmp\") == 0) {\n\t\targ_keep_var_tmp = 1;\n\t\treturn 0;\n\t}\n\t// writable-run-user\n\tif (strcmp(ptr, \"writable-run-user\") == 0) {\n\t\targ_writable_run_user = 1;\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"writable-var-log\") == 0) {\n\t\targ_writable_var_log = 1;\n\t\treturn 0;\n\t}\n\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xvfb\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xvfb(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (cfg.etc_private_keep) {\n\t\t\tif ( asprintf(&cfg.etc_private_keep, \"%s,%s\", cfg.etc_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.etc_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_etc = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /opt list of files and directories\n\tif (strncmp(ptr, \"private-opt \", 12) == 0) {\n\t\tif (cfg.opt_private_keep) {\n\t\t\tif ( asprintf(&cfg.opt_private_keep, \"%s,%s\", cfg.opt_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.opt_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_opt = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /srv list of files and directories\n\tif (strncmp(ptr, \"private-srv \", 12) == 0) {\n\t\tif (cfg.srv_private_keep) {\n\t\t\tif ( asprintf(&cfg.srv_private_keep, \"%s,%s\", cfg.srv_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.srv_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_srv = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tif (cfg.bin_private_keep) {\n\t\t\tif ( asprintf(&cfg.bin_private_keep, \"%s,%s\", cfg.bin_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.bin_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_bin = 1;\n\t\treturn 0;\n\t}\n\n\t// private /lib list of files\n\tif (strncmp(ptr, \"private-lib\", 11) == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_LIB)) {\n\t\t\tif (ptr[11] == ' ') {\n\t\t\t\tif (cfg.lib_private_keep) {\n\t\t\t\t\tif (ptr[12] != '\\0' && asprintf(&cfg.lib_private_keep, \"%s,%s\", cfg.lib_private_keep, ptr + 12) < 0)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t} else {\n\t\t\t\t\tcfg.lib_private_keep = ptr + 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\targ_private_lib = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-lib\");\n\t\treturn 0;\n\t}\n\n\n#ifdef HAVE_OVERLAYFS\n\tif (strncmp(ptr, \"overlay-named \", 14) == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\t\t\targ_overlay_reuse = 1;\n\n\t\t\tchar *subdirname = ptr + 14;\n\t\t\tif (*subdirname == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay option\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check name\n\t\t\tinvalid_filename(subdirname, 0); // no globbing\n\t\t\tif (strstr(subdirname, \"..\") || strstr(subdirname, \"/\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay-tmpfs\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\n\t\t\tchar *subdirname;\n\t\t\tif (asprintf(&subdirname, \"%d\", getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\n\t\t\tfree(subdirname);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\t}\n#endif\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1, 0); // no globbing\n\t\t\tinvalid_filename(dname2, 0); // no globbing\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"bind\");\n\t\treturn 0;\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tcheck_unsigned(ptr + 14, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 14, \"%llu\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-cpu \", 11) == 0) {\n\t\t\tcheck_unsigned(ptr + 11, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 11, \"%llu\", &cfg.rlimit_cpu);\n\t\t\targ_rlimit_cpu = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tcheck_unsigned(ptr + 18, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 18, \"%llu\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-as \", 10) == 0) {\n\t\t\tcheck_unsigned(ptr + 10, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 10, \"%llu\", &cfg.rlimit_as);\n\t\t\targ_rlimit_as = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"timeout \", 8) == 0) {\n\t\tcfg.timeout = extract_timeout(ptr +8);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0) {\n\t\t\t// try to join by name only\n\t\t\tpid_t pid;\n\t\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t\t// find first non-option arg\n\t\t\t\tint i;\n\t\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t// set sandbox name and start normally\n\t\t\tcfg.name = ptr + 14;\n\t\t\tif (strlen(cfg.name) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"join\");\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"disable-mnt\") == 0) {\n\t\targ_disable_mnt = 1;\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse {\n\t\t\tstatic int whitelist_warning_printed = 0;\n\t\t\tif (!whitelist_warning_printed) {\n\t\t\t\twarning_feature_disabled(\"whitelist\");\n\t\t\t\twhitelist_warning_printed = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n#else\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"nowhitelist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr, 1); // globbing\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *xephyr_screen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nextern char *xephyr_screen;\n\nint profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\n\t// check and process conditional profile lines\n\tif (profile_check_conditional(ptr, lineno, fname) == 0)\n\t\treturn 0;\n\n\t// check ignore list\n\tif (is_in_ignore_list(ptr))\n\t\treturn 0;\n\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tprofile_add_ignore(ptr + 7);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\txephyr_screen = ptr + 14;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\t// mkdir\n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\t// process mkdir again while applying blacklists\n\t}\n\t// mkfile\n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\t// process mkfile again while applying blacklists\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse\n\t\t\twarning_feature_disabled(\"noroot\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tif (cfg.home_private_keep) {\n\t\t\t\tif ( asprintf(&cfg.home_private_keep, \"%s,%s\", cfg.home_private_keep, ptr + 13) < 0 )\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t} else\n\t\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\targ_private = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-home\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-cache\") == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_CACHE))\n\t\t\targ_private_cache = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"private-cache\");\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"keep-dev-shm\") == 0) {\n\t\targ_keep_dev_shm = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"noautopulse\") == 0) {\n\t\targ_noautopulse = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"notv\") == 0) {\n\t\targ_notv = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodvd\") == 0) {\n\t\targ_nodvd = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"novideo\") == 0) {\n\t\targ_novideo = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodbus\") == 0) {\n\t\targ_nodbus = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nou2f\") == 0) {\n\t        arg_nou2f = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n\t\targ_nonetwork  = 1;\n\t\tcfg.bridge0.configured = 0;\n\t\tcfg.bridge1.configured = 0;\n\t\tcfg.bridge2.configured = 0;\n\t\tcfg.bridge3.configured = 0;\n\t\tcfg.interface0.configured = 0;\n\t\tcfg.interface1.configured = 0;\n\t\tcfg.interface2.configured = 0;\n\t\tcfg.interface3.configured = 0;\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbr->dev = ptr + 4;\n\t\t\tbr->configured = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"netmask \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->masksandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the network mask twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this network mask for the last bridge defined\n\t\t\tif (atoip(ptr + 8, &br->masksandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid  network mask\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// if the bridge is not configured, use this mask as the bridge mask\n\t\t\tif (br->mask == 0)\n\t\t\t\tbr->mask = br->masksandbox;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: interface %s already has a network mask defined; \"\n\t\t\t\t\t\"please remove --netmask\\n\",\n\t\t\t\t\tbr->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IPv6 address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->ip6sandbox = strdup(ptr + 4);\n\t\t\tif (br->ip6sandbox == NULL)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\tif (cfg.protocol) {\n\t\t\t\tfwarning(\"two protocol lists are present, \\\"%s\\\" will be installed\\n\", cfg.protocol);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// store list\n\t\t\tcfg.protocol = strdup(ptr + 9);\n\t\t\tif (!cfg.protocol)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = seccomp_check_list(ptr + 8);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"seccomp.block-secondary\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp_block_secondary = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// memory deny write&execute\n\tif (strcmp(ptr, \"memory-deny-write-execute\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_memory_deny_write_execute = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\n\t// hosts-file\n\tif (strncmp(ptr, \"hosts-file \", 11) == 0) {\n\t\tcfg.hosts_file = fs_check_hosts_file(ptr + 11);\n\t\treturn 0;\n\t}\n\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\n\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IPv4 or IPv6 address\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tchar *dns = strdup(ptr + 4);\n\t\tif (!dns)\n\t\t\terrExit(\"strdup\");\n\n\t\tif (cfg.dns1 == NULL)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == NULL)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == NULL)\n\t\t\tcfg.dns3 = dns;\n\t\telse if (cfg.dns4 == NULL)\n\t\t\tcfg.dns4 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 4 DNS servers can be specified\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 5) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tif (checkcfg(CFG_CGROUP))\n\t\t\tset_cgroup(ptr + 7);\n\t\telse\n\t\t\twarning_feature_disabled(\"cgroup\");\n\t\treturn 0;\n\t}\n\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"machine-id\") == 0) {\n\t\targ_machineid = 1;\n\t\treturn 0;\n\t}\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t// don't overwrite /var/tmp\n\tif (strcmp(ptr, \"keep-var-tmp\") == 0) {\n\t\targ_keep_var_tmp = 1;\n\t\treturn 0;\n\t}\n\t// writable-run-user\n\tif (strcmp(ptr, \"writable-run-user\") == 0) {\n\t\targ_writable_run_user = 1;\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"writable-var-log\") == 0) {\n\t\targ_writable_var_log = 1;\n\t\treturn 0;\n\t}\n\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xvfb\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xvfb(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (cfg.etc_private_keep) {\n\t\t\tif ( asprintf(&cfg.etc_private_keep, \"%s,%s\", cfg.etc_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.etc_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_etc = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /opt list of files and directories\n\tif (strncmp(ptr, \"private-opt \", 12) == 0) {\n\t\tif (cfg.opt_private_keep) {\n\t\t\tif ( asprintf(&cfg.opt_private_keep, \"%s,%s\", cfg.opt_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.opt_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_opt = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /srv list of files and directories\n\tif (strncmp(ptr, \"private-srv \", 12) == 0) {\n\t\tif (cfg.srv_private_keep) {\n\t\t\tif ( asprintf(&cfg.srv_private_keep, \"%s,%s\", cfg.srv_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.srv_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_srv = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tif (cfg.bin_private_keep) {\n\t\t\tif ( asprintf(&cfg.bin_private_keep, \"%s,%s\", cfg.bin_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.bin_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_bin = 1;\n\t\treturn 0;\n\t}\n\n\t// private /lib list of files\n\tif (strncmp(ptr, \"private-lib\", 11) == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_LIB)) {\n\t\t\tif (ptr[11] == ' ') {\n\t\t\t\tif (cfg.lib_private_keep) {\n\t\t\t\t\tif (ptr[12] != '\\0' && asprintf(&cfg.lib_private_keep, \"%s,%s\", cfg.lib_private_keep, ptr + 12) < 0)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t} else {\n\t\t\t\t\tcfg.lib_private_keep = ptr + 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\targ_private_lib = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-lib\");\n\t\treturn 0;\n\t}\n\n\n#ifdef HAVE_OVERLAYFS\n\tif (strncmp(ptr, \"overlay-named \", 14) == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\t\t\targ_overlay_reuse = 1;\n\n\t\t\tchar *subdirname = ptr + 14;\n\t\t\tif (*subdirname == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay option\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check name\n\t\t\tinvalid_filename(subdirname, 0); // no globbing\n\t\t\tif (strstr(subdirname, \"..\") || strstr(subdirname, \"/\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay-tmpfs\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\n\t\t\tchar *subdirname;\n\t\t\tif (asprintf(&subdirname, \"%d\", getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\n\t\t\tfree(subdirname);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\t}\n#endif\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1, 0); // no globbing\n\t\t\tinvalid_filename(dname2, 0); // no globbing\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"bind\");\n\t\treturn 0;\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tcheck_unsigned(ptr + 14, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 14, \"%llu\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-cpu \", 11) == 0) {\n\t\t\tcheck_unsigned(ptr + 11, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 11, \"%llu\", &cfg.rlimit_cpu);\n\t\t\targ_rlimit_cpu = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tcheck_unsigned(ptr + 18, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 18, \"%llu\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-as \", 10) == 0) {\n\t\t\tcheck_unsigned(ptr + 10, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 10, \"%llu\", &cfg.rlimit_as);\n\t\t\targ_rlimit_as = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"timeout \", 8) == 0) {\n\t\tcfg.timeout = extract_timeout(ptr +8);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0) {\n\t\t\t// try to join by name only\n\t\t\tpid_t pid;\n\t\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t\t// find first non-option arg\n\t\t\t\tint i;\n\t\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t// set sandbox name and start normally\n\t\t\tcfg.name = ptr + 14;\n\t\t\tif (strlen(cfg.name) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"join\");\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"disable-mnt\") == 0) {\n\t\targ_disable_mnt = 1;\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse {\n\t\t\tstatic int whitelist_warning_printed = 0;\n\t\t\tif (!whitelist_warning_printed) {\n\t\t\t\twarning_feature_disabled(\"whitelist\");\n\t\t\t\twhitelist_warning_printed = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n#else\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"nowhitelist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr, 1); // globbing\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newprofile"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_read",
          "args": [
            "newprofile"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "profile_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "1387-1509",
          "snippet": "void profile_read(const char *fname) {\n\tEUID_ASSERT();\n\n\t// exit program if maximum include level was reached\n\tif (include_level > MAX_INCLUDE_LEVEL) {\n\t\tfprintf(stderr, \"Error: maximum profile include level was reached\\n\");\n\t\texit(1);\n\t}\n\n\t// check file\n\tinvalid_filename(fname, 0); // no globbing\n\tif (strlen(fname) == 0 || is_dir(fname)) {\n\t\tfprintf(stderr, \"Error: invalid profile file\\n\");\n\t\texit(1);\n\t}\n\tif (access(fname, R_OK)) {\n\t\t// if the file ends in \".local\", do not exit\n\t\tconst char *base = gnu_basename(fname);\n\t\tchar *ptr = strstr(base, \".local\");\n\t\tif (ptr && strlen(ptr) == 6)\n\t\t\treturn;\n\n\t\tfprintf(stderr, \"Error: cannot access profile file: %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// allow debuggers\n\tif (arg_allow_debuggers) {\n\t\tchar *tmp = strrchr(fname, '/');\n\t\tif (tmp && *(tmp + 1) != '\\0') {\n\t\t\ttmp++;\n\t\t\tif (strcmp(tmp, \"disable-devel.inc\") == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// open profile file:\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"Error: cannot open profile file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// save the name of the file for --profile.print option\n\tif (include_level == 0)\n\t\tset_profile_run_file(getpid(), fname);\n\n\tint msg_printed = 0;\n\n\t// read the file line by line\n\tchar buf[MAX_READ + 1];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\t++lineno;\n\t\t// remove empty space - ptr in allocated memory\n\t\tchar *ptr = line_remove_spaces(buf);\n\t\tif (ptr == NULL)\n\t\t\tcontinue;\n\n\t\t// comments\n\t\tif (*ptr == '#' || *ptr == '\\0') {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process quiet\n\t\t// todo: a quiet in the profile file cannot be disabled by --ignore on command line\n\t\tif (strcmp(ptr, \"quiet\") == 0) {\n\t\t\tif (is_in_ignore_list(ptr))\n\t\t\t\targ_quiet = 0;\n\t\t\telse\n\t\t\t\targ_quiet = 1;\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!msg_printed) {\n\t\t\tfmessage(\"Reading profile %s\\n\", fname);\n\t\t\tmsg_printed = 1;\n\t\t}\n\n\t\t// process include\n\t\tif (strncmp(ptr, \"include \", 8) == 0) {\n\t\t\tinclude_level++;\n\n\t\t\t// expand macros in front of the include profile file\n\t\t\tchar *newprofile = expand_macros(ptr + 8);\n\n\t\t\tchar *ptr2 = newprofile;\n\t\t\twhile (*ptr2 != '/' && *ptr2 != '\\0')\n\t\t\t\tptr2++;\n\t\t\t// profile path contains no / chars, do a search\n\t\t\tif (*ptr2 == '\\0') {\n\t\t\t\tint rv = profile_find_firejail(newprofile, 0); // returns 1 if a profile was found in sysconfig directory\n\t\t\t\tif (!rv) {\n\t\t\t\t\t// maybe this is a file in the local working directory?\n\t\t\t\t\t// it will stop the sandbox if not!\n\t\t\t\t\t// Note: if the file ends in .local it will not stop the program\n\t\t\t\t\tprofile_read(newprofile);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprofile_read(newprofile);\n\t\t\t}\n\n\t\t\tinclude_level--;\n\t\t\tfree(newprofile);\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// verify syntax, exit in case of error\n\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\tprofile_add(ptr);\n// we cannot free ptr here, data is extracted from ptr and linked as a pointer in cfg structure\n//\t\telse {\n//\t\t\tfree(ptr);\n//\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t}\n\tfclose(fp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "profile_find_firejail",
          "args": [
            "newprofile",
            "0"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "profile_find_firejail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "70-83",
          "snippet": "int profile_find_firejail(const char *name, int add_ext) {\n\t// look for a profile in ~/.config/firejail directory\n\tchar *usercfgdir;\n\tif (asprintf(&usercfgdir, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tint rv = profile_find(name, usercfgdir, add_ext);\n\tfree(usercfgdir);\n\n\tif (!rv)\n\t\t// look for a user profile in /etc/firejail directory\n\t\trv = profile_find(name, SYSCONFDIR, add_ext);\n\n\treturn rv;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nint profile_find_firejail(const char *name, int add_ext) {\n\t// look for a profile in ~/.config/firejail directory\n\tchar *usercfgdir;\n\tif (asprintf(&usercfgdir, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tint rv = profile_find(name, usercfgdir, add_ext);\n\tfree(usercfgdir);\n\n\tif (!rv)\n\t\t// look for a user profile in /etc/firejail directory\n\t\trv = profile_find(name, SYSCONFDIR, add_ext);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_macros",
          "args": [
            "ptr + 8"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"include \"",
            "8"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"Reading profile %s\\n\"",
            "fname"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "189-198",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_in_ignore_list",
          "args": [
            "ptr"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "is_in_ignore_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "94-110",
          "snippet": "static int is_in_ignore_list(char *ptr) {\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\n\t\tint len = strlen(cfg.profile_ignore[i]);\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], len) == 0) {\n\t\t\t// full word match\n\t\t\tif (*(ptr + len) == '\\0' || *(ptr + len) == ' ')\n\t\t\t\treturn 1;\t// ignore line\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nstatic int is_in_ignore_list(char *ptr) {\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\n\t\tint len = strlen(cfg.profile_ignore[i]);\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], len) == 0) {\n\t\t\t// full word match\n\t\t\tif (*(ptr + len) == '\\0' || *(ptr + len) == ' ')\n\t\t\t\treturn 1;\t// ignore line\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"quiet\""
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_remove_spaces",
          "args": [
            "buf"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "line_remove_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "480-529",
          "snippet": "char *line_remove_spaces(const char *buf) {\n\tEUID_ASSERT();\n\tassert(buf);\n\tsize_t len = strlen(buf);\n\tif (len == 0)\n\t\treturn NULL;\n\tassert(len + 1 != 0 && buf[len] == '\\0');\n\n\t// allocate memory for the new string\n\tchar *rv = malloc(len + 1);\n\tif (rv == NULL)\n\t\terrExit(\"malloc\");\n\n\t// remove space at start of line\n\tconst char *ptr1 = buf;\n\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\tptr1++;\n\n\t// copy data and remove additional spaces\n\tchar *ptr2 = rv;\n\tint state = 0;\n\twhile (*ptr1 != '\\0') {\n\t\tif (*ptr1 == '\\n' || *ptr1 == '\\r')\n\t\t\tbreak;\n\n\t\tif (state == 0) {\n\t\t\tif (*ptr1 != ' ' && *ptr1 != '\\t')\n\t\t\t\t*ptr2++ = *ptr1++;\n\t\t\telse {\n\t\t\t\t*ptr2++ = ' ';\n\t\t\t\tptr1++;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t  // state == 1\n\t\t\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\t\t\tptr1++;\n\t\t\tstate = 0;\n\t\t}\n\t}\n\n\t// strip last blank character if any\n\tif (ptr2 > rv && *(ptr2 - 1) == ' ')\n\t\t--ptr2;\n\t*ptr2 = '\\0';\n\t//\tif (arg_debug)\n\t//\t\tprintf(\"Processing line #%s#\\n\", rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *line_remove_spaces(const char *buf) {\n\tEUID_ASSERT();\n\tassert(buf);\n\tsize_t len = strlen(buf);\n\tif (len == 0)\n\t\treturn NULL;\n\tassert(len + 1 != 0 && buf[len] == '\\0');\n\n\t// allocate memory for the new string\n\tchar *rv = malloc(len + 1);\n\tif (rv == NULL)\n\t\terrExit(\"malloc\");\n\n\t// remove space at start of line\n\tconst char *ptr1 = buf;\n\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\tptr1++;\n\n\t// copy data and remove additional spaces\n\tchar *ptr2 = rv;\n\tint state = 0;\n\twhile (*ptr1 != '\\0') {\n\t\tif (*ptr1 == '\\n' || *ptr1 == '\\r')\n\t\t\tbreak;\n\n\t\tif (state == 0) {\n\t\t\tif (*ptr1 != ' ' && *ptr1 != '\\t')\n\t\t\t\t*ptr2++ = *ptr1++;\n\t\t\telse {\n\t\t\t\t*ptr2++ = ' ';\n\t\t\t\tptr1++;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t  // state == 1\n\t\t\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\t\t\tptr1++;\n\t\t\tstate = 0;\n\t\t}\n\t}\n\n\t// strip last blank character if any\n\tif (ptr2 > rv && *(ptr2 - 1) == ' ')\n\t\t--ptr2;\n\t*ptr2 = '\\0';\n\t//\tif (arg_debug)\n\t//\t\tprintf(\"Processing line #%s#\\n\", rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAX_READ",
            "fp"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_profile_run_file",
          "args": [
            "getpid()",
            "fname"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "set_profile_run_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/run_files.c",
          "lines": "135-154",
          "snippet": "void set_profile_run_file(pid_t pid, const char *fname) {\n\tchar *runfile;\n\tif (asprintf(&runfile, \"%s/%d\", RUN_FIREJAIL_PROFILE_DIR, pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\t// the file is deleted first\n\tFILE *fp = fopen(runfile, \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot create %s\\n\", runfile);\n\t\texit(1);\n\t}\n\tfprintf(fp, \"%s\\n\", fname);\n\n\t// mode and ownership\n\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\tfclose(fp);\n\tEUID_USER();\n\tfree(runfile);\n}",
          "includes": [
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nvoid set_profile_run_file(pid_t pid, const char *fname) {\n\tchar *runfile;\n\tif (asprintf(&runfile, \"%s/%d\", RUN_FIREJAIL_PROFILE_DIR, pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\t// the file is deleted first\n\tFILE *fp = fopen(runfile, \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot create %s\\n\", runfile);\n\t\texit(1);\n\t}\n\tfprintf(fp, \"%s\\n\", fname);\n\n\t// mode and ownership\n\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\tfclose(fp);\n\tEUID_USER();\n\tfree(runfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open profile file %s\\n\"",
            "fname"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tmp",
            "\"disable-devel.inc\""
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "fname",
            "'/'"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot access profile file: %s\\n\"",
            "fname"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "base",
            "\".local\""
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnu_basename",
          "args": [
            "fname"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "gnu_basename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "815-820",
          "snippet": "const char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nconst char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "fname",
            "R_OK"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "478-485",
          "snippet": "int access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_access_t orig_access = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_access_t orig_access = NULL;\n\nint access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid profile file\\n\""
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dir",
          "args": [
            "fname"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "401-428",
          "snippet": "int is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalid_filename",
          "args": [
            "fname",
            "0"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: maximum profile include level was reached\\n\""
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int include_level = 0;\n\nvoid profile_read(const char *fname) {\n\tEUID_ASSERT();\n\n\t// exit program if maximum include level was reached\n\tif (include_level > MAX_INCLUDE_LEVEL) {\n\t\tfprintf(stderr, \"Error: maximum profile include level was reached\\n\");\n\t\texit(1);\n\t}\n\n\t// check file\n\tinvalid_filename(fname, 0); // no globbing\n\tif (strlen(fname) == 0 || is_dir(fname)) {\n\t\tfprintf(stderr, \"Error: invalid profile file\\n\");\n\t\texit(1);\n\t}\n\tif (access(fname, R_OK)) {\n\t\t// if the file ends in \".local\", do not exit\n\t\tconst char *base = gnu_basename(fname);\n\t\tchar *ptr = strstr(base, \".local\");\n\t\tif (ptr && strlen(ptr) == 6)\n\t\t\treturn;\n\n\t\tfprintf(stderr, \"Error: cannot access profile file: %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// allow debuggers\n\tif (arg_allow_debuggers) {\n\t\tchar *tmp = strrchr(fname, '/');\n\t\tif (tmp && *(tmp + 1) != '\\0') {\n\t\t\ttmp++;\n\t\t\tif (strcmp(tmp, \"disable-devel.inc\") == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// open profile file:\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"Error: cannot open profile file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// save the name of the file for --profile.print option\n\tif (include_level == 0)\n\t\tset_profile_run_file(getpid(), fname);\n\n\tint msg_printed = 0;\n\n\t// read the file line by line\n\tchar buf[MAX_READ + 1];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\t++lineno;\n\t\t// remove empty space - ptr in allocated memory\n\t\tchar *ptr = line_remove_spaces(buf);\n\t\tif (ptr == NULL)\n\t\t\tcontinue;\n\n\t\t// comments\n\t\tif (*ptr == '#' || *ptr == '\\0') {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process quiet\n\t\t// todo: a quiet in the profile file cannot be disabled by --ignore on command line\n\t\tif (strcmp(ptr, \"quiet\") == 0) {\n\t\t\tif (is_in_ignore_list(ptr))\n\t\t\t\targ_quiet = 0;\n\t\t\telse\n\t\t\t\targ_quiet = 1;\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!msg_printed) {\n\t\t\tfmessage(\"Reading profile %s\\n\", fname);\n\t\t\tmsg_printed = 1;\n\t\t}\n\n\t\t// process include\n\t\tif (strncmp(ptr, \"include \", 8) == 0) {\n\t\t\tinclude_level++;\n\n\t\t\t// expand macros in front of the include profile file\n\t\t\tchar *newprofile = expand_macros(ptr + 8);\n\n\t\t\tchar *ptr2 = newprofile;\n\t\t\twhile (*ptr2 != '/' && *ptr2 != '\\0')\n\t\t\t\tptr2++;\n\t\t\t// profile path contains no / chars, do a search\n\t\t\tif (*ptr2 == '\\0') {\n\t\t\t\tint rv = profile_find_firejail(newprofile, 0); // returns 1 if a profile was found in sysconfig directory\n\t\t\t\tif (!rv) {\n\t\t\t\t\t// maybe this is a file in the local working directory?\n\t\t\t\t\t// it will stop the sandbox if not!\n\t\t\t\t\t// Note: if the file ends in .local it will not stop the program\n\t\t\t\t\tprofile_read(newprofile);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprofile_read(newprofile);\n\t\t\t}\n\n\t\t\tinclude_level--;\n\t\t\tfree(newprofile);\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// verify syntax, exit in case of error\n\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\tprofile_add(ptr);\n// we cannot free ptr here, data is extracted from ptr and linked as a pointer in cfg structure\n//\t\telse {\n//\t\t\tfree(ptr);\n//\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t}\n\tfclose(fp);\n}"
  },
  {
    "function_name": "profile_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "1364-1383",
    "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "prf",
            "0",
            "sizeof(ProfileEntry)"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(ProfileEntry)"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
  },
  {
    "function_name": "profile_check_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "243-1361",
    "snippet": "int profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\n\t// check and process conditional profile lines\n\tif (profile_check_conditional(ptr, lineno, fname) == 0)\n\t\treturn 0;\n\n\t// check ignore list\n\tif (is_in_ignore_list(ptr))\n\t\treturn 0;\n\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tprofile_add_ignore(ptr + 7);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\txephyr_screen = ptr + 14;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\t// mkdir\n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\t// process mkdir again while applying blacklists\n\t}\n\t// mkfile\n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\t// process mkfile again while applying blacklists\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse\n\t\t\twarning_feature_disabled(\"noroot\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tif (cfg.home_private_keep) {\n\t\t\t\tif ( asprintf(&cfg.home_private_keep, \"%s,%s\", cfg.home_private_keep, ptr + 13) < 0 )\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t} else\n\t\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\targ_private = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-home\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-cache\") == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_CACHE))\n\t\t\targ_private_cache = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"private-cache\");\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"keep-dev-shm\") == 0) {\n\t\targ_keep_dev_shm = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"noautopulse\") == 0) {\n\t\targ_noautopulse = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"notv\") == 0) {\n\t\targ_notv = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodvd\") == 0) {\n\t\targ_nodvd = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"novideo\") == 0) {\n\t\targ_novideo = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodbus\") == 0) {\n\t\targ_nodbus = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nou2f\") == 0) {\n\t        arg_nou2f = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n\t\targ_nonetwork  = 1;\n\t\tcfg.bridge0.configured = 0;\n\t\tcfg.bridge1.configured = 0;\n\t\tcfg.bridge2.configured = 0;\n\t\tcfg.bridge3.configured = 0;\n\t\tcfg.interface0.configured = 0;\n\t\tcfg.interface1.configured = 0;\n\t\tcfg.interface2.configured = 0;\n\t\tcfg.interface3.configured = 0;\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbr->dev = ptr + 4;\n\t\t\tbr->configured = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"netmask \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->masksandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the network mask twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this network mask for the last bridge defined\n\t\t\tif (atoip(ptr + 8, &br->masksandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid  network mask\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// if the bridge is not configured, use this mask as the bridge mask\n\t\t\tif (br->mask == 0)\n\t\t\t\tbr->mask = br->masksandbox;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: interface %s already has a network mask defined; \"\n\t\t\t\t\t\"please remove --netmask\\n\",\n\t\t\t\t\tbr->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IPv6 address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->ip6sandbox = strdup(ptr + 4);\n\t\t\tif (br->ip6sandbox == NULL)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\tif (cfg.protocol) {\n\t\t\t\tfwarning(\"two protocol lists are present, \\\"%s\\\" will be installed\\n\", cfg.protocol);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// store list\n\t\t\tcfg.protocol = strdup(ptr + 9);\n\t\t\tif (!cfg.protocol)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = seccomp_check_list(ptr + 8);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"seccomp.block-secondary\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp_block_secondary = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// memory deny write&execute\n\tif (strcmp(ptr, \"memory-deny-write-execute\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_memory_deny_write_execute = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\n\t// hosts-file\n\tif (strncmp(ptr, \"hosts-file \", 11) == 0) {\n\t\tcfg.hosts_file = fs_check_hosts_file(ptr + 11);\n\t\treturn 0;\n\t}\n\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\n\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IPv4 or IPv6 address\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tchar *dns = strdup(ptr + 4);\n\t\tif (!dns)\n\t\t\terrExit(\"strdup\");\n\n\t\tif (cfg.dns1 == NULL)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == NULL)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == NULL)\n\t\t\tcfg.dns3 = dns;\n\t\telse if (cfg.dns4 == NULL)\n\t\t\tcfg.dns4 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 4 DNS servers can be specified\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 5) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tif (checkcfg(CFG_CGROUP))\n\t\t\tset_cgroup(ptr + 7);\n\t\telse\n\t\t\twarning_feature_disabled(\"cgroup\");\n\t\treturn 0;\n\t}\n\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"machine-id\") == 0) {\n\t\targ_machineid = 1;\n\t\treturn 0;\n\t}\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t// don't overwrite /var/tmp\n\tif (strcmp(ptr, \"keep-var-tmp\") == 0) {\n\t\targ_keep_var_tmp = 1;\n\t\treturn 0;\n\t}\n\t// writable-run-user\n\tif (strcmp(ptr, \"writable-run-user\") == 0) {\n\t\targ_writable_run_user = 1;\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"writable-var-log\") == 0) {\n\t\targ_writable_var_log = 1;\n\t\treturn 0;\n\t}\n\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xvfb\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xvfb(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (cfg.etc_private_keep) {\n\t\t\tif ( asprintf(&cfg.etc_private_keep, \"%s,%s\", cfg.etc_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.etc_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_etc = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /opt list of files and directories\n\tif (strncmp(ptr, \"private-opt \", 12) == 0) {\n\t\tif (cfg.opt_private_keep) {\n\t\t\tif ( asprintf(&cfg.opt_private_keep, \"%s,%s\", cfg.opt_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.opt_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_opt = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /srv list of files and directories\n\tif (strncmp(ptr, \"private-srv \", 12) == 0) {\n\t\tif (cfg.srv_private_keep) {\n\t\t\tif ( asprintf(&cfg.srv_private_keep, \"%s,%s\", cfg.srv_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.srv_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_srv = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tif (cfg.bin_private_keep) {\n\t\t\tif ( asprintf(&cfg.bin_private_keep, \"%s,%s\", cfg.bin_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.bin_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_bin = 1;\n\t\treturn 0;\n\t}\n\n\t// private /lib list of files\n\tif (strncmp(ptr, \"private-lib\", 11) == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_LIB)) {\n\t\t\tif (ptr[11] == ' ') {\n\t\t\t\tif (cfg.lib_private_keep) {\n\t\t\t\t\tif (ptr[12] != '\\0' && asprintf(&cfg.lib_private_keep, \"%s,%s\", cfg.lib_private_keep, ptr + 12) < 0)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t} else {\n\t\t\t\t\tcfg.lib_private_keep = ptr + 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\targ_private_lib = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-lib\");\n\t\treturn 0;\n\t}\n\n\n#ifdef HAVE_OVERLAYFS\n\tif (strncmp(ptr, \"overlay-named \", 14) == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\t\t\targ_overlay_reuse = 1;\n\n\t\t\tchar *subdirname = ptr + 14;\n\t\t\tif (*subdirname == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay option\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check name\n\t\t\tinvalid_filename(subdirname, 0); // no globbing\n\t\t\tif (strstr(subdirname, \"..\") || strstr(subdirname, \"/\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay-tmpfs\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\n\t\t\tchar *subdirname;\n\t\t\tif (asprintf(&subdirname, \"%d\", getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\n\t\t\tfree(subdirname);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\t}\n#endif\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1, 0); // no globbing\n\t\t\tinvalid_filename(dname2, 0); // no globbing\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"bind\");\n\t\treturn 0;\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tcheck_unsigned(ptr + 14, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 14, \"%llu\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-cpu \", 11) == 0) {\n\t\t\tcheck_unsigned(ptr + 11, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 11, \"%llu\", &cfg.rlimit_cpu);\n\t\t\targ_rlimit_cpu = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tcheck_unsigned(ptr + 18, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 18, \"%llu\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-as \", 10) == 0) {\n\t\t\tcheck_unsigned(ptr + 10, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 10, \"%llu\", &cfg.rlimit_as);\n\t\t\targ_rlimit_as = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"timeout \", 8) == 0) {\n\t\tcfg.timeout = extract_timeout(ptr +8);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0) {\n\t\t\t// try to join by name only\n\t\t\tpid_t pid;\n\t\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t\t// find first non-option arg\n\t\t\t\tint i;\n\t\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t// set sandbox name and start normally\n\t\t\tcfg.name = ptr + 14;\n\t\t\tif (strlen(cfg.name) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"join\");\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"disable-mnt\") == 0) {\n\t\targ_disable_mnt = 1;\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse {\n\t\t\tstatic int whitelist_warning_printed = 0;\n\t\t\tif (!whitelist_warning_printed) {\n\t\t\t\twarning_feature_disabled(\"whitelist\");\n\t\t\t\twhitelist_warning_printed = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n#else\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"nowhitelist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr, 1); // globbing\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *xephyr_screen;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: line %d in the custom profile is invalid\\n\"",
            "lineno"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: line %d in %s is invalid\\n\"",
            "lineno",
            "fname"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: \\\"%s\\\" is an invalid filename\\n\"",
            "ptr"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "ptr",
            "\"..\""
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_filename",
          "args": [
            "ptr",
            "1"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: line %d in the custom profile is invalid\\n\"",
            "lineno"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: line %d in %s is invalid\\n\"",
            "lineno",
            "fname"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: \\\"%s\\\" as a command line option is invalid\\n\"",
            "ptr"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: tmpfs available only when running the sandbox as root\\n\""
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"tmpfs \"",
            "6"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"noexec \"",
            "7"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"read-write \"",
            "11"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"read-only \"",
            "10"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"nowhitelist \"",
            "12"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warning_feature_disabled",
          "args": [
            "\"whitelist\""
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "warning_feature_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "89-91",
          "snippet": "static void warning_feature_disabled(const char *feature) {\n\tfwarning(\"%s feature is disabled in Firejail configuration file\\n\", feature);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nstatic void warning_feature_disabled(const char *feature) {\n\tfwarning(\"%s feature is disabled in Firejail configuration file\\n\", feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_WHITELIST"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/checkcfg.c",
          "lines": "35-213",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *xpra_extra_params = \"\";",
            "char *xvfb_screen = \"800x600x24\";",
            "char *xvfb_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *xpra_extra_params = \"\";\nchar *xvfb_screen = \"800x600x24\";\nchar *xvfb_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"whitelist \"",
            "10"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"noblacklist \"",
            "12"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"blacklist-nolog \"",
            "16"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"blacklist \"",
            "10"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"disable-mnt\""
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid sandbox name\\n\""
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg.name"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "join",
          "args": [
            "pid",
            "cfg.original_argc",
            "cfg.original_argv",
            "i + 1"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "288-491",
          "snippet": "void join(pid_t pid, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\n\tpid_t parent = pid;\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(pid)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\textract_x11_display(parent);\n\n\tEUID_ROOT();\n\t// in user mode set caps seccomp, cpu, cgroup, etc\n\tif (getuid() != 0) {\n\t\textract_nonewprivs(pid);  // redundant on Linux >= 4.10; duplicated in function extract_caps\n\t\textract_caps(pid);\n\t\textract_cpu(pid);\n\t\textract_cgroup(pid);\n\t\textract_nogroups(pid);\n\t\textract_user_namespace(pid);\n\t}\n\n\t// set cgroup\n\tif (cfg.cgroup)\t// not available for uid 0\n\t\tset_cgroup(cfg.cgroup);\n\n\t// set umask, also uid 0\n\textract_umask(pid);\n\n\t// join namespaces\n\tif (arg_join_network) {\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t}\n\telse if (arg_join_filesystem) {\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\telse {\n\t\tif (join_namespace(pid, \"ipc\") ||\n\t\t    join_namespace(pid, \"net\") ||\n\t\t    join_namespace(pid, \"pid\") ||\n\t\t    join_namespace(pid, \"uts\") ||\n\t\t    join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop discretionary access control capabilities for root sandboxes\n\t\tcaps_drop_dac_override();\n\n\t\t// chroot into /proc/PID/root directory\n\t\tchar *rootdir;\n\t\tif (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tint rv;\n\t\tif (!arg_join_network) {\n\t\t\trv = chroot(rootdir); // this will fail for processes in sandboxes not started with --chroot option\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"changing root to %s\\n\", rootdir);\n\t\t}\n\n\t\tEUID_USER();\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\n\t\t// set caps filter\n\t\tEUID_ROOT();\n\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\tcaps_set(caps);\n#ifdef HAVE_SECCOMP\n\t\tif (getuid() != 0)\n\t\t\tseccomp_load_file_list();\n#endif\n\n\t\t// mount user namespace or drop privileges\n\t\tif (arg_noroot) {\t// not available for uid 0\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Joining user namespace\\n\");\n\t\t\tif (join_namespace(1, \"user\"))\n\t\t\t\texit(1);\n\n\t\t\t// user namespace resets capabilities\n\t\t\t// set caps filter\n\t\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\t\tcaps_set(caps);\n\t\t}\n\n\t\t// set nonewprivs\n\t\tif (arg_nonewprivs == 1) {\t// not available for uid 0\n\t\t\tint rv = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\t\t\tif (arg_debug && rv == 0)\n\t\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t\t}\n\n\t\tEUID_USER();\n\t\tint cwd = 0;\n\t\tif (cfg.cwd) {\n\t\t\tif (chdir(cfg.cwd) == 0)\n\t\t\t\tcwd = 1;\n\t\t}\n\n\t\tif (!cwd) {\n\t\t\tif (chdir(\"/\") < 0)\n\t\t\t\terrExit(\"chdir\");\n\t\t\tif (cfg.homedir) {\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t\t/* coverity[toctou] */\n\t\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\t\terrExit(\"chdir\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// drop privileges\n\t\tdrop_privs(arg_nogroups);\n\n\t\t// kill the child in case the parent died\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t\textract_command(argc, argv, index);\n\t\tif (cfg.command_line == NULL) {\n\t\t\tassert(cfg.shell);\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t}\n\t\tif (arg_debug)\n\t\t\tprintf(\"Extracted command #%s#\\n\", cfg.command_line);\n\n\t\t// set cpu affinity\n\t\tif (cfg.cpus)\t// not available for uid 0\n\t\t\tset_cpu_affinity();\n\n\t\t// set nice value\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\n\t\t// add x11 display\n\t\tif (display) {\n\t\t\tchar *display_str;\n\t\t\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tsetenv(\"DISPLAY\", display_str, 1);\n\t\t\tfree(display_str);\n\t\t}\n\n\t\tstart_application(0, NULL);\n\n\t\t// it will never get here!!!\n\t}\n\n\tint status = 0;\n\t//*****************************\n\t// following code is signal-safe\n\n\tinstall_handler();\n\n\t// wait for the child to finish\n\twaitpid(child, &status, 0);\n\n\t// restore default signal action\n\tsignal(SIGTERM, SIG_DFL);\n\n\t// end of signal-safe code\n\t//*****************************\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\tstatus = WEXITSTATUS(status);\n\t} else if (WIFSIGNALED(status)) {\n\t\tstatus = WTERMSIG(status);\n\t} else {\n\t\tstatus = 0;\n\t}\n\n\texit(status);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int apply_caps = 0;",
            "static uint64_t caps = 0;",
            "static unsigned display = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic int apply_caps = 0;\nstatic uint64_t caps = 0;\nstatic unsigned display = 0;\n\nvoid join(pid_t pid, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\n\tpid_t parent = pid;\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(pid)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\textract_x11_display(parent);\n\n\tEUID_ROOT();\n\t// in user mode set caps seccomp, cpu, cgroup, etc\n\tif (getuid() != 0) {\n\t\textract_nonewprivs(pid);  // redundant on Linux >= 4.10; duplicated in function extract_caps\n\t\textract_caps(pid);\n\t\textract_cpu(pid);\n\t\textract_cgroup(pid);\n\t\textract_nogroups(pid);\n\t\textract_user_namespace(pid);\n\t}\n\n\t// set cgroup\n\tif (cfg.cgroup)\t// not available for uid 0\n\t\tset_cgroup(cfg.cgroup);\n\n\t// set umask, also uid 0\n\textract_umask(pid);\n\n\t// join namespaces\n\tif (arg_join_network) {\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t}\n\telse if (arg_join_filesystem) {\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\telse {\n\t\tif (join_namespace(pid, \"ipc\") ||\n\t\t    join_namespace(pid, \"net\") ||\n\t\t    join_namespace(pid, \"pid\") ||\n\t\t    join_namespace(pid, \"uts\") ||\n\t\t    join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop discretionary access control capabilities for root sandboxes\n\t\tcaps_drop_dac_override();\n\n\t\t// chroot into /proc/PID/root directory\n\t\tchar *rootdir;\n\t\tif (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tint rv;\n\t\tif (!arg_join_network) {\n\t\t\trv = chroot(rootdir); // this will fail for processes in sandboxes not started with --chroot option\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"changing root to %s\\n\", rootdir);\n\t\t}\n\n\t\tEUID_USER();\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\n\t\t// set caps filter\n\t\tEUID_ROOT();\n\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\tcaps_set(caps);\n#ifdef HAVE_SECCOMP\n\t\tif (getuid() != 0)\n\t\t\tseccomp_load_file_list();\n#endif\n\n\t\t// mount user namespace or drop privileges\n\t\tif (arg_noroot) {\t// not available for uid 0\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Joining user namespace\\n\");\n\t\t\tif (join_namespace(1, \"user\"))\n\t\t\t\texit(1);\n\n\t\t\t// user namespace resets capabilities\n\t\t\t// set caps filter\n\t\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\t\tcaps_set(caps);\n\t\t}\n\n\t\t// set nonewprivs\n\t\tif (arg_nonewprivs == 1) {\t// not available for uid 0\n\t\t\tint rv = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\t\t\tif (arg_debug && rv == 0)\n\t\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t\t}\n\n\t\tEUID_USER();\n\t\tint cwd = 0;\n\t\tif (cfg.cwd) {\n\t\t\tif (chdir(cfg.cwd) == 0)\n\t\t\t\tcwd = 1;\n\t\t}\n\n\t\tif (!cwd) {\n\t\t\tif (chdir(\"/\") < 0)\n\t\t\t\terrExit(\"chdir\");\n\t\t\tif (cfg.homedir) {\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t\t/* coverity[toctou] */\n\t\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\t\terrExit(\"chdir\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// drop privileges\n\t\tdrop_privs(arg_nogroups);\n\n\t\t// kill the child in case the parent died\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t\textract_command(argc, argv, index);\n\t\tif (cfg.command_line == NULL) {\n\t\t\tassert(cfg.shell);\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t}\n\t\tif (arg_debug)\n\t\t\tprintf(\"Extracted command #%s#\\n\", cfg.command_line);\n\n\t\t// set cpu affinity\n\t\tif (cfg.cpus)\t// not available for uid 0\n\t\t\tset_cpu_affinity();\n\n\t\t// set nice value\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\n\t\t// add x11 display\n\t\tif (display) {\n\t\t\tchar *display_str;\n\t\t\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tsetenv(\"DISPLAY\", display_str, 1);\n\t\t\tfree(display_str);\n\t\t}\n\n\t\tstart_application(0, NULL);\n\n\t\t// it will never get here!!!\n\t}\n\n\tint status = 0;\n\t//*****************************\n\t// following code is signal-safe\n\n\tinstall_handler();\n\n\t// wait for the child to finish\n\twaitpid(child, &status, 0);\n\n\t// restore default signal action\n\tsignal(SIGTERM, SIG_DFL);\n\n\t// end of signal-safe code\n\t//*****************************\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\tstatus = WEXITSTATUS(status);\n\t} else if (WIFSIGNALED(status)) {\n\t\tstatus = WTERMSIG(status);\n\t} else {\n\t\tstatus = 0;\n\t}\n\n\texit(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cfg.original_argv[i]",
            "\"--\"",
            "2"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_shell",
          "args": [],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "guess_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "810-835",
          "snippet": "char *guess_shell(void) {\n\tchar *shell = NULL;\n\tstruct stat s;\n\n\tshell = getenv(\"SHELL\");\n\tif (shell) {\n\t\tinvalid_filename(shell, 0); // no globbing\n\t\tif (!is_dir(shell) && strstr(shell, \"..\") == NULL && stat(shell, &s) == 0 && access(shell, X_OK) == 0)\n\t\t\treturn shell;\n\t}\n\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], X_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nchar *guess_shell(void) {\n\tchar *shell = NULL;\n\tstruct stat s;\n\n\tshell = getenv(\"SHELL\");\n\tif (shell) {\n\t\tinvalid_filename(shell, 0); // no globbing\n\t\tif (!is_dir(shell) && strstr(shell, \"..\") == NULL && stat(shell, &s) == 0 && access(shell, X_OK) == 0)\n\t\t\treturn shell;\n\t}\n\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], X_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}"
        }
      },
      {
        "call_info": {
          "callee": "name2pid",
          "args": [
            "ptr + 14",
            "&pid"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "name2pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "63-126",
          "snippet": "int name2pid(const char *name, pid_t *pid) {\n\tpid_t parent = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir))) {\n\t\tpid_t newpid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (newpid == parent)\n\t\t\tcontinue;\n\n\t\t// check if this is a firejail executable\n\t\tchar *comm = pid_proc_comm(newpid);\n\t\tif (comm) {\n\t\t\tif (strcmp(comm, \"firejail\")) {\n\t\t\t\tfree(comm);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t}\n\n\t\t// look for the sandbox name in /run/firejail/name/<PID>\n\t\t// todo: use RUN_FIREJAIL_NAME_DIR define from src/firejail/firejail.h\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/run/firejail/name/%d\", newpid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\tif (fgets(buf, BUFLEN, fp)) {\n\t\t\t\t// remove \\n\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\t\tif (strcmp(buf, name) == 0) {\n\t\t\t\t\t\t// we found it!\n\t\t\t\t\t\tfclose(fp);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\t*pid = newpid;\n\t\t\t\t\t\tclosedir(dir);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"Error: invalid %s\\n\", fname);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tfree(fname);\n\t}\n\tclosedir(dir);\n\treturn 1;\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define BUFLEN 4096",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define BUFLEN 4096\n#define BUFLEN 4096\n\nint name2pid(const char *name, pid_t *pid) {\n\tpid_t parent = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir))) {\n\t\tpid_t newpid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (newpid == parent)\n\t\t\tcontinue;\n\n\t\t// check if this is a firejail executable\n\t\tchar *comm = pid_proc_comm(newpid);\n\t\tif (comm) {\n\t\t\tif (strcmp(comm, \"firejail\")) {\n\t\t\t\tfree(comm);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t}\n\n\t\t// look for the sandbox name in /run/firejail/name/<PID>\n\t\t// todo: use RUN_FIREJAIL_NAME_DIR define from src/firejail/firejail.h\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/run/firejail/name/%d\", newpid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\tif (fgets(buf, BUFLEN, fp)) {\n\t\t\t\t// remove \\n\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\t\tif (strcmp(buf, name) == 0) {\n\t\t\t\t\t\t// we found it!\n\t\t\t\t\t\tfclose(fp);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\t*pid = newpid;\n\t\t\t\t\t\tclosedir(dir);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"Error: invalid %s\\n\", fname);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tfree(fname);\n\t}\n\tclosedir(dir);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"join-or-start \"",
            "14"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_timeout",
          "args": [
            "ptr +8"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "extract_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1094-1110",
          "snippet": "unsigned extract_timeout(const char *str) {\n\tunsigned s;\n\tunsigned m;\n\tunsigned h;\n\tint rv = sscanf(str, \"%02u:%02u:%02u\", &h, &m, &s);\n\tif (rv != 3) {\n\t\tfprintf(stderr, \"Error: invalid timeout, please use a hh:mm:ss format\\n\");\n\t\texit(1);\n\t}\n\tunsigned timeout = h * 3600 + m * 60 + s;\n\tif (timeout == 0) {\n\t\tfprintf(stderr, \"Error: invalid timeout\\n\");\n\t\texit(1);\n\t}\n\n\treturn timeout;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nunsigned extract_timeout(const char *str) {\n\tunsigned s;\n\tunsigned m;\n\tunsigned h;\n\tint rv = sscanf(str, \"%02u:%02u:%02u\", &h, &m, &s);\n\tif (rv != 3) {\n\t\tfprintf(stderr, \"Error: invalid timeout, please use a hh:mm:ss format\\n\");\n\t\texit(1);\n\t}\n\tunsigned timeout = h * 3600 + m * 60 + s;\n\tif (timeout == 0) {\n\t\tfprintf(stderr, \"Error: invalid timeout\\n\");\n\t\texit(1);\n\t}\n\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"timeout \"",
            "8"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid rlimit option on line %d\\n\"",
            "lineno"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr + 10",
            "\"%llu\"",
            "&cfg.rlimit_as"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_unsigned",
          "args": [
            "ptr + 10",
            "\"Error: invalid rlimit in profile file: \""
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "check_unsigned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "585-595",
          "snippet": "void check_unsigned(const char *str, const char *msg) {\n\tEUID_ASSERT();\n\tconst char *ptr = str;\n\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0') {\n\t\tif (!isdigit(*ptr)) {\n\t\t\tfprintf(stderr, \"%s %s\\n\", msg, str);\n\t\t\texit(1);\n\t\t}\n\t\tptr++;\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid check_unsigned(const char *str, const char *msg) {\n\tEUID_ASSERT();\n\tconst char *ptr = str;\n\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0') {\n\t\tif (!isdigit(*ptr)) {\n\t\t\tfprintf(stderr, \"%s %s\\n\", msg, str);\n\t\t\texit(1);\n\t\t}\n\t\tptr++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit-as \"",
            "10"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr + 18",
            "\"%llu\"",
            "&cfg.rlimit_sigpending"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit-sigpending \"",
            "18"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr + 13",
            "\"%llu\"",
            "&cfg.rlimit_fsize"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit-fsize \"",
            "13"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr + 13",
            "\"%llu\"",
            "&cfg.rlimit_nproc"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit-nproc \"",
            "13"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr + 11",
            "\"%llu\"",
            "&cfg.rlimit_cpu"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit-cpu \"",
            "11"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr + 14",
            "\"%llu\"",
            "&cfg.rlimit_nofile"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit-nofile \"",
            "14"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit\"",
            "6"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Symbolic links are not allowed for bind command\\n\""
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "dname2"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "432-459",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid file name.\\n\""
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "dname2",
            "\"..\""
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "dname1",
            "\"..\""
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_filename",
          "args": [
            "dname2",
            "0"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_filename",
          "args": [
            "dname1",
            "0"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: missing second directory for bind\\n\""
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_comma",
          "args": [
            "dname1"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "split_comma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "532-544",
          "snippet": "char *split_comma(char *str) {\n\tEUID_ASSERT();\n\tif (str == NULL || *str == '\\0')\n\t\treturn NULL;\n\tchar *ptr = strchr(str, ',');\n\tif (!ptr)\n\t\treturn NULL;\n\t*ptr = '\\0';\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn NULL;\n\treturn ptr;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *split_comma(char *str) {\n\tEUID_ASSERT();\n\tif (str == NULL || *str == '\\0')\n\t\treturn NULL;\n\tchar *ptr = strchr(str, ',');\n\tif (!ptr)\n\t\treturn NULL;\n\t*ptr = '\\0';\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn NULL;\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --bind option is available only if running as root\\n\""
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"bind \"",
            "5"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "subdirname"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_check_overlay_dir",
          "args": [
            "subdirname",
            "arg_overlay_reuse"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "fs_check_overlay_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "868-921",
          "snippet": "char *fs_check_overlay_dir(const char *subdirname, int allow_reuse) {\n\tassert(subdirname);\n\tstruct stat s;\n\tchar *dirname;\n\n\tif (asprintf(&dirname, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// check if ~/.firejail already exists\n\tif (lstat(dirname, &s) == 0) {\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dirname);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// create ~/.firejail directory\n\t\tcreate_empty_dir_as_user(dirname, 0700);\n\t\tif (stat(dirname, &s) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot create directory %s\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(dirname);\n\n\t// check overlay directory\n\tif (asprintf(&dirname, \"%s/.firejail/%s\", cfg.homedir, subdirname) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(dirname, &s) == 0) {\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dirname);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: overlay directory %s is not owned by the root user\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (allow_reuse == 0) {\n\t\t\tfprintf(stderr, \"Error: overlay directory exists, but reuse is not allowed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn dirname;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nchar *fs_check_overlay_dir(const char *subdirname, int allow_reuse) {\n\tassert(subdirname);\n\tstruct stat s;\n\tchar *dirname;\n\n\tif (asprintf(&dirname, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// check if ~/.firejail already exists\n\tif (lstat(dirname, &s) == 0) {\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dirname);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// create ~/.firejail directory\n\t\tcreate_empty_dir_as_user(dirname, 0700);\n\t\tif (stat(dirname, &s) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot create directory %s\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(dirname);\n\n\t// check overlay directory\n\tif (asprintf(&dirname, \"%s/.firejail/%s\", cfg.homedir, subdirname) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(dirname, &s) == 0) {\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dirname);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: overlay directory %s is not owned by the root user\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t\tif (allow_reuse == 0) {\n\t\t\tfprintf(stderr, \"Error: overlay directory exists, but reuse is not allowed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn dirname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&subdirname",
            "\"%d\"",
            "getpid()"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --overlay option is not available on Grsecurity systems\\n\""
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/proc/sys/kernel/grsecurity\"",
            "&s"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --overlay and --chroot options are mutually exclusive\\n\""
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only one overlay command is allowed\\n\""
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"overlay\""
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --overlay option is not available on Grsecurity systems\\n\""
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --overlay and --chroot options are mutually exclusive\\n\""
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only one overlay command is allowed\\n\""
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"overlay-tmpfs\""
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid overlay name\\n\""
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "subdirname",
            "\"/\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "subdirname",
            "\"..\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_filename",
          "args": [
            "subdirname",
            "0"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid overlay option\\n\""
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --overlay option is not available on Grsecurity systems\\n\""
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --overlay and --chroot options are mutually exclusive\\n\""
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only one overlay command is allowed\\n\""
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"overlay-named \"",
            "14"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cfg.lib_private_keep",
            "\"%s,%s\"",
            "cfg.lib_private_keep",
            "ptr + 12"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"private-lib\"",
            "11"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cfg.bin_private_keep",
            "\"%s,%s\"",
            "cfg.bin_private_keep",
            "ptr + 12"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"private-bin \"",
            "12"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cfg.srv_private_keep",
            "\"%s,%s\"",
            "cfg.srv_private_keep",
            "ptr + 12"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"private-srv \"",
            "12"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cfg.opt_private_keep",
            "\"%s,%s\"",
            "cfg.opt_private_keep",
            "ptr + 12"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"private-opt \"",
            "12"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cfg.etc_private_keep",
            "\"%s,%s\"",
            "cfg.etc_private_keep",
            "ptr + 12"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --private-etc and --writable-etc are mutually exclusive\\n\""
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"private-etc \"",
            "12"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_start",
          "args": [
            "cfg.original_argc",
            "cfg.original_argv"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "1037-1057",
          "snippet": "void x11_start(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\n\t// check xpra\n\tif (program_in_path(\"xpra\"))\n\t\tx11_start_xpra(argc, argv);\n\telse if (program_in_path(\"Xephyr\"))\n\t\tx11_start_xephyr(argc, argv);\n\telse {\n\t\tfprintf(stderr, \"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\texit(0);\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\n\t// check xpra\n\tif (program_in_path(\"xpra\"))\n\t\tx11_start_xpra(argc, argv);\n\telse if (program_in_path(\"Xephyr\"))\n\t\tx11_start_xephyr(argc, argv);\n\telse {\n\t\tfprintf(stderr, \"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\texit(0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "x11env",
            "\"yes\""
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_X11\""
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"x11\""
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_start_xvfb",
          "args": [
            "cfg.original_argc",
            "cfg.original_argv"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start_xvfb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "200-389",
          "snippet": "void x11_start_xvfb(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// mever try to run X servers as root!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xvfb\n\tif (!program_in_path(\"Xvfb\")) {\n\t\tfprintf(stderr, \"\\nError: Xvfb program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xvfb\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xvfb\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xvfb_screen);\n\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"Xvfb\", display_str, \"-screen\", \"0\", xvfb_screen\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tassert(xvfb_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xvfb_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xvfb_extra_params);\n\tif (*xvfb_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xvfb_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xvfb_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xvfb_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xvfb_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xvfb_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) server_argv[pos++] = temp + i + 2;\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') server_argv[pos++] = temp + i + 1;\n\t\t}\n\t}\n\n\tserver_argv[pos++] = NULL;\n\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv))); // no overrun\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xvfb server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2);\t\t\t  // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Stating xvfb client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xvfb...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xvfb server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xvfb\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tfmessage(\"\\n*** Attaching to Xvfb display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t}\n\telse if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL);\t\t\t\t  // fulneral\n\n\texit(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xvfb(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// mever try to run X servers as root!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xvfb\n\tif (!program_in_path(\"Xvfb\")) {\n\t\tfprintf(stderr, \"\\nError: Xvfb program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xvfb\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xvfb\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xvfb_screen);\n\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"Xvfb\", display_str, \"-screen\", \"0\", xvfb_screen\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tassert(xvfb_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xvfb_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xvfb_extra_params);\n\tif (*xvfb_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xvfb_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xvfb_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xvfb_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xvfb_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xvfb_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) server_argv[pos++] = temp + i + 2;\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') server_argv[pos++] = temp + i + 1;\n\t\t}\n\t}\n\n\tserver_argv[pos++] = NULL;\n\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv))); // no overrun\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xvfb server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2);\t\t\t  // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Stating xvfb client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xvfb...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xvfb server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xvfb\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tfmessage(\"\\n*** Attaching to Xvfb display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t}\n\telse if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL);\t\t\t\t  // fulneral\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "x11env",
            "\"yes\""
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_X11\""
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"x11 xvfb\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_start_xpra",
          "args": [
            "cfg.original_argc",
            "cfg.original_argv"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start_xpra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "1006-1034",
          "snippet": "void x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (!program_in_path(\"xpra\")) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (checkcfg(CFG_XPRA_ATTACH))\n\t\tx11_start_xpra_new(argc, argv, display_str);\n\telse\n\t\tx11_start_xpra_old(argc, argv, display, display_str);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (!program_in_path(\"xpra\")) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (checkcfg(CFG_XPRA_ATTACH))\n\t\tx11_start_xpra_new(argc, argv, display_str);\n\telse\n\t\tx11_start_xpra_old(argc, argv, display, display_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "x11env",
            "\"yes\""
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_X11\""
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"x11 xpra\""
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"x11 xorg\""
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_start_xephyr",
          "args": [
            "cfg.original_argc",
            "cfg.original_argv"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start_xephyr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "414-619",
          "snippet": "void x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\n\t// default xephyr screen can be overwritten by a --xephyr-screen= command line option\n\tchar *newscreen = extract_setting(argc, argv, \"--xephyr-screen=\");\n\tif (newscreen)\n\t\txephyr_screen = newscreen;\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (!program_in_path(\"Xephyr\")) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[pos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[pos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\t\t\t\t\t\t  // no overrun\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\t{\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2);\t\t\t  // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"*** Starting xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t}\n\telse if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL);\t\t\t\t  // fulneral\n\n\texit(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\n\t// default xephyr screen can be overwritten by a --xephyr-screen= command line option\n\tchar *newscreen = extract_setting(argc, argv, \"--xephyr-screen=\");\n\tif (newscreen)\n\t\txephyr_screen = newscreen;\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (!program_in_path(\"Xephyr\")) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[pos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[pos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\t\t\t\t\t\t  // no overrun\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\t{\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2);\t\t\t  // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"*** Starting xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t}\n\telse if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL);\t\t\t\t  // fulneral\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "x11env",
            "\"yes\""
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_X11\""
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"x11 xephyr\""
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"x11 none\""
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_check_private_dir",
          "args": [],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "fs_check_private_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "353-367",
          "snippet": "void fs_check_private_dir(void) {\n\tEUID_ASSERT();\n\tinvalid_filename(cfg.home_private, 0); // no globbing\n\n\t// Expand the home directory\n\tchar *tmp = expand_macros(cfg.home_private);\n\tcfg.home_private = realpath(tmp, NULL);\n\tfree(tmp);\n\n\tif (!cfg.home_private\n\t || !is_dir(cfg.home_private)) {\n\t\tfprintf(stderr, \"Error: invalid private directory\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_check_private_dir(void) {\n\tEUID_ASSERT();\n\tinvalid_filename(cfg.home_private, 0); // no globbing\n\n\t// Expand the home directory\n\tchar *tmp = expand_macros(cfg.home_private);\n\tcfg.home_private = realpath(tmp, NULL);\n\tfree(tmp);\n\n\tif (!cfg.home_private\n\t || !is_dir(cfg.home_private)) {\n\t\tfprintf(stderr, \"Error: invalid private directory\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"private \"",
            "8"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"writable-var-log\""
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"writable-run-user\""
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"keep-var-tmp\""
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"writable-var\""
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"machine-id\""
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: private-etc and writable-etc are mutually exclusive\\n\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"writable-etc\""
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cgroup",
          "args": [
            "ptr + 7"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "set_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cgroup.c",
          "lines": "72-119",
          "snippet": "void set_cgroup(const char *path) {\n\tEUID_ASSERT();\n\n\tinvalid_filename(path, 0); // no globbing\n\n\t// path starts with /sys/fs/cgroup\n\tif (strncmp(path, \"/sys/fs/cgroup\", 14) != 0)\n\t\tgoto errout;\n\n\t// path ends in tasks\n\tchar *ptr = strstr(path, \"tasks\");\n\tif (!ptr)\n\t\tgoto errout;\n\tif (*(ptr + 5) != '\\0')\n\t\tgoto errout;\n\n\t// no .. traversal\n\tptr = strstr(path, \"..\");\n\tif (ptr)\n\t\tgoto errout;\n\n\t// tasks file exists\n\tstruct stat s;\n\tif (stat(path, &s) == -1)\n\t\tgoto errout;\n\n\t// task file belongs to the user running the sandbox\n\tif (s.st_uid != getuid() && s.st_gid != getgid())\n\t\tgoto errout2;\n\n\t// add the task to cgroup\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(path,\t\"a\");\n\tif (!fp)\n\t\tgoto errout;\n\tpid_t pid = getpid();\n\tint rv = fprintf(fp, \"%d\\n\", pid);\n\t(void) rv;\n\tfclose(fp);\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: invalid cgroup\\n\");\n\texit(1);\nerrout2:\n\tfprintf(stderr, \"Error: you don't have permissions to use this control group\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nvoid set_cgroup(const char *path) {\n\tEUID_ASSERT();\n\n\tinvalid_filename(path, 0); // no globbing\n\n\t// path starts with /sys/fs/cgroup\n\tif (strncmp(path, \"/sys/fs/cgroup\", 14) != 0)\n\t\tgoto errout;\n\n\t// path ends in tasks\n\tchar *ptr = strstr(path, \"tasks\");\n\tif (!ptr)\n\t\tgoto errout;\n\tif (*(ptr + 5) != '\\0')\n\t\tgoto errout;\n\n\t// no .. traversal\n\tptr = strstr(path, \"..\");\n\tif (ptr)\n\t\tgoto errout;\n\n\t// tasks file exists\n\tstruct stat s;\n\tif (stat(path, &s) == -1)\n\t\tgoto errout;\n\n\t// task file belongs to the user running the sandbox\n\tif (s.st_uid != getuid() && s.st_gid != getgid())\n\t\tgoto errout2;\n\n\t// add the task to cgroup\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(path,\t\"a\");\n\tif (!fp)\n\t\tgoto errout;\n\tpid_t pid = getpid();\n\tint rv = fprintf(fp, \"%d\\n\", pid);\n\t(void) rv;\n\tfclose(fp);\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: invalid cgroup\\n\");\n\texit(1);\nerrout2:\n\tfprintf(stderr, \"Error: you don't have permissions to use this control group\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"cgroup \"",
            "7"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "ptr + 5"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"nice \"",
            "5"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cpu_list",
          "args": [
            "ptr + 4"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "read_cpu_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cpu.c",
          "lines": "42-72",
          "snippet": "void read_cpu_list(const char *str) {\n\tEUID_ASSERT();\n\n\tchar *tmp = strdup(str);\n\tif (tmp == NULL)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = tmp;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == ',' || isdigit(*ptr))\n\t\t\t;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid cpu list\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr++;\n\t}\n\n\tchar *start = tmp;\n\tptr = tmp;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == ',') {\n\t\t\t*ptr = '\\0';\n\t\t\tset_cpu(start);\n\t\t\tstart = ptr + 1;\n\t\t}\n\t\tptr++;\n\t}\n\tset_cpu(start);\n\tfree(tmp);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <sched.h>\n#include \"firejail.h\"\n\nvoid read_cpu_list(const char *str) {\n\tEUID_ASSERT();\n\n\tchar *tmp = strdup(str);\n\tif (tmp == NULL)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = tmp;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == ',' || isdigit(*ptr))\n\t\t\t;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid cpu list\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr++;\n\t}\n\n\tchar *start = tmp;\n\tptr = tmp;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == ',') {\n\t\t\t*ptr = '\\0';\n\t\t\tset_cpu(start);\n\t\t\tstart = ptr + 1;\n\t\t}\n\t\tptr++;\n\t}\n\tset_cpu(start);\n\tfree(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"cpu \"",
            "4"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: up to 4 DNS servers can be specified\\n\""
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 4"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid DNS server IPv4 or IPv6 address\\n\""
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_ip46_address",
          "args": [
            "ptr + 4"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "check_ip46_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network.c",
          "lines": "32-64",
          "snippet": "int check_ip46_address(const char *addr) {\n\t// check ipv4 address\n\tuint32_t tmp;\n\tif (atoip(addr, &tmp) == 0)\n\t\treturn 1;\n\n\t// check ipv6 address\n\tstruct in6_addr result;\n\n\tchar *tmpstr = strdup(addr);\n\tif (!tmpstr)\n\t\terrExit(\"strdup\");\n\tchar *ptr = strchr(tmpstr, '/');\n\tif (ptr) {\n\t\t*ptr = '\\0';\n\t\tptr++;\n\t\tint mask = atoi(ptr);\n\t\t// check the network mask\n\t\tif (mask < 0 || mask > 128) {\n\t\t\tfree(tmpstr);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (inet_pton(AF_INET6, tmpstr, &result) == 1) {\n\t\tfree(tmpstr);\n\t\treturn 1;\n\t}\n\n\tfree(tmpstr);\n\n\t// failed\n\treturn 0;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint check_ip46_address(const char *addr) {\n\t// check ipv4 address\n\tuint32_t tmp;\n\tif (atoip(addr, &tmp) == 0)\n\t\treturn 1;\n\n\t// check ipv6 address\n\tstruct in6_addr result;\n\n\tchar *tmpstr = strdup(addr);\n\tif (!tmpstr)\n\t\terrExit(\"strdup\");\n\tchar *ptr = strchr(tmpstr, '/');\n\tif (ptr) {\n\t\t*ptr = '\\0';\n\t\tptr++;\n\t\tint mask = atoi(ptr);\n\t\t// check the network mask\n\t\tif (mask < 0 || mask > 128) {\n\t\t\tfree(tmpstr);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (inet_pton(AF_INET6, tmpstr, &result) == 1) {\n\t\tfree(tmpstr);\n\t\treturn 1;\n\t}\n\n\tfree(tmpstr);\n\n\t// failed\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"dns \"",
            "4"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_check_hosts_file",
          "args": [
            "ptr + 11"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "fs_check_hosts_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_hostname.c",
          "lines": "189-206",
          "snippet": "char *fs_check_hosts_file(const char *fname) {\n\tassert(fname);\n\tinvalid_filename(fname, 0); // no globbing\n\tchar *rv = expand_macros(fname);\n\n\t// no a link\n\tif (is_link(rv))\n\t\tgoto errexit;\n\n\t// the user has read access to the file\n\tif (access(rv, R_OK))\n\t\tgoto errexit;\n\n\treturn rv;\nerrexit:\n\tfprintf(stderr, \"Error: invalid file %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nchar *fs_check_hosts_file(const char *fname) {\n\tassert(fname);\n\tinvalid_filename(fname, 0); // no globbing\n\tchar *rv = expand_macros(fname);\n\n\t// no a link\n\tif (is_link(rv))\n\t\tgoto errexit;\n\n\t// the user has read access to the file\n\tif (access(rv, R_OK))\n\t\tgoto errexit;\n\n\treturn rv;\nerrexit:\n\tfprintf(stderr, \"Error: invalid file %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"hosts-file \"",
            "11"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"hostname \"",
            "9"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "caps_check_list",
          "args": [
            "arg_caps_list",
            "NULL"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "caps_check_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/caps.c",
          "lines": "184-227",
          "snippet": "void caps_check_list(const char *clist, void (*callback)(int)) {\n\t// don't allow empty lists\n\tif (clist == NULL || *clist == '\\0') {\n\t\tfprintf(stderr, \"Error: empty capabilities list\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(clist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = str;\n\tchar *start = str;\n\twhile (*ptr != '\\0') {\n\t\tif (islower(*ptr) || isdigit(*ptr) || *ptr == '_')\n\t\t\t;\n\t\telse if (*ptr == ',') {\n\t\t\t*ptr = '\\0';\n\t\t\tint nr = caps_find_name(start);\n\t\t\tif (nr == -1)\n\t\t\t\tgoto errexit;\n\t\t\telse if (callback != NULL)\n\t\t\t\tcallback(nr);\n\n\t\t\tstart = ptr + 1;\n\t\t}\n\t\tptr++;\n\t}\n\tif (*start != '\\0') {\n\t\tint nr = caps_find_name(start);\n\t\tif (nr == -1)\n\t\t\tgoto errexit;\n\t\telse if (callback != NULL)\n\t\t\tcallback(nr);\n\t}\n\n\tfree(str);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: capability \\\"%s\\\" not found\\n\", start);\n\texit(1);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nvoid caps_check_list(const char *clist, void (*callback)(int)) {\n\t// don't allow empty lists\n\tif (clist == NULL || *clist == '\\0') {\n\t\tfprintf(stderr, \"Error: empty capabilities list\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(clist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = str;\n\tchar *start = str;\n\twhile (*ptr != '\\0') {\n\t\tif (islower(*ptr) || isdigit(*ptr) || *ptr == '_')\n\t\t\t;\n\t\telse if (*ptr == ',') {\n\t\t\t*ptr = '\\0';\n\t\t\tint nr = caps_find_name(start);\n\t\t\tif (nr == -1)\n\t\t\t\tgoto errexit;\n\t\t\telse if (callback != NULL)\n\t\t\t\tcallback(nr);\n\n\t\t\tstart = ptr + 1;\n\t\t}\n\t\tptr++;\n\t}\n\tif (*start != '\\0') {\n\t\tint nr = caps_find_name(start);\n\t\tif (nr == -1)\n\t\t\tgoto errexit;\n\t\telse if (callback != NULL)\n\t\t\tcallback(nr);\n\t}\n\n\tfree(str);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: capability \\\"%s\\\" not found\\n\", start);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 10"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"caps.keep \"",
            "10"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 10"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"caps.drop \"",
            "10"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"memory-deny-write-execute\""
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_check_list",
          "args": [
            "ptr + 13"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_check_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/seccomp.c",
          "lines": "35-60",
          "snippet": "char *seccomp_check_list(const char *str) {\n\tassert(str);\n\tif (strlen(str) == 0) {\n\t\tfprintf(stderr, \"Error: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\tint len = strlen(str) + 1;\n\tchar *rv = malloc(len);\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\tmemset(rv, 0, len);\n\n\tconst char *ptr1 = str;\n\tchar *ptr2 = rv;\n\twhile (*ptr1 != '\\0') {\n\t\tif (isalnum(*ptr1) || *ptr1 == '_' || *ptr1 == ',' || *ptr1 == ':' || *ptr1 == '@' || *ptr1 == '-')\n\t\t\t*ptr2++ = *ptr1++;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid syscall list\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn rv;\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"firejail.h\"\n\nchar *seccomp_check_list(const char *str) {\n\tassert(str);\n\tif (strlen(str) == 0) {\n\t\tfprintf(stderr, \"Error: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\tint len = strlen(str) + 1;\n\tchar *rv = malloc(len);\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\tmemset(rv, 0, len);\n\n\tconst char *ptr1 = str;\n\tchar *ptr2 = rv;\n\twhile (*ptr1 != '\\0') {\n\t\tif (isalnum(*ptr1) || *ptr1 == '_' || *ptr1 == ',' || *ptr1 == ':' || *ptr1 == '@' || *ptr1 == '-')\n\t\t\t*ptr2++ = *ptr1++;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid syscall list\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"seccomp.keep \"",
            "13"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"seccomp.drop \"",
            "13"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"seccomp.block-secondary\""
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"seccomp \"",
            "8"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_store",
          "args": [
            "ptr + 6",
            "RMENV"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "env_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
          "lines": "167-206",
          "snippet": "void env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rmenv \"",
            "6"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"env \"",
            "4"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 9"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"two protocol lists are present, \\\"%s\\\" will be installed\\n\"",
            "cfg.protocol"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"protocol \"",
            "9"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"apparmor\""
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid IP address\\n\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoip",
          "args": [
            "ptr + 10",
            "&cfg.defaultgw"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "atoip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "62-70",
          "snippet": "static inline int atoip(const char *str, uint32_t *ip) {\n\tunsigned a, b, c, d;\n\n\tif (sscanf(str, \"%u.%u.%u.%u\", &a, &b, &c, &d) != 4 || a > 255 || b > 255 || c > 255 || d > 255)\n\t\treturn 1;\n\n\t*ip = a * 0x1000000 + b * 0x10000 + c * 0x100 + d;\n\treturn 0;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline int atoip(const char *str, uint32_t *ip) {\n\tunsigned a, b, c, d;\n\n\tif (sscanf(str, \"%u.%u.%u.%u\", &a, &b, &c, &d) != 4 || a > 255 || b > 255 || c > 255 || d > 255)\n\t\treturn 1;\n\n\t*ip = a * 0x1000000 + b * 0x10000 + c * 0x100 + d;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"defaultgw \"",
            "10"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 4"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid IPv6 address\\n\""
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot configure the IP address twice for the same interface\\n\""
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last_bridge_configured",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "last_bridge_configured",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/firejail.h",
          "lines": "288-299",
          "snippet": "static inline Bridge *last_bridge_configured(void) {\n\tif (cfg.bridge3.configured)\n\t\treturn &cfg.bridge3;\n\telse if (cfg.bridge2.configured)\n\t\treturn &cfg.bridge2;\n\telse if (cfg.bridge1.configured)\n\t\treturn &cfg.bridge1;\n\telse if (cfg.bridge0.configured)\n\t\treturn &cfg.bridge0;\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include \"../include/euid_common.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <stdarg.h>\n#include \"../include/euid_common.h\"\n#include \"../include/common.h\"\n\nstatic inline Bridge *last_bridge_configured(void) {\n\tif (cfg.bridge3.configured)\n\t\treturn &cfg.bridge3;\n\telse if (cfg.bridge2.configured)\n\t\treturn &cfg.bridge2;\n\telse if (cfg.bridge1.configured)\n\t\treturn &cfg.bridge1;\n\telse if (cfg.bridge0.configured)\n\t\treturn &cfg.bridge0;\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"ip6 \"",
            "4"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid IP address\\n\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr + 3",
            "\"none\""
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot configure the IP address twice for the same interface\\n\""
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"ip \"",
            "3"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: interface %s already has a network mask defined; \"\n\t\t\t\t\t\"please remove --netmask\\n\"",
            "br->dev"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid  network mask\\n\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot configure the network mask twice for the same interface\\n\""
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"netmask \"",
            "8"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid mtu value\\n\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr + 4",
            "\"%d\"",
            "&br->mtu"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"mtu \"",
            "4"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid MAC address\\n\""
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomac",
          "args": [
            "ptr + 4",
            "br->macsandbox"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "atomac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "84-99",
          "snippet": "static inline int atomac(char *str, unsigned char macAddr[6]) {\n\tunsigned mac[6];\n\n\tif (sscanf(str, \"%2x:%2x:%2x:%2x:%2x:%2x\", &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]) != 6)\n\t\treturn 1;\n\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (mac[i] > 0xff)\n\t\t\treturn 1;\n\n\t\tmacAddr[i] = (unsigned char) mac[i];\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline int atomac(char *str, unsigned char macAddr[6]) {\n\tunsigned mac[6];\n\n\tif (sscanf(str, \"%2x:%2x:%2x:%2x:%2x:%2x\", &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]) != 6)\n\t\treturn 1;\n\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (mac[i] > 0xff)\n\t\t\treturn 1;\n\n\t\tmacAddr[i] = (unsigned char) mac[i];\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot configure the MAC address twice for the same interface\\n\""
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac_not_zero",
          "args": [
            "br->macsandbox"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "mac_not_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "102-110",
          "snippet": "static inline int mac_not_zero(const unsigned char mac[6]) {\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (mac[i] != 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline int mac_not_zero(const unsigned char mac[6]) {\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (mac[i] != 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"mac \"",
            "4"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid IP range\\n\""
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid IP range\\n\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot configure the IP range twice for the same interface\\n\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"iprange \"",
            "8"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no veth-name configured\\n\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 10"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"veth-name \"",
            "10"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: maximum 4 network devices are allowed\\n\""
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot attach to lo device\\n\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr + 4",
            "\"lo\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"net \"",
            "4"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"net none\""
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_netfilter_file",
          "args": [
            "arg_netfilter6_file"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "check_netfilter_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/netfilter.c",
          "lines": "27-44",
          "snippet": "void check_netfilter_file(const char *fname) {\n\tEUID_ASSERT();\n\n\tchar *tmp = strdup(fname);\n\tif (!tmp)\n\t\terrExit(\"strdup\");\n\tchar *ptr = strchr(tmp, ',');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\tinvalid_filename(tmp, 0); // no globbing\n\n\tif (is_dir(tmp) || is_link(tmp) || strstr(tmp, \"..\") || access(tmp, R_OK )) {\n\t\tfprintf(stderr, \"Error: invalid network filter file %s\\n\", tmp);\n\t\texit(1);\n\t}\n\tfree(tmp);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid check_netfilter_file(const char *fname) {\n\tEUID_ASSERT();\n\n\tchar *tmp = strdup(fname);\n\tif (!tmp)\n\t\terrExit(\"strdup\");\n\tchar *ptr = strchr(tmp, ',');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\tinvalid_filename(tmp, 0); // no globbing\n\n\tif (is_dir(tmp) || is_link(tmp) || strstr(tmp, \"..\") || access(tmp, R_OK )) {\n\t\tfprintf(stderr, \"Error: invalid network filter file %s\\n\", tmp);\n\t\texit(1);\n\t}\n\tfree(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 11"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"netfilter6 \"",
            "11"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 10"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"netfilter \"",
            "10"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"netfilter\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"nou2f\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"nodbus\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"no3d\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"novideo\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"nodvd\""
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"notv\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"noautopulse\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"nosound\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"nogroups\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"private-tmp\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"keep-dev-shm\""
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"private-dev\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"private-cache\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"allusers\""
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cfg.home_private_keep",
            "\"%s,%s\"",
            "cfg.home_private_keep",
            "ptr + 13"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"private-home \"",
            "13"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"private\""
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"tracelog\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"shell none\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"caps.drop all\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"caps\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"seccomp\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"nonewprivs\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_user_namespace",
          "args": [],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "check_user_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "303-325",
          "snippet": "void check_user_namespace(void) {\n\tEUID_ASSERT();\n\tif (getuid() == 0)\n\t\tgoto errout;\n\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0)\n\t\targ_noroot = 1;\n\telse\n\t\tgoto errout;\n\n\treturn;\n\nerrout:\n\tfwarning(\"noroot option is not available\\n\");\n\targ_noroot = 0;\n\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_noroot = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_noroot = 0;\n\nvoid check_user_namespace(void) {\n\tEUID_ASSERT();\n\tif (getuid() == 0)\n\t\tgoto errout;\n\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0)\n\t\targ_noroot = 1;\n\telse\n\t\tgoto errout;\n\n\treturn;\n\nerrout:\n\tfwarning(\"noroot option is not available\\n\");\n\targ_noroot = 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"noroot\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"ipc-namespace\""
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid sandbox name\\n\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"name \"",
            "5"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_mkfile",
          "args": [
            "ptr + 7"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "fs_mkfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_mkdir.c",
          "lines": "98-121",
          "snippet": "void fs_mkfile(const char *name) {\n\tEUID_ASSERT();\n\n\t// check file name\n\tinvalid_filename(name, 0); // no globbing\n\tchar *expanded = expand_macros(name);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0 &&\n\t    strncmp(expanded, \"/tmp\", 4) != 0) {\n\t\tfprintf(stderr, \"Error: only files in user home or /tmp are supported by mkfile\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create file\n\ttouch_file_as_user(expanded, 0600);\n\ndoexit:\n\tfree(expanded);\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/wait.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/wait.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_mkfile(const char *name) {\n\tEUID_ASSERT();\n\n\t// check file name\n\tinvalid_filename(name, 0); // no globbing\n\tchar *expanded = expand_macros(name);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0 &&\n\t    strncmp(expanded, \"/tmp\", 4) != 0) {\n\t\tfprintf(stderr, \"Error: only files in user home or /tmp are supported by mkfile\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create file\n\ttouch_file_as_user(expanded, 0600);\n\ndoexit:\n\tfree(expanded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"mkfile \"",
            "7"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_mkdir",
          "args": [
            "ptr + 6"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "fs_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_mkdir.c",
          "lines": "58-96",
          "snippet": "void fs_mkdir(const char *name) {\n\tEUID_ASSERT();\n\n\t// check directory name\n\tinvalid_filename(name, 0); // no globbing\n\tchar *expanded = expand_macros(name);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0 &&\n\t    strncmp(expanded, \"/tmp\", 4) != 0) {\n\t\tfprintf(stderr, \"Error: only directories in user home or /tmp are supported by mkdir\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create directory\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// create directory\n\t\tmkdir_recursive(expanded);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/wait.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/wait.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_mkdir(const char *name) {\n\tEUID_ASSERT();\n\n\t// check directory name\n\tinvalid_filename(name, 0); // no globbing\n\tchar *expanded = expand_macros(name);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0 &&\n\t    strncmp(expanded, \"/tmp\", 4) != 0) {\n\t\tfprintf(stderr, \"Error: only directories in user home or /tmp are supported by mkdir\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create directory\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// create directory\n\t\tmkdir_recursive(expanded);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"mkdir \"",
            "6"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"xephyr-screen \"",
            "14"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_add_ignore",
          "args": [
            "ptr + 7"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add_ignore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "112-135",
          "snippet": "void profile_add_ignore(const char *str) {\n\tassert(str);\n\tif (*str == '\\0') {\n\t\tfprintf(stderr, \"Error: invalid ignore option\\n\");\n\t\texit(1);\n\t}\n\n\t// find an empty entry in profile_ignore array\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\t}\n\tif (i >= MAX_PROFILE_IGNORE) {\n\t\tfprintf(stderr, \"Error: maximum %d --ignore options are permitted\\n\", MAX_PROFILE_IGNORE);\n\t\texit(1);\n\t}\n\t// ... and configure it\n\telse {\n\t\tcfg.profile_ignore[i] = strdup(str);\n\t\tif (!cfg.profile_ignore[i])\n\t\t\terrExit(\"strdup\");\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add_ignore(const char *str) {\n\tassert(str);\n\tif (*str == '\\0') {\n\t\tfprintf(stderr, \"Error: invalid ignore option\\n\");\n\t\texit(1);\n\t}\n\n\t// find an empty entry in profile_ignore array\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\t}\n\tif (i >= MAX_PROFILE_IGNORE) {\n\t\tfprintf(stderr, \"Error: maximum %d --ignore options are permitted\\n\", MAX_PROFILE_IGNORE);\n\t\texit(1);\n\t}\n\t// ... and configure it\n\telse {\n\t\tcfg.profile_ignore[i] = strdup(str);\n\t\tif (!cfg.profile_ignore[i])\n\t\t\terrExit(\"strdup\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"ignore \"",
            "7"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_in_ignore_list",
          "args": [
            "ptr"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "is_in_ignore_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "94-110",
          "snippet": "static int is_in_ignore_list(char *ptr) {\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\n\t\tint len = strlen(cfg.profile_ignore[i]);\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], len) == 0) {\n\t\t\t// full word match\n\t\t\tif (*(ptr + len) == '\\0' || *(ptr + len) == ' ')\n\t\t\t\treturn 1;\t// ignore line\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nstatic int is_in_ignore_list(char *ptr) {\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\n\t\tint len = strlen(cfg.profile_ignore[i]);\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], len) == 0) {\n\t\t\t// full word match\n\t\t\tif (*(ptr + len) == '\\0' || *(ptr + len) == ' ')\n\t\t\t\treturn 1;\t// ignore line\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_check_conditional",
          "args": [
            "ptr",
            "lineno",
            "fname"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "profile_check_conditional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "161-237",
          "snippet": "int profile_check_conditional(char *ptr, int lineno, const char *fname) {\n\tchar *tmp = ptr, *msg = NULL;\n\n\tif (*ptr++ != '?')\n\t\treturn 1;\n\n\tCond *cond = conditionals;\n\twhile (cond->name) {\n\t\t// continue if not this conditional\n\t\tif (strncmp(ptr, cond->name, strlen(cond->name)) != 0) {\n\t\t\tcond++;\n\t\t\tcontinue;\n\t\t}\n\t\tptr += strlen(cond->name);\n\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\t\tif (*ptr++ != ':') {\n\t\t\tmsg = \"invalid conditional syntax: colon must come after conditional\";\n\t\t\tptr = tmp;\n\t\t\tgoto error;\n\t\t}\n\t\tif (*ptr == '\\0') {\n\t\t\tmsg = \"invalid conditional syntax: no profile line after conditional\";\n\t\t\tptr = tmp;\n\t\t\tgoto error;\n\t\t}\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\n\t\t// if set, continue processing statement in caller\n\t\tint value = cond->check();\n\t\tif (value) {\n\t\t\t// move ptr to start of profile line\n\t\t\tptr = strdup(ptr);\n\t\t\tif (!ptr)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// check that the profile line does not contain either\n\t\t\t// quiet or include directives\n\t\t\tif ((strncmp(ptr, \"quiet\", 5) == 0) ||\n\t\t\t    (strncmp(ptr, \"include\", 7) == 0)) {\n\t\t\t\tmsg = \"invalid conditional syntax: quiet and include not allowed in conditionals\";\n\t\t\t\tptr = tmp;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\t// verify syntax, exit in case of error\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"conditional %s, %s\\n\", cond->name, ptr);\n\t\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\t\tprofile_add(ptr);\n\t\t}\n\t\t// tell caller to ignore\n\t\treturn 0;\n\t}\n\n\ttmp = ptr;\n\t// get the conditional used\n\twhile (*tmp != ':' && *tmp != '\\0')\n\t\ttmp++;\n\t*tmp = '\\0';\n\n\t// this was a '?' prefix, but didn't match any of the conditionals\n\tmsg = \"invalid/unsupported conditional\";\n\nerror:\n\tfprintf(stderr, \"Error: %s (\\\"%s\\\"\", msg, ptr);\n\tif (lineno == 0) ;\n\telse if (fname != NULL)\n\t\tfprintf(stderr, \" on line %d in %s\", lineno, fname);\n\telse\n\t\tfprintf(stderr, \" on line %d in the custom profile\", lineno);\n\tfprintf(stderr, \")\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Cond conditionals[] = {\n\t{\"HAS_APPIMAGE\", check_appimage},\n\t{\"HAS_NODBUS\", check_nodbus},\n\t{\"BROWSER_DISABLE_U2F\", check_disable_u2f},\n\t{ NULL, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nCond conditionals[] = {\n\t{\"HAS_APPIMAGE\", check_appimage},\n\t{\"HAS_NODBUS\", check_nodbus},\n\t{\"BROWSER_DISABLE_U2F\", check_disable_u2f},\n\t{ NULL, NULL }\n};\n\nint profile_check_conditional(char *ptr, int lineno, const char *fname) {\n\tchar *tmp = ptr, *msg = NULL;\n\n\tif (*ptr++ != '?')\n\t\treturn 1;\n\n\tCond *cond = conditionals;\n\twhile (cond->name) {\n\t\t// continue if not this conditional\n\t\tif (strncmp(ptr, cond->name, strlen(cond->name)) != 0) {\n\t\t\tcond++;\n\t\t\tcontinue;\n\t\t}\n\t\tptr += strlen(cond->name);\n\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\t\tif (*ptr++ != ':') {\n\t\t\tmsg = \"invalid conditional syntax: colon must come after conditional\";\n\t\t\tptr = tmp;\n\t\t\tgoto error;\n\t\t}\n\t\tif (*ptr == '\\0') {\n\t\t\tmsg = \"invalid conditional syntax: no profile line after conditional\";\n\t\t\tptr = tmp;\n\t\t\tgoto error;\n\t\t}\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\n\t\t// if set, continue processing statement in caller\n\t\tint value = cond->check();\n\t\tif (value) {\n\t\t\t// move ptr to start of profile line\n\t\t\tptr = strdup(ptr);\n\t\t\tif (!ptr)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// check that the profile line does not contain either\n\t\t\t// quiet or include directives\n\t\t\tif ((strncmp(ptr, \"quiet\", 5) == 0) ||\n\t\t\t    (strncmp(ptr, \"include\", 7) == 0)) {\n\t\t\t\tmsg = \"invalid conditional syntax: quiet and include not allowed in conditionals\";\n\t\t\t\tptr = tmp;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\t// verify syntax, exit in case of error\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"conditional %s, %s\\n\", cond->name, ptr);\n\t\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\t\tprofile_add(ptr);\n\t\t}\n\t\t// tell caller to ignore\n\t\treturn 0;\n\t}\n\n\ttmp = ptr;\n\t// get the conditional used\n\twhile (*tmp != ':' && *tmp != '\\0')\n\t\ttmp++;\n\t*tmp = '\\0';\n\n\t// this was a '?' prefix, but didn't match any of the conditionals\n\tmsg = \"invalid/unsupported conditional\";\n\nerror:\n\tfprintf(stderr, \"Error: %s (\\\"%s\\\"\", msg, ptr);\n\tif (lineno == 0) ;\n\telse if (fname != NULL)\n\t\tfprintf(stderr, \" on line %d in %s\", lineno, fname);\n\telse\n\t\tfprintf(stderr, \" on line %d in the custom profile\", lineno);\n\tfprintf(stderr, \")\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nextern char *xephyr_screen;\n\nint profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\n\t// check and process conditional profile lines\n\tif (profile_check_conditional(ptr, lineno, fname) == 0)\n\t\treturn 0;\n\n\t// check ignore list\n\tif (is_in_ignore_list(ptr))\n\t\treturn 0;\n\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tprofile_add_ignore(ptr + 7);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\txephyr_screen = ptr + 14;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\t// mkdir\n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\t// process mkdir again while applying blacklists\n\t}\n\t// mkfile\n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\t// process mkfile again while applying blacklists\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse\n\t\t\twarning_feature_disabled(\"noroot\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tif (cfg.home_private_keep) {\n\t\t\t\tif ( asprintf(&cfg.home_private_keep, \"%s,%s\", cfg.home_private_keep, ptr + 13) < 0 )\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t} else\n\t\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\targ_private = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-home\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-cache\") == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_CACHE))\n\t\t\targ_private_cache = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"private-cache\");\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"keep-dev-shm\") == 0) {\n\t\targ_keep_dev_shm = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"noautopulse\") == 0) {\n\t\targ_noautopulse = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"notv\") == 0) {\n\t\targ_notv = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodvd\") == 0) {\n\t\targ_nodvd = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"novideo\") == 0) {\n\t\targ_novideo = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodbus\") == 0) {\n\t\targ_nodbus = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nou2f\") == 0) {\n\t        arg_nou2f = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n\t\targ_nonetwork  = 1;\n\t\tcfg.bridge0.configured = 0;\n\t\tcfg.bridge1.configured = 0;\n\t\tcfg.bridge2.configured = 0;\n\t\tcfg.bridge3.configured = 0;\n\t\tcfg.interface0.configured = 0;\n\t\tcfg.interface1.configured = 0;\n\t\tcfg.interface2.configured = 0;\n\t\tcfg.interface3.configured = 0;\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbr->dev = ptr + 4;\n\t\t\tbr->configured = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"netmask \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->masksandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the network mask twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this network mask for the last bridge defined\n\t\t\tif (atoip(ptr + 8, &br->masksandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid  network mask\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// if the bridge is not configured, use this mask as the bridge mask\n\t\t\tif (br->mask == 0)\n\t\t\t\tbr->mask = br->masksandbox;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: interface %s already has a network mask defined; \"\n\t\t\t\t\t\"please remove --netmask\\n\",\n\t\t\t\t\tbr->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IPv6 address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->ip6sandbox = strdup(ptr + 4);\n\t\t\tif (br->ip6sandbox == NULL)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\tif (cfg.protocol) {\n\t\t\t\tfwarning(\"two protocol lists are present, \\\"%s\\\" will be installed\\n\", cfg.protocol);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// store list\n\t\t\tcfg.protocol = strdup(ptr + 9);\n\t\t\tif (!cfg.protocol)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = seccomp_check_list(ptr + 8);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"seccomp.block-secondary\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp_block_secondary = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// memory deny write&execute\n\tif (strcmp(ptr, \"memory-deny-write-execute\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_memory_deny_write_execute = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\n\t// hosts-file\n\tif (strncmp(ptr, \"hosts-file \", 11) == 0) {\n\t\tcfg.hosts_file = fs_check_hosts_file(ptr + 11);\n\t\treturn 0;\n\t}\n\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\n\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IPv4 or IPv6 address\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tchar *dns = strdup(ptr + 4);\n\t\tif (!dns)\n\t\t\terrExit(\"strdup\");\n\n\t\tif (cfg.dns1 == NULL)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == NULL)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == NULL)\n\t\t\tcfg.dns3 = dns;\n\t\telse if (cfg.dns4 == NULL)\n\t\t\tcfg.dns4 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 4 DNS servers can be specified\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 5) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tif (checkcfg(CFG_CGROUP))\n\t\t\tset_cgroup(ptr + 7);\n\t\telse\n\t\t\twarning_feature_disabled(\"cgroup\");\n\t\treturn 0;\n\t}\n\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"machine-id\") == 0) {\n\t\targ_machineid = 1;\n\t\treturn 0;\n\t}\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t// don't overwrite /var/tmp\n\tif (strcmp(ptr, \"keep-var-tmp\") == 0) {\n\t\targ_keep_var_tmp = 1;\n\t\treturn 0;\n\t}\n\t// writable-run-user\n\tif (strcmp(ptr, \"writable-run-user\") == 0) {\n\t\targ_writable_run_user = 1;\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"writable-var-log\") == 0) {\n\t\targ_writable_var_log = 1;\n\t\treturn 0;\n\t}\n\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xvfb\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xvfb(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (cfg.etc_private_keep) {\n\t\t\tif ( asprintf(&cfg.etc_private_keep, \"%s,%s\", cfg.etc_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.etc_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_etc = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /opt list of files and directories\n\tif (strncmp(ptr, \"private-opt \", 12) == 0) {\n\t\tif (cfg.opt_private_keep) {\n\t\t\tif ( asprintf(&cfg.opt_private_keep, \"%s,%s\", cfg.opt_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.opt_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_opt = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /srv list of files and directories\n\tif (strncmp(ptr, \"private-srv \", 12) == 0) {\n\t\tif (cfg.srv_private_keep) {\n\t\t\tif ( asprintf(&cfg.srv_private_keep, \"%s,%s\", cfg.srv_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.srv_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_srv = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tif (cfg.bin_private_keep) {\n\t\t\tif ( asprintf(&cfg.bin_private_keep, \"%s,%s\", cfg.bin_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.bin_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_bin = 1;\n\t\treturn 0;\n\t}\n\n\t// private /lib list of files\n\tif (strncmp(ptr, \"private-lib\", 11) == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_LIB)) {\n\t\t\tif (ptr[11] == ' ') {\n\t\t\t\tif (cfg.lib_private_keep) {\n\t\t\t\t\tif (ptr[12] != '\\0' && asprintf(&cfg.lib_private_keep, \"%s,%s\", cfg.lib_private_keep, ptr + 12) < 0)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t} else {\n\t\t\t\t\tcfg.lib_private_keep = ptr + 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\targ_private_lib = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-lib\");\n\t\treturn 0;\n\t}\n\n\n#ifdef HAVE_OVERLAYFS\n\tif (strncmp(ptr, \"overlay-named \", 14) == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\t\t\targ_overlay_reuse = 1;\n\n\t\t\tchar *subdirname = ptr + 14;\n\t\t\tif (*subdirname == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay option\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check name\n\t\t\tinvalid_filename(subdirname, 0); // no globbing\n\t\t\tif (strstr(subdirname, \"..\") || strstr(subdirname, \"/\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay-tmpfs\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\n\t\t\tchar *subdirname;\n\t\t\tif (asprintf(&subdirname, \"%d\", getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\n\t\t\tfree(subdirname);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\t}\n#endif\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1, 0); // no globbing\n\t\t\tinvalid_filename(dname2, 0); // no globbing\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"bind\");\n\t\treturn 0;\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tcheck_unsigned(ptr + 14, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 14, \"%llu\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-cpu \", 11) == 0) {\n\t\t\tcheck_unsigned(ptr + 11, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 11, \"%llu\", &cfg.rlimit_cpu);\n\t\t\targ_rlimit_cpu = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tcheck_unsigned(ptr + 18, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 18, \"%llu\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-as \", 10) == 0) {\n\t\t\tcheck_unsigned(ptr + 10, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 10, \"%llu\", &cfg.rlimit_as);\n\t\t\targ_rlimit_as = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"timeout \", 8) == 0) {\n\t\tcfg.timeout = extract_timeout(ptr +8);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0) {\n\t\t\t// try to join by name only\n\t\t\tpid_t pid;\n\t\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t\t// find first non-option arg\n\t\t\t\tint i;\n\t\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t// set sandbox name and start normally\n\t\t\tcfg.name = ptr + 14;\n\t\t\tif (strlen(cfg.name) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"join\");\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"disable-mnt\") == 0) {\n\t\targ_disable_mnt = 1;\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse {\n\t\t\tstatic int whitelist_warning_printed = 0;\n\t\t\tif (!whitelist_warning_printed) {\n\t\t\t\twarning_feature_disabled(\"whitelist\");\n\t\t\t\twhitelist_warning_printed = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n#else\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"nowhitelist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr, 1); // globbing\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "profile_check_conditional",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "161-237",
    "snippet": "int profile_check_conditional(char *ptr, int lineno, const char *fname) {\n\tchar *tmp = ptr, *msg = NULL;\n\n\tif (*ptr++ != '?')\n\t\treturn 1;\n\n\tCond *cond = conditionals;\n\twhile (cond->name) {\n\t\t// continue if not this conditional\n\t\tif (strncmp(ptr, cond->name, strlen(cond->name)) != 0) {\n\t\t\tcond++;\n\t\t\tcontinue;\n\t\t}\n\t\tptr += strlen(cond->name);\n\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\t\tif (*ptr++ != ':') {\n\t\t\tmsg = \"invalid conditional syntax: colon must come after conditional\";\n\t\t\tptr = tmp;\n\t\t\tgoto error;\n\t\t}\n\t\tif (*ptr == '\\0') {\n\t\t\tmsg = \"invalid conditional syntax: no profile line after conditional\";\n\t\t\tptr = tmp;\n\t\t\tgoto error;\n\t\t}\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\n\t\t// if set, continue processing statement in caller\n\t\tint value = cond->check();\n\t\tif (value) {\n\t\t\t// move ptr to start of profile line\n\t\t\tptr = strdup(ptr);\n\t\t\tif (!ptr)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// check that the profile line does not contain either\n\t\t\t// quiet or include directives\n\t\t\tif ((strncmp(ptr, \"quiet\", 5) == 0) ||\n\t\t\t    (strncmp(ptr, \"include\", 7) == 0)) {\n\t\t\t\tmsg = \"invalid conditional syntax: quiet and include not allowed in conditionals\";\n\t\t\t\tptr = tmp;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\t// verify syntax, exit in case of error\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"conditional %s, %s\\n\", cond->name, ptr);\n\t\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\t\tprofile_add(ptr);\n\t\t}\n\t\t// tell caller to ignore\n\t\treturn 0;\n\t}\n\n\ttmp = ptr;\n\t// get the conditional used\n\twhile (*tmp != ':' && *tmp != '\\0')\n\t\ttmp++;\n\t*tmp = '\\0';\n\n\t// this was a '?' prefix, but didn't match any of the conditionals\n\tmsg = \"invalid/unsupported conditional\";\n\nerror:\n\tfprintf(stderr, \"Error: %s (\\\"%s\\\"\", msg, ptr);\n\tif (lineno == 0) ;\n\telse if (fname != NULL)\n\t\tfprintf(stderr, \" on line %d in %s\", lineno, fname);\n\telse\n\t\tfprintf(stderr, \" on line %d in the custom profile\", lineno);\n\tfprintf(stderr, \")\\n\");\n\texit(1);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Cond conditionals[] = {\n\t{\"HAS_APPIMAGE\", check_appimage},\n\t{\"HAS_NODBUS\", check_nodbus},\n\t{\"BROWSER_DISABLE_U2F\", check_disable_u2f},\n\t{ NULL, NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\")\\n\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" on line %d in the custom profile\"",
            "lineno"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" on line %d in %s\"",
            "lineno",
            "fname"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s (\\\"%s\\\"\"",
            "msg",
            "ptr"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_add",
          "args": [
            "ptr"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "1364-1383",
          "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_check_line",
          "args": [
            "ptr",
            "lineno",
            "fname"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "profile_check_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "243-1361",
          "snippet": "int profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\n\t// check and process conditional profile lines\n\tif (profile_check_conditional(ptr, lineno, fname) == 0)\n\t\treturn 0;\n\n\t// check ignore list\n\tif (is_in_ignore_list(ptr))\n\t\treturn 0;\n\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tprofile_add_ignore(ptr + 7);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\txephyr_screen = ptr + 14;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\t// mkdir\n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\t// process mkdir again while applying blacklists\n\t}\n\t// mkfile\n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\t// process mkfile again while applying blacklists\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse\n\t\t\twarning_feature_disabled(\"noroot\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tif (cfg.home_private_keep) {\n\t\t\t\tif ( asprintf(&cfg.home_private_keep, \"%s,%s\", cfg.home_private_keep, ptr + 13) < 0 )\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t} else\n\t\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\targ_private = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-home\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-cache\") == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_CACHE))\n\t\t\targ_private_cache = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"private-cache\");\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"keep-dev-shm\") == 0) {\n\t\targ_keep_dev_shm = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"noautopulse\") == 0) {\n\t\targ_noautopulse = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"notv\") == 0) {\n\t\targ_notv = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodvd\") == 0) {\n\t\targ_nodvd = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"novideo\") == 0) {\n\t\targ_novideo = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodbus\") == 0) {\n\t\targ_nodbus = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nou2f\") == 0) {\n\t        arg_nou2f = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n\t\targ_nonetwork  = 1;\n\t\tcfg.bridge0.configured = 0;\n\t\tcfg.bridge1.configured = 0;\n\t\tcfg.bridge2.configured = 0;\n\t\tcfg.bridge3.configured = 0;\n\t\tcfg.interface0.configured = 0;\n\t\tcfg.interface1.configured = 0;\n\t\tcfg.interface2.configured = 0;\n\t\tcfg.interface3.configured = 0;\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbr->dev = ptr + 4;\n\t\t\tbr->configured = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"netmask \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->masksandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the network mask twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this network mask for the last bridge defined\n\t\t\tif (atoip(ptr + 8, &br->masksandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid  network mask\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// if the bridge is not configured, use this mask as the bridge mask\n\t\t\tif (br->mask == 0)\n\t\t\t\tbr->mask = br->masksandbox;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: interface %s already has a network mask defined; \"\n\t\t\t\t\t\"please remove --netmask\\n\",\n\t\t\t\t\tbr->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IPv6 address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->ip6sandbox = strdup(ptr + 4);\n\t\t\tif (br->ip6sandbox == NULL)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\tif (cfg.protocol) {\n\t\t\t\tfwarning(\"two protocol lists are present, \\\"%s\\\" will be installed\\n\", cfg.protocol);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// store list\n\t\t\tcfg.protocol = strdup(ptr + 9);\n\t\t\tif (!cfg.protocol)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = seccomp_check_list(ptr + 8);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"seccomp.block-secondary\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp_block_secondary = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// memory deny write&execute\n\tif (strcmp(ptr, \"memory-deny-write-execute\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_memory_deny_write_execute = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\n\t// hosts-file\n\tif (strncmp(ptr, \"hosts-file \", 11) == 0) {\n\t\tcfg.hosts_file = fs_check_hosts_file(ptr + 11);\n\t\treturn 0;\n\t}\n\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\n\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IPv4 or IPv6 address\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tchar *dns = strdup(ptr + 4);\n\t\tif (!dns)\n\t\t\terrExit(\"strdup\");\n\n\t\tif (cfg.dns1 == NULL)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == NULL)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == NULL)\n\t\t\tcfg.dns3 = dns;\n\t\telse if (cfg.dns4 == NULL)\n\t\t\tcfg.dns4 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 4 DNS servers can be specified\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 5) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tif (checkcfg(CFG_CGROUP))\n\t\t\tset_cgroup(ptr + 7);\n\t\telse\n\t\t\twarning_feature_disabled(\"cgroup\");\n\t\treturn 0;\n\t}\n\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"machine-id\") == 0) {\n\t\targ_machineid = 1;\n\t\treturn 0;\n\t}\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t// don't overwrite /var/tmp\n\tif (strcmp(ptr, \"keep-var-tmp\") == 0) {\n\t\targ_keep_var_tmp = 1;\n\t\treturn 0;\n\t}\n\t// writable-run-user\n\tif (strcmp(ptr, \"writable-run-user\") == 0) {\n\t\targ_writable_run_user = 1;\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"writable-var-log\") == 0) {\n\t\targ_writable_var_log = 1;\n\t\treturn 0;\n\t}\n\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xvfb\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xvfb(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (cfg.etc_private_keep) {\n\t\t\tif ( asprintf(&cfg.etc_private_keep, \"%s,%s\", cfg.etc_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.etc_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_etc = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /opt list of files and directories\n\tif (strncmp(ptr, \"private-opt \", 12) == 0) {\n\t\tif (cfg.opt_private_keep) {\n\t\t\tif ( asprintf(&cfg.opt_private_keep, \"%s,%s\", cfg.opt_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.opt_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_opt = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /srv list of files and directories\n\tif (strncmp(ptr, \"private-srv \", 12) == 0) {\n\t\tif (cfg.srv_private_keep) {\n\t\t\tif ( asprintf(&cfg.srv_private_keep, \"%s,%s\", cfg.srv_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.srv_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_srv = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tif (cfg.bin_private_keep) {\n\t\t\tif ( asprintf(&cfg.bin_private_keep, \"%s,%s\", cfg.bin_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.bin_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_bin = 1;\n\t\treturn 0;\n\t}\n\n\t// private /lib list of files\n\tif (strncmp(ptr, \"private-lib\", 11) == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_LIB)) {\n\t\t\tif (ptr[11] == ' ') {\n\t\t\t\tif (cfg.lib_private_keep) {\n\t\t\t\t\tif (ptr[12] != '\\0' && asprintf(&cfg.lib_private_keep, \"%s,%s\", cfg.lib_private_keep, ptr + 12) < 0)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t} else {\n\t\t\t\t\tcfg.lib_private_keep = ptr + 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\targ_private_lib = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-lib\");\n\t\treturn 0;\n\t}\n\n\n#ifdef HAVE_OVERLAYFS\n\tif (strncmp(ptr, \"overlay-named \", 14) == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\t\t\targ_overlay_reuse = 1;\n\n\t\t\tchar *subdirname = ptr + 14;\n\t\t\tif (*subdirname == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay option\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check name\n\t\t\tinvalid_filename(subdirname, 0); // no globbing\n\t\t\tif (strstr(subdirname, \"..\") || strstr(subdirname, \"/\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay-tmpfs\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\n\t\t\tchar *subdirname;\n\t\t\tif (asprintf(&subdirname, \"%d\", getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\n\t\t\tfree(subdirname);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\t}\n#endif\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1, 0); // no globbing\n\t\t\tinvalid_filename(dname2, 0); // no globbing\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"bind\");\n\t\treturn 0;\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tcheck_unsigned(ptr + 14, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 14, \"%llu\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-cpu \", 11) == 0) {\n\t\t\tcheck_unsigned(ptr + 11, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 11, \"%llu\", &cfg.rlimit_cpu);\n\t\t\targ_rlimit_cpu = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tcheck_unsigned(ptr + 18, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 18, \"%llu\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-as \", 10) == 0) {\n\t\t\tcheck_unsigned(ptr + 10, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 10, \"%llu\", &cfg.rlimit_as);\n\t\t\targ_rlimit_as = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"timeout \", 8) == 0) {\n\t\tcfg.timeout = extract_timeout(ptr +8);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0) {\n\t\t\t// try to join by name only\n\t\t\tpid_t pid;\n\t\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t\t// find first non-option arg\n\t\t\t\tint i;\n\t\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t// set sandbox name and start normally\n\t\t\tcfg.name = ptr + 14;\n\t\t\tif (strlen(cfg.name) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"join\");\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"disable-mnt\") == 0) {\n\t\targ_disable_mnt = 1;\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse {\n\t\t\tstatic int whitelist_warning_printed = 0;\n\t\t\tif (!whitelist_warning_printed) {\n\t\t\t\twarning_feature_disabled(\"whitelist\");\n\t\t\t\twhitelist_warning_printed = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n#else\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"nowhitelist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr, 1); // globbing\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *xephyr_screen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nextern char *xephyr_screen;\n\nint profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\n\t// check and process conditional profile lines\n\tif (profile_check_conditional(ptr, lineno, fname) == 0)\n\t\treturn 0;\n\n\t// check ignore list\n\tif (is_in_ignore_list(ptr))\n\t\treturn 0;\n\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tprofile_add_ignore(ptr + 7);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\txephyr_screen = ptr + 14;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\t// mkdir\n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\t// process mkdir again while applying blacklists\n\t}\n\t// mkfile\n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\t// process mkfile again while applying blacklists\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse\n\t\t\twarning_feature_disabled(\"noroot\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tif (cfg.home_private_keep) {\n\t\t\t\tif ( asprintf(&cfg.home_private_keep, \"%s,%s\", cfg.home_private_keep, ptr + 13) < 0 )\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t} else\n\t\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\targ_private = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-home\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-cache\") == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_CACHE))\n\t\t\targ_private_cache = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"private-cache\");\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"keep-dev-shm\") == 0) {\n\t\targ_keep_dev_shm = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"noautopulse\") == 0) {\n\t\targ_noautopulse = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"notv\") == 0) {\n\t\targ_notv = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodvd\") == 0) {\n\t\targ_nodvd = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"novideo\") == 0) {\n\t\targ_novideo = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodbus\") == 0) {\n\t\targ_nodbus = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nou2f\") == 0) {\n\t        arg_nou2f = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n\t\targ_nonetwork  = 1;\n\t\tcfg.bridge0.configured = 0;\n\t\tcfg.bridge1.configured = 0;\n\t\tcfg.bridge2.configured = 0;\n\t\tcfg.bridge3.configured = 0;\n\t\tcfg.interface0.configured = 0;\n\t\tcfg.interface1.configured = 0;\n\t\tcfg.interface2.configured = 0;\n\t\tcfg.interface3.configured = 0;\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbr->dev = ptr + 4;\n\t\t\tbr->configured = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"netmask \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->masksandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the network mask twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this network mask for the last bridge defined\n\t\t\tif (atoip(ptr + 8, &br->masksandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid  network mask\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// if the bridge is not configured, use this mask as the bridge mask\n\t\t\tif (br->mask == 0)\n\t\t\t\tbr->mask = br->masksandbox;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: interface %s already has a network mask defined; \"\n\t\t\t\t\t\"please remove --netmask\\n\",\n\t\t\t\t\tbr->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IPv6 address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->ip6sandbox = strdup(ptr + 4);\n\t\t\tif (br->ip6sandbox == NULL)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\tif (cfg.protocol) {\n\t\t\t\tfwarning(\"two protocol lists are present, \\\"%s\\\" will be installed\\n\", cfg.protocol);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// store list\n\t\t\tcfg.protocol = strdup(ptr + 9);\n\t\t\tif (!cfg.protocol)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = seccomp_check_list(ptr + 8);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"seccomp.block-secondary\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp_block_secondary = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// memory deny write&execute\n\tif (strcmp(ptr, \"memory-deny-write-execute\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_memory_deny_write_execute = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\n\t// hosts-file\n\tif (strncmp(ptr, \"hosts-file \", 11) == 0) {\n\t\tcfg.hosts_file = fs_check_hosts_file(ptr + 11);\n\t\treturn 0;\n\t}\n\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\n\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IPv4 or IPv6 address\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tchar *dns = strdup(ptr + 4);\n\t\tif (!dns)\n\t\t\terrExit(\"strdup\");\n\n\t\tif (cfg.dns1 == NULL)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == NULL)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == NULL)\n\t\t\tcfg.dns3 = dns;\n\t\telse if (cfg.dns4 == NULL)\n\t\t\tcfg.dns4 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 4 DNS servers can be specified\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 5) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tif (checkcfg(CFG_CGROUP))\n\t\t\tset_cgroup(ptr + 7);\n\t\telse\n\t\t\twarning_feature_disabled(\"cgroup\");\n\t\treturn 0;\n\t}\n\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"machine-id\") == 0) {\n\t\targ_machineid = 1;\n\t\treturn 0;\n\t}\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t// don't overwrite /var/tmp\n\tif (strcmp(ptr, \"keep-var-tmp\") == 0) {\n\t\targ_keep_var_tmp = 1;\n\t\treturn 0;\n\t}\n\t// writable-run-user\n\tif (strcmp(ptr, \"writable-run-user\") == 0) {\n\t\targ_writable_run_user = 1;\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"writable-var-log\") == 0) {\n\t\targ_writable_var_log = 1;\n\t\treturn 0;\n\t}\n\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xvfb\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xvfb(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (cfg.etc_private_keep) {\n\t\t\tif ( asprintf(&cfg.etc_private_keep, \"%s,%s\", cfg.etc_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.etc_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_etc = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /opt list of files and directories\n\tif (strncmp(ptr, \"private-opt \", 12) == 0) {\n\t\tif (cfg.opt_private_keep) {\n\t\t\tif ( asprintf(&cfg.opt_private_keep, \"%s,%s\", cfg.opt_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.opt_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_opt = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /srv list of files and directories\n\tif (strncmp(ptr, \"private-srv \", 12) == 0) {\n\t\tif (cfg.srv_private_keep) {\n\t\t\tif ( asprintf(&cfg.srv_private_keep, \"%s,%s\", cfg.srv_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.srv_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_srv = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tif (cfg.bin_private_keep) {\n\t\t\tif ( asprintf(&cfg.bin_private_keep, \"%s,%s\", cfg.bin_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.bin_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_bin = 1;\n\t\treturn 0;\n\t}\n\n\t// private /lib list of files\n\tif (strncmp(ptr, \"private-lib\", 11) == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_LIB)) {\n\t\t\tif (ptr[11] == ' ') {\n\t\t\t\tif (cfg.lib_private_keep) {\n\t\t\t\t\tif (ptr[12] != '\\0' && asprintf(&cfg.lib_private_keep, \"%s,%s\", cfg.lib_private_keep, ptr + 12) < 0)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t} else {\n\t\t\t\t\tcfg.lib_private_keep = ptr + 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\targ_private_lib = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-lib\");\n\t\treturn 0;\n\t}\n\n\n#ifdef HAVE_OVERLAYFS\n\tif (strncmp(ptr, \"overlay-named \", 14) == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\t\t\targ_overlay_reuse = 1;\n\n\t\t\tchar *subdirname = ptr + 14;\n\t\t\tif (*subdirname == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay option\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check name\n\t\t\tinvalid_filename(subdirname, 0); // no globbing\n\t\t\tif (strstr(subdirname, \"..\") || strstr(subdirname, \"/\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay-tmpfs\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\n\t\t\tchar *subdirname;\n\t\t\tif (asprintf(&subdirname, \"%d\", getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\n\t\t\tfree(subdirname);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\t}\n#endif\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1, 0); // no globbing\n\t\t\tinvalid_filename(dname2, 0); // no globbing\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"bind\");\n\t\treturn 0;\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tcheck_unsigned(ptr + 14, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 14, \"%llu\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-cpu \", 11) == 0) {\n\t\t\tcheck_unsigned(ptr + 11, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 11, \"%llu\", &cfg.rlimit_cpu);\n\t\t\targ_rlimit_cpu = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tcheck_unsigned(ptr + 18, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 18, \"%llu\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-as \", 10) == 0) {\n\t\t\tcheck_unsigned(ptr + 10, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 10, \"%llu\", &cfg.rlimit_as);\n\t\t\targ_rlimit_as = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"timeout \", 8) == 0) {\n\t\tcfg.timeout = extract_timeout(ptr +8);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0) {\n\t\t\t// try to join by name only\n\t\t\tpid_t pid;\n\t\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t\t// find first non-option arg\n\t\t\t\tint i;\n\t\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t// set sandbox name and start normally\n\t\t\tcfg.name = ptr + 14;\n\t\t\tif (strlen(cfg.name) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"join\");\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"disable-mnt\") == 0) {\n\t\targ_disable_mnt = 1;\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse {\n\t\t\tstatic int whitelist_warning_printed = 0;\n\t\t\tif (!whitelist_warning_printed) {\n\t\t\t\twarning_feature_disabled(\"whitelist\");\n\t\t\t\twhitelist_warning_printed = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n#else\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"nowhitelist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr, 1); // globbing\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"conditional %s, %s\\n\"",
            "cond->name",
            "ptr"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"include\"",
            "7"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"quiet\"",
            "5"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond->check",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cond->name"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "cond->name",
            "strlen(cond->name)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nCond conditionals[] = {\n\t{\"HAS_APPIMAGE\", check_appimage},\n\t{\"HAS_NODBUS\", check_nodbus},\n\t{\"BROWSER_DISABLE_U2F\", check_disable_u2f},\n\t{ NULL, NULL }\n};\n\nint profile_check_conditional(char *ptr, int lineno, const char *fname) {\n\tchar *tmp = ptr, *msg = NULL;\n\n\tif (*ptr++ != '?')\n\t\treturn 1;\n\n\tCond *cond = conditionals;\n\twhile (cond->name) {\n\t\t// continue if not this conditional\n\t\tif (strncmp(ptr, cond->name, strlen(cond->name)) != 0) {\n\t\t\tcond++;\n\t\t\tcontinue;\n\t\t}\n\t\tptr += strlen(cond->name);\n\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\t\tif (*ptr++ != ':') {\n\t\t\tmsg = \"invalid conditional syntax: colon must come after conditional\";\n\t\t\tptr = tmp;\n\t\t\tgoto error;\n\t\t}\n\t\tif (*ptr == '\\0') {\n\t\t\tmsg = \"invalid conditional syntax: no profile line after conditional\";\n\t\t\tptr = tmp;\n\t\t\tgoto error;\n\t\t}\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\n\t\t// if set, continue processing statement in caller\n\t\tint value = cond->check();\n\t\tif (value) {\n\t\t\t// move ptr to start of profile line\n\t\t\tptr = strdup(ptr);\n\t\t\tif (!ptr)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// check that the profile line does not contain either\n\t\t\t// quiet or include directives\n\t\t\tif ((strncmp(ptr, \"quiet\", 5) == 0) ||\n\t\t\t    (strncmp(ptr, \"include\", 7) == 0)) {\n\t\t\t\tmsg = \"invalid conditional syntax: quiet and include not allowed in conditionals\";\n\t\t\t\tptr = tmp;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\t// verify syntax, exit in case of error\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"conditional %s, %s\\n\", cond->name, ptr);\n\t\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\t\tprofile_add(ptr);\n\t\t}\n\t\t// tell caller to ignore\n\t\treturn 0;\n\t}\n\n\ttmp = ptr;\n\t// get the conditional used\n\twhile (*tmp != ':' && *tmp != '\\0')\n\t\ttmp++;\n\t*tmp = '\\0';\n\n\t// this was a '?' prefix, but didn't match any of the conditionals\n\tmsg = \"invalid/unsupported conditional\";\n\nerror:\n\tfprintf(stderr, \"Error: %s (\\\"%s\\\"\", msg, ptr);\n\tif (lineno == 0) ;\n\telse if (fname != NULL)\n\t\tfprintf(stderr, \" on line %d in %s\", lineno, fname);\n\telse\n\t\tfprintf(stderr, \" on line %d in the custom profile\", lineno);\n\tfprintf(stderr, \")\\n\");\n\texit(1);\n}"
  },
  {
    "function_name": "check_disable_u2f",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "150-152",
    "snippet": "static int check_disable_u2f(void) {\n\treturn checkcfg(CFG_BROWSER_DISABLE_U2F) != 0;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_BROWSER_DISABLE_U2F"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/checkcfg.c",
          "lines": "35-213",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *xpra_extra_params = \"\";",
            "char *xvfb_screen = \"800x600x24\";",
            "char *xvfb_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *xpra_extra_params = \"\";\nchar *xvfb_screen = \"800x600x24\";\nchar *xvfb_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nstatic int check_disable_u2f(void) {\n\treturn checkcfg(CFG_BROWSER_DISABLE_U2F) != 0;\n}"
  },
  {
    "function_name": "check_nodbus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "146-148",
    "snippet": "static int check_nodbus(void) {\n\treturn arg_nodbus != 0;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nstatic int check_nodbus(void) {\n\treturn arg_nodbus != 0;\n}"
  },
  {
    "function_name": "check_appimage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "142-144",
    "snippet": "static int check_appimage(void) {\n\treturn arg_appimage != 0;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nstatic int check_appimage(void) {\n\treturn arg_appimage != 0;\n}"
  },
  {
    "function_name": "profile_add_ignore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "112-135",
    "snippet": "void profile_add_ignore(const char *str) {\n\tassert(str);\n\tif (*str == '\\0') {\n\t\tfprintf(stderr, \"Error: invalid ignore option\\n\");\n\t\texit(1);\n\t}\n\n\t// find an empty entry in profile_ignore array\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\t}\n\tif (i >= MAX_PROFILE_IGNORE) {\n\t\tfprintf(stderr, \"Error: maximum %d --ignore options are permitted\\n\", MAX_PROFILE_IGNORE);\n\t\texit(1);\n\t}\n\t// ... and configure it\n\telse {\n\t\tcfg.profile_ignore[i] = strdup(str);\n\t\tif (!cfg.profile_ignore[i])\n\t\t\terrExit(\"strdup\");\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: maximum %d --ignore options are permitted\\n\"",
            "MAX_PROFILE_IGNORE"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid ignore option\\n\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add_ignore(const char *str) {\n\tassert(str);\n\tif (*str == '\\0') {\n\t\tfprintf(stderr, \"Error: invalid ignore option\\n\");\n\t\texit(1);\n\t}\n\n\t// find an empty entry in profile_ignore array\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\t}\n\tif (i >= MAX_PROFILE_IGNORE) {\n\t\tfprintf(stderr, \"Error: maximum %d --ignore options are permitted\\n\", MAX_PROFILE_IGNORE);\n\t\texit(1);\n\t}\n\t// ... and configure it\n\telse {\n\t\tcfg.profile_ignore[i] = strdup(str);\n\t\tif (!cfg.profile_ignore[i])\n\t\t\terrExit(\"strdup\");\n\t}\n}"
  },
  {
    "function_name": "is_in_ignore_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "94-110",
    "snippet": "static int is_in_ignore_list(char *ptr) {\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\n\t\tint len = strlen(cfg.profile_ignore[i]);\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], len) == 0) {\n\t\t\t// full word match\n\t\t\tif (*(ptr + len) == '\\0' || *(ptr + len) == ' ')\n\t\t\t\treturn 1;\t// ignore line\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "cfg.profile_ignore[i]",
            "len"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg.profile_ignore[i]"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nstatic int is_in_ignore_list(char *ptr) {\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\n\t\tint len = strlen(cfg.profile_ignore[i]);\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], len) == 0) {\n\t\t\t// full word match\n\t\t\tif (*(ptr + len) == '\\0' || *(ptr + len) == ' ')\n\t\t\t\treturn 1;\t// ignore line\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "warning_feature_disabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "89-91",
    "snippet": "static void warning_feature_disabled(const char *feature) {\n\tfwarning(\"%s feature is disabled in Firejail configuration file\\n\", feature);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"%s feature is disabled in Firejail configuration file\\n\"",
            "feature"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nstatic void warning_feature_disabled(const char *feature) {\n\tfwarning(\"%s feature is disabled in Firejail configuration file\\n\", feature);\n}"
  },
  {
    "function_name": "profile_find_firejail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "70-83",
    "snippet": "int profile_find_firejail(const char *name, int add_ext) {\n\t// look for a profile in ~/.config/firejail directory\n\tchar *usercfgdir;\n\tif (asprintf(&usercfgdir, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tint rv = profile_find(name, usercfgdir, add_ext);\n\tfree(usercfgdir);\n\n\tif (!rv)\n\t\t// look for a user profile in /etc/firejail directory\n\t\trv = profile_find(name, SYSCONFDIR, add_ext);\n\n\treturn rv;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_find",
          "args": [
            "name",
            "SYSCONFDIR",
            "add_ext"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "profile_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "29-66",
          "snippet": "static int profile_find(const char *name, const char *dir, int add_ext) {\n\tEUID_ASSERT();\n\tassert(name);\n\tassert(dir);\n\n\tint rv = 0;\n\tDIR *dp;\n\tchar *pname = NULL;\n\tif (add_ext) {\n\t\tif (asprintf(&pname, \"%s.profile\", name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\telse\n\t\t\tname = pname;\n\t}\n\n\tdp = opendir (dir);\n\tif (dp != NULL) {\n\t\tstruct dirent *ep;\n\t\twhile ((ep = readdir(dp)) != NULL) {\n\t\t\tif (strcmp(ep->d_name, name) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s profile in %s directory\\n\", name, dir);\n\t\t\t\tchar *etcpname;\n\t\t\t\tif (asprintf(&etcpname, \"%s/%s\", dir, name) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprofile_read(etcpname);\n\t\t\t\tfree(etcpname);\n\t\t\t\trv = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t(void) closedir (dp);\n\t}\n\n\tif (pname)\n\t\tfree(pname);\n\treturn rv;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nstatic int profile_find(const char *name, const char *dir, int add_ext) {\n\tEUID_ASSERT();\n\tassert(name);\n\tassert(dir);\n\n\tint rv = 0;\n\tDIR *dp;\n\tchar *pname = NULL;\n\tif (add_ext) {\n\t\tif (asprintf(&pname, \"%s.profile\", name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\telse\n\t\t\tname = pname;\n\t}\n\n\tdp = opendir (dir);\n\tif (dp != NULL) {\n\t\tstruct dirent *ep;\n\t\twhile ((ep = readdir(dp)) != NULL) {\n\t\t\tif (strcmp(ep->d_name, name) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s profile in %s directory\\n\", name, dir);\n\t\t\t\tchar *etcpname;\n\t\t\t\tif (asprintf(&etcpname, \"%s/%s\", dir, name) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprofile_read(etcpname);\n\t\t\t\tfree(etcpname);\n\t\t\t\trv = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t(void) closedir (dp);\n\t}\n\n\tif (pname)\n\t\tfree(pname);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "usercfgdir"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&usercfgdir",
            "\"%s/.config/firejail\"",
            "cfg.homedir"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nint profile_find_firejail(const char *name, int add_ext) {\n\t// look for a profile in ~/.config/firejail directory\n\tchar *usercfgdir;\n\tif (asprintf(&usercfgdir, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tint rv = profile_find(name, usercfgdir, add_ext);\n\tfree(usercfgdir);\n\n\tif (!rv)\n\t\t// look for a user profile in /etc/firejail directory\n\t\trv = profile_find(name, SYSCONFDIR, add_ext);\n\n\treturn rv;\n}"
  },
  {
    "function_name": "profile_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
    "lines": "29-66",
    "snippet": "static int profile_find(const char *name, const char *dir, int add_ext) {\n\tEUID_ASSERT();\n\tassert(name);\n\tassert(dir);\n\n\tint rv = 0;\n\tDIR *dp;\n\tchar *pname = NULL;\n\tif (add_ext) {\n\t\tif (asprintf(&pname, \"%s.profile\", name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\telse\n\t\t\tname = pname;\n\t}\n\n\tdp = opendir (dir);\n\tif (dp != NULL) {\n\t\tstruct dirent *ep;\n\t\twhile ((ep = readdir(dp)) != NULL) {\n\t\t\tif (strcmp(ep->d_name, name) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s profile in %s directory\\n\", name, dir);\n\t\t\t\tchar *etcpname;\n\t\t\t\tif (asprintf(&etcpname, \"%s/%s\", dir, name) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprofile_read(etcpname);\n\t\t\t\tfree(etcpname);\n\t\t\t\trv = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t(void) closedir (dp);\n\t}\n\n\tif (pname)\n\t\tfree(pname);\n\treturn rv;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pname"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dp"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "etcpname"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_read",
          "args": [
            "etcpname"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "profile_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "1387-1509",
          "snippet": "void profile_read(const char *fname) {\n\tEUID_ASSERT();\n\n\t// exit program if maximum include level was reached\n\tif (include_level > MAX_INCLUDE_LEVEL) {\n\t\tfprintf(stderr, \"Error: maximum profile include level was reached\\n\");\n\t\texit(1);\n\t}\n\n\t// check file\n\tinvalid_filename(fname, 0); // no globbing\n\tif (strlen(fname) == 0 || is_dir(fname)) {\n\t\tfprintf(stderr, \"Error: invalid profile file\\n\");\n\t\texit(1);\n\t}\n\tif (access(fname, R_OK)) {\n\t\t// if the file ends in \".local\", do not exit\n\t\tconst char *base = gnu_basename(fname);\n\t\tchar *ptr = strstr(base, \".local\");\n\t\tif (ptr && strlen(ptr) == 6)\n\t\t\treturn;\n\n\t\tfprintf(stderr, \"Error: cannot access profile file: %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// allow debuggers\n\tif (arg_allow_debuggers) {\n\t\tchar *tmp = strrchr(fname, '/');\n\t\tif (tmp && *(tmp + 1) != '\\0') {\n\t\t\ttmp++;\n\t\t\tif (strcmp(tmp, \"disable-devel.inc\") == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// open profile file:\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"Error: cannot open profile file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// save the name of the file for --profile.print option\n\tif (include_level == 0)\n\t\tset_profile_run_file(getpid(), fname);\n\n\tint msg_printed = 0;\n\n\t// read the file line by line\n\tchar buf[MAX_READ + 1];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\t++lineno;\n\t\t// remove empty space - ptr in allocated memory\n\t\tchar *ptr = line_remove_spaces(buf);\n\t\tif (ptr == NULL)\n\t\t\tcontinue;\n\n\t\t// comments\n\t\tif (*ptr == '#' || *ptr == '\\0') {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process quiet\n\t\t// todo: a quiet in the profile file cannot be disabled by --ignore on command line\n\t\tif (strcmp(ptr, \"quiet\") == 0) {\n\t\t\tif (is_in_ignore_list(ptr))\n\t\t\t\targ_quiet = 0;\n\t\t\telse\n\t\t\t\targ_quiet = 1;\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!msg_printed) {\n\t\t\tfmessage(\"Reading profile %s\\n\", fname);\n\t\t\tmsg_printed = 1;\n\t\t}\n\n\t\t// process include\n\t\tif (strncmp(ptr, \"include \", 8) == 0) {\n\t\t\tinclude_level++;\n\n\t\t\t// expand macros in front of the include profile file\n\t\t\tchar *newprofile = expand_macros(ptr + 8);\n\n\t\t\tchar *ptr2 = newprofile;\n\t\t\twhile (*ptr2 != '/' && *ptr2 != '\\0')\n\t\t\t\tptr2++;\n\t\t\t// profile path contains no / chars, do a search\n\t\t\tif (*ptr2 == '\\0') {\n\t\t\t\tint rv = profile_find_firejail(newprofile, 0); // returns 1 if a profile was found in sysconfig directory\n\t\t\t\tif (!rv) {\n\t\t\t\t\t// maybe this is a file in the local working directory?\n\t\t\t\t\t// it will stop the sandbox if not!\n\t\t\t\t\t// Note: if the file ends in .local it will not stop the program\n\t\t\t\t\tprofile_read(newprofile);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprofile_read(newprofile);\n\t\t\t}\n\n\t\t\tinclude_level--;\n\t\t\tfree(newprofile);\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// verify syntax, exit in case of error\n\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\tprofile_add(ptr);\n// we cannot free ptr here, data is extracted from ptr and linked as a pointer in cfg structure\n//\t\telse {\n//\t\t\tfree(ptr);\n//\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t}\n\tfclose(fp);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int include_level = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int include_level = 0;\n\nvoid profile_read(const char *fname) {\n\tEUID_ASSERT();\n\n\t// exit program if maximum include level was reached\n\tif (include_level > MAX_INCLUDE_LEVEL) {\n\t\tfprintf(stderr, \"Error: maximum profile include level was reached\\n\");\n\t\texit(1);\n\t}\n\n\t// check file\n\tinvalid_filename(fname, 0); // no globbing\n\tif (strlen(fname) == 0 || is_dir(fname)) {\n\t\tfprintf(stderr, \"Error: invalid profile file\\n\");\n\t\texit(1);\n\t}\n\tif (access(fname, R_OK)) {\n\t\t// if the file ends in \".local\", do not exit\n\t\tconst char *base = gnu_basename(fname);\n\t\tchar *ptr = strstr(base, \".local\");\n\t\tif (ptr && strlen(ptr) == 6)\n\t\t\treturn;\n\n\t\tfprintf(stderr, \"Error: cannot access profile file: %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// allow debuggers\n\tif (arg_allow_debuggers) {\n\t\tchar *tmp = strrchr(fname, '/');\n\t\tif (tmp && *(tmp + 1) != '\\0') {\n\t\t\ttmp++;\n\t\t\tif (strcmp(tmp, \"disable-devel.inc\") == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// open profile file:\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"Error: cannot open profile file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// save the name of the file for --profile.print option\n\tif (include_level == 0)\n\t\tset_profile_run_file(getpid(), fname);\n\n\tint msg_printed = 0;\n\n\t// read the file line by line\n\tchar buf[MAX_READ + 1];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\t++lineno;\n\t\t// remove empty space - ptr in allocated memory\n\t\tchar *ptr = line_remove_spaces(buf);\n\t\tif (ptr == NULL)\n\t\t\tcontinue;\n\n\t\t// comments\n\t\tif (*ptr == '#' || *ptr == '\\0') {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process quiet\n\t\t// todo: a quiet in the profile file cannot be disabled by --ignore on command line\n\t\tif (strcmp(ptr, \"quiet\") == 0) {\n\t\t\tif (is_in_ignore_list(ptr))\n\t\t\t\targ_quiet = 0;\n\t\t\telse\n\t\t\t\targ_quiet = 1;\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!msg_printed) {\n\t\t\tfmessage(\"Reading profile %s\\n\", fname);\n\t\t\tmsg_printed = 1;\n\t\t}\n\n\t\t// process include\n\t\tif (strncmp(ptr, \"include \", 8) == 0) {\n\t\t\tinclude_level++;\n\n\t\t\t// expand macros in front of the include profile file\n\t\t\tchar *newprofile = expand_macros(ptr + 8);\n\n\t\t\tchar *ptr2 = newprofile;\n\t\t\twhile (*ptr2 != '/' && *ptr2 != '\\0')\n\t\t\t\tptr2++;\n\t\t\t// profile path contains no / chars, do a search\n\t\t\tif (*ptr2 == '\\0') {\n\t\t\t\tint rv = profile_find_firejail(newprofile, 0); // returns 1 if a profile was found in sysconfig directory\n\t\t\t\tif (!rv) {\n\t\t\t\t\t// maybe this is a file in the local working directory?\n\t\t\t\t\t// it will stop the sandbox if not!\n\t\t\t\t\t// Note: if the file ends in .local it will not stop the program\n\t\t\t\t\tprofile_read(newprofile);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprofile_read(newprofile);\n\t\t\t}\n\n\t\t\tinclude_level--;\n\t\t\tfree(newprofile);\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// verify syntax, exit in case of error\n\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\tprofile_add(ptr);\n// we cannot free ptr here, data is extracted from ptr and linked as a pointer in cfg structure\n//\t\telse {\n//\t\t\tfree(ptr);\n//\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t}\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&etcpname",
            "\"%s/%s\"",
            "dir",
            "name"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Found %s profile in %s directory\\n\"",
            "name",
            "dir"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ep->d_name",
            "name"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dp"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "dir"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "466-473",
          "snippet": "DIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_opendir_t orig_opendir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&pname",
            "\"%s.profile\"",
            "name"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nstatic int profile_find(const char *name, const char *dir, int add_ext) {\n\tEUID_ASSERT();\n\tassert(name);\n\tassert(dir);\n\n\tint rv = 0;\n\tDIR *dp;\n\tchar *pname = NULL;\n\tif (add_ext) {\n\t\tif (asprintf(&pname, \"%s.profile\", name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\telse\n\t\t\tname = pname;\n\t}\n\n\tdp = opendir (dir);\n\tif (dp != NULL) {\n\t\tstruct dirent *ep;\n\t\twhile ((ep = readdir(dp)) != NULL) {\n\t\t\tif (strcmp(ep->d_name, name) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s profile in %s directory\\n\", name, dir);\n\t\t\t\tchar *etcpname;\n\t\t\t\tif (asprintf(&etcpname, \"%s/%s\", dir, name) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprofile_read(etcpname);\n\t\t\t\tfree(etcpname);\n\t\t\t\trv = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t(void) closedir (dp);\n\t}\n\n\tif (pname)\n\t\tfree(pname);\n\treturn rv;\n}"
  }
]