[
  {
    "function_name": "enter_network_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "1305-1341",
    "snippet": "void enter_network_namespace(pid_t pid) {\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid_t child = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(child)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// check network namespace\n\tchar *name;\n\tif (asprintf(&name, \"/run/firejail/network/%d-netmap\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: the sandbox doesn't use a new network namespace\\n\");\n\t\texit(1);\n\t}\n\n\t// join the namespace\n\tEUID_ROOT();\n\tif (join_namespace(child, \"net\")) {\n\t\tfprintf(stderr, \"Error: cannot join the network namespace\\n\");\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot join the network namespace\\n\""
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "child",
            "\"net\""
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "join_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "36-59",
          "snippet": "int join_namespace(pid_t pid, char *type) {\n\tchar *path;\n\tif (asprintf(&path, \"/proc/%u/ns/%s\", pid, type) == -1)\n\t\terrExit(\"asprintf\");\n\n\tint fd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto errout;\n\n\tif (syscall(__NR_setns, fd, 0) < 0) {\n\t\tclose(fd);\n\t\tgoto errout;\n\t}\n\n\tclose(fd);\n\tfree(path);\n\treturn 0;\n\nerrout:\n\tfree(path);\n\tfprintf(stderr, \"Error: cannot join namespace %s\\\\n\", type);\n\treturn -1;\n\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nint join_namespace(pid_t pid, char *type) {\n\tchar *path;\n\tif (asprintf(&path, \"/proc/%u/ns/%s\", pid, type) == -1)\n\t\terrExit(\"asprintf\");\n\n\tint fd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto errout;\n\n\tif (syscall(__NR_setns, fd, 0) < 0) {\n\t\tclose(fd);\n\t\tgoto errout;\n\t}\n\n\tclose(fd);\n\tfree(path);\n\treturn 0;\n\nerrout:\n\tfree(path);\n\tfprintf(stderr, \"Error: cannot join namespace %s\\\\n\", type);\n\treturn -1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: the sandbox doesn't use a new network namespace\\n\""
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "name",
            "&s"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&name",
            "\"/run/firejail/network/%d-netmap\"",
            "pid"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: permission is denied to join a sandbox created by a different user.\\n\""
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_get_uid",
          "args": [
            "pid"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "pid_get_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "823-865",
          "snippet": "uid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 4;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\treturn rv;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nuid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 4;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no valid sandbox\\n\""
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_sandbox",
          "args": [
            "child"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "invalid_sandbox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1214-1272",
          "snippet": "int invalid_sandbox(const pid_t pid) {\n\t// check if a file \"ready-for-join\" exists\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_READY_FOR_JOIN) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tFILE *fp = fopen(fname, \"re\");\n\tEUID_USER();\n\tfree(fname);\n\tif (!fp)\n\t\treturn 1;\n\t// regular file owned by root\n\tint fd = fileno(fp);\n\tif (fd == -1)\n\t\terrExit(\"fileno\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != 0) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\t// check if it is non-empty\n\tchar buf[BUFLEN];\n\tif (fgets(buf, BUFLEN, fp) == NULL) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\tfclose(fp);\n\t// confirm \"ready\" string was written\n\tif (strncmp(buf, \"ready\\n\", 6) != 0)\n\t\treturn 1;\n\n\t// walk down the process tree a few nodes, there should be no firejail leaf\n#define MAXNODES 5\n\tpid_t current = pid, next;\n\tint i;\n\tfor (i = 0; i < MAXNODES; i++) {\n\t\tif (find_child(current, &next) == 1) {\n\t\t\t// found a leaf\n\t\t\tEUID_ROOT();\n\t\t\tchar *comm = pid_proc_comm(current);\n\t\t\tEUID_USER();\n\t\t\tif (!comm) {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\t\tfree(comm);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXNODES 5",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define MAXNODES 5\n#define BUFLEN 4096\n\nint invalid_sandbox(const pid_t pid) {\n\t// check if a file \"ready-for-join\" exists\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_READY_FOR_JOIN) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tFILE *fp = fopen(fname, \"re\");\n\tEUID_USER();\n\tfree(fname);\n\tif (!fp)\n\t\treturn 1;\n\t// regular file owned by root\n\tint fd = fileno(fp);\n\tif (fd == -1)\n\t\terrExit(\"fileno\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != 0) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\t// check if it is non-empty\n\tchar buf[BUFLEN];\n\tif (fgets(buf, BUFLEN, fp) == NULL) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\tfclose(fp);\n\t// confirm \"ready\" string was written\n\tif (strncmp(buf, \"ready\\n\", 6) != 0)\n\t\treturn 1;\n\n\t// walk down the process tree a few nodes, there should be no firejail leaf\n#define MAXNODES 5\n\tpid_t current = pid, next;\n\tint i;\n\tfor (i = 0; i < MAXNODES; i++) {\n\t\tif (find_child(current, &next) == 1) {\n\t\t\t// found a leaf\n\t\t\tEUID_ROOT();\n\t\t\tchar *comm = pid_proc_comm(current);\n\t\t\tEUID_USER();\n\t\t\tif (!comm) {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\t\tfree(comm);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "switch_to_child",
          "args": [
            "pid"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "switch_to_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "258-284",
          "snippet": "pid_t switch_to_child(pid_t pid) {\n\tEUID_ROOT();\n\terrno = 0;\n\tchar *comm = pid_proc_comm(pid);\n\tif (!comm) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Error: cannot find process with pid %d\\n\", pid);\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tEUID_USER();\n\tif (strcmp(comm, \"firejail\") == 0) {\n\t\tpid_t child;\n\t\tif (find_child(pid, &child) == 1) {\n\t\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfmessage(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) child);\n\t\tpid = child;\n\t}\n\tfree(comm);\n\treturn pid;\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\npid_t switch_to_child(pid_t pid) {\n\tEUID_ROOT();\n\terrno = 0;\n\tchar *comm = pid_proc_comm(pid);\n\tif (!comm) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Error: cannot find process with pid %d\\n\", pid);\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tEUID_USER();\n\tif (strcmp(comm, \"firejail\") == 0) {\n\t\tpid_t child;\n\t\tif (find_child(pid, &child) == 1) {\n\t\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfmessage(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) child);\n\t\tpid = child;\n\t}\n\tfree(comm);\n\treturn pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid enter_network_namespace(pid_t pid) {\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid_t child = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(child)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// check network namespace\n\tchar *name;\n\tif (asprintf(&name, \"/run/firejail/network/%d-netmap\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: the sandbox doesn't use a new network namespace\\n\");\n\t\texit(1);\n\t}\n\n\t// join the namespace\n\tEUID_ROOT();\n\tif (join_namespace(child, \"net\")) {\n\t\tfprintf(stderr, \"Error: cannot join the network namespace\\n\");\n\t\texit(1);\n\t}\n}"
  },
  {
    "function_name": "has_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "1274-1303",
    "snippet": "int has_handler(pid_t pid, int signal) {\n\tif (signal > 0 && signal <= SIGRTMAX) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tEUID_ROOT();\n\t\tFILE *fp = fopen(fname, \"re\");\n\t\tEUID_USER();\n\t\tfree(fname);\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\twhile (fgets(buf, BUFLEN, fp)) {\n\t\t\t\tif (strncmp(buf, \"SigCgt:\", 7) == 0) {\n\t\t\t\t\tchar *ptr = buf + 7;\n\t\t\t\t\tunsigned long long val;\n\t\t\t\t\tif (sscanf(ptr, \"%llx\", &val) != 1) {\n\t\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tval >>= (signal - 1);\n\t\t\t\t\tval &= 1;\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\treturn val;  // 1 if process has a handler for the signal, else 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define BUFLEN 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot read /proc file\\n\""
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%llx\"",
            "&val"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"SigCgt:\"",
            "7"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "BUFLEN",
            "fp"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"re\""
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/status\"",
            "pid"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nint has_handler(pid_t pid, int signal) {\n\tif (signal > 0 && signal <= SIGRTMAX) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tEUID_ROOT();\n\t\tFILE *fp = fopen(fname, \"re\");\n\t\tEUID_USER();\n\t\tfree(fname);\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\twhile (fgets(buf, BUFLEN, fp)) {\n\t\t\t\tif (strncmp(buf, \"SigCgt:\", 7) == 0) {\n\t\t\t\t\tchar *ptr = buf + 7;\n\t\t\t\t\tunsigned long long val;\n\t\t\t\t\tif (sscanf(ptr, \"%llx\", &val) != 1) {\n\t\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tval >>= (signal - 1);\n\t\t\t\t\tval &= 1;\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\treturn val;  // 1 if process has a handler for the signal, else 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "invalid_sandbox",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "1214-1272",
    "snippet": "int invalid_sandbox(const pid_t pid) {\n\t// check if a file \"ready-for-join\" exists\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_READY_FOR_JOIN) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tFILE *fp = fopen(fname, \"re\");\n\tEUID_USER();\n\tfree(fname);\n\tif (!fp)\n\t\treturn 1;\n\t// regular file owned by root\n\tint fd = fileno(fp);\n\tif (fd == -1)\n\t\terrExit(\"fileno\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != 0) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\t// check if it is non-empty\n\tchar buf[BUFLEN];\n\tif (fgets(buf, BUFLEN, fp) == NULL) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\tfclose(fp);\n\t// confirm \"ready\" string was written\n\tif (strncmp(buf, \"ready\\n\", 6) != 0)\n\t\treturn 1;\n\n\t// walk down the process tree a few nodes, there should be no firejail leaf\n#define MAXNODES 5\n\tpid_t current = pid, next;\n\tint i;\n\tfor (i = 0; i < MAXNODES; i++) {\n\t\tif (find_child(current, &next) == 1) {\n\t\t\t// found a leaf\n\t\t\tEUID_ROOT();\n\t\t\tchar *comm = pid_proc_comm(current);\n\t\t\tEUID_USER();\n\t\t\tif (!comm) {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\t\tfree(comm);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = next;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAXNODES 5",
      "#define BUFLEN 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comm"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comm"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "comm",
            "\"firejail\""
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot read /proc file\\n\""
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_proc_comm",
          "args": [
            "current"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "pid_proc_comm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "128-164",
          "snippet": "char *pid_proc_comm(const pid_t pid) {\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/comm\", pid) == -1)\n\t\treturn NULL;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn NULL;\n\t}\n\tfree(fname);\n\n\t// read file\n\tchar buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// remove \\n\n\tchar *ptr = strchr(buffer, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\t// return a malloc copy of the command line\n\tchar *rv = strdup(buffer);\n\tif (!rv)\n\t\treturn NULL;\n\tif (strlen(rv) == 0) {\n\t\tfree(rv);\n\t\treturn NULL;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define BUFLEN 4096",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define BUFLEN 4096\n#define BUFLEN 4096\n\nchar *pid_proc_comm(const pid_t pid) {\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/comm\", pid) == -1)\n\t\treturn NULL;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn NULL;\n\t}\n\tfree(fname);\n\n\t// read file\n\tchar buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// remove \\n\n\tchar *ptr = strchr(buffer, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\t// return a malloc copy of the command line\n\tchar *rv = strdup(buffer);\n\tif (!rv)\n\t\treturn NULL;\n\tif (strlen(rv) == 0) {\n\t\tfree(rv);\n\t\treturn NULL;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_child",
          "args": [
            "current",
            "&next"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "600-659",
          "snippet": "int find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nint find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"ready\\n\"",
            "6"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "BUFLEN",
            "fp"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "s.st_mode"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&s"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fileno\""
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "fp"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"re\""
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/root%s\"",
            "pid",
            "RUN_READY_FOR_JOIN"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define MAXNODES 5\n#define BUFLEN 4096\n\nint invalid_sandbox(const pid_t pid) {\n\t// check if a file \"ready-for-join\" exists\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_READY_FOR_JOIN) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tFILE *fp = fopen(fname, \"re\");\n\tEUID_USER();\n\tfree(fname);\n\tif (!fp)\n\t\treturn 1;\n\t// regular file owned by root\n\tint fd = fileno(fp);\n\tif (fd == -1)\n\t\terrExit(\"fileno\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != 0) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\t// check if it is non-empty\n\tchar buf[BUFLEN];\n\tif (fgets(buf, BUFLEN, fp) == NULL) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\tfclose(fp);\n\t// confirm \"ready\" string was written\n\tif (strncmp(buf, \"ready\\n\", 6) != 0)\n\t\treturn 1;\n\n\t// walk down the process tree a few nodes, there should be no firejail leaf\n#define MAXNODES 5\n\tpid_t current = pid, next;\n\tint i;\n\tfor (i = 0; i < MAXNODES; i++) {\n\t\tif (find_child(current, &next) == 1) {\n\t\t\t// found a leaf\n\t\t\tEUID_ROOT();\n\t\t\tchar *comm = pid_proc_comm(current);\n\t\t\tEUID_USER();\n\t\t\tif (!comm) {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\t\tfree(comm);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = next;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "safe_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "1143-1209",
    "snippet": "int safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define EMPTY_STRING (\"\")"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open \\\"%s\\\", invalid filename\\n\"",
            "path"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dup"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "parentfd"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "parentfd",
            "current_tok",
            "flags|O_NOFOLLOW"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"/\""
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dup"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "parentfd",
            "current_tok",
            "flags|O_NOFOLLOW"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"/\""
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "parentfd",
            "tok",
            "O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tok"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "dup",
            "\"/\""
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"open\""
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/\"",
            "O_PATH|O_DIRECTORY|O_CLOEXEC"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "p"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "path",
            "'/'"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "path",
            "\"..\""
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nint safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}"
  },
  {
    "function_name": "disable_file_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "1129-1139",
    "snippet": "void disable_file_path(const char *path, const char *file) {\n\tassert(file);\n\tassert(path);\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%s\", path, file) == -1)\n\t\terrExit(\"asprintf\");\n\n\tdisable_file_or_dir(fname);\n\tfree(fname);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_file_or_dir",
          "args": [
            "fname"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "disable_file_or_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1112-1127",
          "snippet": "void disable_file_or_dir(const char *fname) {\n\tif (arg_debug)\n\t\tprintf(\"blacklist %s\\n\", fname);\n\tstruct stat s;\n\tif (stat(fname, &s) != -1) {\n\t\tif (is_dir(fname)) {\n\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\terrExit(\"disable directory\");\n\t\t}\n\t\telse {\n\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\terrExit(\"disable file\");\n\t\t}\n\t}\n\tfs_logger2(\"blacklist\", fname);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid disable_file_or_dir(const char *fname) {\n\tif (arg_debug)\n\t\tprintf(\"blacklist %s\\n\", fname);\n\tstruct stat s;\n\tif (stat(fname, &s) != -1) {\n\t\tif (is_dir(fname)) {\n\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\terrExit(\"disable directory\");\n\t\t}\n\t\telse {\n\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\terrExit(\"disable file\");\n\t\t}\n\t}\n\tfs_logger2(\"blacklist\", fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/%s\"",
            "path",
            "file"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "file"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid disable_file_path(const char *path, const char *file) {\n\tassert(file);\n\tassert(path);\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%s\", path, file) == -1)\n\t\terrExit(\"asprintf\");\n\n\tdisable_file_or_dir(fname);\n\tfree(fname);\n}"
  },
  {
    "function_name": "disable_file_or_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "1112-1127",
    "snippet": "void disable_file_or_dir(const char *fname) {\n\tif (arg_debug)\n\t\tprintf(\"blacklist %s\\n\", fname);\n\tstruct stat s;\n\tif (stat(fname, &s) != -1) {\n\t\tif (is_dir(fname)) {\n\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\terrExit(\"disable directory\");\n\t\t}\n\t\telse {\n\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\terrExit(\"disable file\");\n\t\t}\n\t}\n\tfs_logger2(\"blacklist\", fname);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"blacklist\"",
            "fname"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"disable file\""
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_FILE",
            "fname",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"disable directory\""
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_DIR",
            "fname",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dir",
          "args": [
            "fname"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "401-428",
          "snippet": "int is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"blacklist %s\\n\"",
            "fname"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid disable_file_or_dir(const char *fname) {\n\tif (arg_debug)\n\t\tprintf(\"blacklist %s\\n\", fname);\n\tstruct stat s;\n\tif (stat(fname, &s) != -1) {\n\t\tif (is_dir(fname)) {\n\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\terrExit(\"disable directory\");\n\t\t}\n\t\telse {\n\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\terrExit(\"disable file\");\n\t\t}\n\t}\n\tfs_logger2(\"blacklist\", fname);\n}"
  },
  {
    "function_name": "extract_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "1094-1110",
    "snippet": "unsigned extract_timeout(const char *str) {\n\tunsigned s;\n\tunsigned m;\n\tunsigned h;\n\tint rv = sscanf(str, \"%02u:%02u:%02u\", &h, &m, &s);\n\tif (rv != 3) {\n\t\tfprintf(stderr, \"Error: invalid timeout, please use a hh:mm:ss format\\n\");\n\t\texit(1);\n\t}\n\tunsigned timeout = h * 3600 + m * 60 + s;\n\tif (timeout == 0) {\n\t\tfprintf(stderr, \"Error: invalid timeout\\n\");\n\t\texit(1);\n\t}\n\n\treturn timeout;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid timeout\\n\""
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid timeout, please use a hh:mm:ss format\\n\""
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%02u:%02u:%02u\"",
            "&h",
            "&m",
            "&s"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nunsigned extract_timeout(const char *str) {\n\tunsigned s;\n\tunsigned m;\n\tunsigned h;\n\tint rv = sscanf(str, \"%02u:%02u:%02u\", &h, &m, &s);\n\tif (rv != 3) {\n\t\tfprintf(stderr, \"Error: invalid timeout, please use a hh:mm:ss format\\n\");\n\t\texit(1);\n\t}\n\tunsigned timeout = h * 3600 + m * 60 + s;\n\tif (timeout == 0) {\n\t\tfprintf(stderr, \"Error: invalid timeout\\n\");\n\t\texit(1);\n\t}\n\n\treturn timeout;\n}"
  },
  {
    "function_name": "mkdir_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "1056-1092",
    "snippet": "void mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid) {\n\tassert(fname);\n\tmode &= 07777;\n#if 0\n\tprintf(\"fname %s, uid %d, gid %d, mode %x - \", fname, uid, gid, (unsigned) mode);\n\tif (S_ISLNK(mode))\n\t\tprintf(\"l\");\n\telse if (S_ISDIR(mode))\n\t\tprintf(\"d\");\n\telse if (S_ISCHR(mode))\n\t\tprintf(\"c\");\n\telse if (S_ISBLK(mode))\n\t\tprintf(\"b\");\n\telse if (S_ISSOCK(mode))\n\t\tprintf(\"s\");\n\telse\n\t\tprintf(\"-\");\n\tprintf( (mode & S_IRUSR) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWUSR) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXUSR) ? \"x\" : \"-\");\n\tprintf( (mode & S_IRGRP) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWGRP) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXGRP) ? \"x\" : \"-\");\n\tprintf( (mode & S_IROTH) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWOTH) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXOTH) ? \"x\" : \"-\");\n\tprintf(\"\\n\");\n#endif\n\tif (mkdir(fname, mode) == -1 ||\n\t    chmod(fname, mode) == -1 ||\n\t    chown(fname, uid, gid)) {\n\t    \tfprintf(stderr, \"Error: failed to create %s directory\\n\", fname);\n\t\terrExit(\"mkdir/chmod\");\n\t}\n\n\tASSERT_PERMS(fname, uid, gid, mode);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "fname",
            "uid",
            "gid",
            "mode"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir/chmod\""
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: failed to create %s directory\\n\"",
            "fname"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "fname",
            "uid",
            "gid"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "fname",
            "mode"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "fname",
            "mode"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "382-389",
          "snippet": "int mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdir_t orig_mkdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "(mode & S_IXOTH) ? \"x\" : \"-\""
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "(mode & S_IWOTH) ? \"w\" : \"-\""
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "(mode & S_IROTH) ? \"r\" : \"-\""
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "(mode & S_IXGRP) ? \"x\" : \"-\""
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "(mode & S_IWGRP) ? \"w\" : \"-\""
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "(mode & S_IRGRP) ? \"r\" : \"-\""
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "(mode & S_IXUSR) ? \"x\" : \"-\""
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "(mode & S_IWUSR) ? \"w\" : \"-\""
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "(mode & S_IRUSR) ? \"r\" : \"-\""
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"-\""
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"s\""
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "mode"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"b\""
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"c\""
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"d\""
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"l\""
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"fname %s, uid %d, gid %d, mode %x - \"",
            "fname",
            "uid",
            "gid",
            "(unsigned) mode"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid) {\n\tassert(fname);\n\tmode &= 07777;\n#if 0\n\tprintf(\"fname %s, uid %d, gid %d, mode %x - \", fname, uid, gid, (unsigned) mode);\n\tif (S_ISLNK(mode))\n\t\tprintf(\"l\");\n\telse if (S_ISDIR(mode))\n\t\tprintf(\"d\");\n\telse if (S_ISCHR(mode))\n\t\tprintf(\"c\");\n\telse if (S_ISBLK(mode))\n\t\tprintf(\"b\");\n\telse if (S_ISSOCK(mode))\n\t\tprintf(\"s\");\n\telse\n\t\tprintf(\"-\");\n\tprintf( (mode & S_IRUSR) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWUSR) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXUSR) ? \"x\" : \"-\");\n\tprintf( (mode & S_IRGRP) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWGRP) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXGRP) ? \"x\" : \"-\");\n\tprintf( (mode & S_IROTH) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWOTH) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXOTH) ? \"x\" : \"-\");\n\tprintf(\"\\n\");\n#endif\n\tif (mkdir(fname, mode) == -1 ||\n\t    chmod(fname, mode) == -1 ||\n\t    chown(fname, uid, gid)) {\n\t    \tfprintf(stderr, \"Error: failed to create %s directory\\n\", fname);\n\t\terrExit(\"mkdir/chmod\");\n\t}\n\n\tASSERT_PERMS(fname, uid, gid, mode);\n}"
  },
  {
    "function_name": "set_perms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "1047-1054",
    "snippet": "int set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "fname",
            "uid",
            "gid"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "fname",
            "mode"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "create_empty_file_as_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "1028-1044",
    "snippet": "void create_empty_file_as_root(const char *fname, mode_t mode) {\n\tassert(fname);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(fname, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s file\\n\", fname);\n\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(fname, \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, mode);\n\t\tfclose(fp);\n\t}\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "0",
            "0",
            "mode"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fopen\""
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"w\""
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Creating empty %s file\\n\"",
            "fname"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid create_empty_file_as_root(const char *fname, mode_t mode) {\n\tassert(fname);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(fname, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s file\\n\", fname);\n\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(fname, \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, mode);\n\t\tfclose(fp);\n\t}\n}"
  },
  {
    "function_name": "create_empty_dir_as_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "1009-1026",
    "snippet": "void create_empty_dir_as_root(const char *dir, mode_t mode) {\n\tassert(dir);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(dir, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s directory\\n\", dir);\n\t\t/* coverity[toctou] */\n\t\t// don't fail if directory already exists. This can be the case in a race\n\t\t// condition, when two jails launch at the same time. See #1013\n\t\tif (mkdir(dir, mode) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tif (set_perms(dir, 0, 0, mode))\n\t\t\terrExit(\"set_perms\");\n\t\tASSERT_PERMS(dir, 0, 0, mode);\n\t}\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "dir",
            "0",
            "0",
            "mode"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"set_perms\""
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_perms",
          "args": [
            "dir",
            "0",
            "0",
            "mode"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "set_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1047-1054",
          "snippet": "int set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "dir",
            "mode"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "382-389",
          "snippet": "int mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdir_t orig_mkdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Creating empty %s directory\\n\"",
            "dir"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir",
            "&s"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid create_empty_dir_as_root(const char *dir, mode_t mode) {\n\tassert(dir);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(dir, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s directory\\n\", dir);\n\t\t/* coverity[toctou] */\n\t\t// don't fail if directory already exists. This can be the case in a race\n\t\t// condition, when two jails launch at the same time. See #1013\n\t\tif (mkdir(dir, mode) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tif (set_perms(dir, 0, 0, mode))\n\t\t\terrExit(\"set_perms\");\n\t\tASSERT_PERMS(dir, 0, 0, mode);\n\t}\n}"
  },
  {
    "function_name": "create_empty_dir_as_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "972-1007",
    "snippet": "int create_empty_dir_as_user(const char *dir, mode_t mode) {\n\tassert(dir);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(dir, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s directory\\n\", dir);\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\n\t\t\tif (mkdir(dir, mode) == 0) {\n\t\t\t\tif (chmod(dir, mode) == -1)\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\telse if (arg_debug) {\n\t\t\t\tchar *str;\n\t\t\t\tif (asprintf(&str, \"Directory %s not created\", dir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tperror(str);\n\t\t\t}\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\twaitpid(child, NULL, 0);\n\t\tif (stat(dir, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir",
            "&s"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "0"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gcov_flush",
          "args": [],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "str"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&str",
            "\"Directory %s not created\"",
            "dir"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "dir",
            "mode"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "dir",
            "mode"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "382-389",
          "snippet": "int mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdir_t orig_mkdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "0"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "121-142",
          "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Creating empty %s directory\\n\"",
            "dir"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint create_empty_dir_as_user(const char *dir, mode_t mode) {\n\tassert(dir);\n\tmode &= 07777;\n\tstruct stat s;\n\n\tif (stat(dir, &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating empty %s directory\\n\", dir);\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\n\t\t\tif (mkdir(dir, mode) == 0) {\n\t\t\t\tif (chmod(dir, mode) == -1)\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\telse if (arg_debug) {\n\t\t\t\tchar *str;\n\t\t\t\tif (asprintf(&str, \"Directory %s not created\", dir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tperror(str);\n\t\t\t}\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\twaitpid(child, NULL, 0);\n\t\tif (stat(dir, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "flush_stdin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "959-969",
    "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "STDIN_FILENO",
            "TCFLSH",
            "TCIFLUSH"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"removing %d bytes from stdin\\n\"",
            "cnt"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "STDIN_FILENO",
            "FIONREAD",
            "&cnt"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "remove_overlay_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "900-957",
    "snippet": "int remove_overlay_directory(void) {\n\tEUID_ASSERT();\n\tstruct stat s;\n\tsleep(1);\n\n\tchar *path;\n\tif (asprintf(&path, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (lstat(path, &s) == 0) {\n\t\t// deal with obvious problems such as symlinks and root ownership\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", path);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", path);\n\t\t\texit(1);\n\t\t}\n\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// open ~/.firejail, fails if there is any symlink\n\t\t\tint fd = safe_fd(path, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\t\tif (fd == -1)\n\t\t\t\terrExit(\"safe_fd\");\n\t\t\t// chdir to ~/.firejail\n\t\t\tif (fchdir(fd) == -1)\n\t\t\t\terrExit(\"fchdir\");\n\t\t\tclose(fd);\n\n\t\t\tEUID_ROOT();\n\t\t\t// FTW_PHYS - do not follow symbolic links\n\t\t\tif (nftw(\".\", remove_callback, 64, FTW_DEPTH | FTW_PHYS) == -1)\n\t\t\t\terrExit(\"nftw\");\n\n\t\t\tEUID_USER();\n\t\t\t// remove ~/.firejail\n\t\t\tif (rmdir(path) == -1)\n\t\t\t\terrExit(\"rmdir\");\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t\t// check if ~/.firejail was deleted\n\t\tif (stat(path, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&s"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "0"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gcov_flush",
          "args": [],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"rmdir\""
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "path"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "404-411",
          "snippet": "int rmdir(const char *pathname) {\n\tif (!orig_rmdir)\n\t\torig_rmdir = (orig_rmdir_t)dlsym(RTLD_NEXT, \"rmdir\");\n\n\tint rv = orig_rmdir(pathname);\n\tprintf(\"%u:%s:rmdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_rmdir_t orig_rmdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_rmdir_t orig_rmdir = NULL;\n\nint rmdir(const char *pathname) {\n\tif (!orig_rmdir)\n\t\torig_rmdir = (orig_rmdir_t)dlsym(RTLD_NEXT, \"rmdir\");\n\n\tint rv = orig_rmdir(pathname);\n\tprintf(\"%u:%s:rmdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"nftw\""
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nftw",
          "args": [
            "\".\"",
            "remove_callback",
            "64",
            "FTW_DEPTH | FTW_PHYS"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fchdir\""
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "fd"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "fchdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "684-708",
          "snippet": "int fchdir(int fd) {\n#ifdef DEBUG\n\tprintf(\"%s %d\\n\", __FUNCTION__, fd);\n#endif\n\tif (!orig_fchdir)\n\t\torig_fchdir = (orig_fchdir_t)dlsym(RTLD_NEXT, \"fchdir\");\n\n\tfree(cwd);\n\tchar *pathname=malloc(PATH_MAX);\n\tif (pathname) {\n\t\tif (snprintf(pathname,PATH_MAX,\"/proc/self/fd/%d\", fd)>0) {\n\t\t\tcwd = realpath(pathname, NULL);\n\t\t} else {\n\t\t\tcwd = NULL;\n\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t}\n\t\tfree(pathname);\n\t} else {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tcwd = NULL;\n\t}\n\n\tint rv = orig_fchdir(fd);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char* cwd = NULL;",
            "static orig_fchdir_t orig_fchdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char* cwd = NULL;\nstatic orig_fchdir_t orig_fchdir = NULL;\n\nint fchdir(int fd) {\n#ifdef DEBUG\n\tprintf(\"%s %d\\n\", __FUNCTION__, fd);\n#endif\n\tif (!orig_fchdir)\n\t\torig_fchdir = (orig_fchdir_t)dlsym(RTLD_NEXT, \"fchdir\");\n\n\tfree(cwd);\n\tchar *pathname=malloc(PATH_MAX);\n\tif (pathname) {\n\t\tif (snprintf(pathname,PATH_MAX,\"/proc/self/fd/%d\", fd)>0) {\n\t\t\tcwd = realpath(pathname, NULL);\n\t\t} else {\n\t\t\tcwd = NULL;\n\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t}\n\t\tfree(pathname);\n\t} else {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tcwd = NULL;\n\t}\n\n\tint rv = orig_fchdir(fd);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"safe_fd\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_fd",
          "args": [
            "path",
            "O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "safe_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1143-1209",
          "snippet": "int safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define EMPTY_STRING (\"\")"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nint safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is not owned by the current user\\n\"",
            "path"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is not a directory\\n\"",
            "path"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is a symbolic link\\n\"",
            "path"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "s.st_mode"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&path",
            "\"%s/.firejail\"",
            "cfg.homedir"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "firemon_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "90-121",
          "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios tlocal;",
            "static struct termios twait;",
            "static int terminal_set = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint remove_overlay_directory(void) {\n\tEUID_ASSERT();\n\tstruct stat s;\n\tsleep(1);\n\n\tchar *path;\n\tif (asprintf(&path, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (lstat(path, &s) == 0) {\n\t\t// deal with obvious problems such as symlinks and root ownership\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", path);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", path);\n\t\t\texit(1);\n\t\t}\n\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// open ~/.firejail, fails if there is any symlink\n\t\t\tint fd = safe_fd(path, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\t\tif (fd == -1)\n\t\t\t\terrExit(\"safe_fd\");\n\t\t\t// chdir to ~/.firejail\n\t\t\tif (fchdir(fd) == -1)\n\t\t\t\terrExit(\"fchdir\");\n\t\t\tclose(fd);\n\n\t\t\tEUID_ROOT();\n\t\t\t// FTW_PHYS - do not follow symbolic links\n\t\t\tif (nftw(\".\", remove_callback, 64, FTW_DEPTH | FTW_PHYS) == -1)\n\t\t\t\terrExit(\"nftw\");\n\n\t\t\tEUID_USER();\n\t\t\t// remove ~/.firejail\n\t\t\tif (rmdir(path) == -1)\n\t\t\t\terrExit(\"rmdir\");\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t\t// check if ~/.firejail was deleted\n\t\tif (stat(path, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "remove_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "881-897",
    "snippet": "static int remove_callback(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf) {\n\t(void) sb;\n\t(void) typeflag;\n\t(void) ftwbuf;\n\tassert(fpath);\n\n\tif (strcmp(fpath, \".\") == 0)\n\t\treturn 0;\n\n\tif (remove(fpath)) {\t// removes the link not the actual file\n\t\tperror(\"remove\");\n\t\tfprintf(stderr, \"Error: cannot remove file from user .firejail directory: %s\\n\", fpath);\n\t\texit(1);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot remove file from user .firejail directory: %s\\n\"",
            "fpath"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"remove\""
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "fpath"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "line_remove_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "480-529",
          "snippet": "char *line_remove_spaces(const char *buf) {\n\tEUID_ASSERT();\n\tassert(buf);\n\tsize_t len = strlen(buf);\n\tif (len == 0)\n\t\treturn NULL;\n\tassert(len + 1 != 0 && buf[len] == '\\0');\n\n\t// allocate memory for the new string\n\tchar *rv = malloc(len + 1);\n\tif (rv == NULL)\n\t\terrExit(\"malloc\");\n\n\t// remove space at start of line\n\tconst char *ptr1 = buf;\n\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\tptr1++;\n\n\t// copy data and remove additional spaces\n\tchar *ptr2 = rv;\n\tint state = 0;\n\twhile (*ptr1 != '\\0') {\n\t\tif (*ptr1 == '\\n' || *ptr1 == '\\r')\n\t\t\tbreak;\n\n\t\tif (state == 0) {\n\t\t\tif (*ptr1 != ' ' && *ptr1 != '\\t')\n\t\t\t\t*ptr2++ = *ptr1++;\n\t\t\telse {\n\t\t\t\t*ptr2++ = ' ';\n\t\t\t\tptr1++;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t  // state == 1\n\t\t\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\t\t\tptr1++;\n\t\t\tstate = 0;\n\t\t}\n\t}\n\n\t// strip last blank character if any\n\tif (ptr2 > rv && *(ptr2 - 1) == ' ')\n\t\t--ptr2;\n\t*ptr2 = '\\0';\n\t//\tif (arg_debug)\n\t//\t\tprintf(\"Processing line #%s#\\n\", rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *line_remove_spaces(const char *buf) {\n\tEUID_ASSERT();\n\tassert(buf);\n\tsize_t len = strlen(buf);\n\tif (len == 0)\n\t\treturn NULL;\n\tassert(len + 1 != 0 && buf[len] == '\\0');\n\n\t// allocate memory for the new string\n\tchar *rv = malloc(len + 1);\n\tif (rv == NULL)\n\t\terrExit(\"malloc\");\n\n\t// remove space at start of line\n\tconst char *ptr1 = buf;\n\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\tptr1++;\n\n\t// copy data and remove additional spaces\n\tchar *ptr2 = rv;\n\tint state = 0;\n\twhile (*ptr1 != '\\0') {\n\t\tif (*ptr1 == '\\n' || *ptr1 == '\\r')\n\t\t\tbreak;\n\n\t\tif (state == 0) {\n\t\t\tif (*ptr1 != ' ' && *ptr1 != '\\t')\n\t\t\t\t*ptr2++ = *ptr1++;\n\t\t\telse {\n\t\t\t\t*ptr2++ = ' ';\n\t\t\t\tptr1++;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t  // state == 1\n\t\t\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\t\t\tptr1++;\n\t\t\tstate = 0;\n\t\t}\n\t}\n\n\t// strip last blank character if any\n\tif (ptr2 > rv && *(ptr2 - 1) == ' ')\n\t\t--ptr2;\n\t*ptr2 = '\\0';\n\t//\tif (arg_debug)\n\t//\t\tprintf(\"Processing line #%s#\\n\", rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fpath",
            "\".\""
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fpath"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nstatic int remove_callback(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf) {\n\t(void) sb;\n\t(void) typeflag;\n\t(void) ftwbuf;\n\tassert(fpath);\n\n\tif (strcmp(fpath, \".\") == 0)\n\t\treturn 0;\n\n\tif (remove(fpath)) {\t// removes the link not the actual file\n\t\tperror(\"remove\");\n\t\tfprintf(stderr, \"Error: cannot remove file from user .firejail directory: %s\\n\", fpath);\n\t\texit(1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_group_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "870-878",
    "snippet": "uid_t get_group_id(const char *group) {\n\t// find tty group id\n\tgid_t gid = 0;\n\tstruct group *g = getgrnam(group);\n\tif (g)\n\t\tgid = g->gr_gid;\n\n\treturn gid;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getgrnam",
          "args": [
            "group"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nuid_t get_group_id(const char *group) {\n\t// find tty group id\n\tgid_t gid = 0;\n\tstruct group *g = getgrnam(group);\n\tif (g)\n\t\tgid = g->gr_gid;\n\n\treturn gid;\n}"
  },
  {
    "function_name": "pid_get_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "823-865",
    "snippet": "uid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 4;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\treturn rv;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "ptr"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot read /proc file\\n\""
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"Uid:\"",
            "4"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "PIDS_BUFLEN - 1",
            "fp"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open /proc file\\n\""
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"asprintf\""
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&file",
            "\"/proc/%u/status\"",
            "pid"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nuid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 4;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\treturn rv;\n}"
  },
  {
    "function_name": "gnu_basename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "815-820",
    "snippet": "const char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "path",
            "'/'"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nconst char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}"
  },
  {
    "function_name": "notify_other",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "798-807",
    "snippet": "void notify_other(int fd) {\n\tFILE* stream;\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tstream = fdopen(newfd, \"w\");\n\tfprintf(stream, \"arg_noroot=%d\\n\", arg_noroot);\n\tfflush(stream);\n\tfclose(stream);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "stream"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stream"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stream",
            "\"arg_noroot=%d\\n\"",
            "arg_noroot"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "newfd",
            "\"w\""
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"dup\""
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "fd"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "duplicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_bin.c",
          "lines": "151-220",
          "snippet": "static void duplicate(char *fname) {\n\tassert(fname);\n\n\tif (*fname == '~' || strstr(fname, \"..\")) {\n\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", fname);\n\t\texit(1);\n\t}\n\tinvalid_filename(fname, 0); // no globbing\n\n\tchar *full_path;\n\tif (*fname == '/') {\n\t\t// If the absolute filename is indicated, directly use it. This\n\t\t// is required for the following cases:\n\t\t//  - if user's $PATH order is not the same as the above\n\t\t//    paths[] variable order\n\t\tif (!valid_full_path_file(fname)) {\n\t\t\tfwarning(\"invalid private-bin path %s\\n\", fname);\n\t\t\treturn;\n\t\t}\n\n\t\tfull_path = strdup(fname);\n\t\tif (!full_path)\n\t\t\terrExit(\"strdup\");\n\t}\n\telse {\n\t\t// Find the standard directory (by looping through paths[])\n\t\t// where the filename fname is located\n\t\tchar *path = check_dir_or_file(fname);\n\t\tif (!path)\n\t\t\treturn;\n\t\tif (asprintf(&full_path, \"%s/%s\", path, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\n\t// add to private-lib list\n\tif (cfg.bin_private_lib == NULL) {\n\t\tif (asprintf(&cfg.bin_private_lib, \"%s,%s\",fname, full_path) == -1)\n\t\t\terrExit(\"asprinf\");\n\t}\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s,%s,%s\", cfg.bin_private_lib, fname, full_path) == -1)\n\t\t\terrExit(\"asprinf\");\n\t\tfree(cfg.bin_private_lib);\n\t\tcfg.bin_private_lib = tmp;\n\t}\n\n\t// if full_path is symlink, and the link is in our path, copy both the file and the symlink\n\tif (is_link(full_path)) {\n\t\tchar *actual_path = realpath(full_path, NULL);\n\t\tif (actual_path) {\n\t\t\tif (valid_full_path_file(actual_path)) {\n\t\t\t\t// solving problems such as /bin/sh -> /bin/dash\n\t\t\t\t// copy the real file pointed by symlink\n\t\t\t\tsbox_run(SBOX_ROOT| SBOX_SECCOMP, 3, PATH_FCOPY, actual_path, RUN_BIN_DIR);\n\t\t\t\tprog_cnt++;\n\t\t\t\tchar *f = strrchr(actual_path, '/');\n\t\t\t\tif (f && *(++f) !='\\0')\n\t\t\t\t\treport_duplication(f);\n\t\t\t}\n\t\t\tfree(actual_path);\n\t\t}\n\t}\n\n\t// copy a file or a symlink\n\tsbox_run(SBOX_ROOT| SBOX_SECCOMP, 3, PATH_FCOPY, full_path, RUN_BIN_DIR);\n\tprog_cnt++;\n\tfree(full_path);\n\treport_duplication(fname);\n}",
          "includes": [
            "#include <glob.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int prog_cnt = 0;",
            "static char *paths[] = {\n\t\"/usr/local/bin\",\n\t\"/usr/bin\",\n\t\"/bin\",\n\t\"/usr/games\",\n\t\"/usr/local/games\",\n\t\"/usr/local/sbin\",\n\t\"/usr/sbin\",\n\t\"/sbin\",\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <glob.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int prog_cnt = 0;\nstatic char *paths[] = {\n\t\"/usr/local/bin\",\n\t\"/usr/bin\",\n\t\"/bin\",\n\t\"/usr/games\",\n\t\"/usr/local/games\",\n\t\"/usr/local/sbin\",\n\t\"/usr/sbin\",\n\t\"/sbin\",\n\tNULL\n};\n\nstatic void duplicate(char *fname) {\n\tassert(fname);\n\n\tif (*fname == '~' || strstr(fname, \"..\")) {\n\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", fname);\n\t\texit(1);\n\t}\n\tinvalid_filename(fname, 0); // no globbing\n\n\tchar *full_path;\n\tif (*fname == '/') {\n\t\t// If the absolute filename is indicated, directly use it. This\n\t\t// is required for the following cases:\n\t\t//  - if user's $PATH order is not the same as the above\n\t\t//    paths[] variable order\n\t\tif (!valid_full_path_file(fname)) {\n\t\t\tfwarning(\"invalid private-bin path %s\\n\", fname);\n\t\t\treturn;\n\t\t}\n\n\t\tfull_path = strdup(fname);\n\t\tif (!full_path)\n\t\t\terrExit(\"strdup\");\n\t}\n\telse {\n\t\t// Find the standard directory (by looping through paths[])\n\t\t// where the filename fname is located\n\t\tchar *path = check_dir_or_file(fname);\n\t\tif (!path)\n\t\t\treturn;\n\t\tif (asprintf(&full_path, \"%s/%s\", path, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\n\t// add to private-lib list\n\tif (cfg.bin_private_lib == NULL) {\n\t\tif (asprintf(&cfg.bin_private_lib, \"%s,%s\",fname, full_path) == -1)\n\t\t\terrExit(\"asprinf\");\n\t}\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s,%s,%s\", cfg.bin_private_lib, fname, full_path) == -1)\n\t\t\terrExit(\"asprinf\");\n\t\tfree(cfg.bin_private_lib);\n\t\tcfg.bin_private_lib = tmp;\n\t}\n\n\t// if full_path is symlink, and the link is in our path, copy both the file and the symlink\n\tif (is_link(full_path)) {\n\t\tchar *actual_path = realpath(full_path, NULL);\n\t\tif (actual_path) {\n\t\t\tif (valid_full_path_file(actual_path)) {\n\t\t\t\t// solving problems such as /bin/sh -> /bin/dash\n\t\t\t\t// copy the real file pointed by symlink\n\t\t\t\tsbox_run(SBOX_ROOT| SBOX_SECCOMP, 3, PATH_FCOPY, actual_path, RUN_BIN_DIR);\n\t\t\t\tprog_cnt++;\n\t\t\t\tchar *f = strrchr(actual_path, '/');\n\t\t\t\tif (f && *(++f) !='\\0')\n\t\t\t\t\treport_duplication(f);\n\t\t\t}\n\t\t\tfree(actual_path);\n\t\t}\n\t}\n\n\t// copy a file or a symlink\n\tsbox_run(SBOX_ROOT| SBOX_SECCOMP, 3, PATH_FCOPY, full_path, RUN_BIN_DIR);\n\tprog_cnt++;\n\tfree(full_path);\n\treport_duplication(fname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid notify_other(int fd) {\n\tFILE* stream;\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tstream = fdopen(newfd, \"w\");\n\tfprintf(stream, \"arg_noroot=%d\\n\", arg_noroot);\n\tfflush(stream);\n\tfclose(stream);\n}"
  },
  {
    "function_name": "wait_for_other",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "746-796",
    "snippet": "void wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define BUFLEN 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "stream"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: unexpected message from peer: %s\\n\"",
            "childstr"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "childstr",
            "\"arg_noroot=1\""
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "childstr",
            "\"arg_noroot=0\""
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\"",
            "pid",
            "status"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Peer %d unexpectedly killed (%s)\\n\"",
            "pid",
            "strsignal(WTERMSIG(status))"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsignal",
          "args": [
            "WTERMSIG(status)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Peer %d unexpectedly exited with status %d\\n\"",
            "pid",
            "WEXITSTATUS(status)"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "&status"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "746-796",
          "snippet": "void wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: proc %d cannot sync with peer: %s\\n\"",
            "getpid()",
            "ferror(stream) ? strerror(errno) : \"unexpected EOF\""
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ferror",
          "args": [
            "stream"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fgets\""
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "childstr",
            "BUFLEN",
            "stream"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "newfd",
            "\"r\""
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"dup\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "fd"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "duplicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_bin.c",
          "lines": "151-220",
          "snippet": "static void duplicate(char *fname) {\n\tassert(fname);\n\n\tif (*fname == '~' || strstr(fname, \"..\")) {\n\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", fname);\n\t\texit(1);\n\t}\n\tinvalid_filename(fname, 0); // no globbing\n\n\tchar *full_path;\n\tif (*fname == '/') {\n\t\t// If the absolute filename is indicated, directly use it. This\n\t\t// is required for the following cases:\n\t\t//  - if user's $PATH order is not the same as the above\n\t\t//    paths[] variable order\n\t\tif (!valid_full_path_file(fname)) {\n\t\t\tfwarning(\"invalid private-bin path %s\\n\", fname);\n\t\t\treturn;\n\t\t}\n\n\t\tfull_path = strdup(fname);\n\t\tif (!full_path)\n\t\t\terrExit(\"strdup\");\n\t}\n\telse {\n\t\t// Find the standard directory (by looping through paths[])\n\t\t// where the filename fname is located\n\t\tchar *path = check_dir_or_file(fname);\n\t\tif (!path)\n\t\t\treturn;\n\t\tif (asprintf(&full_path, \"%s/%s\", path, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\n\t// add to private-lib list\n\tif (cfg.bin_private_lib == NULL) {\n\t\tif (asprintf(&cfg.bin_private_lib, \"%s,%s\",fname, full_path) == -1)\n\t\t\terrExit(\"asprinf\");\n\t}\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s,%s,%s\", cfg.bin_private_lib, fname, full_path) == -1)\n\t\t\terrExit(\"asprinf\");\n\t\tfree(cfg.bin_private_lib);\n\t\tcfg.bin_private_lib = tmp;\n\t}\n\n\t// if full_path is symlink, and the link is in our path, copy both the file and the symlink\n\tif (is_link(full_path)) {\n\t\tchar *actual_path = realpath(full_path, NULL);\n\t\tif (actual_path) {\n\t\t\tif (valid_full_path_file(actual_path)) {\n\t\t\t\t// solving problems such as /bin/sh -> /bin/dash\n\t\t\t\t// copy the real file pointed by symlink\n\t\t\t\tsbox_run(SBOX_ROOT| SBOX_SECCOMP, 3, PATH_FCOPY, actual_path, RUN_BIN_DIR);\n\t\t\t\tprog_cnt++;\n\t\t\t\tchar *f = strrchr(actual_path, '/');\n\t\t\t\tif (f && *(++f) !='\\0')\n\t\t\t\t\treport_duplication(f);\n\t\t\t}\n\t\t\tfree(actual_path);\n\t\t}\n\t}\n\n\t// copy a file or a symlink\n\tsbox_run(SBOX_ROOT| SBOX_SECCOMP, 3, PATH_FCOPY, full_path, RUN_BIN_DIR);\n\tprog_cnt++;\n\tfree(full_path);\n\treport_duplication(fname);\n}",
          "includes": [
            "#include <glob.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int prog_cnt = 0;",
            "static char *paths[] = {\n\t\"/usr/local/bin\",\n\t\"/usr/bin\",\n\t\"/bin\",\n\t\"/usr/games\",\n\t\"/usr/local/games\",\n\t\"/usr/local/sbin\",\n\t\"/usr/sbin\",\n\t\"/sbin\",\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <glob.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int prog_cnt = 0;\nstatic char *paths[] = {\n\t\"/usr/local/bin\",\n\t\"/usr/bin\",\n\t\"/bin\",\n\t\"/usr/games\",\n\t\"/usr/local/games\",\n\t\"/usr/local/sbin\",\n\t\"/usr/sbin\",\n\t\"/sbin\",\n\tNULL\n};\n\nstatic void duplicate(char *fname) {\n\tassert(fname);\n\n\tif (*fname == '~' || strstr(fname, \"..\")) {\n\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", fname);\n\t\texit(1);\n\t}\n\tinvalid_filename(fname, 0); // no globbing\n\n\tchar *full_path;\n\tif (*fname == '/') {\n\t\t// If the absolute filename is indicated, directly use it. This\n\t\t// is required for the following cases:\n\t\t//  - if user's $PATH order is not the same as the above\n\t\t//    paths[] variable order\n\t\tif (!valid_full_path_file(fname)) {\n\t\t\tfwarning(\"invalid private-bin path %s\\n\", fname);\n\t\t\treturn;\n\t\t}\n\n\t\tfull_path = strdup(fname);\n\t\tif (!full_path)\n\t\t\terrExit(\"strdup\");\n\t}\n\telse {\n\t\t// Find the standard directory (by looping through paths[])\n\t\t// where the filename fname is located\n\t\tchar *path = check_dir_or_file(fname);\n\t\tif (!path)\n\t\t\treturn;\n\t\tif (asprintf(&full_path, \"%s/%s\", path, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\n\t// add to private-lib list\n\tif (cfg.bin_private_lib == NULL) {\n\t\tif (asprintf(&cfg.bin_private_lib, \"%s,%s\",fname, full_path) == -1)\n\t\t\terrExit(\"asprinf\");\n\t}\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s,%s,%s\", cfg.bin_private_lib, fname, full_path) == -1)\n\t\t\terrExit(\"asprinf\");\n\t\tfree(cfg.bin_private_lib);\n\t\tcfg.bin_private_lib = tmp;\n\t}\n\n\t// if full_path is symlink, and the link is in our path, copy both the file and the symlink\n\tif (is_link(full_path)) {\n\t\tchar *actual_path = realpath(full_path, NULL);\n\t\tif (actual_path) {\n\t\t\tif (valid_full_path_file(actual_path)) {\n\t\t\t\t// solving problems such as /bin/sh -> /bin/dash\n\t\t\t\t// copy the real file pointed by symlink\n\t\t\t\tsbox_run(SBOX_ROOT| SBOX_SECCOMP, 3, PATH_FCOPY, actual_path, RUN_BIN_DIR);\n\t\t\t\tprog_cnt++;\n\t\t\t\tchar *f = strrchr(actual_path, '/');\n\t\t\t\tif (f && *(++f) !='\\0')\n\t\t\t\t\treport_duplication(f);\n\t\t\t}\n\t\t\tfree(actual_path);\n\t\t}\n\t}\n\n\t// copy a file or a symlink\n\tsbox_run(SBOX_ROOT| SBOX_SECCOMP, 3, PATH_FCOPY, full_path, RUN_BIN_DIR);\n\tprog_cnt++;\n\tfree(full_path);\n\treport_duplication(fname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nvoid wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}"
  },
  {
    "function_name": "update_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "719-743",
    "snippet": "void update_map(char *mapping, char *map_file) {\n\tint fd;\n\tsize_t j;\n\tsize_t map_len;\t\t\t\t  /* Length of 'mapping' */\n\n\t/* Replace commas in mapping string with newlines */\n\n\tmap_len = strlen(mapping);\n\tfor (j = 0; j < map_len; j++)\n\t\tif (mapping[j] == ',')\n\t\t\tmapping[j] = '\\n';\n\n\tfd = open(map_file, O_RDWR);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Error: cannot open %s: %s\\n\", map_file, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (write(fd, mapping, map_len) != (ssize_t)map_len) {\n\t\tfprintf(stderr, \"Error: cannot write to %s: %s\\n\", map_file, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(fd);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot write to %s: %s\\n\"",
            "map_file",
            "strerror(errno)"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "mapping",
            "map_len"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "log_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/ftee/main.c",
          "lines": "104-135",
          "snippet": "static void log_write(const unsigned char *str, int len, const char *fname) {\n\tassert(fname);\n\n\tif (out_fp == NULL) {\n\t\tout_fp = fopen(fname, \"w\");\n\t\tif (!out_fp) {\n\t\t\tfprintf(stderr, \"Error: cannot open log file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tout_cnt = 0;\n\t}\n\n\t// rotate files\n\tout_cnt += len;\n\tif (out_cnt >= out_max) {\n\t\tlog_rotate(fname);\n\n\t\t// reopen the first file\n\t\tif (out_fp)\n\t\t\tfclose(out_fp);\n\t\tout_fp = fopen(fname, \"w\");\n\t\tif (!out_fp) {\n\t\t\tfprintf(stderr, \"Error: cannot open log file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tout_cnt = len;\n\t}\n\n\tint rv = fwrite(str, len, 1, out_fp);\n\t(void) rv;\n\tfflush(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"ftee.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FILE *out_fp = NULL;",
            "static int out_cnt = 0;",
            "static int out_max = 500 * 1024;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"ftee.h\"\n\nstatic FILE *out_fp = NULL;\nstatic int out_cnt = 0;\nstatic int out_max = 500 * 1024;\n\nstatic void log_write(const unsigned char *str, int len, const char *fname) {\n\tassert(fname);\n\n\tif (out_fp == NULL) {\n\t\tout_fp = fopen(fname, \"w\");\n\t\tif (!out_fp) {\n\t\t\tfprintf(stderr, \"Error: cannot open log file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tout_cnt = 0;\n\t}\n\n\t// rotate files\n\tout_cnt += len;\n\tif (out_cnt >= out_max) {\n\t\tlog_rotate(fname);\n\n\t\t// reopen the first file\n\t\tif (out_fp)\n\t\t\tfclose(out_fp);\n\t\tout_fp = fopen(fname, \"w\");\n\t\tif (!out_fp) {\n\t\t\tfprintf(stderr, \"Error: cannot open log file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tout_cnt = len;\n\t}\n\n\tint rv = fwrite(str, len, 1, out_fp);\n\t(void) rv;\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open %s: %s\\n\"",
            "map_file",
            "strerror(errno)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "map_file",
            "O_RDWR"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mapping"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid update_map(char *mapping, char *map_file) {\n\tint fd;\n\tsize_t j;\n\tsize_t map_len;\t\t\t\t  /* Length of 'mapping' */\n\n\t/* Replace commas in mapping string with newlines */\n\n\tmap_len = strlen(mapping);\n\tfor (j = 0; j < map_len; j++)\n\t\tif (mapping[j] == ',')\n\t\t\tmapping[j] = '\\n';\n\n\tfd = open(map_file, O_RDWR);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Error: cannot open %s: %s\\n\", map_file, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (write(fd, mapping, map_len) != (ssize_t)map_len) {\n\t\tfprintf(stderr, \"Error: cannot write to %s: %s\\n\", map_file, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(fd);\n}"
  },
  {
    "function_name": "extract_command_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "662-716",
    "snippet": "void extract_command_name(int index, char **argv) {\n\tEUID_ASSERT();\n\tassert(argv);\n\tassert(argv[index]);\n\n\t// configure command index\n\tcfg.original_program_index = index;\n\n\tchar *str = strdup(argv[index]);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\t// if we have a symbolic link, use the real path to extract the name\n//\tif (is_link(argv[index])) {\n//\t\tchar*newname = realpath(argv[index], NULL);\n//\t\tif (newname) {\n//\t\t\tfree(str);\n//\t\t\tstr = newname;\n//\t\t}\n//\t}\n\n\t// configure command name\n\tcfg.command_name = str;\n\tif (!cfg.command_name)\n\t\terrExit(\"strdup\");\n\n\t// remove the path: /usr/bin/firefox becomes firefox\n\tchar *basename = cfg.command_name;\n\tchar *ptr = strrchr(cfg.command_name, '/');\n\tif (ptr) {\n\t\tbasename = ++ptr;\n\t\tif (*ptr == '\\0') {\n\t\t\tfprintf(stderr, \"Error: invalid command name\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse\n\t\tptr = basename;\n\n\t// restrict the command name to the first word\n\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0')\n\t\tptr++;\n\n\t// command name is a substring of cfg.command_name\n\tif (basename != cfg.command_name || *ptr != '\\0') {\n\t\t*ptr = '\\0';\n\n\t\tbasename = strdup(basename);\n\t\tif (!basename)\n\t\t\terrExit(\"strdup\");\n\n\t\tfree(cfg.command_name);\n\t\tcfg.command_name = basename;\n\t}\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cfg.command_name"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "basename"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid command name\\n\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "cfg.command_name",
            "'/'"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[index]"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "argv[index]"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "argv"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid extract_command_name(int index, char **argv) {\n\tEUID_ASSERT();\n\tassert(argv);\n\tassert(argv[index]);\n\n\t// configure command index\n\tcfg.original_program_index = index;\n\n\tchar *str = strdup(argv[index]);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\t// if we have a symbolic link, use the real path to extract the name\n//\tif (is_link(argv[index])) {\n//\t\tchar*newname = realpath(argv[index], NULL);\n//\t\tif (newname) {\n//\t\t\tfree(str);\n//\t\t\tstr = newname;\n//\t\t}\n//\t}\n\n\t// configure command name\n\tcfg.command_name = str;\n\tif (!cfg.command_name)\n\t\terrExit(\"strdup\");\n\n\t// remove the path: /usr/bin/firefox becomes firefox\n\tchar *basename = cfg.command_name;\n\tchar *ptr = strrchr(cfg.command_name, '/');\n\tif (ptr) {\n\t\tbasename = ++ptr;\n\t\tif (*ptr == '\\0') {\n\t\t\tfprintf(stderr, \"Error: invalid command name\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse\n\t\tptr = basename;\n\n\t// restrict the command name to the first word\n\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0')\n\t\tptr++;\n\n\t// command name is a substring of cfg.command_name\n\tif (basename != cfg.command_name || *ptr != '\\0') {\n\t\t*ptr = '\\0';\n\n\t\tbasename = strdup(basename);\n\t\tif (!basename)\n\t\t\terrExit(\"strdup\");\n\n\t\tfree(cfg.command_name);\n\t\tcfg.command_name = basename;\n\t}\n}"
  },
  {
    "function_name": "find_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "600-659",
    "snippet": "int find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define BUFLEN 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "ptr"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot read /proc file\\n\""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"PPid:\"",
            "5"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "BUFLEN - 1",
            "fp"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"asprintf\""
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&file",
            "\"/proc/%u/status\"",
            "pid"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "entry->d_name",
            "&end",
            "10"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open /proc directory\\n\""
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/proc\""
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "466-473",
          "snippet": "DIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_opendir_t orig_opendir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "firemon_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "90-121",
          "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios tlocal;",
            "static struct termios twait;",
            "static int terminal_set = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nint find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}"
  },
  {
    "function_name": "check_unsigned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "585-595",
    "snippet": "void check_unsigned(const char *str, const char *msg) {\n\tEUID_ASSERT();\n\tconst char *ptr = str;\n\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0') {\n\t\tif (!isdigit(*ptr)) {\n\t\t\tfprintf(stderr, \"%s %s\\n\", msg, str);\n\t\t\texit(1);\n\t\t}\n\t\tptr++;\n\t}\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s %s\\n\"",
            "msg",
            "str"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*ptr"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid check_unsigned(const char *str, const char *msg) {\n\tEUID_ASSERT();\n\tconst char *ptr = str;\n\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0') {\n\t\tif (!isdigit(*ptr)) {\n\t\t\tfprintf(stderr, \"%s %s\\n\", msg, str);\n\t\t\texit(1);\n\t\t}\n\t\tptr++;\n\t}\n}"
  },
  {
    "function_name": "clean_pathname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "550-582",
    "snippet": "char *clean_pathname(const char *path) {\n\tassert(path);\n\tsize_t len = strlen(path);\n\tassert(len + 1 != 0 && path[len] == '\\0');\n\n\tchar *rv = malloc(len + 1);\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\n\tif (len > 0) {\n\t\tsize_t i, j, cnt;\n\t\tfor (i = 0, j = 0, cnt = 0; i < len; i++) {\n\t\t\tif (path[i] == '/')\n\t\t\t\tcnt++;\n\t\t\telse\n\t\t\t\tcnt = 0;\n\n\t\t\tif (cnt < 2) {\n\t\t\t\trv[j] = path[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\trv[j] = '\\0';\n\n\t\t// remove a trailing slash\n\t\tif (j > 1 && rv[j - 1] == '/')\n\t\t\trv[j - 1] = '\\0';\n\t}\n\telse\n\t\t*rv = '\\0';\n\n\treturn rv;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len + 1"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len + 1 != 0 && path[len] == '\\0'"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *clean_pathname(const char *path) {\n\tassert(path);\n\tsize_t len = strlen(path);\n\tassert(len + 1 != 0 && path[len] == '\\0');\n\n\tchar *rv = malloc(len + 1);\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\n\tif (len > 0) {\n\t\tsize_t i, j, cnt;\n\t\tfor (i = 0, j = 0, cnt = 0; i < len; i++) {\n\t\t\tif (path[i] == '/')\n\t\t\t\tcnt++;\n\t\t\telse\n\t\t\t\tcnt = 0;\n\n\t\t\tif (cnt < 2) {\n\t\t\t\trv[j] = path[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\trv[j] = '\\0';\n\n\t\t// remove a trailing slash\n\t\tif (j > 1 && rv[j - 1] == '/')\n\t\t\trv[j - 1] = '\\0';\n\t}\n\telse\n\t\t*rv = '\\0';\n\n\treturn rv;\n}"
  },
  {
    "function_name": "split_comma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "532-544",
    "snippet": "char *split_comma(char *str) {\n\tEUID_ASSERT();\n\tif (str == NULL || *str == '\\0')\n\t\treturn NULL;\n\tchar *ptr = strchr(str, ',');\n\tif (!ptr)\n\t\treturn NULL;\n\t*ptr = '\\0';\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn NULL;\n\treturn ptr;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "','"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *split_comma(char *str) {\n\tEUID_ASSERT();\n\tif (str == NULL || *str == '\\0')\n\t\treturn NULL;\n\tchar *ptr = strchr(str, ',');\n\tif (!ptr)\n\t\treturn NULL;\n\t*ptr = '\\0';\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn NULL;\n\treturn ptr;\n}"
  },
  {
    "function_name": "line_remove_spaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "480-529",
    "snippet": "char *line_remove_spaces(const char *buf) {\n\tEUID_ASSERT();\n\tassert(buf);\n\tsize_t len = strlen(buf);\n\tif (len == 0)\n\t\treturn NULL;\n\tassert(len + 1 != 0 && buf[len] == '\\0');\n\n\t// allocate memory for the new string\n\tchar *rv = malloc(len + 1);\n\tif (rv == NULL)\n\t\terrExit(\"malloc\");\n\n\t// remove space at start of line\n\tconst char *ptr1 = buf;\n\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\tptr1++;\n\n\t// copy data and remove additional spaces\n\tchar *ptr2 = rv;\n\tint state = 0;\n\twhile (*ptr1 != '\\0') {\n\t\tif (*ptr1 == '\\n' || *ptr1 == '\\r')\n\t\t\tbreak;\n\n\t\tif (state == 0) {\n\t\t\tif (*ptr1 != ' ' && *ptr1 != '\\t')\n\t\t\t\t*ptr2++ = *ptr1++;\n\t\t\telse {\n\t\t\t\t*ptr2++ = ' ';\n\t\t\t\tptr1++;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t  // state == 1\n\t\t\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\t\t\tptr1++;\n\t\t\tstate = 0;\n\t\t}\n\t}\n\n\t// strip last blank character if any\n\tif (ptr2 > rv && *(ptr2 - 1) == ' ')\n\t\t--ptr2;\n\t*ptr2 = '\\0';\n\t//\tif (arg_debug)\n\t//\t\tprintf(\"Processing line #%s#\\n\", rv);\n\n\treturn rv;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len + 1"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len + 1 != 0 && buf[len] == '\\0'"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "buf"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *line_remove_spaces(const char *buf) {\n\tEUID_ASSERT();\n\tassert(buf);\n\tsize_t len = strlen(buf);\n\tif (len == 0)\n\t\treturn NULL;\n\tassert(len + 1 != 0 && buf[len] == '\\0');\n\n\t// allocate memory for the new string\n\tchar *rv = malloc(len + 1);\n\tif (rv == NULL)\n\t\terrExit(\"malloc\");\n\n\t// remove space at start of line\n\tconst char *ptr1 = buf;\n\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\tptr1++;\n\n\t// copy data and remove additional spaces\n\tchar *ptr2 = rv;\n\tint state = 0;\n\twhile (*ptr1 != '\\0') {\n\t\tif (*ptr1 == '\\n' || *ptr1 == '\\r')\n\t\t\tbreak;\n\n\t\tif (state == 0) {\n\t\t\tif (*ptr1 != ' ' && *ptr1 != '\\t')\n\t\t\t\t*ptr2++ = *ptr1++;\n\t\t\telse {\n\t\t\t\t*ptr2++ = ' ';\n\t\t\t\tptr1++;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t  // state == 1\n\t\t\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\t\t\tptr1++;\n\t\t\tstate = 0;\n\t\t}\n\t}\n\n\t// strip last blank character if any\n\tif (ptr2 > rv && *(ptr2 - 1) == ' ')\n\t\t--ptr2;\n\t*ptr2 = '\\0';\n\t//\tif (arg_debug)\n\t//\t\tprintf(\"Processing line #%s#\\n\", rv);\n\n\treturn rv;\n}"
  },
  {
    "function_name": "trim_trailing_slash_or_dot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "463-477",
    "snippet": "void trim_trailing_slash_or_dot(char *path) {\n\tassert(path);\n\n\tchar *end = strchr(path, '\\0');\n\tif ((end - path) > 1) {\n\t\tend--;\n\t\twhile (*end == '/' ||\n\t\t      (*end == '.' && *(end - 1) == '/')) {\n\t\t\t*end = '\\0';\n\t\t\tend--;\n\t\t\tif (end == path)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "path",
            "'\\0'"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid trim_trailing_slash_or_dot(char *path) {\n\tassert(path);\n\n\tchar *end = strchr(path, '\\0');\n\tif ((end - path) > 1) {\n\t\tend--;\n\t\twhile (*end == '/' ||\n\t\t      (*end == '.' && *(end - 1) == '/')) {\n\t\t\t*end = '\\0';\n\t\t\tend--;\n\t\t\tif (end == path)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "is_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "432-459",
    "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dup"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dup"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "s.st_mode"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "dup",
            "&s"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim_trailing_slash_or_dot",
          "args": [
            "dup"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "trim_trailing_slash_or_dot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "463-477",
          "snippet": "void trim_trailing_slash_or_dot(char *path) {\n\tassert(path);\n\n\tchar *end = strchr(path, '\\0');\n\tif ((end - path) > 1) {\n\t\tend--;\n\t\twhile (*end == '/' ||\n\t\t      (*end == '.' && *(end - 1) == '/')) {\n\t\t\t*end = '\\0';\n\t\t\tend--;\n\t\t\tif (end == path)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid trim_trailing_slash_or_dot(char *path) {\n\tassert(path);\n\n\tchar *end = strchr(path, '\\0');\n\tif ((end - path) > 1) {\n\t\tend--;\n\t\twhile (*end == '/' ||\n\t\t      (*end == '.' && *(end - 1) == '/')) {\n\t\t\t*end = '\\0';\n\t\t\tend--;\n\t\t\tif (end == path)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "fname"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "s.st_mode"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
  },
  {
    "function_name": "is_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "401-428",
    "snippet": "int is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "tmp",
            "&s"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot allocate memory, %s:%d\\n\"",
            "__FILE__",
            "__LINE__"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&tmp",
            "\"%s/\"",
            "fname"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fname"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "touch_file_as_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "377-398",
    "snippet": "void touch_file_as_user(const char *fname, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tFILE *fp = fopen(fname, \"wx\");\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, -1, -1, mode);\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "0"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gcov_flush",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "-1",
            "-1",
            "mode"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"wx\""
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "0"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "121-142",
          "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid touch_file_as_user(const char *fname, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tFILE *fp = fopen(fname, \"wx\");\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, -1, -1, mode);\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
  },
  {
    "function_name": "copy_file_from_user_to_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "337-374",
    "snippet": "void copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\treturn;\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tint src = open(srcname, O_RDONLY);\n\t\tif (src < 0) {\n\t\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\t} else {\n\t\t\tif (copy_file_by_fd(src, dst)) {\n\t\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n\t\t\t}\n\t\t\tclose(src);\n\t\t}\n\t\tclose(dst);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tif (fchown(dst, uid, gid) == -1)\n\t\terrExit(\"fchown\");\n\tif (fchmod(dst, mode) == -1)\n\t\terrExit(\"fchmod\");\n\tclose(dst);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "dst"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fchmod\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "dst",
            "mode"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fchown\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "dst",
            "uid",
            "gid"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "0"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gcov_flush",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"cannot copy %s\\n\"",
            "srcname"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_file_by_fd",
          "args": [
            "src",
            "dst"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_by_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "263-281",
          "snippet": "static int copy_file_by_fd(int src, int dst) {\n\tassert(src >= 0);\n\tassert(dst >= 0);\n\n\tssize_t len;\n\tstatic const int BUFLEN = 1024;\n\tunsigned char buf[BUFLEN];\n\twhile ((len = read(src, buf, BUFLEN)) > 0) {\n\t\tint done = 0;\n\t\twhile (done != len) {\n\t\t\tint rv = write(dst, buf + done, len - done);\n\t\t\tif (rv == -1)\n\t\t\t\treturn -1;\n\t\t\tdone += rv;\n\t\t}\n\t}\n//\tfflush(0);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nstatic int copy_file_by_fd(int src, int dst) {\n\tassert(src >= 0);\n\tassert(dst >= 0);\n\n\tssize_t len;\n\tstatic const int BUFLEN = 1024;\n\tunsigned char buf[BUFLEN];\n\twhile ((len = read(src, buf, BUFLEN)) > 0) {\n\t\tint done = 0;\n\t\twhile (done != len) {\n\t\t\tint rv = write(dst, buf + done, len - done);\n\t\t\tif (rv == -1)\n\t\t\t\treturn -1;\n\t\t\tdone += rv;\n\t\t}\n\t}\n//\tfflush(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "srcname",
            "O_RDONLY"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "0"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "121-142",
          "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "destname",
            "O_CREAT|O_WRONLY|O_TRUNC",
            "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "freopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "346-353",
          "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\treturn;\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tint src = open(srcname, O_RDONLY);\n\t\tif (src < 0) {\n\t\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\t} else {\n\t\t\tif (copy_file_by_fd(src, dst)) {\n\t\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n\t\t\t}\n\t\t\tclose(src);\n\t\t}\n\t\tclose(dst);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tif (fchown(dst, uid, gid) == -1)\n\t\terrExit(\"fchown\");\n\tif (fchmod(dst, mode) == -1)\n\t\terrExit(\"fchmod\");\n\tclose(dst);\n}"
  },
  {
    "function_name": "copy_file_as_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "316-335",
    "snippet": "void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "0"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gcov_flush",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"cannot copy %s\\n\"",
            "srcname"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_file",
          "args": [
            "srcname",
            "destname",
            "uid",
            "gid",
            "mode"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_from_user_to_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "337-374",
          "snippet": "void copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\treturn;\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tint src = open(srcname, O_RDONLY);\n\t\tif (src < 0) {\n\t\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\t} else {\n\t\t\tif (copy_file_by_fd(src, dst)) {\n\t\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n\t\t\t}\n\t\t\tclose(src);\n\t\t}\n\t\tclose(dst);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tif (fchown(dst, uid, gid) == -1)\n\t\terrExit(\"fchown\");\n\tif (fchmod(dst, mode) == -1)\n\t\terrExit(\"fchmod\");\n\tclose(dst);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\treturn;\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tint src = open(srcname, O_RDONLY);\n\t\tif (src < 0) {\n\t\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\t} else {\n\t\t\tif (copy_file_by_fd(src, dst)) {\n\t\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n\t\t\t}\n\t\t\tclose(src);\n\t\t}\n\t\tclose(dst);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tif (fchown(dst, uid, gid) == -1)\n\t\terrExit(\"fchown\");\n\tif (fchmod(dst, mode) == -1)\n\t\terrExit(\"fchmod\");\n\tclose(dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "0"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "121-142",
          "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
  },
  {
    "function_name": "copy_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "284-313",
    "snippet": "int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(srcname);\n\tassert(destname);\n\n\t// open source\n\tint src = open(srcname, O_RDONLY);\n\tif (src < 0) {\n\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\treturn -1;\n\t}\n\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\tclose(src);\n\t\treturn -1;\n\t}\n\n\tint errors = copy_file_by_fd(src, dst);\n\tif (!errors) {\n\t\tif (fchown(dst, uid, gid) == -1)\n\t\t\terrExit(\"fchown\");\n\t\tif (fchmod(dst, mode) == -1)\n\t\t\terrExit(\"fchmod\");\n\t}\n\tclose(src);\n\tclose(dst);\n\treturn errors;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "dst"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fchmod\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "dst",
            "mode"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fchown\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "dst",
            "uid",
            "gid"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_file_by_fd",
          "args": [
            "src",
            "dst"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_by_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "263-281",
          "snippet": "static int copy_file_by_fd(int src, int dst) {\n\tassert(src >= 0);\n\tassert(dst >= 0);\n\n\tssize_t len;\n\tstatic const int BUFLEN = 1024;\n\tunsigned char buf[BUFLEN];\n\twhile ((len = read(src, buf, BUFLEN)) > 0) {\n\t\tint done = 0;\n\t\twhile (done != len) {\n\t\t\tint rv = write(dst, buf + done, len - done);\n\t\t\tif (rv == -1)\n\t\t\t\treturn -1;\n\t\t\tdone += rv;\n\t\t}\n\t}\n//\tfflush(0);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nstatic int copy_file_by_fd(int src, int dst) {\n\tassert(src >= 0);\n\tassert(dst >= 0);\n\n\tssize_t len;\n\tstatic const int BUFLEN = 1024;\n\tunsigned char buf[BUFLEN];\n\twhile ((len = read(src, buf, BUFLEN)) > 0) {\n\t\tint done = 0;\n\t\twhile (done != len) {\n\t\t\tint rv = write(dst, buf + done, len - done);\n\t\t\tif (rv == -1)\n\t\t\t\treturn -1;\n\t\t\tdone += rv;\n\t\t}\n\t}\n//\tfflush(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"cannot open destination file %s, file not copied\\n\"",
            "destname"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "destname",
            "O_CREAT|O_WRONLY|O_TRUNC",
            "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "freopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "346-353",
          "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "srcname",
            "O_RDONLY"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "destname"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "srcname"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(srcname);\n\tassert(destname);\n\n\t// open source\n\tint src = open(srcname, O_RDONLY);\n\tif (src < 0) {\n\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\treturn -1;\n\t}\n\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\tclose(src);\n\t\treturn -1;\n\t}\n\n\tint errors = copy_file_by_fd(src, dst);\n\tif (!errors) {\n\t\tif (fchown(dst, uid, gid) == -1)\n\t\t\terrExit(\"fchown\");\n\t\tif (fchmod(dst, mode) == -1)\n\t\t\terrExit(\"fchmod\");\n\t}\n\tclose(src);\n\tclose(dst);\n\treturn errors;\n}"
  },
  {
    "function_name": "copy_file_by_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "263-281",
    "snippet": "static int copy_file_by_fd(int src, int dst) {\n\tassert(src >= 0);\n\tassert(dst >= 0);\n\n\tssize_t len;\n\tstatic const int BUFLEN = 1024;\n\tunsigned char buf[BUFLEN];\n\twhile ((len = read(src, buf, BUFLEN)) > 0) {\n\t\tint done = 0;\n\t\twhile (done != len) {\n\t\t\tint rv = write(dst, buf + done, len - done);\n\t\t\tif (rv == -1)\n\t\t\t\treturn -1;\n\t\t\tdone += rv;\n\t\t}\n\t}\n//\tfflush(0);\n\treturn 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define BUFLEN 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "dst",
            "buf + done",
            "len - done"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "log_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/ftee/main.c",
          "lines": "104-135",
          "snippet": "static void log_write(const unsigned char *str, int len, const char *fname) {\n\tassert(fname);\n\n\tif (out_fp == NULL) {\n\t\tout_fp = fopen(fname, \"w\");\n\t\tif (!out_fp) {\n\t\t\tfprintf(stderr, \"Error: cannot open log file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tout_cnt = 0;\n\t}\n\n\t// rotate files\n\tout_cnt += len;\n\tif (out_cnt >= out_max) {\n\t\tlog_rotate(fname);\n\n\t\t// reopen the first file\n\t\tif (out_fp)\n\t\t\tfclose(out_fp);\n\t\tout_fp = fopen(fname, \"w\");\n\t\tif (!out_fp) {\n\t\t\tfprintf(stderr, \"Error: cannot open log file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tout_cnt = len;\n\t}\n\n\tint rv = fwrite(str, len, 1, out_fp);\n\t(void) rv;\n\tfflush(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"ftee.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FILE *out_fp = NULL;",
            "static int out_cnt = 0;",
            "static int out_max = 500 * 1024;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"ftee.h\"\n\nstatic FILE *out_fp = NULL;\nstatic int out_cnt = 0;\nstatic int out_max = 500 * 1024;\n\nstatic void log_write(const unsigned char *str, int len, const char *fname) {\n\tassert(fname);\n\n\tif (out_fp == NULL) {\n\t\tout_fp = fopen(fname, \"w\");\n\t\tif (!out_fp) {\n\t\t\tfprintf(stderr, \"Error: cannot open log file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tout_cnt = 0;\n\t}\n\n\t// rotate files\n\tout_cnt += len;\n\tif (out_cnt >= out_max) {\n\t\tlog_rotate(fname);\n\n\t\t// reopen the first file\n\t\tif (out_fp)\n\t\t\tfclose(out_fp);\n\t\tout_fp = fopen(fname, \"w\");\n\t\tif (!out_fp) {\n\t\t\tfprintf(stderr, \"Error: cannot open log file %s\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tout_cnt = len;\n\t}\n\n\tint rv = fwrite(str, len, 1, out_fp);\n\t(void) rv;\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "src",
            "buf",
            "BUFLEN"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dst >= 0"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "src >= 0"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nstatic int copy_file_by_fd(int src, int dst) {\n\tassert(src >= 0);\n\tassert(dst >= 0);\n\n\tssize_t len;\n\tstatic const int BUFLEN = 1024;\n\tunsigned char buf[BUFLEN];\n\twhile ((len = read(src, buf, BUFLEN)) > 0) {\n\t\tint done = 0;\n\t\twhile (done != len) {\n\t\t\tint rv = write(dst, buf + done, len - done);\n\t\t\tif (rv == -1)\n\t\t\t\treturn -1;\n\t\t\tdone += rv;\n\t\t}\n\t}\n//\tfflush(0);\n\treturn 0;\n}"
  },
  {
    "function_name": "set_nice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "254-260",
    "snippet": "void set_nice(int inc) {\n\terrno = 0;\n\tint rv = nice(inc);\n\t(void) rv;\n\tif (errno)\n\t\tfwarning(\"cannot set nice value\\n\");\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"cannot set nice value\\n\""
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nice",
          "args": [
            "inc"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "set_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "254-260",
          "snippet": "void set_nice(int inc) {\n\terrno = 0;\n\tint rv = nice(inc);\n\t(void) rv;\n\tif (errno)\n\t\tfwarning(\"cannot set nice value\\n\");\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid set_nice(int inc) {\n\terrno = 0;\n\tint rv = nice(inc);\n\t(void) rv;\n\tif (errno)\n\t\tfwarning(\"cannot set nice value\\n\");\n}"
  },
  {
    "function_name": "logerr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "244-251",
    "snippet": "void logerr(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_ERR, \"%s\\n\", msg);\n\tcloselog();\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closelog",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_ERR",
            "\"%s\\n\"",
            "msg"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "\"firejail\"",
            "LOG_NDELAY | LOG_PID",
            "LOG_USER"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logerr(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_ERR, \"%s\\n\", msg);\n\tcloselog();\n}"
  },
  {
    "function_name": "logargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "220-241",
    "snippet": "void logargs(int argc, char **argv) {\n\tif (!arg_debug)\n\t\treturn;\n\n\tint i;\n\tint len = 0;\n\n\t// calculate message length\n\tfor (i = 0; i < argc; i++)\n\t\tlen += strlen(argv[i]) + 1;\t  // + ' '\n\n\t// build message\n\tchar msg[len + 1];\n\tchar *ptr = msg;\n\tfor (i = 0; i < argc; i++) {\n\t\tsprintf(ptr, \"%s \", argv[i]);\n\t\tptr += strlen(ptr);\n\t}\n\n\t// log message\n\tlogmsg(msg);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logmsg",
          "args": [
            "msg"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "logmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "210-217",
          "snippet": "void logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr",
            "\"%s \"",
            "argv[i]"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logargs(int argc, char **argv) {\n\tif (!arg_debug)\n\t\treturn;\n\n\tint i;\n\tint len = 0;\n\n\t// calculate message length\n\tfor (i = 0; i < argc; i++)\n\t\tlen += strlen(argv[i]) + 1;\t  // + ' '\n\n\t// build message\n\tchar msg[len + 1];\n\tchar *ptr = msg;\n\tfor (i = 0; i < argc; i++) {\n\t\tsprintf(ptr, \"%s \", argv[i]);\n\t\tptr += strlen(ptr);\n\t}\n\n\t// log message\n\tlogmsg(msg);\n}"
  },
  {
    "function_name": "logmsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "210-217",
    "snippet": "void logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closelog",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_INFO",
            "\"%s\\n\"",
            "msg"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "\"firejail\"",
            "LOG_NDELAY | LOG_PID",
            "LOG_USER"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}"
  },
  {
    "function_name": "logsignal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "200-207",
    "snippet": "void logsignal(int s) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"Signal %d caught\", s);\n\tcloselog();\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closelog",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_INFO",
            "\"Signal %d caught\"",
            "s"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "\"firejail\"",
            "LOG_NDELAY | LOG_PID",
            "LOG_USER"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logsignal(int s) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"Signal %d caught\", s);\n\tcloselog();\n}"
  },
  {
    "function_name": "fmessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "189-198",
    "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfprintf",
          "args": [
            "stderr",
            "fmt",
            "args"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
  },
  {
    "function_name": "fwarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "178-187",
    "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfprintf",
          "args": [
            "stderr",
            "fmt",
            "args"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: \""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
  },
  {
    "function_name": "mkpath_as_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "145-176",
    "snippet": "int mkpath_as_root(const char* path) {\n\tassert(path && *path);\n\n\t// work on a copy of the path\n\tchar *file_path = strdup(path);\n\tif (!file_path)\n\t\terrExit(\"strdup\");\n\n\tchar* p;\n\tint done = 0;\n\tfor (p=strchr(file_path+1, '/'); p; p=strchr(p+1, '/')) {\n\t\t*p='\\0';\n\t\tif (mkdir(file_path, 0755)==-1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tfree(file_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (set_perms(file_path, 0, 0, 0755))\n\t\t\t\terrExit(\"set_perms\");\n\t\t\tdone = 1;\n\t\t}\n\n\t\t*p='/';\n\t}\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(file_path);\n\treturn 0;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file_path"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"mkpath\"",
            "path"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"set_perms\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_perms",
          "args": [
            "file_path",
            "0",
            "0",
            "0755"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "set_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1047-1054",
          "snippet": "int set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file_path"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "file_path",
            "0755"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "382-389",
          "snippet": "int mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdir_t orig_mkdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p+1",
            "'/'"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "file_path+1",
            "'/'"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path && *path"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint mkpath_as_root(const char* path) {\n\tassert(path && *path);\n\n\t// work on a copy of the path\n\tchar *file_path = strdup(path);\n\tif (!file_path)\n\t\terrExit(\"strdup\");\n\n\tchar* p;\n\tint done = 0;\n\tfor (p=strchr(file_path+1, '/'); p; p=strchr(p+1, '/')) {\n\t\t*p='\\0';\n\t\tif (mkdir(file_path, 0755)==-1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tfree(file_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (set_perms(file_path, 0, 0, 0755))\n\t\t\t\terrExit(\"set_perms\");\n\t\t\tdone = 1;\n\t\t}\n\n\t\t*p='/';\n\t}\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(file_path);\n\treturn 0;\n}"
  },
  {
    "function_name": "drop_privs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "121-142",
    "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setresuid\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "-1",
            "getuid()",
            "getuid()"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "setresuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "658-666",
          "snippet": "int setresuid(uid_t ruid, uid_t euid, uid_t suid) {\n\tif (!orig_setresuid)\n\t\torig_setresuid = (orig_setresuid_t)dlsym(RTLD_NEXT, \"setresuid\");\n\n\tint rv = orig_setresuid(ruid, euid, suid);\n\tprintf(\"%u:%s:setresuid %d %d %d:%d\\n\", pid(), name(), ruid, euid, suid, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_setresuid_t orig_setresuid = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_setresuid_t orig_setresuid = NULL;\n\nint setresuid(uid_t ruid, uid_t euid, uid_t suid) {\n\tif (!orig_setresuid)\n\t\torig_setresuid = (orig_setresuid_t)dlsym(RTLD_NEXT, \"setresuid\");\n\n\tint rv = orig_setresuid(ruid, euid, suid);\n\tprintf(\"%u:%s:setresuid %d %d %d:%d\\n\", pid(), name(), ruid, euid, suid, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setresgid\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "-1",
            "getgid()",
            "getgid()"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "setresgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "670-678",
          "snippet": "int setresgid(gid_t rgid, gid_t egid, gid_t sgid) {\n\tif (!orig_setresgid)\n\t\torig_setresgid = (orig_setresgid_t)dlsym(RTLD_NEXT, \"setresgid\");\n\n\tint rv = orig_setresgid(rgid, egid, sgid);\n\tprintf(\"%u:%s:setresgid %d %d %d:%d\\n\", pid(), name(), rgid, egid, sgid, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_setresgid_t orig_setresgid = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_setresgid_t orig_setresgid = NULL;\n\nint setresgid(gid_t rgid, gid_t egid, gid_t sgid) {\n\tif (!orig_setresgid)\n\t\torig_setresgid = (orig_setresgid_t)dlsym(RTLD_NEXT, \"setresgid\");\n\n\tint rv = orig_setresgid(rgid, egid, sgid);\n\tprintf(\"%u:%s:setresgid %d %d %d:%d\\n\", pid(), name(), rgid, egid, sgid, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_supplementary_groups",
          "args": [
            "gid"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "clean_supplementary_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "59-116",
          "snippet": "static void clean_supplementary_groups(gid_t gid) {\n\tassert(cfg.username);\n\tgid_t groups[MAX_GROUPS];\n\tint ngroups = MAX_GROUPS;\n\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\tif (rv == -1)\n\t\tgoto clean_all;\n\n\t// clean supplementary group list\n\t// allow only tty, audio, video, games\n\tgid_t new_groups[MAX_GROUPS];\n\tint new_ngroups = 0;\n\tchar *allowed[] = {\n\t\t\"tty\",\n\t\t\"audio\",\n\t\t\"video\",\n\t\t\"games\",\n\t\tNULL\n\t};\n\n\tint i = 0;\n\twhile (allowed[i]) {\n\t\tgid_t g = get_group_id(allowed[i]);\n\t \tif (g) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < ngroups; j++) {\n\t\t\t\tif (g == groups[j]) {\n\t\t\t\t\tnew_groups[new_ngroups] = g;\n\t\t\t\t\tnew_ngroups++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\tif (new_ngroups) {\n\t\trv = setgroups(new_ngroups, new_groups);\n\t\tif (rv)\n\t\t\tgoto clean_all;\n\n\t\tif (arg_debug) {\n\t\t\tprintf(\"Supplementary groups: \");\n\t\t\tfor (i = 0; i < new_ngroups; i++)\n\t\t\t\tprintf(\"%d \", new_groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\telse\n\t\tgoto clean_all;\n\n\treturn;\n\nclean_all:\n\tfwarning(\"cleaning all supplementary groups\\n\");\n\tif (setgroups(0, NULL) < 0)\n\t\terrExit(\"setgroups\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_GROUPS 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define MAX_GROUPS 1024\n\nstatic void clean_supplementary_groups(gid_t gid) {\n\tassert(cfg.username);\n\tgid_t groups[MAX_GROUPS];\n\tint ngroups = MAX_GROUPS;\n\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\tif (rv == -1)\n\t\tgoto clean_all;\n\n\t// clean supplementary group list\n\t// allow only tty, audio, video, games\n\tgid_t new_groups[MAX_GROUPS];\n\tint new_ngroups = 0;\n\tchar *allowed[] = {\n\t\t\"tty\",\n\t\t\"audio\",\n\t\t\"video\",\n\t\t\"games\",\n\t\tNULL\n\t};\n\n\tint i = 0;\n\twhile (allowed[i]) {\n\t\tgid_t g = get_group_id(allowed[i]);\n\t \tif (g) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < ngroups; j++) {\n\t\t\t\tif (g == groups[j]) {\n\t\t\t\t\tnew_groups[new_ngroups] = g;\n\t\t\t\t\tnew_ngroups++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\tif (new_ngroups) {\n\t\trv = setgroups(new_ngroups, new_groups);\n\t\tif (rv)\n\t\t\tgoto clean_all;\n\n\t\tif (arg_debug) {\n\t\t\tprintf(\"Supplementary groups: \");\n\t\t\tfor (i = 0; i < new_ngroups; i++)\n\t\t\t\tprintf(\"%d \", new_groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\telse\n\t\tgoto clean_all;\n\n\treturn;\n\nclean_all:\n\tfwarning(\"cleaning all supplementary groups\\n\");\n\tif (setgroups(0, NULL) < 0)\n\t\terrExit(\"setgroups\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No supplementary groups\\n\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setgroups\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\"",
            "getpid()",
            "getuid()",
            "gid",
            "nogroups"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
  },
  {
    "function_name": "clean_supplementary_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "59-116",
    "snippet": "static void clean_supplementary_groups(gid_t gid) {\n\tassert(cfg.username);\n\tgid_t groups[MAX_GROUPS];\n\tint ngroups = MAX_GROUPS;\n\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\tif (rv == -1)\n\t\tgoto clean_all;\n\n\t// clean supplementary group list\n\t// allow only tty, audio, video, games\n\tgid_t new_groups[MAX_GROUPS];\n\tint new_ngroups = 0;\n\tchar *allowed[] = {\n\t\t\"tty\",\n\t\t\"audio\",\n\t\t\"video\",\n\t\t\"games\",\n\t\tNULL\n\t};\n\n\tint i = 0;\n\twhile (allowed[i]) {\n\t\tgid_t g = get_group_id(allowed[i]);\n\t \tif (g) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < ngroups; j++) {\n\t\t\t\tif (g == groups[j]) {\n\t\t\t\t\tnew_groups[new_ngroups] = g;\n\t\t\t\t\tnew_ngroups++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\tif (new_ngroups) {\n\t\trv = setgroups(new_ngroups, new_groups);\n\t\tif (rv)\n\t\t\tgoto clean_all;\n\n\t\tif (arg_debug) {\n\t\t\tprintf(\"Supplementary groups: \");\n\t\t\tfor (i = 0; i < new_ngroups; i++)\n\t\t\t\tprintf(\"%d \", new_groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\telse\n\t\tgoto clean_all;\n\n\treturn;\n\nclean_all:\n\tfwarning(\"cleaning all supplementary groups\\n\");\n\tif (setgroups(0, NULL) < 0)\n\t\terrExit(\"setgroups\");\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAX_GROUPS 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setgroups\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"cleaning all supplementary groups\\n\""
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%d \"",
            "new_groups[i]"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Supplementary groups: \""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "new_ngroups",
            "new_groups"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_group_id",
          "args": [
            "allowed[i]"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "get_group_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "870-878",
          "snippet": "uid_t get_group_id(const char *group) {\n\t// find tty group id\n\tgid_t gid = 0;\n\tstruct group *g = getgrnam(group);\n\tif (g)\n\t\tgid = g->gr_gid;\n\n\treturn gid;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nuid_t get_group_id(const char *group) {\n\t// find tty group id\n\tgid_t gid = 0;\n\tstruct group *g = getgrnam(group);\n\tif (g)\n\t\tgid = g->gr_gid;\n\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgrouplist",
          "args": [
            "cfg.username",
            "gid",
            "groups",
            "&ngroups"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cfg.username"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define MAX_GROUPS 1024\n\nstatic void clean_supplementary_groups(gid_t gid) {\n\tassert(cfg.username);\n\tgid_t groups[MAX_GROUPS];\n\tint ngroups = MAX_GROUPS;\n\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\tif (rv == -1)\n\t\tgoto clean_all;\n\n\t// clean supplementary group list\n\t// allow only tty, audio, video, games\n\tgid_t new_groups[MAX_GROUPS];\n\tint new_ngroups = 0;\n\tchar *allowed[] = {\n\t\t\"tty\",\n\t\t\"audio\",\n\t\t\"video\",\n\t\t\"games\",\n\t\tNULL\n\t};\n\n\tint i = 0;\n\twhile (allowed[i]) {\n\t\tgid_t g = get_group_id(allowed[i]);\n\t \tif (g) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < ngroups; j++) {\n\t\t\t\tif (g == groups[j]) {\n\t\t\t\t\tnew_groups[new_ngroups] = g;\n\t\t\t\t\tnew_ngroups++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\tif (new_ngroups) {\n\t\trv = setgroups(new_ngroups, new_groups);\n\t\tif (rv)\n\t\t\tgoto clean_all;\n\n\t\tif (arg_debug) {\n\t\t\tprintf(\"Supplementary groups: \");\n\t\t\tfor (i = 0; i < new_ngroups; i++)\n\t\t\t\tprintf(\"%d \", new_groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\telse\n\t\tgoto clean_all;\n\n\treturn;\n\nclean_all:\n\tfwarning(\"cleaning all supplementary groups\\n\");\n\tif (setgroups(0, NULL) < 0)\n\t\terrExit(\"setgroups\");\n}"
  },
  {
    "function_name": "errLogExit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
    "lines": "40-57",
    "snippet": "void errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <grp.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <ftw.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "msg2"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "firemon_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "90-121",
          "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios tlocal;",
            "static struct termios twait;",
            "static int terminal_set = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "closelog",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_CRIT",
            "\"%s\"",
            "msg2"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&msg2",
            "\"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\"",
            "getuid()",
            "m->fsname",
            "m->dir",
            "m->fstype",
            "msg1"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vasprintf",
          "args": [
            "&msg1",
            "fmt",
            "args"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_mount",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "get_last_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "131-152",
          "snippet": "MountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [
            "static char mbuf[MAX_BUF];",
            "static MountData mdata;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nstatic char mbuf[MAX_BUF];\nstatic MountData mdata;\n\nMountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "\"firejail\"",
            "LOG_NDELAY | LOG_PID",
            "LOG_AUTH"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}"
  }
]