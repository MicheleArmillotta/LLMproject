[
  {
    "function_name": "tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/tree.c",
    "lines": "22-34",
    "snippet": "void tree(pid_t pid) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (i == skip_process)\n\t\t\tcontinue;\n\t\tif (pids[i].level == 1)\n\t\t\tpid_print_tree(i, 0, arg_nowrap);\n\t}\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_print_tree",
          "args": [
            "i",
            "0",
            "arg_nowrap"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "pid_print_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "253-269",
          "snippet": "void pid_print_tree(unsigned index, unsigned parent, int nowrap) {\n\tprint_elem(index, nowrap);\n\n\t// Remove unused parameter warning\n\t(void)parent;\n\n\tunsigned i;\n\tfor (i = index + 1; i < (unsigned)max_pids; i++) {\n\t\tif (pids[i].parent == (pid_t)index)\n\t\t\tpid_print_tree(i, index, nowrap);\n\t}\n\n\tfor (i = 0; i < index; i++) {\n\t\tif (pids[i].parent == (pid_t)index)\n\t\t\tpid_print_tree(i, index, nowrap);\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Process *pids = NULL;",
            "int max_pids=32769;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\nProcess *pids = NULL;\nint max_pids=32769;\n\nvoid pid_print_tree(unsigned index, unsigned parent, int nowrap) {\n\tprint_elem(index, nowrap);\n\n\t// Remove unused parameter warning\n\t(void)parent;\n\n\tunsigned i;\n\tfor (i = index + 1; i < (unsigned)max_pids; i++) {\n\t\tif (pids[i].parent == (pid_t)index)\n\t\t\tpid_print_tree(i, index, nowrap);\n\t}\n\n\tfor (i = 0; i < index; i++) {\n\t\tif (pids[i].parent == (pid_t)index)\n\t\t\tpid_print_tree(i, index, nowrap);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_read",
          "args": [
            "pid"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "pid_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "304-428",
          "snippet": "void pid_read(pid_t mon_pid) {\n\tif (pids == NULL) {\n\t\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\t\tif (fp) {\n\t\t\tint val;\n\t\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\t\tif (val >= max_pids)\n\t\t\t\t\tmax_pids = val + 1;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tpids = malloc(sizeof(Process) * max_pids);\n\t\tif (pids == NULL)\n\t\t\terrExit(\"malloc\");\n\t}\n\tmemset(pids, 0, sizeof(Process) * max_pids);\n\tpid_t mypid = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpid_t child = -1;\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (child < 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == mypid)\n\t\t\tcontinue;\n\n\t\t// skip PID 1 just in case we run a sandbox-in-sandbox\n\t\tif (pid == 1)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[PIDS_BUFLEN];\n\t\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"Name:\", 5) == 0) {\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif ((strcmp(ptr, \"firejail\") == 0) && (mon_pid == 0 || mon_pid == pid)) {\n\t\t\t\t\tif (pid_proc_cmdline_x11_xpra_xephyr(pid))\n\t\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t}\n\t\t\tif (strncmp(buf, \"State:\", 6) == 0) {\n\t\t\t\tif (strstr(buf, \"(zombie)\"))\n\t\t\t\t\tpids[pid].zombie = 1;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tunsigned parent = atoi(ptr);\n\t\t\t\tparent %= max_pids;\n\t\t\t\tif (pids[parent].level > 0) {\n\t\t\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t\t\t}\n\t\t\t\tpids[pid].parent = parent;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\t\tchar *ptr = buf + 4;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tpids[pid].uid = atoi(ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\n\tpid_t pid;\n\tfor (pid = 0; pid < max_pids; pid++) {\n\t\tint parent = pids[pid].parent;\n\t\tif (pids[parent].level > 0) {\n\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [
            "#define PIDS_BUFLEN 4096"
          ],
          "globals_used": [
            "Process *pids = NULL;",
            "int max_pids=32769;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\n#define PIDS_BUFLEN 4096\n\nProcess *pids = NULL;\nint max_pids=32769;\n\nvoid pid_read(pid_t mon_pid) {\n\tif (pids == NULL) {\n\t\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\t\tif (fp) {\n\t\t\tint val;\n\t\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\t\tif (val >= max_pids)\n\t\t\t\t\tmax_pids = val + 1;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tpids = malloc(sizeof(Process) * max_pids);\n\t\tif (pids == NULL)\n\t\t\terrExit(\"malloc\");\n\t}\n\tmemset(pids, 0, sizeof(Process) * max_pids);\n\tpid_t mypid = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpid_t child = -1;\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (child < 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == mypid)\n\t\t\tcontinue;\n\n\t\t// skip PID 1 just in case we run a sandbox-in-sandbox\n\t\tif (pid == 1)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[PIDS_BUFLEN];\n\t\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"Name:\", 5) == 0) {\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif ((strcmp(ptr, \"firejail\") == 0) && (mon_pid == 0 || mon_pid == pid)) {\n\t\t\t\t\tif (pid_proc_cmdline_x11_xpra_xephyr(pid))\n\t\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t}\n\t\t\tif (strncmp(buf, \"State:\", 6) == 0) {\n\t\t\t\tif (strstr(buf, \"(zombie)\"))\n\t\t\t\t\tpids[pid].zombie = 1;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tunsigned parent = atoi(ptr);\n\t\t\t\tparent %= max_pids;\n\t\t\t\tif (pids[parent].level > 0) {\n\t\t\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t\t\t}\n\t\t\t\tpids[pid].parent = parent;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\t\tchar *ptr = buf + 4;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tpids[pid].uid = atoi(ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\n\tpid_t pid;\n\tfor (pid = 0; pid < max_pids; pid++) {\n\t\tint parent = pids[pid].parent;\n\t\tif (pids[parent].level > 0) {\n\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"firemon.h\"\n\nvoid tree(pid_t pid) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (i == skip_process)\n\t\t\tcontinue;\n\t\tif (pids[i].level == 1)\n\t\t\tpid_print_tree(i, 0, arg_nowrap);\n\t}\n\tprintf(\"\\n\");\n}"
  }
]