[
  {
    "function_name": "interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/interface.c",
    "lines": "158-174",
    "snippet": "void interface(pid_t pid, int print_procs) {\n\tpid_read(pid); // a pid of 0 will include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1) {\n\t\t\t\tprint_sandbox(child);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <linux/sockios.h>",
      "#include <linux/if_link.h>",
      "#include <linux/netlink.h>",
      "#include <linux/connector.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_sandbox",
          "args": [
            "child"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "print_sandbox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/interface.c",
          "lines": "138-156",
          "snippet": "static void print_sandbox(pid_t pid) {\n\tpid_t child = fork();\n\tif (child == -1)\n\t\treturn;\n\n\tif (child == 0) {\n\t\tint rv = join_namespace(pid, \"net\");\n\t\tif (rv)\n\t\t\treturn;\n\t\tnet_ifprint();\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <linux/sockios.h>",
            "#include <linux/if_link.h>",
            "#include <linux/netlink.h>",
            "#include <linux/connector.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <linux/sockios.h>\n#include <linux/if_link.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"firemon.h\"\n\nstatic void print_sandbox(pid_t pid) {\n\tpid_t child = fork();\n\tif (child == -1)\n\t\treturn;\n\n\tif (child == 0) {\n\t\tint rv = join_namespace(pid, \"net\");\n\t\tif (rv)\n\t\t\treturn;\n\t\tnet_ifprint();\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_child",
          "args": [
            "i"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "65-87",
          "snippet": "int find_child(int id) {\n\tint i;\n\tint first_child = -1;\n\n\t// find the first child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 2 && pids[i].parent == id) {\n\t\t\tfirst_child = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (first_child == -1)\n\t\treturn -1;\n\n\t// find the second child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 3 && pids[i].parent == first_child)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nint find_child(int id) {\n\tint i;\n\tint first_child = -1;\n\n\t// find the first child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 2 && pids[i].parent == id) {\n\t\t\tfirst_child = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (first_child == -1)\n\t\treturn -1;\n\n\t// find the second child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 3 && pids[i].parent == first_child)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_print_list",
          "args": [
            "i",
            "arg_nowrap"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "pid_print_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "271-273",
          "snippet": "void pid_print_list(unsigned index, int nowrap) {\n\tprint_elem(index, nowrap);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\nvoid pid_print_list(unsigned index, int nowrap) {\n\tprint_elem(index, nowrap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_read",
          "args": [
            "pid"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "pid_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "304-428",
          "snippet": "void pid_read(pid_t mon_pid) {\n\tif (pids == NULL) {\n\t\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\t\tif (fp) {\n\t\t\tint val;\n\t\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\t\tif (val >= max_pids)\n\t\t\t\t\tmax_pids = val + 1;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tpids = malloc(sizeof(Process) * max_pids);\n\t\tif (pids == NULL)\n\t\t\terrExit(\"malloc\");\n\t}\n\tmemset(pids, 0, sizeof(Process) * max_pids);\n\tpid_t mypid = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpid_t child = -1;\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (child < 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == mypid)\n\t\t\tcontinue;\n\n\t\t// skip PID 1 just in case we run a sandbox-in-sandbox\n\t\tif (pid == 1)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[PIDS_BUFLEN];\n\t\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"Name:\", 5) == 0) {\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif ((strcmp(ptr, \"firejail\") == 0) && (mon_pid == 0 || mon_pid == pid)) {\n\t\t\t\t\tif (pid_proc_cmdline_x11_xpra_xephyr(pid))\n\t\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t}\n\t\t\tif (strncmp(buf, \"State:\", 6) == 0) {\n\t\t\t\tif (strstr(buf, \"(zombie)\"))\n\t\t\t\t\tpids[pid].zombie = 1;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tunsigned parent = atoi(ptr);\n\t\t\t\tparent %= max_pids;\n\t\t\t\tif (pids[parent].level > 0) {\n\t\t\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t\t\t}\n\t\t\t\tpids[pid].parent = parent;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\t\tchar *ptr = buf + 4;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tpids[pid].uid = atoi(ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\n\tpid_t pid;\n\tfor (pid = 0; pid < max_pids; pid++) {\n\t\tint parent = pids[pid].parent;\n\t\tif (pids[parent].level > 0) {\n\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [
            "#define PIDS_BUFLEN 4096"
          ],
          "globals_used": [
            "Process *pids = NULL;",
            "int max_pids=32769;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\n#define PIDS_BUFLEN 4096\n\nProcess *pids = NULL;\nint max_pids=32769;\n\nvoid pid_read(pid_t mon_pid) {\n\tif (pids == NULL) {\n\t\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\t\tif (fp) {\n\t\t\tint val;\n\t\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\t\tif (val >= max_pids)\n\t\t\t\t\tmax_pids = val + 1;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tpids = malloc(sizeof(Process) * max_pids);\n\t\tif (pids == NULL)\n\t\t\terrExit(\"malloc\");\n\t}\n\tmemset(pids, 0, sizeof(Process) * max_pids);\n\tpid_t mypid = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpid_t child = -1;\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (child < 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == mypid)\n\t\t\tcontinue;\n\n\t\t// skip PID 1 just in case we run a sandbox-in-sandbox\n\t\tif (pid == 1)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[PIDS_BUFLEN];\n\t\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"Name:\", 5) == 0) {\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif ((strcmp(ptr, \"firejail\") == 0) && (mon_pid == 0 || mon_pid == pid)) {\n\t\t\t\t\tif (pid_proc_cmdline_x11_xpra_xephyr(pid))\n\t\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t}\n\t\t\tif (strncmp(buf, \"State:\", 6) == 0) {\n\t\t\t\tif (strstr(buf, \"(zombie)\"))\n\t\t\t\t\tpids[pid].zombie = 1;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tunsigned parent = atoi(ptr);\n\t\t\t\tparent %= max_pids;\n\t\t\t\tif (pids[parent].level > 0) {\n\t\t\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t\t\t}\n\t\t\t\tpids[pid].parent = parent;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\t\tchar *ptr = buf + 4;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tpids[pid].uid = atoi(ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\n\tpid_t pid;\n\tfor (pid = 0; pid < max_pids; pid++) {\n\t\tint parent = pids[pid].parent;\n\t\tif (pids[parent].level > 0) {\n\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <linux/sockios.h>\n#include <linux/if_link.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"firemon.h\"\n\nvoid interface(pid_t pid, int print_procs) {\n\tpid_read(pid); // a pid of 0 will include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1) {\n\t\t\t\tprint_sandbox(child);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "print_sandbox",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/interface.c",
    "lines": "138-156",
    "snippet": "static void print_sandbox(pid_t pid) {\n\tpid_t child = fork();\n\tif (child == -1)\n\t\treturn;\n\n\tif (child == 0) {\n\t\tint rv = join_namespace(pid, \"net\");\n\t\tif (rv)\n\t\t\treturn;\n\t\tnet_ifprint();\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <linux/sockios.h>",
      "#include <linux/if_link.h>",
      "#include <linux/netlink.h>",
      "#include <linux/connector.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "0"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gcov_flush",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_ifprint",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "net_ifprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/interface.c",
          "lines": "37-136",
          "snippet": "static void net_ifprint(void) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tint fd;\n\tif ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\t\tfprintf(stderr, \"Error: cannot open AF_INET socket\\n\");\n\t\texit(1);\n\t}\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\t// walk through the linked list\n\tprintf(\"  Link status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_PACKET) {\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP) {\n\t\t\t\tif (ifa->ifa_data != NULL) {\n\t\t\t\t\tstruct rtnl_link_stats *stats = ifa->ifa_data;\n\n\t\t\t\t\t// extract mac address\n\t\t\t\t\tstruct ifreq ifr;\n\t\t\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\t\t\tstrncpy(ifr.ifr_name,  ifa->ifa_name, IFNAMSIZ - 1);\n\t\t\t\t\tint rv = ioctl (fd, SIOCGIFHWADDR, &ifr);\n\n\t\t\t\t\tif (rv == 0)\n\t\t\t\t\t\tprintf(\"     %s UP, %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\t\t\t\t\tifa->ifa_name, PRINT_MAC((unsigned char *) &ifr.ifr_hwaddr.sa_data));\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"     %s UP\\n\", ifa->ifa_name);\n\n\t\t\t\t\tprintf(\"          tx/rx: %u/%u packets,  %u/%u bytes\\n\",\n\t\t\t\t\t\tstats->tx_packets, stats->rx_packets,\n\t\t\t\t\t\tstats->tx_bytes, stats->rx_bytes);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"     %s DOWN\\n\", ifa->ifa_name);\n\t\t}\n\t}\n\n\n\t// walk through the linked list\n\tprintf(\"  IPv4 status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\tprintf(\"     %s %s, %d.%d.%d.%d/%u\\n\",\n\t\t\t\tifa->ifa_name, status, PRINT_IP(ip), mask2bits(mask));\n\t\t}\n\t}\n\n\n\t// walk through the linked list\n\tprintf(\"  IPv6 status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET6) {\n\t\t\tchar host[NI_MAXHOST];\n\t\t\tint s = getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in6),\n\t\t\t\thost, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);\n\t\t\tif (s == 0) {\n\t\t\t\tchar *ptr;\n\t\t\t\tif ((ptr = strchr(host, '%')) != NULL)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tchar *status;\n\t\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\t\tstatus = \"UP\";\n\t\t\t\telse\n\t\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t\tprintf(\"     %s %s, %s\\n\", ifa->ifa_name, status, host);\n\t\t\t}\n\t\t}\n\t}\n\n\tfreeifaddrs(ifaddr);\n\tclose(fd);\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <linux/sockios.h>",
            "#include <linux/if_link.h>",
            "#include <linux/netlink.h>",
            "#include <linux/connector.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <linux/sockios.h>\n#include <linux/if_link.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"firemon.h\"\n\nstatic void net_ifprint(void) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tint fd;\n\tif ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\t\tfprintf(stderr, \"Error: cannot open AF_INET socket\\n\");\n\t\texit(1);\n\t}\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\t// walk through the linked list\n\tprintf(\"  Link status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_PACKET) {\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP) {\n\t\t\t\tif (ifa->ifa_data != NULL) {\n\t\t\t\t\tstruct rtnl_link_stats *stats = ifa->ifa_data;\n\n\t\t\t\t\t// extract mac address\n\t\t\t\t\tstruct ifreq ifr;\n\t\t\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\t\t\tstrncpy(ifr.ifr_name,  ifa->ifa_name, IFNAMSIZ - 1);\n\t\t\t\t\tint rv = ioctl (fd, SIOCGIFHWADDR, &ifr);\n\n\t\t\t\t\tif (rv == 0)\n\t\t\t\t\t\tprintf(\"     %s UP, %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\t\t\t\t\tifa->ifa_name, PRINT_MAC((unsigned char *) &ifr.ifr_hwaddr.sa_data));\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"     %s UP\\n\", ifa->ifa_name);\n\n\t\t\t\t\tprintf(\"          tx/rx: %u/%u packets,  %u/%u bytes\\n\",\n\t\t\t\t\t\tstats->tx_packets, stats->rx_packets,\n\t\t\t\t\t\tstats->tx_bytes, stats->rx_bytes);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"     %s DOWN\\n\", ifa->ifa_name);\n\t\t}\n\t}\n\n\n\t// walk through the linked list\n\tprintf(\"  IPv4 status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\tprintf(\"     %s %s, %d.%d.%d.%d/%u\\n\",\n\t\t\t\tifa->ifa_name, status, PRINT_IP(ip), mask2bits(mask));\n\t\t}\n\t}\n\n\n\t// walk through the linked list\n\tprintf(\"  IPv6 status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET6) {\n\t\t\tchar host[NI_MAXHOST];\n\t\t\tint s = getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in6),\n\t\t\t\thost, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);\n\t\t\tif (s == 0) {\n\t\t\t\tchar *ptr;\n\t\t\t\tif ((ptr = strchr(host, '%')) != NULL)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tchar *status;\n\t\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\t\tstatus = \"UP\";\n\t\t\t\telse\n\t\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t\tprintf(\"     %s %s, %s\\n\", ifa->ifa_name, status, host);\n\t\t\t}\n\t\t}\n\t}\n\n\tfreeifaddrs(ifaddr);\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "pid",
            "\"net\""
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "join_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "36-59",
          "snippet": "int join_namespace(pid_t pid, char *type) {\n\tchar *path;\n\tif (asprintf(&path, \"/proc/%u/ns/%s\", pid, type) == -1)\n\t\terrExit(\"asprintf\");\n\n\tint fd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto errout;\n\n\tif (syscall(__NR_setns, fd, 0) < 0) {\n\t\tclose(fd);\n\t\tgoto errout;\n\t}\n\n\tclose(fd);\n\tfree(path);\n\treturn 0;\n\nerrout:\n\tfree(path);\n\tfprintf(stderr, \"Error: cannot join namespace %s\\\\n\", type);\n\treturn -1;\n\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nint join_namespace(pid_t pid, char *type) {\n\tchar *path;\n\tif (asprintf(&path, \"/proc/%u/ns/%s\", pid, type) == -1)\n\t\terrExit(\"asprintf\");\n\n\tint fd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto errout;\n\n\tif (syscall(__NR_setns, fd, 0) < 0) {\n\t\tclose(fd);\n\t\tgoto errout;\n\t}\n\n\tclose(fd);\n\tfree(path);\n\treturn 0;\n\nerrout:\n\tfree(path);\n\tfprintf(stderr, \"Error: cannot join namespace %s\\\\n\", type);\n\treturn -1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <linux/sockios.h>\n#include <linux/if_link.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"firemon.h\"\n\nstatic void print_sandbox(pid_t pid) {\n\tpid_t child = fork();\n\tif (child == -1)\n\t\treturn;\n\n\tif (child == 0) {\n\t\tint rv = join_namespace(pid, \"net\");\n\t\tif (rv)\n\t\t\treturn;\n\t\tnet_ifprint();\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
  },
  {
    "function_name": "net_ifprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/interface.c",
    "lines": "37-136",
    "snippet": "static void net_ifprint(void) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tint fd;\n\tif ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\t\tfprintf(stderr, \"Error: cannot open AF_INET socket\\n\");\n\t\texit(1);\n\t}\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\t// walk through the linked list\n\tprintf(\"  Link status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_PACKET) {\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP) {\n\t\t\t\tif (ifa->ifa_data != NULL) {\n\t\t\t\t\tstruct rtnl_link_stats *stats = ifa->ifa_data;\n\n\t\t\t\t\t// extract mac address\n\t\t\t\t\tstruct ifreq ifr;\n\t\t\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\t\t\tstrncpy(ifr.ifr_name,  ifa->ifa_name, IFNAMSIZ - 1);\n\t\t\t\t\tint rv = ioctl (fd, SIOCGIFHWADDR, &ifr);\n\n\t\t\t\t\tif (rv == 0)\n\t\t\t\t\t\tprintf(\"     %s UP, %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\t\t\t\t\tifa->ifa_name, PRINT_MAC((unsigned char *) &ifr.ifr_hwaddr.sa_data));\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"     %s UP\\n\", ifa->ifa_name);\n\n\t\t\t\t\tprintf(\"          tx/rx: %u/%u packets,  %u/%u bytes\\n\",\n\t\t\t\t\t\tstats->tx_packets, stats->rx_packets,\n\t\t\t\t\t\tstats->tx_bytes, stats->rx_bytes);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"     %s DOWN\\n\", ifa->ifa_name);\n\t\t}\n\t}\n\n\n\t// walk through the linked list\n\tprintf(\"  IPv4 status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\tprintf(\"     %s %s, %d.%d.%d.%d/%u\\n\",\n\t\t\t\tifa->ifa_name, status, PRINT_IP(ip), mask2bits(mask));\n\t\t}\n\t}\n\n\n\t// walk through the linked list\n\tprintf(\"  IPv6 status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET6) {\n\t\t\tchar host[NI_MAXHOST];\n\t\t\tint s = getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in6),\n\t\t\t\thost, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);\n\t\t\tif (s == 0) {\n\t\t\t\tchar *ptr;\n\t\t\t\tif ((ptr = strchr(host, '%')) != NULL)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tchar *status;\n\t\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\t\tstatus = \"UP\";\n\t\t\t\telse\n\t\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t\tprintf(\"     %s %s, %s\\n\", ifa->ifa_name, status, host);\n\t\t\t}\n\t\t}\n\t}\n\n\tfreeifaddrs(ifaddr);\n\tclose(fd);\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <linux/sockios.h>",
      "#include <linux/if_link.h>",
      "#include <linux/netlink.h>",
      "#include <linux/connector.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "ifaddr"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"     %s %s, %s\\n\"",
            "ifa->ifa_name",
            "status",
            "host"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "host",
            "'%'"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "ifa->ifa_addr",
            "sizeof(struct sockaddr_in6)",
            "host",
            "NI_MAXHOST",
            "NULL",
            "0",
            "NI_NUMERICHOST"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  IPv6 status:\\n\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"     %s %s, %d.%d.%d.%d/%u\\n\"",
            "ifa->ifa_name",
            "status",
            "PRINT_IP(ip)",
            "mask2bits(mask)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mask2bits",
          "args": [
            "mask"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "mask2bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "47-59",
          "snippet": "static inline uint8_t mask2bits(uint32_t mask) {\n\tuint32_t tmp = 0x80000000;\n\tint i;\n\tuint8_t rv = 0;\n\n\tfor (i = 0; i < 32; i++, tmp >>= 1) {\n\t\tif (tmp & mask)\n\t\t\trv++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline uint8_t mask2bits(uint32_t mask) {\n\tuint32_t tmp = 0x80000000;\n\tint i;\n\tuint8_t rv = 0;\n\n\tfor (i = 0; i < 32; i++, tmp >>= 1) {\n\t\tif (tmp & mask)\n\t\t\trv++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "ip"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "si->sin_addr.s_addr"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "si->sin_addr.s_addr"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  IPv4 status:\\n\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"     %s DOWN\\n\"",
            "ifa->ifa_name"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"          tx/rx: %u/%u packets,  %u/%u bytes\\n\"",
            "stats->tx_packets",
            "stats->rx_packets",
            "stats->tx_bytes",
            "stats->rx_bytes"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"     %s UP\\n\"",
            "ifa->ifa_name"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"     %s UP, %02x:%02x:%02x:%02x:%02x:%02x\\n\"",
            "ifa->ifa_name",
            "PRINT_MAC((unsigned char *) &ifr.ifr_hwaddr.sa_data)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_MAC",
          "args": [
            "(unsigned char *) &ifr.ifr_hwaddr.sa_data"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "SIOCGIFHWADDR",
            "&ifr"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifa->ifa_name",
            "IFNAMSIZ - 1"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  Link status:\\n\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"getifaddrs\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&ifaddr"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open AF_INET socket\\n\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <linux/sockios.h>\n#include <linux/if_link.h>\n#include <linux/netlink.h>\n#include <linux/connector.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"firemon.h\"\n\nstatic void net_ifprint(void) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tint fd;\n\tif ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\t\tfprintf(stderr, \"Error: cannot open AF_INET socket\\n\");\n\t\texit(1);\n\t}\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\t// walk through the linked list\n\tprintf(\"  Link status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_PACKET) {\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP) {\n\t\t\t\tif (ifa->ifa_data != NULL) {\n\t\t\t\t\tstruct rtnl_link_stats *stats = ifa->ifa_data;\n\n\t\t\t\t\t// extract mac address\n\t\t\t\t\tstruct ifreq ifr;\n\t\t\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\t\t\tstrncpy(ifr.ifr_name,  ifa->ifa_name, IFNAMSIZ - 1);\n\t\t\t\t\tint rv = ioctl (fd, SIOCGIFHWADDR, &ifr);\n\n\t\t\t\t\tif (rv == 0)\n\t\t\t\t\t\tprintf(\"     %s UP, %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\t\t\t\t\tifa->ifa_name, PRINT_MAC((unsigned char *) &ifr.ifr_hwaddr.sa_data));\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"     %s UP\\n\", ifa->ifa_name);\n\n\t\t\t\t\tprintf(\"          tx/rx: %u/%u packets,  %u/%u bytes\\n\",\n\t\t\t\t\t\tstats->tx_packets, stats->rx_packets,\n\t\t\t\t\t\tstats->tx_bytes, stats->rx_bytes);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"     %s DOWN\\n\", ifa->ifa_name);\n\t\t}\n\t}\n\n\n\t// walk through the linked list\n\tprintf(\"  IPv4 status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\tprintf(\"     %s %s, %d.%d.%d.%d/%u\\n\",\n\t\t\t\tifa->ifa_name, status, PRINT_IP(ip), mask2bits(mask));\n\t\t}\n\t}\n\n\n\t// walk through the linked list\n\tprintf(\"  IPv6 status:\\n\");\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET6) {\n\t\t\tchar host[NI_MAXHOST];\n\t\t\tint s = getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in6),\n\t\t\t\thost, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);\n\t\t\tif (s == 0) {\n\t\t\t\tchar *ptr;\n\t\t\t\tif ((ptr = strchr(host, '%')) != NULL)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tchar *status;\n\t\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\t\tstatus = \"UP\";\n\t\t\t\telse\n\t\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t\tprintf(\"     %s %s, %s\\n\", ifa->ifa_name, status, host);\n\t\t\t}\n\t\t}\n\t}\n\n\tfreeifaddrs(ifaddr);\n\tclose(fd);\n}"
  }
]