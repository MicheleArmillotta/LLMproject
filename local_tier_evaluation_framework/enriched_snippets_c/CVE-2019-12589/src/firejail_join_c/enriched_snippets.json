[
  {
    "function_name": "join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "288-491",
    "snippet": "void join(pid_t pid, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\n\tpid_t parent = pid;\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(pid)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\textract_x11_display(parent);\n\n\tEUID_ROOT();\n\t// in user mode set caps seccomp, cpu, cgroup, etc\n\tif (getuid() != 0) {\n\t\textract_nonewprivs(pid);  // redundant on Linux >= 4.10; duplicated in function extract_caps\n\t\textract_caps(pid);\n\t\textract_cpu(pid);\n\t\textract_cgroup(pid);\n\t\textract_nogroups(pid);\n\t\textract_user_namespace(pid);\n\t}\n\n\t// set cgroup\n\tif (cfg.cgroup)\t// not available for uid 0\n\t\tset_cgroup(cfg.cgroup);\n\n\t// set umask, also uid 0\n\textract_umask(pid);\n\n\t// join namespaces\n\tif (arg_join_network) {\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t}\n\telse if (arg_join_filesystem) {\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\telse {\n\t\tif (join_namespace(pid, \"ipc\") ||\n\t\t    join_namespace(pid, \"net\") ||\n\t\t    join_namespace(pid, \"pid\") ||\n\t\t    join_namespace(pid, \"uts\") ||\n\t\t    join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop discretionary access control capabilities for root sandboxes\n\t\tcaps_drop_dac_override();\n\n\t\t// chroot into /proc/PID/root directory\n\t\tchar *rootdir;\n\t\tif (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tint rv;\n\t\tif (!arg_join_network) {\n\t\t\trv = chroot(rootdir); // this will fail for processes in sandboxes not started with --chroot option\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"changing root to %s\\n\", rootdir);\n\t\t}\n\n\t\tEUID_USER();\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\n\t\t// set caps filter\n\t\tEUID_ROOT();\n\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\tcaps_set(caps);\n#ifdef HAVE_SECCOMP\n\t\tif (getuid() != 0)\n\t\t\tseccomp_load_file_list();\n#endif\n\n\t\t// mount user namespace or drop privileges\n\t\tif (arg_noroot) {\t// not available for uid 0\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Joining user namespace\\n\");\n\t\t\tif (join_namespace(1, \"user\"))\n\t\t\t\texit(1);\n\n\t\t\t// user namespace resets capabilities\n\t\t\t// set caps filter\n\t\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\t\tcaps_set(caps);\n\t\t}\n\n\t\t// set nonewprivs\n\t\tif (arg_nonewprivs == 1) {\t// not available for uid 0\n\t\t\tint rv = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\t\t\tif (arg_debug && rv == 0)\n\t\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t\t}\n\n\t\tEUID_USER();\n\t\tint cwd = 0;\n\t\tif (cfg.cwd) {\n\t\t\tif (chdir(cfg.cwd) == 0)\n\t\t\t\tcwd = 1;\n\t\t}\n\n\t\tif (!cwd) {\n\t\t\tif (chdir(\"/\") < 0)\n\t\t\t\terrExit(\"chdir\");\n\t\t\tif (cfg.homedir) {\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t\t/* coverity[toctou] */\n\t\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\t\terrExit(\"chdir\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// drop privileges\n\t\tdrop_privs(arg_nogroups);\n\n\t\t// kill the child in case the parent died\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t\textract_command(argc, argv, index);\n\t\tif (cfg.command_line == NULL) {\n\t\t\tassert(cfg.shell);\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t}\n\t\tif (arg_debug)\n\t\t\tprintf(\"Extracted command #%s#\\n\", cfg.command_line);\n\n\t\t// set cpu affinity\n\t\tif (cfg.cpus)\t// not available for uid 0\n\t\t\tset_cpu_affinity();\n\n\t\t// set nice value\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\n\t\t// add x11 display\n\t\tif (display) {\n\t\t\tchar *display_str;\n\t\t\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tsetenv(\"DISPLAY\", display_str, 1);\n\t\t\tfree(display_str);\n\t\t}\n\n\t\tstart_application(0, NULL);\n\n\t\t// it will never get here!!!\n\t}\n\n\tint status = 0;\n\t//*****************************\n\t// following code is signal-safe\n\n\tinstall_handler();\n\n\t// wait for the child to finish\n\twaitpid(child, &status, 0);\n\n\t// restore default signal action\n\tsignal(SIGTERM, SIG_DFL);\n\n\t// end of signal-safe code\n\t//*****************************\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\tstatus = WEXITSTATUS(status);\n\t} else if (WIFSIGNALED(status)) {\n\t\tstatus = WTERMSIG(status);\n\t} else {\n\t\tstatus = 0;\n\t}\n\n\texit(status);\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int apply_caps = 0;",
      "static uint64_t caps = 0;",
      "static unsigned display = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "status"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_stdin",
          "args": [],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "flush_stdin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "959-969",
          "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "SIG_DFL"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&status",
            "0"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "install_handler",
          "args": [],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "install_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "43-51",
          "snippet": "static void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// handle SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsga.sa_handler = signal_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// handle SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsga.sa_handler = signal_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_application",
          "args": [
            "0",
            "NULL"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "start_application",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "432-566",
          "snippet": "void start_application(int no_sandbox, FILE *fp) {\n\t// set environment\n\tif (no_sandbox == 0) {\n\t\tenv_defaults();\n\t\tenv_apply();\n\t}\n\t// restore original umask\n\tumask(orig_umask);\n\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tint rv = ok_to_run(cfg.original_argv[cfg.original_program_index]);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\tif (rv)\n\t\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: no suitable %s executable found\\n\", cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid start_application(int no_sandbox, FILE *fp) {\n\t// set environment\n\tif (no_sandbox == 0) {\n\t\tenv_defaults();\n\t\tenv_apply();\n\t}\n\t// restore original umask\n\tumask(orig_umask);\n\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tint rv = ok_to_run(cfg.original_argv[cfg.original_program_index]);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\tif (rv)\n\t\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: no suitable %s executable found\\n\", cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "display_str"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"DISPLAY\"",
            "display_str",
            "1"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&display_str",
            "\":%d\"",
            "display"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nice",
          "args": [
            "cfg.nice"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "set_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "254-260",
          "snippet": "void set_nice(int inc) {\n\terrno = 0;\n\tint rv = nice(inc);\n\t(void) rv;\n\tif (errno)\n\t\tfwarning(\"cannot set nice value\\n\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid set_nice(int inc) {\n\terrno = 0;\n\tint rv = nice(inc);\n\t(void) rv;\n\tif (errno)\n\t\tfwarning(\"cannot set nice value\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_affinity",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_affinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cpu.c",
          "lines": "106-132",
          "snippet": "void set_cpu_affinity(void) {\n\t// set cpu affinity\n\tcpu_set_t mask;\n\tCPU_ZERO(&mask);\n\n\tint i;\n\tuint32_t m = 1;\n\tfor (i = 0; i < 32; i++, m <<= 1) {\n\t\tif (cfg.cpus & m)\n\t\t\tCPU_SET(i, &mask);\n\t}\n\n\tif (sched_setaffinity(0, sizeof(mask), &mask) == -1)\n\t\tfwarning(\"cannot set cpu affinity\\n\");\n\n        \t// verify cpu affinity\n\tcpu_set_t mask2;\n\tCPU_ZERO(&mask2);\n\tif (sched_getaffinity(0, sizeof(mask2), &mask2) == -1)\n\t\tfwarning(\"cannot verify cpu affinity\\n\");\n        \telse if (arg_debug) {\n\t        \tif (CPU_EQUAL(&mask, &mask2))\n        \t\t\tprintf(\"CPU affinity set\\n\");\n\t\telse\n        \t\t\tprintf(\"CPU affinity not set\\n\");\n        \t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <sched.h>\n#include \"firejail.h\"\n\nvoid set_cpu_affinity(void) {\n\t// set cpu affinity\n\tcpu_set_t mask;\n\tCPU_ZERO(&mask);\n\n\tint i;\n\tuint32_t m = 1;\n\tfor (i = 0; i < 32; i++, m <<= 1) {\n\t\tif (cfg.cpus & m)\n\t\t\tCPU_SET(i, &mask);\n\t}\n\n\tif (sched_setaffinity(0, sizeof(mask), &mask) == -1)\n\t\tfwarning(\"cannot set cpu affinity\\n\");\n\n        \t// verify cpu affinity\n\tcpu_set_t mask2;\n\tCPU_ZERO(&mask2);\n\tif (sched_getaffinity(0, sizeof(mask2), &mask2) == -1)\n\t\tfwarning(\"cannot verify cpu affinity\\n\");\n        \telse if (arg_debug) {\n\t        \tif (CPU_EQUAL(&mask, &mask2))\n        \t\t\tprintf(\"CPU affinity set\\n\");\n\t\telse\n        \t\t\tprintf(\"CPU affinity not set\\n\");\n        \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Extracted command #%s#\\n\"",
            "cfg.command_line"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cfg.shell"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_command",
          "args": [
            "argc",
            "argv",
            "index"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "extract_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "82-103",
          "snippet": "static void extract_command(int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tif (index >= argc)\n\t\treturn;\n\n\t// doubledash followed by positional parameters\n\tif (strcmp(argv[index], \"--\") == 0) {\n\t\targ_doubledash = 1;\n\t\tindex++;\n\t\tif (index >= argc)\n\t\t\treturn;\n\t}\n\n\t// first argv needs to be a valid command\n\tif (arg_doubledash == 0 && *argv[index] == '-') {\n\t\tfprintf(stderr, \"Error: invalid option %s after --join\\n\", argv[index]);\n\t\texit(1);\n\t}\n\n\t// build command\n\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, index);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_command(int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tif (index >= argc)\n\t\treturn;\n\n\t// doubledash followed by positional parameters\n\tif (strcmp(argv[index], \"--\") == 0) {\n\t\targ_doubledash = 1;\n\t\tindex++;\n\t\tif (index >= argc)\n\t\t\treturn;\n\t}\n\n\t// first argv needs to be a valid command\n\tif (arg_doubledash == 0 && *argv[index] == '-') {\n\t\tfprintf(stderr, \"Error: invalid option %s after --join\\n\", argv[index]);\n\t\texit(1);\n\t}\n\n\t// build command\n\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_PDEATHSIG",
            "SIGKILL",
            "0",
            "0",
            "0"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "arg_nogroups"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "121-142",
          "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "cfg.homedir"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "fchdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "684-708",
          "snippet": "int fchdir(int fd) {\n#ifdef DEBUG\n\tprintf(\"%s %d\\n\", __FUNCTION__, fd);\n#endif\n\tif (!orig_fchdir)\n\t\torig_fchdir = (orig_fchdir_t)dlsym(RTLD_NEXT, \"fchdir\");\n\n\tfree(cwd);\n\tchar *pathname=malloc(PATH_MAX);\n\tif (pathname) {\n\t\tif (snprintf(pathname,PATH_MAX,\"/proc/self/fd/%d\", fd)>0) {\n\t\t\tcwd = realpath(pathname, NULL);\n\t\t} else {\n\t\t\tcwd = NULL;\n\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t}\n\t\tfree(pathname);\n\t} else {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tcwd = NULL;\n\t}\n\n\tint rv = orig_fchdir(fd);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char* cwd = NULL;",
            "static orig_fchdir_t orig_fchdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char* cwd = NULL;\nstatic orig_fchdir_t orig_fchdir = NULL;\n\nint fchdir(int fd) {\n#ifdef DEBUG\n\tprintf(\"%s %d\\n\", __FUNCTION__, fd);\n#endif\n\tif (!orig_fchdir)\n\t\torig_fchdir = (orig_fchdir_t)dlsym(RTLD_NEXT, \"fchdir\");\n\n\tfree(cwd);\n\tchar *pathname=malloc(PATH_MAX);\n\tif (pathname) {\n\t\tif (snprintf(pathname,PATH_MAX,\"/proc/self/fd/%d\", fd)>0) {\n\t\t\tcwd = realpath(pathname, NULL);\n\t\t} else {\n\t\t\tcwd = NULL;\n\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t}\n\t\tfree(pathname);\n\t} else {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tcwd = NULL;\n\t}\n\n\tint rv = orig_fchdir(fd);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cfg.homedir",
            "&s"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"NO_NEW_PRIVS set\\n\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_NO_NEW_PRIVS",
            "1",
            "0",
            "0",
            "0"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "caps_set",
          "args": [
            "caps"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "caps_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/caps.c",
          "lines": "346-349",
          "snippet": "static void caps_set_bit(int nr) {\n\tuint64_t mask = 1LLU << nr;\n\tfilter |= mask;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t filter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nstatic uint64_t filter;\n\nstatic void caps_set_bit(int nr) {\n\tuint64_t mask = 1LLU << nr;\n\tfilter |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "1",
            "\"user\""
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "join_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "36-59",
          "snippet": "int join_namespace(pid_t pid, char *type) {\n\tchar *path;\n\tif (asprintf(&path, \"/proc/%u/ns/%s\", pid, type) == -1)\n\t\terrExit(\"asprintf\");\n\n\tint fd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto errout;\n\n\tif (syscall(__NR_setns, fd, 0) < 0) {\n\t\tclose(fd);\n\t\tgoto errout;\n\t}\n\n\tclose(fd);\n\tfree(path);\n\treturn 0;\n\nerrout:\n\tfree(path);\n\tfprintf(stderr, \"Error: cannot join namespace %s\\\\n\", type);\n\treturn -1;\n\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nint join_namespace(pid_t pid, char *type) {\n\tchar *path;\n\tif (asprintf(&path, \"/proc/%u/ns/%s\", pid, type) == -1)\n\t\terrExit(\"asprintf\");\n\n\tint fd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto errout;\n\n\tif (syscall(__NR_setns, fd, 0) < 0) {\n\t\tclose(fd);\n\t\tgoto errout;\n\t}\n\n\tclose(fd);\n\tfree(path);\n\treturn 0;\n\nerrout:\n\tfree(path);\n\tfprintf(stderr, \"Error: cannot join namespace %s\\\\n\", type);\n\treturn -1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Joining user namespace\\n\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_load_file_list",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_load_file_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/seccomp.c",
          "lines": "101-118",
          "snippet": "void seccomp_load_file_list(void) {\n\tFILE *fp = fopen(RUN_SECCOMP_LIST, \"r\");\n\tif (!fp)\n\t\treturn; // no seccomp configuration whatsoever\n\n\tload_file_list_flag = 1;\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tseccomp_load(buf);\n\t}\n\n\tfclose(fp);\n\tload_file_list_flag = 0;\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"firejail.h\"\n\n#define MAXBUF 4096\n\nvoid seccomp_load_file_list(void) {\n\tFILE *fp = fopen(RUN_SECCOMP_LIST, \"r\");\n\tif (!fp)\n\t\treturn; // no seccomp configuration whatsoever\n\n\tload_file_list_flag = 1;\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tseccomp_load(buf);\n\t}\n\n\tfclose(fp);\n\tload_file_list_flag = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"changing root to %s\\n\"",
            "rootdir"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "rootdir"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "fs_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "1366-1497",
          "snippet": "void fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&rootdir",
            "\"/proc/%d/root\"",
            "pid"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "caps_drop_dac_override",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "caps_drop_dac_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/caps.c",
          "lines": "252-262",
          "snippet": "void caps_drop_dac_override(void) {\n\tif (getuid() == 0 && !arg_noprofile) {\n\t\tif (prctl(PR_CAPBSET_DROP, CAP_DAC_OVERRIDE, 0, 0, 0));\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Drop CAP_DAC_OVERRIDE\\n\");\n\n\t\tif (prctl(PR_CAPBSET_DROP, CAP_DAC_READ_SEARCH, 0, 0, 0));\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Drop CAP_DAC_READ_SEARCH\\n\");\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nvoid caps_drop_dac_override(void) {\n\tif (getuid() == 0 && !arg_noprofile) {\n\t\tif (prctl(PR_CAPBSET_DROP, CAP_DAC_OVERRIDE, 0, 0, 0));\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Drop CAP_DAC_OVERRIDE\\n\");\n\n\t\tif (prctl(PR_CAPBSET_DROP, CAP_DAC_READ_SEARCH, 0, 0, 0));\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Drop CAP_DAC_READ_SEARCH\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_umask",
          "args": [
            "pid"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "extract_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "240-256",
          "snippet": "static void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cgroup",
          "args": [
            "cfg.cgroup"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "set_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cgroup.c",
          "lines": "72-119",
          "snippet": "void set_cgroup(const char *path) {\n\tEUID_ASSERT();\n\n\tinvalid_filename(path, 0); // no globbing\n\n\t// path starts with /sys/fs/cgroup\n\tif (strncmp(path, \"/sys/fs/cgroup\", 14) != 0)\n\t\tgoto errout;\n\n\t// path ends in tasks\n\tchar *ptr = strstr(path, \"tasks\");\n\tif (!ptr)\n\t\tgoto errout;\n\tif (*(ptr + 5) != '\\0')\n\t\tgoto errout;\n\n\t// no .. traversal\n\tptr = strstr(path, \"..\");\n\tif (ptr)\n\t\tgoto errout;\n\n\t// tasks file exists\n\tstruct stat s;\n\tif (stat(path, &s) == -1)\n\t\tgoto errout;\n\n\t// task file belongs to the user running the sandbox\n\tif (s.st_uid != getuid() && s.st_gid != getgid())\n\t\tgoto errout2;\n\n\t// add the task to cgroup\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(path,\t\"a\");\n\tif (!fp)\n\t\tgoto errout;\n\tpid_t pid = getpid();\n\tint rv = fprintf(fp, \"%d\\n\", pid);\n\t(void) rv;\n\tfclose(fp);\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: invalid cgroup\\n\");\n\texit(1);\nerrout2:\n\tfprintf(stderr, \"Error: you don't have permissions to use this control group\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nvoid set_cgroup(const char *path) {\n\tEUID_ASSERT();\n\n\tinvalid_filename(path, 0); // no globbing\n\n\t// path starts with /sys/fs/cgroup\n\tif (strncmp(path, \"/sys/fs/cgroup\", 14) != 0)\n\t\tgoto errout;\n\n\t// path ends in tasks\n\tchar *ptr = strstr(path, \"tasks\");\n\tif (!ptr)\n\t\tgoto errout;\n\tif (*(ptr + 5) != '\\0')\n\t\tgoto errout;\n\n\t// no .. traversal\n\tptr = strstr(path, \"..\");\n\tif (ptr)\n\t\tgoto errout;\n\n\t// tasks file exists\n\tstruct stat s;\n\tif (stat(path, &s) == -1)\n\t\tgoto errout;\n\n\t// task file belongs to the user running the sandbox\n\tif (s.st_uid != getuid() && s.st_gid != getgid())\n\t\tgoto errout2;\n\n\t// add the task to cgroup\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(path,\t\"a\");\n\tif (!fp)\n\t\tgoto errout;\n\tpid_t pid = getpid();\n\tint rv = fprintf(fp, \"%d\\n\", pid);\n\t(void) rv;\n\tfclose(fp);\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: invalid cgroup\\n\");\n\texit(1);\nerrout2:\n\tfprintf(stderr, \"Error: you don't have permissions to use this control group\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_user_namespace",
          "args": [
            "pid"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "extract_user_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "206-238",
          "snippet": "static void extract_user_namespace(pid_t pid) {\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0);\n\telse\n\t\treturn;\n\n\t// read uid map\n\tchar *uidmap;\n\tif (asprintf(&uidmap, \"/proc/%u/uid_map\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(uidmap, \"r\");\n\tif (!fp) {\n\t\tfree(uidmap);\n\t\treturn;\n\t}\n\n\t// check uid map\n\tint u1;\n\tint u2;\n\tif (fscanf(fp, \"%d %d\", &u1, &u2) == 2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"User namespace detected: %s, %d, %d\\n\", uidmap, u1, u2);\n\t\tif (u1 != 0 || u2 != 0)\n\t\t\targ_noroot = 1;\n\t}\n\tfclose(fp);\n\tfree(uidmap);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_user_namespace(pid_t pid) {\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0);\n\telse\n\t\treturn;\n\n\t// read uid map\n\tchar *uidmap;\n\tif (asprintf(&uidmap, \"/proc/%u/uid_map\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(uidmap, \"r\");\n\tif (!fp) {\n\t\tfree(uidmap);\n\t\treturn;\n\t}\n\n\t// check uid map\n\tint u1;\n\tint u2;\n\tif (fscanf(fp, \"%d %d\", &u1, &u2) == 2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"User namespace detected: %s, %d, %d\\n\", uidmap, u1, u2);\n\t\tif (u1 != 0 || u2 != 0)\n\t\t\targ_noroot = 1;\n\t}\n\tfclose(fp);\n\tfree(uidmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_nogroups",
          "args": [
            "pid"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "extract_nogroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "105-118",
          "snippet": "static void extract_nogroups(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_GROUPS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\targ_nogroups = 1;\n\tfree(fname);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_nogroups(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_GROUPS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\targ_nogroups = 1;\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_cgroup",
          "args": [
            "pid"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "extract_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "151-165",
          "snippet": "static void extract_cgroup(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CGROUP_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// there is a cgroup file CGROUP_CFG, load it!\n\tload_cgroup(fname);\n\tfree(fname);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_cgroup(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CGROUP_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// there is a cgroup file CGROUP_CFG, load it!\n\tload_cgroup(fname);\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_cpu",
          "args": [
            "pid"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "extract_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "135-149",
          "snippet": "static void extract_cpu(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CPU_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// there is a CPU_CFG file, load it!\n\tload_cpu(fname);\n\tfree(fname);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_cpu(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CPU_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// there is a CPU_CFG file, load it!\n\tload_cpu(fname);\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_caps",
          "args": [
            "pid"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "extract_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "167-204",
          "snippet": "static void extract_caps(pid_t pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp)\n\t\tgoto errexit;\n\n\tchar buf[BUFLEN];\n\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"CapBnd:\", 7) == 0) {\n\t\t\tchar *ptr = buf + 7;\n\t\t\tunsigned long long val;\n\t\t\tif (sscanf(ptr, \"%llx\", &val) != 1)\n\t\t\t\tgoto errexit;\n\t\t\tapply_caps = 1;\n\t\t\tcaps = val;\n\t\t}\n\t\telse if (strncmp(buf, \"NoNewPrivs:\", 11) == 0) {\n\t\t\tchar *ptr = buf + 11;\n\t\t\tint val;\n\t\t\tif (sscanf(ptr, \"%d\", &val) != 1)\n\t\t\t\tgoto errexit;\n\t\t\tif (val)\n\t\t\t\targ_nonewprivs = 1;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot read stat file for process %u\\n\", pid);\n\texit(1);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [
            "static int apply_caps = 0;",
            "static uint64_t caps = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nstatic int apply_caps = 0;\nstatic uint64_t caps = 0;\n\nstatic void extract_caps(pid_t pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp)\n\t\tgoto errexit;\n\n\tchar buf[BUFLEN];\n\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"CapBnd:\", 7) == 0) {\n\t\t\tchar *ptr = buf + 7;\n\t\t\tunsigned long long val;\n\t\t\tif (sscanf(ptr, \"%llx\", &val) != 1)\n\t\t\t\tgoto errexit;\n\t\t\tapply_caps = 1;\n\t\t\tcaps = val;\n\t\t}\n\t\telse if (strncmp(buf, \"NoNewPrivs:\", 11) == 0) {\n\t\t\tchar *ptr = buf + 11;\n\t\t\tint val;\n\t\t\tif (sscanf(ptr, \"%d\", &val) != 1)\n\t\t\t\tgoto errexit;\n\t\t\tif (val)\n\t\t\t\targ_nonewprivs = 1;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot read stat file for process %u\\n\", pid);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_nonewprivs",
          "args": [
            "pid"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "extract_nonewprivs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "120-133",
          "snippet": "static void extract_nonewprivs(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_NONEWPRIVS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\targ_nonewprivs = 1;\n\tfree(fname);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_nonewprivs(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_NONEWPRIVS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\targ_nonewprivs = 1;\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_x11_display",
          "args": [
            "parent"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "extract_x11_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "53-80",
          "snippet": "static void extract_x11_display(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d\", RUN_FIREJAIL_X11_DIR, pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"r\");\n\tfree(fname);\n\tif (!fp)\n\t\treturn;\n\n\tif (1 != fscanf(fp, \"%u\", &display)) {\n\t\tfprintf(stderr, \"Error: cannot read X11 display file\\n\");\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfclose(fp);\n\n\t// check display range\n\tif (display < X11_DISPLAY_START || display > X11_DISPLAY_END) {\n\t\tfprintf(stderr, \"Error: invalid X11 display range\\n\");\n\t\treturn;\n\t}\n\n\t// store the display number for join process in /run/firejail/x11\n\tEUID_ROOT();\n\tset_x11_run_file(getpid(), display);\n\tEUID_USER();\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned display = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic unsigned display = 0;\n\nstatic void extract_x11_display(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d\", RUN_FIREJAIL_X11_DIR, pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"r\");\n\tfree(fname);\n\tif (!fp)\n\t\treturn;\n\n\tif (1 != fscanf(fp, \"%u\", &display)) {\n\t\tfprintf(stderr, \"Error: cannot read X11 display file\\n\");\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfclose(fp);\n\n\t// check display range\n\tif (display < X11_DISPLAY_START || display > X11_DISPLAY_END) {\n\t\tfprintf(stderr, \"Error: invalid X11 display range\\n\");\n\t\treturn;\n\t}\n\n\t// store the display number for join process in /run/firejail/x11\n\tEUID_ROOT();\n\tset_x11_run_file(getpid(), display);\n\tEUID_USER();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: permission is denied to join a sandbox created by a different user.\\n\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_get_uid",
          "args": [
            "pid"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "pid_get_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "823-865",
          "snippet": "uid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 4;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\treturn rv;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nuid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 4;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no valid sandbox\\n\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_sandbox",
          "args": [
            "pid"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "invalid_sandbox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1214-1272",
          "snippet": "int invalid_sandbox(const pid_t pid) {\n\t// check if a file \"ready-for-join\" exists\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_READY_FOR_JOIN) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tFILE *fp = fopen(fname, \"re\");\n\tEUID_USER();\n\tfree(fname);\n\tif (!fp)\n\t\treturn 1;\n\t// regular file owned by root\n\tint fd = fileno(fp);\n\tif (fd == -1)\n\t\terrExit(\"fileno\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != 0) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\t// check if it is non-empty\n\tchar buf[BUFLEN];\n\tif (fgets(buf, BUFLEN, fp) == NULL) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\tfclose(fp);\n\t// confirm \"ready\" string was written\n\tif (strncmp(buf, \"ready\\n\", 6) != 0)\n\t\treturn 1;\n\n\t// walk down the process tree a few nodes, there should be no firejail leaf\n#define MAXNODES 5\n\tpid_t current = pid, next;\n\tint i;\n\tfor (i = 0; i < MAXNODES; i++) {\n\t\tif (find_child(current, &next) == 1) {\n\t\t\t// found a leaf\n\t\t\tEUID_ROOT();\n\t\t\tchar *comm = pid_proc_comm(current);\n\t\t\tEUID_USER();\n\t\t\tif (!comm) {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\t\tfree(comm);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXNODES 5",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define MAXNODES 5\n#define BUFLEN 4096\n\nint invalid_sandbox(const pid_t pid) {\n\t// check if a file \"ready-for-join\" exists\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_READY_FOR_JOIN) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tFILE *fp = fopen(fname, \"re\");\n\tEUID_USER();\n\tfree(fname);\n\tif (!fp)\n\t\treturn 1;\n\t// regular file owned by root\n\tint fd = fileno(fp);\n\tif (fd == -1)\n\t\terrExit(\"fileno\");\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != 0) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\t// check if it is non-empty\n\tchar buf[BUFLEN];\n\tif (fgets(buf, BUFLEN, fp) == NULL) {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n\tfclose(fp);\n\t// confirm \"ready\" string was written\n\tif (strncmp(buf, \"ready\\n\", 6) != 0)\n\t\treturn 1;\n\n\t// walk down the process tree a few nodes, there should be no firejail leaf\n#define MAXNODES 5\n\tpid_t current = pid, next;\n\tint i;\n\tfor (i = 0; i < MAXNODES; i++) {\n\t\tif (find_child(current, &next) == 1) {\n\t\t\t// found a leaf\n\t\t\tEUID_ROOT();\n\t\t\tchar *comm = pid_proc_comm(current);\n\t\t\tEUID_USER();\n\t\t\tif (!comm) {\n\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\t\tfree(comm);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "switch_to_child",
          "args": [
            "pid"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "switch_to_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "258-284",
          "snippet": "pid_t switch_to_child(pid_t pid) {\n\tEUID_ROOT();\n\terrno = 0;\n\tchar *comm = pid_proc_comm(pid);\n\tif (!comm) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Error: cannot find process with pid %d\\n\", pid);\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tEUID_USER();\n\tif (strcmp(comm, \"firejail\") == 0) {\n\t\tpid_t child;\n\t\tif (find_child(pid, &child) == 1) {\n\t\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfmessage(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) child);\n\t\tpid = child;\n\t}\n\tfree(comm);\n\treturn pid;\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\npid_t switch_to_child(pid_t pid) {\n\tEUID_ROOT();\n\terrno = 0;\n\tchar *comm = pid_proc_comm(pid);\n\tif (!comm) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Error: cannot find process with pid %d\\n\", pid);\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tEUID_USER();\n\tif (strcmp(comm, \"firejail\") == 0) {\n\t\tpid_t child;\n\t\tif (find_child(pid, &child) == 1) {\n\t\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfmessage(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) child);\n\t\tpid = child;\n\t}\n\tfree(comm);\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic int apply_caps = 0;\nstatic uint64_t caps = 0;\nstatic unsigned display = 0;\n\nvoid join(pid_t pid, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\n\tpid_t parent = pid;\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// now check if the pid belongs to a firejail sandbox\n\tif (invalid_sandbox(pid)) {\n\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\texit(1);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\textract_x11_display(parent);\n\n\tEUID_ROOT();\n\t// in user mode set caps seccomp, cpu, cgroup, etc\n\tif (getuid() != 0) {\n\t\textract_nonewprivs(pid);  // redundant on Linux >= 4.10; duplicated in function extract_caps\n\t\textract_caps(pid);\n\t\textract_cpu(pid);\n\t\textract_cgroup(pid);\n\t\textract_nogroups(pid);\n\t\textract_user_namespace(pid);\n\t}\n\n\t// set cgroup\n\tif (cfg.cgroup)\t// not available for uid 0\n\t\tset_cgroup(cfg.cgroup);\n\n\t// set umask, also uid 0\n\textract_umask(pid);\n\n\t// join namespaces\n\tif (arg_join_network) {\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t}\n\telse if (arg_join_filesystem) {\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\telse {\n\t\tif (join_namespace(pid, \"ipc\") ||\n\t\t    join_namespace(pid, \"net\") ||\n\t\t    join_namespace(pid, \"pid\") ||\n\t\t    join_namespace(pid, \"uts\") ||\n\t\t    join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop discretionary access control capabilities for root sandboxes\n\t\tcaps_drop_dac_override();\n\n\t\t// chroot into /proc/PID/root directory\n\t\tchar *rootdir;\n\t\tif (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tint rv;\n\t\tif (!arg_join_network) {\n\t\t\trv = chroot(rootdir); // this will fail for processes in sandboxes not started with --chroot option\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"changing root to %s\\n\", rootdir);\n\t\t}\n\n\t\tEUID_USER();\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\n\t\t// set caps filter\n\t\tEUID_ROOT();\n\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\tcaps_set(caps);\n#ifdef HAVE_SECCOMP\n\t\tif (getuid() != 0)\n\t\t\tseccomp_load_file_list();\n#endif\n\n\t\t// mount user namespace or drop privileges\n\t\tif (arg_noroot) {\t// not available for uid 0\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Joining user namespace\\n\");\n\t\t\tif (join_namespace(1, \"user\"))\n\t\t\t\texit(1);\n\n\t\t\t// user namespace resets capabilities\n\t\t\t// set caps filter\n\t\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\t\tcaps_set(caps);\n\t\t}\n\n\t\t// set nonewprivs\n\t\tif (arg_nonewprivs == 1) {\t// not available for uid 0\n\t\t\tint rv = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\t\t\tif (arg_debug && rv == 0)\n\t\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t\t}\n\n\t\tEUID_USER();\n\t\tint cwd = 0;\n\t\tif (cfg.cwd) {\n\t\t\tif (chdir(cfg.cwd) == 0)\n\t\t\t\tcwd = 1;\n\t\t}\n\n\t\tif (!cwd) {\n\t\t\tif (chdir(\"/\") < 0)\n\t\t\t\terrExit(\"chdir\");\n\t\t\tif (cfg.homedir) {\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t\t/* coverity[toctou] */\n\t\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\t\terrExit(\"chdir\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// drop privileges\n\t\tdrop_privs(arg_nogroups);\n\n\t\t// kill the child in case the parent died\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t\textract_command(argc, argv, index);\n\t\tif (cfg.command_line == NULL) {\n\t\t\tassert(cfg.shell);\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t}\n\t\tif (arg_debug)\n\t\t\tprintf(\"Extracted command #%s#\\n\", cfg.command_line);\n\n\t\t// set cpu affinity\n\t\tif (cfg.cpus)\t// not available for uid 0\n\t\t\tset_cpu_affinity();\n\n\t\t// set nice value\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\n\t\t// add x11 display\n\t\tif (display) {\n\t\t\tchar *display_str;\n\t\t\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tsetenv(\"DISPLAY\", display_str, 1);\n\t\t\tfree(display_str);\n\t\t}\n\n\t\tstart_application(0, NULL);\n\n\t\t// it will never get here!!!\n\t}\n\n\tint status = 0;\n\t//*****************************\n\t// following code is signal-safe\n\n\tinstall_handler();\n\n\t// wait for the child to finish\n\twaitpid(child, &status, 0);\n\n\t// restore default signal action\n\tsignal(SIGTERM, SIG_DFL);\n\n\t// end of signal-safe code\n\t//*****************************\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\tstatus = WEXITSTATUS(status);\n\t} else if (WIFSIGNALED(status)) {\n\t\tstatus = WTERMSIG(status);\n\t} else {\n\t\tstatus = 0;\n\t}\n\n\texit(status);\n}"
  },
  {
    "function_name": "switch_to_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "258-284",
    "snippet": "pid_t switch_to_child(pid_t pid) {\n\tEUID_ROOT();\n\terrno = 0;\n\tchar *comm = pid_proc_comm(pid);\n\tif (!comm) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Error: cannot find process with pid %d\\n\", pid);\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tEUID_USER();\n\tif (strcmp(comm, \"firejail\") == 0) {\n\t\tpid_t child;\n\t\tif (find_child(pid, &child) == 1) {\n\t\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfmessage(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) child);\n\t\tpid = child;\n\t}\n\tfree(comm);\n\treturn pid;\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comm"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"Switching to pid %u, the first child process inside the sandbox\\n\"",
            "(unsigned) child"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "189-198",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no valid sandbox\\n\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_child",
          "args": [
            "pid",
            "&child"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "600-659",
          "snippet": "int find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nint find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "comm",
            "\"firejail\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot read /proc file\\n\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find process with pid %d\\n\"",
            "pid"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_proc_comm",
          "args": [
            "pid"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "pid_proc_comm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "128-164",
          "snippet": "char *pid_proc_comm(const pid_t pid) {\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/comm\", pid) == -1)\n\t\treturn NULL;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn NULL;\n\t}\n\tfree(fname);\n\n\t// read file\n\tchar buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// remove \\n\n\tchar *ptr = strchr(buffer, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\t// return a malloc copy of the command line\n\tchar *rv = strdup(buffer);\n\tif (!rv)\n\t\treturn NULL;\n\tif (strlen(rv) == 0) {\n\t\tfree(rv);\n\t\treturn NULL;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define BUFLEN 4096",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define BUFLEN 4096\n#define BUFLEN 4096\n\nchar *pid_proc_comm(const pid_t pid) {\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/comm\", pid) == -1)\n\t\treturn NULL;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn NULL;\n\t}\n\tfree(fname);\n\n\t// read file\n\tchar buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// remove \\n\n\tchar *ptr = strchr(buffer, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\t// return a malloc copy of the command line\n\tchar *rv = strdup(buffer);\n\tif (!rv)\n\t\treturn NULL;\n\tif (strlen(rv) == 0) {\n\t\tfree(rv);\n\t\treturn NULL;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\npid_t switch_to_child(pid_t pid) {\n\tEUID_ROOT();\n\terrno = 0;\n\tchar *comm = pid_proc_comm(pid);\n\tif (!comm) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Error: cannot find process with pid %d\\n\", pid);\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tEUID_USER();\n\tif (strcmp(comm, \"firejail\") == 0) {\n\t\tpid_t child;\n\t\tif (find_child(pid, &child) == 1) {\n\t\t\tfprintf(stderr, \"Error: no valid sandbox\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfmessage(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) child);\n\t\tpid = child;\n\t}\n\tfree(comm);\n\treturn pid;\n}"
  },
  {
    "function_name": "extract_umask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "240-256",
    "snippet": "static void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot read umask\\n\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "fp",
            "\"%3o\"",
            "&orig_umask"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open umask file\\n\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"re\""
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/root%s\"",
            "pid",
            "RUN_UMASK_FILE"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}"
  },
  {
    "function_name": "extract_user_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "206-238",
    "snippet": "static void extract_user_namespace(pid_t pid) {\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0);\n\telse\n\t\treturn;\n\n\t// read uid map\n\tchar *uidmap;\n\tif (asprintf(&uidmap, \"/proc/%u/uid_map\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(uidmap, \"r\");\n\tif (!fp) {\n\t\tfree(uidmap);\n\t\treturn;\n\t}\n\n\t// check uid map\n\tint u1;\n\tint u2;\n\tif (fscanf(fp, \"%d %d\", &u1, &u2) == 2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"User namespace detected: %s, %d, %d\\n\", uidmap, u1, u2);\n\t\tif (u1 != 0 || u2 != 0)\n\t\t\targ_noroot = 1;\n\t}\n\tfclose(fp);\n\tfree(uidmap);\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "uidmap"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"User namespace detected: %s, %d, %d\\n\"",
            "uidmap",
            "u1",
            "u2"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "fp",
            "\"%d %d\"",
            "&u1",
            "&u2"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "uidmap"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "uidmap",
            "\"r\""
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&uidmap",
            "\"/proc/%u/uid_map\"",
            "pid"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/proc/self/gid_map\"",
            "&s3"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_user_namespace(pid_t pid) {\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0);\n\telse\n\t\treturn;\n\n\t// read uid map\n\tchar *uidmap;\n\tif (asprintf(&uidmap, \"/proc/%u/uid_map\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(uidmap, \"r\");\n\tif (!fp) {\n\t\tfree(uidmap);\n\t\treturn;\n\t}\n\n\t// check uid map\n\tint u1;\n\tint u2;\n\tif (fscanf(fp, \"%d %d\", &u1, &u2) == 2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"User namespace detected: %s, %d, %d\\n\", uidmap, u1, u2);\n\t\tif (u1 != 0 || u2 != 0)\n\t\t\targ_noroot = 1;\n\t}\n\tfclose(fp);\n\tfree(uidmap);\n}"
  },
  {
    "function_name": "extract_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "167-204",
    "snippet": "static void extract_caps(pid_t pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp)\n\t\tgoto errexit;\n\n\tchar buf[BUFLEN];\n\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"CapBnd:\", 7) == 0) {\n\t\t\tchar *ptr = buf + 7;\n\t\t\tunsigned long long val;\n\t\t\tif (sscanf(ptr, \"%llx\", &val) != 1)\n\t\t\t\tgoto errexit;\n\t\t\tapply_caps = 1;\n\t\t\tcaps = val;\n\t\t}\n\t\telse if (strncmp(buf, \"NoNewPrivs:\", 11) == 0) {\n\t\t\tchar *ptr = buf + 11;\n\t\t\tint val;\n\t\t\tif (sscanf(ptr, \"%d\", &val) != 1)\n\t\t\t\tgoto errexit;\n\t\t\tif (val)\n\t\t\t\targ_nonewprivs = 1;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot read stat file for process %u\\n\", pid);\n\texit(1);\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define BUFLEN 4096"
    ],
    "globals_used": [
      "static int apply_caps = 0;",
      "static uint64_t caps = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot read stat file for process %u\\n\"",
            "pid"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%d\"",
            "&val"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"NoNewPrivs:\"",
            "11"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%llx\"",
            "&val"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"CapBnd:\"",
            "7"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "BUFLEN - 1",
            "fp"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"asprintf\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&file",
            "\"/proc/%u/status\"",
            "pid"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nstatic int apply_caps = 0;\nstatic uint64_t caps = 0;\n\nstatic void extract_caps(pid_t pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp)\n\t\tgoto errexit;\n\n\tchar buf[BUFLEN];\n\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"CapBnd:\", 7) == 0) {\n\t\t\tchar *ptr = buf + 7;\n\t\t\tunsigned long long val;\n\t\t\tif (sscanf(ptr, \"%llx\", &val) != 1)\n\t\t\t\tgoto errexit;\n\t\t\tapply_caps = 1;\n\t\t\tcaps = val;\n\t\t}\n\t\telse if (strncmp(buf, \"NoNewPrivs:\", 11) == 0) {\n\t\t\tchar *ptr = buf + 11;\n\t\t\tint val;\n\t\t\tif (sscanf(ptr, \"%d\", &val) != 1)\n\t\t\t\tgoto errexit;\n\t\t\tif (val)\n\t\t\t\targ_nonewprivs = 1;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot read stat file for process %u\\n\", pid);\n\texit(1);\n}"
  },
  {
    "function_name": "extract_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "151-165",
    "snippet": "static void extract_cgroup(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CGROUP_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// there is a cgroup file CGROUP_CFG, load it!\n\tload_cgroup(fname);\n\tfree(fname);\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_cgroup",
          "args": [
            "fname"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "load_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cgroup.c",
          "lines": "47-69",
          "snippet": "void load_cgroup(const char *fname) {\n\tif (!fname)\n\t\treturn;\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tchar buf[MAXBUF];\n\t\tif (fgets(buf, MAXBUF, fp)) {\n\t\t\tcfg.cgroup = strdup(buf);\n\t\t\tif (!cfg.cgroup)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\tgoto errout;\n\n\t\tfclose(fp);\n\t\treturn;\n\t}\nerrout:\n\tfwarning(\"cannot load control group\\n\");\n\tif (fp)\n\t\tfclose(fp);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4096\n\nvoid load_cgroup(const char *fname) {\n\tif (!fname)\n\t\treturn;\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tchar buf[MAXBUF];\n\t\tif (fgets(buf, MAXBUF, fp)) {\n\t\t\tcfg.cgroup = strdup(buf);\n\t\t\tif (!cfg.cgroup)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\tgoto errout;\n\n\t\tfclose(fp);\n\t\treturn;\n\t}\nerrout:\n\tfwarning(\"cannot load control group\\n\");\n\tif (fp)\n\t\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/root%s\"",
            "pid",
            "RUN_CGROUP_CFG"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_cgroup(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CGROUP_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// there is a cgroup file CGROUP_CFG, load it!\n\tload_cgroup(fname);\n\tfree(fname);\n}"
  },
  {
    "function_name": "extract_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "135-149",
    "snippet": "static void extract_cpu(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CPU_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// there is a CPU_CFG file, load it!\n\tload_cpu(fname);\n\tfree(fname);\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_cpu",
          "args": [
            "fname"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "load_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cpu.c",
          "lines": "90-104",
          "snippet": "void load_cpu(const char *fname) {\n\tif (!fname)\n\t\treturn;\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tunsigned tmp;\n\t\tint rv = fscanf(fp, \"%x\", &tmp);\n\t\tif (rv)\n\t\t\tcfg.cpus = (uint32_t) tmp;\n\t\tfclose(fp);\n\t}\n\telse\n\t\tfwarning(\"cannot load cpu affinity mask\\n\");\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <sched.h>\n#include \"firejail.h\"\n\nvoid load_cpu(const char *fname) {\n\tif (!fname)\n\t\treturn;\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tunsigned tmp;\n\t\tint rv = fscanf(fp, \"%x\", &tmp);\n\t\tif (rv)\n\t\t\tcfg.cpus = (uint32_t) tmp;\n\t\tfclose(fp);\n\t}\n\telse\n\t\tfwarning(\"cannot load cpu affinity mask\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/root%s\"",
            "pid",
            "RUN_CPU_CFG"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_cpu(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CPU_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// there is a CPU_CFG file, load it!\n\tload_cpu(fname);\n\tfree(fname);\n}"
  },
  {
    "function_name": "extract_nonewprivs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "120-133",
    "snippet": "static void extract_nonewprivs(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_NONEWPRIVS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\targ_nonewprivs = 1;\n\tfree(fname);\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/root%s\"",
            "pid",
            "RUN_NONEWPRIVS_CFG"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_nonewprivs(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_NONEWPRIVS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\targ_nonewprivs = 1;\n\tfree(fname);\n}"
  },
  {
    "function_name": "extract_nogroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "105-118",
    "snippet": "static void extract_nogroups(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_GROUPS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\targ_nogroups = 1;\n\tfree(fname);\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/root%s\"",
            "pid",
            "RUN_GROUPS_CFG"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_nogroups(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_GROUPS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\targ_nogroups = 1;\n\tfree(fname);\n}"
  },
  {
    "function_name": "extract_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "82-103",
    "snippet": "static void extract_command(int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tif (index >= argc)\n\t\treturn;\n\n\t// doubledash followed by positional parameters\n\tif (strcmp(argv[index], \"--\") == 0) {\n\t\targ_doubledash = 1;\n\t\tindex++;\n\t\tif (index >= argc)\n\t\t\treturn;\n\t}\n\n\t// first argv needs to be a valid command\n\tif (arg_doubledash == 0 && *argv[index] == '-') {\n\t\tfprintf(stderr, \"Error: invalid option %s after --join\\n\", argv[index]);\n\t\texit(1);\n\t}\n\n\t// build command\n\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, index);\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "build_cmdline",
          "args": [
            "&cfg.command_line",
            "&cfg.window_title",
            "argc",
            "argv",
            "index"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "build_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cmdline.c",
          "lines": "137-162",
          "snippet": "void build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tif (arg_debug)\n\t\tprintf(\"Building quoted command line: %s\\n\", *command_line);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <assert.h>",
            "#include <linux/limits.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <string.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nvoid build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tif (arg_debug)\n\t\tprintf(\"Building quoted command line: %s\\n\", *command_line);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid option %s after --join\\n\"",
            "argv[index]"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[index]",
            "\"--\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_command(int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tif (index >= argc)\n\t\treturn;\n\n\t// doubledash followed by positional parameters\n\tif (strcmp(argv[index], \"--\") == 0) {\n\t\targ_doubledash = 1;\n\t\tindex++;\n\t\tif (index >= argc)\n\t\t\treturn;\n\t}\n\n\t// first argv needs to be a valid command\n\tif (arg_doubledash == 0 && *argv[index] == '-') {\n\t\tfprintf(stderr, \"Error: invalid option %s after --join\\n\", argv[index]);\n\t\texit(1);\n\t}\n\n\t// build command\n\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, index);\n}"
  },
  {
    "function_name": "extract_x11_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "53-80",
    "snippet": "static void extract_x11_display(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d\", RUN_FIREJAIL_X11_DIR, pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"r\");\n\tfree(fname);\n\tif (!fp)\n\t\treturn;\n\n\tif (1 != fscanf(fp, \"%u\", &display)) {\n\t\tfprintf(stderr, \"Error: cannot read X11 display file\\n\");\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfclose(fp);\n\n\t// check display range\n\tif (display < X11_DISPLAY_START || display > X11_DISPLAY_END) {\n\t\tfprintf(stderr, \"Error: invalid X11 display range\\n\");\n\t\treturn;\n\t}\n\n\t// store the display number for join process in /run/firejail/x11\n\tEUID_ROOT();\n\tset_x11_run_file(getpid(), display);\n\tEUID_USER();\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned display = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_x11_run_file",
          "args": [
            "getpid()",
            "display"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "set_x11_run_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/run_files.c",
          "lines": "117-133",
          "snippet": "void set_x11_run_file(pid_t pid, int display) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d\", RUN_FIREJAIL_X11_DIR, pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// the file is deleted first\n\tFILE *fp = fopen(fname, \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot create %s\\n\", fname);\n\t\texit(1);\n\t}\n\tfprintf(fp, \"%d\\n\", display);\n\n\t// mode and ownership\n\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\tfclose(fp);\n}",
          "includes": [
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nvoid set_x11_run_file(pid_t pid, int display) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d\", RUN_FIREJAIL_X11_DIR, pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// the file is deleted first\n\tFILE *fp = fopen(fname, \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot create %s\\n\", fname);\n\t\texit(1);\n\t}\n\tfprintf(fp, \"%d\\n\", display);\n\n\t// mode and ownership\n\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid X11 display range\\n\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot read X11 display file\\n\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "fp",
            "\"%u\"",
            "&display"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/%d\"",
            "RUN_FIREJAIL_X11_DIR",
            "pid"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic unsigned display = 0;\n\nstatic void extract_x11_display(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/%d\", RUN_FIREJAIL_X11_DIR, pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"r\");\n\tfree(fname);\n\tif (!fp)\n\t\treturn;\n\n\tif (1 != fscanf(fp, \"%u\", &display)) {\n\t\tfprintf(stderr, \"Error: cannot read X11 display file\\n\");\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfclose(fp);\n\n\t// check display range\n\tif (display < X11_DISPLAY_START || display > X11_DISPLAY_END) {\n\t\tfprintf(stderr, \"Error: invalid X11 display range\\n\");\n\t\treturn;\n\t}\n\n\t// store the display number for join process in /run/firejail/x11\n\tEUID_ROOT();\n\tset_x11_run_file(getpid(), display);\n\tEUID_USER();\n}"
  },
  {
    "function_name": "install_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "43-51",
    "snippet": "static void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// handle SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsga.sa_handler = signal_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGTERM",
            "&sga",
            "NULL"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sga.sa_mask"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// handle SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsga.sa_handler = signal_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}"
  },
  {
    "function_name": "signal_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
    "lines": "37-41",
    "snippet": "static void signal_handler(int sig){\n\tflush_stdin();\n\n\texit(sig);\n}",
    "includes": [
      "#include <sys/prctl.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "sig"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_stdin",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "flush_stdin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "959-969",
          "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void signal_handler(int sig){\n\tflush_stdin();\n\n\texit(sig);\n}"
  }
]