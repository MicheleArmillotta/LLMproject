[
  {
    "function_name": "x11_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/x11.c",
    "lines": "25-63",
    "snippet": "void x11_test(void) {\n\t// check regular display 0 sockets\n\tif (check_unix(\"/tmp/.X11-unix/X0\") == 0)\n\t\tprintf(\"MAYBE: X11 socket /tmp/.X11-unix/X0 is available\\n\");\n\n\tif (check_unix(\"@/tmp/.X11-unix/X0\") == 0)\n\t\tprintf(\"MAYBE: X11 socket @/tmp/.X11-unix/X0 is available\\n\");\n\n\t// check all unix sockets in /tmp/.X11-unix directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp/.X11-unix\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp/.X11-unix\"))) {\n\t\t\t;\n\t\t}\n\t}\n\n\tif (dir == NULL)\n\t\tprintf(\"GOOD: cannot open /tmp/.X11-unix directory\\n\");\n\telse {\n\t\tstruct dirent *entry;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tif (strcmp(entry->d_name, \"X0\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \".\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tchar *name;\n\t\t\tif (asprintf(&name, \"/tmp/.X11-unix/%s\", entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (check_unix(name) == 0)\n\t\t\t\tprintf(\"MAYBE: X11 socket %s is available\\n\", name);\n\t\t\tfree(name);\n\t\t}\n\t\tclosedir(dir);\n\t}\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <sys/socket.h>",
      "#include \"faudit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"MAYBE: X11 socket %s is available\\n\"",
            "name"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_unix",
          "args": [
            "name"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "check_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/dbus.c",
          "lines": "25-47",
          "snippet": "int check_unix(const char *sockfile) {\n\tassert(sockfile);\n\tint rv = -1;\n\n\t// open socket\n\tint sock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1)\n\t\treturn rv;\n\n\t// connect\n\tstruct sockaddr_un remote;\n\tmemset(&remote, 0, sizeof(struct sockaddr_un));\n\tremote.sun_family = AF_UNIX;\n\tstrncpy(remote.sun_path, sockfile, sizeof(remote.sun_path));\n\tint len = strlen(remote.sun_path) + sizeof(remote.sun_family);\n\tif (*sockfile == '@')\n\t\tremote.sun_path[0] = '\\0';\n\tif (connect(sock, (struct sockaddr *)&remote, len) == 0)\n\t\trv = 0;\n\n\tclose(sock);\n\treturn rv;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include \"faudit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include <sys/socket.h>\n#include \"faudit.h\"\n\nint check_unix(const char *sockfile) {\n\tassert(sockfile);\n\tint rv = -1;\n\n\t// open socket\n\tint sock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1)\n\t\treturn rv;\n\n\t// connect\n\tstruct sockaddr_un remote;\n\tmemset(&remote, 0, sizeof(struct sockaddr_un));\n\tremote.sun_family = AF_UNIX;\n\tstrncpy(remote.sun_path, sockfile, sizeof(remote.sun_path));\n\tint len = strlen(remote.sun_path) + sizeof(remote.sun_family);\n\tif (*sockfile == '@')\n\t\tremote.sun_path[0] = '\\0';\n\tif (connect(sock, (struct sockaddr *)&remote, len) == 0)\n\t\trv = 0;\n\n\tclose(sock);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&name",
            "\"/tmp/.X11-unix/%s\"",
            "entry->d_name"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\"..\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\".\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\"X0\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"GOOD: cannot open /tmp/.X11-unix directory\\n\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/tmp/.X11-unix\""
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "466-473",
          "snippet": "DIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_opendir_t orig_opendir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "firemon_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "90-121",
          "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios tlocal;",
            "static struct termios twait;",
            "static int terminal_set = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"MAYBE: X11 socket @/tmp/.X11-unix/X0 is available\\n\""
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"MAYBE: X11 socket /tmp/.X11-unix/X0 is available\\n\""
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <sys/socket.h>\n#include \"faudit.h\"\n\nvoid x11_test(void) {\n\t// check regular display 0 sockets\n\tif (check_unix(\"/tmp/.X11-unix/X0\") == 0)\n\t\tprintf(\"MAYBE: X11 socket /tmp/.X11-unix/X0 is available\\n\");\n\n\tif (check_unix(\"@/tmp/.X11-unix/X0\") == 0)\n\t\tprintf(\"MAYBE: X11 socket @/tmp/.X11-unix/X0 is available\\n\");\n\n\t// check all unix sockets in /tmp/.X11-unix directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp/.X11-unix\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp/.X11-unix\"))) {\n\t\t\t;\n\t\t}\n\t}\n\n\tif (dir == NULL)\n\t\tprintf(\"GOOD: cannot open /tmp/.X11-unix directory\\n\");\n\telse {\n\t\tstruct dirent *entry;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tif (strcmp(entry->d_name, \"X0\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \".\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tchar *name;\n\t\t\tif (asprintf(&name, \"/tmp/.X11-unix/%s\", entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (check_unix(name) == 0)\n\t\t\t\tprintf(\"MAYBE: X11 socket %s is available\\n\", name);\n\t\t\tfree(name);\n\t\t}\n\t\tclosedir(dir);\n\t}\n}"
  }
]