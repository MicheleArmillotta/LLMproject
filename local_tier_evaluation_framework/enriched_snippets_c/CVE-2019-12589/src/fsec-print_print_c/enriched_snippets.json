[
  {
    "function_name": "print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-print/print.c",
    "lines": "307-332",
    "snippet": "void print(struct sock_filter *filter, int entries) {\n\tint i;\n\n\t/* header */\n\tprintf(\" line  OP JT JF    K\\n\");\n\tprintf(\"=================================\\n\");\n\tstruct sock_filter *bpf = filter;\n\tfor (i = 0; i < entries; i++, bpf++) {\n\n\t\t/* convert the bpf statement */\n//\t\tbpf.code = ttoh16(arch, bpf.code);\n//\t\tbpf.k = ttoh32(arch, bpf.k);\n\n\t\t/* display a hex dump */\n\t\tprintf(\" %.4x: %.2x %.2x %.2x %.8x\",\n\t\t       i, bpf->code, bpf->jt, bpf->jf, bpf->k);\n\n\t\t/* display the assembler statements */\n\t\tprintf(\"   \");\n\t\tprintf(\"%-3s\", bpf_decode_op(bpf));\n\t\tprintf(\" \");\n\t\tbpf_decode_args(bpf, i);\n\n\t\tprintf(\"\\n\");\n\t}\n}",
    "includes": [
      "#include \"fsec_print.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_decode_args",
          "args": [
            "bpf",
            "i"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_decode_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-print/print.c",
          "lines": "196-305",
          "snippet": "static void bpf_decode_args(const struct sock_filter *bpf, unsigned int line) {\n\tswitch (BPF_CLASS(bpf->code)) {\n\tcase BPF_LD:\n\tcase BPF_LDX:\n\t\tswitch (BPF_MODE(bpf->code)) {\n\t\tcase BPF_ABS:\n\t\t\tsyscall_loaded = 0;\n\t\t\tif (bpf->k == offsetof(struct seccomp_data, arch))\n\t\t\t\tprintf(\"data.architecture\");\n\t\t\telse if (bpf->k == offsetof(struct seccomp_data, nr)) {\n\t\t\t\tprintf(\"data.syscall-number\");\n\t\t\t\tsyscall_loaded = 1;\n\t\t\t}\n\t\t\telse if (bpf->k == offsetof(struct seccomp_data, instruction_pointer))\n\t\t\t\tprintf(\"data.instruction_pointer\");\n\t\t\telse {\n\t\t\t\tint index = bpf->k - offsetof(struct seccomp_data, args);\n\t\t\t\tprintf(\"data.args[%x]\", index);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_MEM:\n\t\t\tprintf(\"$temp[%u]\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_IMM:\n\t\t\tprintf(\"%x\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_IND:\n\t\t\tprintf(\"$data[X + %x]\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_LEN:\n\t\t\tprintf(\"len($data)\");\n\t\t\tbreak;\n\t\tcase BPF_MSH:\n\t\t\tprintf(\"4 * $data[%x] & 0x0f\", bpf->k);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BPF_ST:\n\tcase BPF_STX:\n\t\tprintf(\"$temp[%u]\", bpf->k);\n\t\tbreak;\n\tcase BPF_ALU:\n\t\tif (BPF_SRC(bpf->code) == BPF_K) {\n\t\t\tswitch (BPF_OP(bpf->code)) {\n\t\t\tcase BPF_OR:\n\t\t\tcase BPF_AND:\n\t\t\t\tprintf(\"%.8x\", bpf->k);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%x\", bpf->k);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tprintf(\"%u\", bpf->k);\n\t\tbreak;\n\tcase BPF_JMP:\n\t\tif (BPF_OP(bpf->code) == BPF_JA) {\n\t\t\tprintf(\"%.4u\", (line + 1) + bpf->k);\n\t\t}\n\t\telse {\n\t\t\tconst char *name = NULL;\n\t\t\tif (syscall_loaded && native_arch)\n\t\t\t\tname = syscall_find_nr(bpf->k);\n\t\t\tif (bpf->k == ARCH_32) {\n\t\t\t\tprintf(\"ARCH_32 %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\t\t native_arch = (ARCH_NR == ARCH_32)? 1: 0;\n\t\t\t}\n\t\t\telse if (bpf->k == ARCH_64) {\n\t\t\t\tprintf(\"ARCH_64 %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\t\t native_arch = (ARCH_NR == ARCH_64)? 1: 0;\n\t\t\t}\n\t\t\telse if (bpf->k == X32_SYSCALL_BIT)\n\t\t\t\tprintf(\"X32_ABI %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\telse if (name)\n\t\t\t\tprintf(\"%s %.4x (false %.4x)\",\n\t\t\t\t       name,\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\telse\n\t\t\t\tprintf(\"%x %.4x (false %.4x)\",\n\t\t\t\t       bpf->k,\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t}\n\t\tbreak;\n\tcase BPF_RET:\n\t\tif (BPF_RVAL(bpf->code) == BPF_A) {\n\t\t\t/* XXX - accumulator? */\n\t\t\tprintf(\"$acc\");\n\t\t}\n\t\telse if (BPF_SRC(bpf->code) == BPF_K) {\n\t\t\tbpf_decode_action(bpf->k);\n\t\t}\n\t\telse if (BPF_SRC(bpf->code) == BPF_X) {\n\t\t\t/* XXX - any idea? */\n\t\t\tprintf(\"???\");\n\t\t}\n\t\tbreak;\n\tcase BPF_MISC:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"???\");\n\t}\n}",
          "includes": [
            "#include \"fsec_print.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int syscall_loaded = 0;",
            "int native_arch = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fsec_print.h\"\n\nint syscall_loaded = 0;\nint native_arch = 0;\n\nstatic void bpf_decode_args(const struct sock_filter *bpf, unsigned int line) {\n\tswitch (BPF_CLASS(bpf->code)) {\n\tcase BPF_LD:\n\tcase BPF_LDX:\n\t\tswitch (BPF_MODE(bpf->code)) {\n\t\tcase BPF_ABS:\n\t\t\tsyscall_loaded = 0;\n\t\t\tif (bpf->k == offsetof(struct seccomp_data, arch))\n\t\t\t\tprintf(\"data.architecture\");\n\t\t\telse if (bpf->k == offsetof(struct seccomp_data, nr)) {\n\t\t\t\tprintf(\"data.syscall-number\");\n\t\t\t\tsyscall_loaded = 1;\n\t\t\t}\n\t\t\telse if (bpf->k == offsetof(struct seccomp_data, instruction_pointer))\n\t\t\t\tprintf(\"data.instruction_pointer\");\n\t\t\telse {\n\t\t\t\tint index = bpf->k - offsetof(struct seccomp_data, args);\n\t\t\t\tprintf(\"data.args[%x]\", index);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_MEM:\n\t\t\tprintf(\"$temp[%u]\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_IMM:\n\t\t\tprintf(\"%x\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_IND:\n\t\t\tprintf(\"$data[X + %x]\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_LEN:\n\t\t\tprintf(\"len($data)\");\n\t\t\tbreak;\n\t\tcase BPF_MSH:\n\t\t\tprintf(\"4 * $data[%x] & 0x0f\", bpf->k);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BPF_ST:\n\tcase BPF_STX:\n\t\tprintf(\"$temp[%u]\", bpf->k);\n\t\tbreak;\n\tcase BPF_ALU:\n\t\tif (BPF_SRC(bpf->code) == BPF_K) {\n\t\t\tswitch (BPF_OP(bpf->code)) {\n\t\t\tcase BPF_OR:\n\t\t\tcase BPF_AND:\n\t\t\t\tprintf(\"%.8x\", bpf->k);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%x\", bpf->k);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tprintf(\"%u\", bpf->k);\n\t\tbreak;\n\tcase BPF_JMP:\n\t\tif (BPF_OP(bpf->code) == BPF_JA) {\n\t\t\tprintf(\"%.4u\", (line + 1) + bpf->k);\n\t\t}\n\t\telse {\n\t\t\tconst char *name = NULL;\n\t\t\tif (syscall_loaded && native_arch)\n\t\t\t\tname = syscall_find_nr(bpf->k);\n\t\t\tif (bpf->k == ARCH_32) {\n\t\t\t\tprintf(\"ARCH_32 %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\t\t native_arch = (ARCH_NR == ARCH_32)? 1: 0;\n\t\t\t}\n\t\t\telse if (bpf->k == ARCH_64) {\n\t\t\t\tprintf(\"ARCH_64 %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\t\t native_arch = (ARCH_NR == ARCH_64)? 1: 0;\n\t\t\t}\n\t\t\telse if (bpf->k == X32_SYSCALL_BIT)\n\t\t\t\tprintf(\"X32_ABI %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\telse if (name)\n\t\t\t\tprintf(\"%s %.4x (false %.4x)\",\n\t\t\t\t       name,\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\telse\n\t\t\t\tprintf(\"%x %.4x (false %.4x)\",\n\t\t\t\t       bpf->k,\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t}\n\t\tbreak;\n\tcase BPF_RET:\n\t\tif (BPF_RVAL(bpf->code) == BPF_A) {\n\t\t\t/* XXX - accumulator? */\n\t\t\tprintf(\"$acc\");\n\t\t}\n\t\telse if (BPF_SRC(bpf->code) == BPF_K) {\n\t\t\tbpf_decode_action(bpf->k);\n\t\t}\n\t\telse if (BPF_SRC(bpf->code) == BPF_X) {\n\t\t\t/* XXX - any idea? */\n\t\t\tprintf(\"???\");\n\t\t}\n\t\tbreak;\n\tcase BPF_MISC:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"???\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" \""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-3s\"",
            "bpf_decode_op(bpf)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_decode_op",
          "args": [
            "bpf"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_decode_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-print/print.c",
          "lines": "56-160",
          "snippet": "static const char *bpf_decode_op(const struct sock_filter *bpf) {\n\tswitch (bpf->code) {\n\tcase BPF_LD+BPF_W+BPF_IMM:\n\tcase BPF_LD+BPF_W+BPF_ABS:\n\tcase BPF_LD+BPF_W+BPF_IND:\n\tcase BPF_LD+BPF_W+BPF_MEM:\n\tcase BPF_LD+BPF_W+BPF_LEN:\n\tcase BPF_LD+BPF_W+BPF_MSH:\n\t\treturn \"ld\";\n\tcase BPF_LD+BPF_H+BPF_IMM:\n\tcase BPF_LD+BPF_H+BPF_ABS:\n\tcase BPF_LD+BPF_H+BPF_IND:\n\tcase BPF_LD+BPF_H+BPF_MEM:\n\tcase BPF_LD+BPF_H+BPF_LEN:\n\tcase BPF_LD+BPF_H+BPF_MSH:\n\t\treturn \"ldh\";\n\tcase BPF_LD+BPF_B+BPF_IMM:\n\tcase BPF_LD+BPF_B+BPF_ABS:\n\tcase BPF_LD+BPF_B+BPF_IND:\n\tcase BPF_LD+BPF_B+BPF_MEM:\n\tcase BPF_LD+BPF_B+BPF_LEN:\n\tcase BPF_LD+BPF_B+BPF_MSH:\n\t\treturn \"ldb\";\n\tcase BPF_LDX+BPF_W+BPF_IMM:\n\tcase BPF_LDX+BPF_W+BPF_ABS:\n\tcase BPF_LDX+BPF_W+BPF_IND:\n\tcase BPF_LDX+BPF_W+BPF_MEM:\n\tcase BPF_LDX+BPF_W+BPF_LEN:\n\tcase BPF_LDX+BPF_W+BPF_MSH:\n\tcase BPF_LDX+BPF_H+BPF_IMM:\n\tcase BPF_LDX+BPF_H+BPF_ABS:\n\tcase BPF_LDX+BPF_H+BPF_IND:\n\tcase BPF_LDX+BPF_H+BPF_MEM:\n\tcase BPF_LDX+BPF_H+BPF_LEN:\n\tcase BPF_LDX+BPF_H+BPF_MSH:\n\tcase BPF_LDX+BPF_B+BPF_IMM:\n\tcase BPF_LDX+BPF_B+BPF_ABS:\n\tcase BPF_LDX+BPF_B+BPF_IND:\n\tcase BPF_LDX+BPF_B+BPF_MEM:\n\tcase BPF_LDX+BPF_B+BPF_LEN:\n\tcase BPF_LDX+BPF_B+BPF_MSH:\n\t\treturn \"ldx\";\n\tcase BPF_ST:\n\t\treturn \"st\";\n\tcase BPF_STX:\n\t\treturn \"stx\";\n\tcase BPF_ALU+BPF_ADD+BPF_K:\n\tcase BPF_ALU+BPF_ADD+BPF_X:\n\t\treturn \"add\";\n\tcase BPF_ALU+BPF_SUB+BPF_K:\n\tcase BPF_ALU+BPF_SUB+BPF_X:\n\t\treturn \"sub\";\n\tcase BPF_ALU+BPF_MUL+BPF_K:\n\tcase BPF_ALU+BPF_MUL+BPF_X:\n\t\treturn \"mul\";\n\tcase BPF_ALU+BPF_DIV+BPF_K:\n\tcase BPF_ALU+BPF_DIV+BPF_X:\n\t\treturn \"div\";\n\tcase BPF_ALU+BPF_OR+BPF_K:\n\tcase BPF_ALU+BPF_OR+BPF_X:\n\t\treturn \"or\";\n\tcase BPF_ALU+BPF_AND+BPF_K:\n\tcase BPF_ALU+BPF_AND+BPF_X:\n\t\treturn \"and\";\n\tcase BPF_ALU+BPF_LSH+BPF_K:\n\tcase BPF_ALU+BPF_LSH+BPF_X:\n\t\treturn \"lsh\";\n\tcase BPF_ALU+BPF_RSH+BPF_K:\n\tcase BPF_ALU+BPF_RSH+BPF_X:\n\t\treturn \"rsh\";\n\tcase BPF_ALU+BPF_NEG+BPF_K:\n\tcase BPF_ALU+BPF_NEG+BPF_X:\n\t\treturn \"neg\";\n\tcase BPF_ALU+BPF_MOD+BPF_K:\n\tcase BPF_ALU+BPF_MOD+BPF_X:\n\t\treturn \"mod\";\n\tcase BPF_ALU+BPF_XOR+BPF_K:\n\tcase BPF_ALU+BPF_XOR+BPF_X:\n\t\treturn \"xor\";\n\tcase BPF_JMP+BPF_JA+BPF_K:\n\tcase BPF_JMP+BPF_JA+BPF_X:\n\t\treturn \"jmp\";\n\tcase BPF_JMP+BPF_JEQ+BPF_K:\n\tcase BPF_JMP+BPF_JEQ+BPF_X:\n\t\treturn \"jeq\";\n\tcase BPF_JMP+BPF_JGT+BPF_K:\n\tcase BPF_JMP+BPF_JGT+BPF_X:\n\t\treturn \"jgt\";\n\tcase BPF_JMP+BPF_JGE+BPF_K:\n\tcase BPF_JMP+BPF_JGE+BPF_X:\n\t\treturn \"jge\";\n\tcase BPF_JMP+BPF_JSET+BPF_K:\n\tcase BPF_JMP+BPF_JSET+BPF_X:\n\t\treturn \"jset\";\n\tcase BPF_RET+BPF_K:\n\tcase BPF_RET+BPF_X:\n\tcase BPF_RET+BPF_A:\n\t\treturn \"ret\";\n\tcase BPF_MISC+BPF_TAX:\n\t\treturn \"tax\";\n\tcase BPF_MISC+BPF_TXA:\n\t\treturn \"txa\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include \"fsec_print.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsec_print.h\"\n\nstatic const char *bpf_decode_op(const struct sock_filter *bpf) {\n\tswitch (bpf->code) {\n\tcase BPF_LD+BPF_W+BPF_IMM:\n\tcase BPF_LD+BPF_W+BPF_ABS:\n\tcase BPF_LD+BPF_W+BPF_IND:\n\tcase BPF_LD+BPF_W+BPF_MEM:\n\tcase BPF_LD+BPF_W+BPF_LEN:\n\tcase BPF_LD+BPF_W+BPF_MSH:\n\t\treturn \"ld\";\n\tcase BPF_LD+BPF_H+BPF_IMM:\n\tcase BPF_LD+BPF_H+BPF_ABS:\n\tcase BPF_LD+BPF_H+BPF_IND:\n\tcase BPF_LD+BPF_H+BPF_MEM:\n\tcase BPF_LD+BPF_H+BPF_LEN:\n\tcase BPF_LD+BPF_H+BPF_MSH:\n\t\treturn \"ldh\";\n\tcase BPF_LD+BPF_B+BPF_IMM:\n\tcase BPF_LD+BPF_B+BPF_ABS:\n\tcase BPF_LD+BPF_B+BPF_IND:\n\tcase BPF_LD+BPF_B+BPF_MEM:\n\tcase BPF_LD+BPF_B+BPF_LEN:\n\tcase BPF_LD+BPF_B+BPF_MSH:\n\t\treturn \"ldb\";\n\tcase BPF_LDX+BPF_W+BPF_IMM:\n\tcase BPF_LDX+BPF_W+BPF_ABS:\n\tcase BPF_LDX+BPF_W+BPF_IND:\n\tcase BPF_LDX+BPF_W+BPF_MEM:\n\tcase BPF_LDX+BPF_W+BPF_LEN:\n\tcase BPF_LDX+BPF_W+BPF_MSH:\n\tcase BPF_LDX+BPF_H+BPF_IMM:\n\tcase BPF_LDX+BPF_H+BPF_ABS:\n\tcase BPF_LDX+BPF_H+BPF_IND:\n\tcase BPF_LDX+BPF_H+BPF_MEM:\n\tcase BPF_LDX+BPF_H+BPF_LEN:\n\tcase BPF_LDX+BPF_H+BPF_MSH:\n\tcase BPF_LDX+BPF_B+BPF_IMM:\n\tcase BPF_LDX+BPF_B+BPF_ABS:\n\tcase BPF_LDX+BPF_B+BPF_IND:\n\tcase BPF_LDX+BPF_B+BPF_MEM:\n\tcase BPF_LDX+BPF_B+BPF_LEN:\n\tcase BPF_LDX+BPF_B+BPF_MSH:\n\t\treturn \"ldx\";\n\tcase BPF_ST:\n\t\treturn \"st\";\n\tcase BPF_STX:\n\t\treturn \"stx\";\n\tcase BPF_ALU+BPF_ADD+BPF_K:\n\tcase BPF_ALU+BPF_ADD+BPF_X:\n\t\treturn \"add\";\n\tcase BPF_ALU+BPF_SUB+BPF_K:\n\tcase BPF_ALU+BPF_SUB+BPF_X:\n\t\treturn \"sub\";\n\tcase BPF_ALU+BPF_MUL+BPF_K:\n\tcase BPF_ALU+BPF_MUL+BPF_X:\n\t\treturn \"mul\";\n\tcase BPF_ALU+BPF_DIV+BPF_K:\n\tcase BPF_ALU+BPF_DIV+BPF_X:\n\t\treturn \"div\";\n\tcase BPF_ALU+BPF_OR+BPF_K:\n\tcase BPF_ALU+BPF_OR+BPF_X:\n\t\treturn \"or\";\n\tcase BPF_ALU+BPF_AND+BPF_K:\n\tcase BPF_ALU+BPF_AND+BPF_X:\n\t\treturn \"and\";\n\tcase BPF_ALU+BPF_LSH+BPF_K:\n\tcase BPF_ALU+BPF_LSH+BPF_X:\n\t\treturn \"lsh\";\n\tcase BPF_ALU+BPF_RSH+BPF_K:\n\tcase BPF_ALU+BPF_RSH+BPF_X:\n\t\treturn \"rsh\";\n\tcase BPF_ALU+BPF_NEG+BPF_K:\n\tcase BPF_ALU+BPF_NEG+BPF_X:\n\t\treturn \"neg\";\n\tcase BPF_ALU+BPF_MOD+BPF_K:\n\tcase BPF_ALU+BPF_MOD+BPF_X:\n\t\treturn \"mod\";\n\tcase BPF_ALU+BPF_XOR+BPF_K:\n\tcase BPF_ALU+BPF_XOR+BPF_X:\n\t\treturn \"xor\";\n\tcase BPF_JMP+BPF_JA+BPF_K:\n\tcase BPF_JMP+BPF_JA+BPF_X:\n\t\treturn \"jmp\";\n\tcase BPF_JMP+BPF_JEQ+BPF_K:\n\tcase BPF_JMP+BPF_JEQ+BPF_X:\n\t\treturn \"jeq\";\n\tcase BPF_JMP+BPF_JGT+BPF_K:\n\tcase BPF_JMP+BPF_JGT+BPF_X:\n\t\treturn \"jgt\";\n\tcase BPF_JMP+BPF_JGE+BPF_K:\n\tcase BPF_JMP+BPF_JGE+BPF_X:\n\t\treturn \"jge\";\n\tcase BPF_JMP+BPF_JSET+BPF_K:\n\tcase BPF_JMP+BPF_JSET+BPF_X:\n\t\treturn \"jset\";\n\tcase BPF_RET+BPF_K:\n\tcase BPF_RET+BPF_X:\n\tcase BPF_RET+BPF_A:\n\t\treturn \"ret\";\n\tcase BPF_MISC+BPF_TAX:\n\t\treturn \"tax\";\n\tcase BPF_MISC+BPF_TXA:\n\t\treturn \"txa\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"   \""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %.4x: %.2x %.2x %.2x %.8x\"",
            "i",
            "bpf->code",
            "bpf->jt",
            "bpf->jf",
            "bpf->k"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"=================================\\n\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" line  OP JT JF    K\\n\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsec_print.h\"\n\nvoid print(struct sock_filter *filter, int entries) {\n\tint i;\n\n\t/* header */\n\tprintf(\" line  OP JT JF    K\\n\");\n\tprintf(\"=================================\\n\");\n\tstruct sock_filter *bpf = filter;\n\tfor (i = 0; i < entries; i++, bpf++) {\n\n\t\t/* convert the bpf statement */\n//\t\tbpf.code = ttoh16(arch, bpf.code);\n//\t\tbpf.k = ttoh32(arch, bpf.k);\n\n\t\t/* display a hex dump */\n\t\tprintf(\" %.4x: %.2x %.2x %.2x %.8x\",\n\t\t       i, bpf->code, bpf->jt, bpf->jf, bpf->k);\n\n\t\t/* display the assembler statements */\n\t\tprintf(\"   \");\n\t\tprintf(\"%-3s\", bpf_decode_op(bpf));\n\t\tprintf(\" \");\n\t\tbpf_decode_args(bpf, i);\n\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "bpf_decode_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-print/print.c",
    "lines": "196-305",
    "snippet": "static void bpf_decode_args(const struct sock_filter *bpf, unsigned int line) {\n\tswitch (BPF_CLASS(bpf->code)) {\n\tcase BPF_LD:\n\tcase BPF_LDX:\n\t\tswitch (BPF_MODE(bpf->code)) {\n\t\tcase BPF_ABS:\n\t\t\tsyscall_loaded = 0;\n\t\t\tif (bpf->k == offsetof(struct seccomp_data, arch))\n\t\t\t\tprintf(\"data.architecture\");\n\t\t\telse if (bpf->k == offsetof(struct seccomp_data, nr)) {\n\t\t\t\tprintf(\"data.syscall-number\");\n\t\t\t\tsyscall_loaded = 1;\n\t\t\t}\n\t\t\telse if (bpf->k == offsetof(struct seccomp_data, instruction_pointer))\n\t\t\t\tprintf(\"data.instruction_pointer\");\n\t\t\telse {\n\t\t\t\tint index = bpf->k - offsetof(struct seccomp_data, args);\n\t\t\t\tprintf(\"data.args[%x]\", index);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_MEM:\n\t\t\tprintf(\"$temp[%u]\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_IMM:\n\t\t\tprintf(\"%x\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_IND:\n\t\t\tprintf(\"$data[X + %x]\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_LEN:\n\t\t\tprintf(\"len($data)\");\n\t\t\tbreak;\n\t\tcase BPF_MSH:\n\t\t\tprintf(\"4 * $data[%x] & 0x0f\", bpf->k);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BPF_ST:\n\tcase BPF_STX:\n\t\tprintf(\"$temp[%u]\", bpf->k);\n\t\tbreak;\n\tcase BPF_ALU:\n\t\tif (BPF_SRC(bpf->code) == BPF_K) {\n\t\t\tswitch (BPF_OP(bpf->code)) {\n\t\t\tcase BPF_OR:\n\t\t\tcase BPF_AND:\n\t\t\t\tprintf(\"%.8x\", bpf->k);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%x\", bpf->k);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tprintf(\"%u\", bpf->k);\n\t\tbreak;\n\tcase BPF_JMP:\n\t\tif (BPF_OP(bpf->code) == BPF_JA) {\n\t\t\tprintf(\"%.4u\", (line + 1) + bpf->k);\n\t\t}\n\t\telse {\n\t\t\tconst char *name = NULL;\n\t\t\tif (syscall_loaded && native_arch)\n\t\t\t\tname = syscall_find_nr(bpf->k);\n\t\t\tif (bpf->k == ARCH_32) {\n\t\t\t\tprintf(\"ARCH_32 %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\t\t native_arch = (ARCH_NR == ARCH_32)? 1: 0;\n\t\t\t}\n\t\t\telse if (bpf->k == ARCH_64) {\n\t\t\t\tprintf(\"ARCH_64 %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\t\t native_arch = (ARCH_NR == ARCH_64)? 1: 0;\n\t\t\t}\n\t\t\telse if (bpf->k == X32_SYSCALL_BIT)\n\t\t\t\tprintf(\"X32_ABI %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\telse if (name)\n\t\t\t\tprintf(\"%s %.4x (false %.4x)\",\n\t\t\t\t       name,\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\telse\n\t\t\t\tprintf(\"%x %.4x (false %.4x)\",\n\t\t\t\t       bpf->k,\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t}\n\t\tbreak;\n\tcase BPF_RET:\n\t\tif (BPF_RVAL(bpf->code) == BPF_A) {\n\t\t\t/* XXX - accumulator? */\n\t\t\tprintf(\"$acc\");\n\t\t}\n\t\telse if (BPF_SRC(bpf->code) == BPF_K) {\n\t\t\tbpf_decode_action(bpf->k);\n\t\t}\n\t\telse if (BPF_SRC(bpf->code) == BPF_X) {\n\t\t\t/* XXX - any idea? */\n\t\t\tprintf(\"???\");\n\t\t}\n\t\tbreak;\n\tcase BPF_MISC:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"???\");\n\t}\n}",
    "includes": [
      "#include \"fsec_print.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int syscall_loaded = 0;",
      "int native_arch = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"???\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"???\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SRC",
          "args": [
            "bpf->code"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_decode_action",
          "args": [
            "bpf->k"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_decode_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-print/print.c",
          "lines": "162-188",
          "snippet": "static void bpf_decode_action(uint32_t k) {\n\tuint32_t act = k & SECCOMP_RET_ACTION;\n\tuint32_t data = k & SECCOMP_RET_DATA;\n\n\tswitch (act) {\n\tcase SECCOMP_RET_KILL:\n\t\tprintf(\"KILL\");\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tprintf(\"TRAP\");\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tprintf(\"ERRNO(%u)\", data);\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tprintf(\"TRACE(%u)\", data);\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tprintf(\"LOG\");\n\t\tbreak;\n\tcase SECCOMP_RET_ALLOW:\n\t\tprintf(\"ALLOW\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"0x%.8x\", k);\n\t}\n}",
          "includes": [
            "#include \"fsec_print.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsec_print.h\"\n\nstatic void bpf_decode_action(uint32_t k) {\n\tuint32_t act = k & SECCOMP_RET_ACTION;\n\tuint32_t data = k & SECCOMP_RET_DATA;\n\n\tswitch (act) {\n\tcase SECCOMP_RET_KILL:\n\t\tprintf(\"KILL\");\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tprintf(\"TRAP\");\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tprintf(\"ERRNO(%u)\", data);\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tprintf(\"TRACE(%u)\", data);\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tprintf(\"LOG\");\n\t\tbreak;\n\tcase SECCOMP_RET_ALLOW:\n\t\tprintf(\"ALLOW\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"0x%.8x\", k);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_SRC",
          "args": [
            "bpf->code"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"$acc\""
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_RVAL",
          "args": [
            "bpf->code"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%x %.4x (false %.4x)\"",
            "bpf->k",
            "(line + 1) + bpf->jt",
            "(line + 1) + bpf->jf"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %.4x (false %.4x)\"",
            "name",
            "(line + 1) + bpf->jt",
            "(line + 1) + bpf->jf"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"X32_ABI %.4x (false %.4x)\"",
            "(line + 1) + bpf->jt",
            "(line + 1) + bpf->jf"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ARCH_64 %.4x (false %.4x)\"",
            "(line + 1) + bpf->jt",
            "(line + 1) + bpf->jf"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ARCH_32 %.4x (false %.4x)\"",
            "(line + 1) + bpf->jt",
            "(line + 1) + bpf->jf"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_find_nr",
          "args": [
            "bpf->k"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_find_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-print/syscall_list.c",
          "lines": "38-47",
          "snippet": "const char *syscall_find_nr(int nr) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (nr == syslist[i].nr)\n\t\t\treturn syslist[i].name;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"fsec_print.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"fsec_print.h\"\n\nstatic const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};\n\nconst char *syscall_find_nr(int nr) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (nr == syslist[i].nr)\n\t\t\treturn syslist[i].name;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%.4u\"",
            "(line + 1) + bpf->k"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "bpf->code"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%u\"",
            "bpf->k"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%x\"",
            "bpf->k"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%.8x\"",
            "bpf->k"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "bpf->code"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SRC",
          "args": [
            "bpf->code"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"$temp[%u]\"",
            "bpf->k"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"4 * $data[%x] & 0x0f\"",
            "bpf->k"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"len($data)\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"$data[X + %x]\"",
            "bpf->k"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%x\"",
            "bpf->k"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"$temp[%u]\"",
            "bpf->k"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"data.args[%x]\"",
            "index"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"data.instruction_pointer\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"data.syscall-number\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"data.architecture\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "bpf->code"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_CLASS",
          "args": [
            "bpf->code"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsec_print.h\"\n\nint syscall_loaded = 0;\nint native_arch = 0;\n\nstatic void bpf_decode_args(const struct sock_filter *bpf, unsigned int line) {\n\tswitch (BPF_CLASS(bpf->code)) {\n\tcase BPF_LD:\n\tcase BPF_LDX:\n\t\tswitch (BPF_MODE(bpf->code)) {\n\t\tcase BPF_ABS:\n\t\t\tsyscall_loaded = 0;\n\t\t\tif (bpf->k == offsetof(struct seccomp_data, arch))\n\t\t\t\tprintf(\"data.architecture\");\n\t\t\telse if (bpf->k == offsetof(struct seccomp_data, nr)) {\n\t\t\t\tprintf(\"data.syscall-number\");\n\t\t\t\tsyscall_loaded = 1;\n\t\t\t}\n\t\t\telse if (bpf->k == offsetof(struct seccomp_data, instruction_pointer))\n\t\t\t\tprintf(\"data.instruction_pointer\");\n\t\t\telse {\n\t\t\t\tint index = bpf->k - offsetof(struct seccomp_data, args);\n\t\t\t\tprintf(\"data.args[%x]\", index);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_MEM:\n\t\t\tprintf(\"$temp[%u]\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_IMM:\n\t\t\tprintf(\"%x\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_IND:\n\t\t\tprintf(\"$data[X + %x]\", bpf->k);\n\t\t\tbreak;\n\t\tcase BPF_LEN:\n\t\t\tprintf(\"len($data)\");\n\t\t\tbreak;\n\t\tcase BPF_MSH:\n\t\t\tprintf(\"4 * $data[%x] & 0x0f\", bpf->k);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BPF_ST:\n\tcase BPF_STX:\n\t\tprintf(\"$temp[%u]\", bpf->k);\n\t\tbreak;\n\tcase BPF_ALU:\n\t\tif (BPF_SRC(bpf->code) == BPF_K) {\n\t\t\tswitch (BPF_OP(bpf->code)) {\n\t\t\tcase BPF_OR:\n\t\t\tcase BPF_AND:\n\t\t\t\tprintf(\"%.8x\", bpf->k);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%x\", bpf->k);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tprintf(\"%u\", bpf->k);\n\t\tbreak;\n\tcase BPF_JMP:\n\t\tif (BPF_OP(bpf->code) == BPF_JA) {\n\t\t\tprintf(\"%.4u\", (line + 1) + bpf->k);\n\t\t}\n\t\telse {\n\t\t\tconst char *name = NULL;\n\t\t\tif (syscall_loaded && native_arch)\n\t\t\t\tname = syscall_find_nr(bpf->k);\n\t\t\tif (bpf->k == ARCH_32) {\n\t\t\t\tprintf(\"ARCH_32 %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\t\t native_arch = (ARCH_NR == ARCH_32)? 1: 0;\n\t\t\t}\n\t\t\telse if (bpf->k == ARCH_64) {\n\t\t\t\tprintf(\"ARCH_64 %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\t\t native_arch = (ARCH_NR == ARCH_64)? 1: 0;\n\t\t\t}\n\t\t\telse if (bpf->k == X32_SYSCALL_BIT)\n\t\t\t\tprintf(\"X32_ABI %.4x (false %.4x)\",\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\telse if (name)\n\t\t\t\tprintf(\"%s %.4x (false %.4x)\",\n\t\t\t\t       name,\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t\telse\n\t\t\t\tprintf(\"%x %.4x (false %.4x)\",\n\t\t\t\t       bpf->k,\n\t\t\t\t       (line + 1) + bpf->jt,\n\t\t\t\t       (line + 1) + bpf->jf);\n\t\t}\n\t\tbreak;\n\tcase BPF_RET:\n\t\tif (BPF_RVAL(bpf->code) == BPF_A) {\n\t\t\t/* XXX - accumulator? */\n\t\t\tprintf(\"$acc\");\n\t\t}\n\t\telse if (BPF_SRC(bpf->code) == BPF_K) {\n\t\t\tbpf_decode_action(bpf->k);\n\t\t}\n\t\telse if (BPF_SRC(bpf->code) == BPF_X) {\n\t\t\t/* XXX - any idea? */\n\t\t\tprintf(\"???\");\n\t\t}\n\t\tbreak;\n\tcase BPF_MISC:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"???\");\n\t}\n}"
  },
  {
    "function_name": "bpf_decode_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-print/print.c",
    "lines": "162-188",
    "snippet": "static void bpf_decode_action(uint32_t k) {\n\tuint32_t act = k & SECCOMP_RET_ACTION;\n\tuint32_t data = k & SECCOMP_RET_DATA;\n\n\tswitch (act) {\n\tcase SECCOMP_RET_KILL:\n\t\tprintf(\"KILL\");\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tprintf(\"TRAP\");\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tprintf(\"ERRNO(%u)\", data);\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tprintf(\"TRACE(%u)\", data);\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tprintf(\"LOG\");\n\t\tbreak;\n\tcase SECCOMP_RET_ALLOW:\n\t\tprintf(\"ALLOW\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"0x%.8x\", k);\n\t}\n}",
    "includes": [
      "#include \"fsec_print.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"0x%.8x\"",
            "k"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ALLOW\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LOG\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"TRACE(%u)\"",
            "data"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERRNO(%u)\"",
            "data"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"TRAP\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"KILL\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsec_print.h\"\n\nstatic void bpf_decode_action(uint32_t k) {\n\tuint32_t act = k & SECCOMP_RET_ACTION;\n\tuint32_t data = k & SECCOMP_RET_DATA;\n\n\tswitch (act) {\n\tcase SECCOMP_RET_KILL:\n\t\tprintf(\"KILL\");\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tprintf(\"TRAP\");\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tprintf(\"ERRNO(%u)\", data);\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tprintf(\"TRACE(%u)\", data);\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tprintf(\"LOG\");\n\t\tbreak;\n\tcase SECCOMP_RET_ALLOW:\n\t\tprintf(\"ALLOW\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"0x%.8x\", k);\n\t}\n}"
  },
  {
    "function_name": "bpf_decode_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fsec-print/print.c",
    "lines": "56-160",
    "snippet": "static const char *bpf_decode_op(const struct sock_filter *bpf) {\n\tswitch (bpf->code) {\n\tcase BPF_LD+BPF_W+BPF_IMM:\n\tcase BPF_LD+BPF_W+BPF_ABS:\n\tcase BPF_LD+BPF_W+BPF_IND:\n\tcase BPF_LD+BPF_W+BPF_MEM:\n\tcase BPF_LD+BPF_W+BPF_LEN:\n\tcase BPF_LD+BPF_W+BPF_MSH:\n\t\treturn \"ld\";\n\tcase BPF_LD+BPF_H+BPF_IMM:\n\tcase BPF_LD+BPF_H+BPF_ABS:\n\tcase BPF_LD+BPF_H+BPF_IND:\n\tcase BPF_LD+BPF_H+BPF_MEM:\n\tcase BPF_LD+BPF_H+BPF_LEN:\n\tcase BPF_LD+BPF_H+BPF_MSH:\n\t\treturn \"ldh\";\n\tcase BPF_LD+BPF_B+BPF_IMM:\n\tcase BPF_LD+BPF_B+BPF_ABS:\n\tcase BPF_LD+BPF_B+BPF_IND:\n\tcase BPF_LD+BPF_B+BPF_MEM:\n\tcase BPF_LD+BPF_B+BPF_LEN:\n\tcase BPF_LD+BPF_B+BPF_MSH:\n\t\treturn \"ldb\";\n\tcase BPF_LDX+BPF_W+BPF_IMM:\n\tcase BPF_LDX+BPF_W+BPF_ABS:\n\tcase BPF_LDX+BPF_W+BPF_IND:\n\tcase BPF_LDX+BPF_W+BPF_MEM:\n\tcase BPF_LDX+BPF_W+BPF_LEN:\n\tcase BPF_LDX+BPF_W+BPF_MSH:\n\tcase BPF_LDX+BPF_H+BPF_IMM:\n\tcase BPF_LDX+BPF_H+BPF_ABS:\n\tcase BPF_LDX+BPF_H+BPF_IND:\n\tcase BPF_LDX+BPF_H+BPF_MEM:\n\tcase BPF_LDX+BPF_H+BPF_LEN:\n\tcase BPF_LDX+BPF_H+BPF_MSH:\n\tcase BPF_LDX+BPF_B+BPF_IMM:\n\tcase BPF_LDX+BPF_B+BPF_ABS:\n\tcase BPF_LDX+BPF_B+BPF_IND:\n\tcase BPF_LDX+BPF_B+BPF_MEM:\n\tcase BPF_LDX+BPF_B+BPF_LEN:\n\tcase BPF_LDX+BPF_B+BPF_MSH:\n\t\treturn \"ldx\";\n\tcase BPF_ST:\n\t\treturn \"st\";\n\tcase BPF_STX:\n\t\treturn \"stx\";\n\tcase BPF_ALU+BPF_ADD+BPF_K:\n\tcase BPF_ALU+BPF_ADD+BPF_X:\n\t\treturn \"add\";\n\tcase BPF_ALU+BPF_SUB+BPF_K:\n\tcase BPF_ALU+BPF_SUB+BPF_X:\n\t\treturn \"sub\";\n\tcase BPF_ALU+BPF_MUL+BPF_K:\n\tcase BPF_ALU+BPF_MUL+BPF_X:\n\t\treturn \"mul\";\n\tcase BPF_ALU+BPF_DIV+BPF_K:\n\tcase BPF_ALU+BPF_DIV+BPF_X:\n\t\treturn \"div\";\n\tcase BPF_ALU+BPF_OR+BPF_K:\n\tcase BPF_ALU+BPF_OR+BPF_X:\n\t\treturn \"or\";\n\tcase BPF_ALU+BPF_AND+BPF_K:\n\tcase BPF_ALU+BPF_AND+BPF_X:\n\t\treturn \"and\";\n\tcase BPF_ALU+BPF_LSH+BPF_K:\n\tcase BPF_ALU+BPF_LSH+BPF_X:\n\t\treturn \"lsh\";\n\tcase BPF_ALU+BPF_RSH+BPF_K:\n\tcase BPF_ALU+BPF_RSH+BPF_X:\n\t\treturn \"rsh\";\n\tcase BPF_ALU+BPF_NEG+BPF_K:\n\tcase BPF_ALU+BPF_NEG+BPF_X:\n\t\treturn \"neg\";\n\tcase BPF_ALU+BPF_MOD+BPF_K:\n\tcase BPF_ALU+BPF_MOD+BPF_X:\n\t\treturn \"mod\";\n\tcase BPF_ALU+BPF_XOR+BPF_K:\n\tcase BPF_ALU+BPF_XOR+BPF_X:\n\t\treturn \"xor\";\n\tcase BPF_JMP+BPF_JA+BPF_K:\n\tcase BPF_JMP+BPF_JA+BPF_X:\n\t\treturn \"jmp\";\n\tcase BPF_JMP+BPF_JEQ+BPF_K:\n\tcase BPF_JMP+BPF_JEQ+BPF_X:\n\t\treturn \"jeq\";\n\tcase BPF_JMP+BPF_JGT+BPF_K:\n\tcase BPF_JMP+BPF_JGT+BPF_X:\n\t\treturn \"jgt\";\n\tcase BPF_JMP+BPF_JGE+BPF_K:\n\tcase BPF_JMP+BPF_JGE+BPF_X:\n\t\treturn \"jge\";\n\tcase BPF_JMP+BPF_JSET+BPF_K:\n\tcase BPF_JMP+BPF_JSET+BPF_X:\n\t\treturn \"jset\";\n\tcase BPF_RET+BPF_K:\n\tcase BPF_RET+BPF_X:\n\tcase BPF_RET+BPF_A:\n\t\treturn \"ret\";\n\tcase BPF_MISC+BPF_TAX:\n\t\treturn \"tax\";\n\tcase BPF_MISC+BPF_TXA:\n\t\treturn \"txa\";\n\t}\n\treturn \"???\";\n}",
    "includes": [
      "#include \"fsec_print.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fsec_print.h\"\n\nstatic const char *bpf_decode_op(const struct sock_filter *bpf) {\n\tswitch (bpf->code) {\n\tcase BPF_LD+BPF_W+BPF_IMM:\n\tcase BPF_LD+BPF_W+BPF_ABS:\n\tcase BPF_LD+BPF_W+BPF_IND:\n\tcase BPF_LD+BPF_W+BPF_MEM:\n\tcase BPF_LD+BPF_W+BPF_LEN:\n\tcase BPF_LD+BPF_W+BPF_MSH:\n\t\treturn \"ld\";\n\tcase BPF_LD+BPF_H+BPF_IMM:\n\tcase BPF_LD+BPF_H+BPF_ABS:\n\tcase BPF_LD+BPF_H+BPF_IND:\n\tcase BPF_LD+BPF_H+BPF_MEM:\n\tcase BPF_LD+BPF_H+BPF_LEN:\n\tcase BPF_LD+BPF_H+BPF_MSH:\n\t\treturn \"ldh\";\n\tcase BPF_LD+BPF_B+BPF_IMM:\n\tcase BPF_LD+BPF_B+BPF_ABS:\n\tcase BPF_LD+BPF_B+BPF_IND:\n\tcase BPF_LD+BPF_B+BPF_MEM:\n\tcase BPF_LD+BPF_B+BPF_LEN:\n\tcase BPF_LD+BPF_B+BPF_MSH:\n\t\treturn \"ldb\";\n\tcase BPF_LDX+BPF_W+BPF_IMM:\n\tcase BPF_LDX+BPF_W+BPF_ABS:\n\tcase BPF_LDX+BPF_W+BPF_IND:\n\tcase BPF_LDX+BPF_W+BPF_MEM:\n\tcase BPF_LDX+BPF_W+BPF_LEN:\n\tcase BPF_LDX+BPF_W+BPF_MSH:\n\tcase BPF_LDX+BPF_H+BPF_IMM:\n\tcase BPF_LDX+BPF_H+BPF_ABS:\n\tcase BPF_LDX+BPF_H+BPF_IND:\n\tcase BPF_LDX+BPF_H+BPF_MEM:\n\tcase BPF_LDX+BPF_H+BPF_LEN:\n\tcase BPF_LDX+BPF_H+BPF_MSH:\n\tcase BPF_LDX+BPF_B+BPF_IMM:\n\tcase BPF_LDX+BPF_B+BPF_ABS:\n\tcase BPF_LDX+BPF_B+BPF_IND:\n\tcase BPF_LDX+BPF_B+BPF_MEM:\n\tcase BPF_LDX+BPF_B+BPF_LEN:\n\tcase BPF_LDX+BPF_B+BPF_MSH:\n\t\treturn \"ldx\";\n\tcase BPF_ST:\n\t\treturn \"st\";\n\tcase BPF_STX:\n\t\treturn \"stx\";\n\tcase BPF_ALU+BPF_ADD+BPF_K:\n\tcase BPF_ALU+BPF_ADD+BPF_X:\n\t\treturn \"add\";\n\tcase BPF_ALU+BPF_SUB+BPF_K:\n\tcase BPF_ALU+BPF_SUB+BPF_X:\n\t\treturn \"sub\";\n\tcase BPF_ALU+BPF_MUL+BPF_K:\n\tcase BPF_ALU+BPF_MUL+BPF_X:\n\t\treturn \"mul\";\n\tcase BPF_ALU+BPF_DIV+BPF_K:\n\tcase BPF_ALU+BPF_DIV+BPF_X:\n\t\treturn \"div\";\n\tcase BPF_ALU+BPF_OR+BPF_K:\n\tcase BPF_ALU+BPF_OR+BPF_X:\n\t\treturn \"or\";\n\tcase BPF_ALU+BPF_AND+BPF_K:\n\tcase BPF_ALU+BPF_AND+BPF_X:\n\t\treturn \"and\";\n\tcase BPF_ALU+BPF_LSH+BPF_K:\n\tcase BPF_ALU+BPF_LSH+BPF_X:\n\t\treturn \"lsh\";\n\tcase BPF_ALU+BPF_RSH+BPF_K:\n\tcase BPF_ALU+BPF_RSH+BPF_X:\n\t\treturn \"rsh\";\n\tcase BPF_ALU+BPF_NEG+BPF_K:\n\tcase BPF_ALU+BPF_NEG+BPF_X:\n\t\treturn \"neg\";\n\tcase BPF_ALU+BPF_MOD+BPF_K:\n\tcase BPF_ALU+BPF_MOD+BPF_X:\n\t\treturn \"mod\";\n\tcase BPF_ALU+BPF_XOR+BPF_K:\n\tcase BPF_ALU+BPF_XOR+BPF_X:\n\t\treturn \"xor\";\n\tcase BPF_JMP+BPF_JA+BPF_K:\n\tcase BPF_JMP+BPF_JA+BPF_X:\n\t\treturn \"jmp\";\n\tcase BPF_JMP+BPF_JEQ+BPF_K:\n\tcase BPF_JMP+BPF_JEQ+BPF_X:\n\t\treturn \"jeq\";\n\tcase BPF_JMP+BPF_JGT+BPF_K:\n\tcase BPF_JMP+BPF_JGT+BPF_X:\n\t\treturn \"jgt\";\n\tcase BPF_JMP+BPF_JGE+BPF_K:\n\tcase BPF_JMP+BPF_JGE+BPF_X:\n\t\treturn \"jge\";\n\tcase BPF_JMP+BPF_JSET+BPF_K:\n\tcase BPF_JMP+BPF_JSET+BPF_X:\n\t\treturn \"jset\";\n\tcase BPF_RET+BPF_K:\n\tcase BPF_RET+BPF_X:\n\tcase BPF_RET+BPF_A:\n\t\treturn \"ret\";\n\tcase BPF_MISC+BPF_TAX:\n\t\treturn \"tax\";\n\tcase BPF_MISC+BPF_TXA:\n\t\treturn \"txa\";\n\t}\n\treturn \"???\";\n}"
  }
]