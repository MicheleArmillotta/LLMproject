[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "888-1172",
    "snippet": "int main(int argc, char **argv) {\n\tint i;\n\tint prog_index = -1;\t\t\t  // index in argv where the program command starts\n\tint lockfd_network = -1;\n\tint lockfd_directory = -1;\n\tint option_cgroup = 0;\n\tint custom_profile = 0;\t// custom profile loaded\n\tint arg_caps_cmdline = 0; \t// caps requested on command line (used to break out of --chroot)\n\n\t// drop permissions by default and rise them when required\n\tEUID_INIT();\n\tEUID_USER();\n\n\t// sanitize the umask\n\torig_umask = umask(022);\n\n\t// check if the user is allowed to use firejail\n\tinit_cfg(argc, argv);\n\tassert(cfg.homedir);\n\n\t// get starting timestamp, process --quiet\n\tstart_timestamp = getticks();\n\tif (check_arg(argc, argv, \"--quiet\", 1))\n\t\targ_quiet = 1;\n\n\t// cleanup at exit\n\tEUID_ROOT();\n\tatexit(clear_atexit);\n\n\t// build /run/firejail directory structure\n\tpreproc_build_firejail_dir();\n\tchar *container_name = getenv(\"container\");\n\tif (!container_name || strcmp(container_name, \"firejail\")) {\n\t\tlockfd_directory = open(RUN_DIRECTORY_LOCK_FILE, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);\n\t\tif (lockfd_directory != -1) {\n\t\t\tint rv = fchown(lockfd_directory, 0, 0);\n\t\t\t(void) rv;\n\t\t\tflock(lockfd_directory, LOCK_EX);\n\t\t}\n\t\tpreproc_clean_run();\n\t\tflock(lockfd_directory, LOCK_UN);\n\t\tclose(lockfd_directory);\n\t}\n\tEUID_USER();\n\n\n\t// process allow-debuggers\n\tif (check_arg(argc, argv, \"--allow-debuggers\", 1)) {\n\t\t// check kernel version\n\t\tstruct utsname u;\n\t\tint rv = uname(&u);\n\t\tif (rv != 0)\n\t\t\terrExit(\"uname\");\n\t\tint major;\n\t\tint minor;\n\t\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\t\texit(1);\n\t\t}\n\t\tif (major < 4 || (major == 4 && minor < 8)) {\n\t\t\tfprintf(stderr, \"Error: --allow-debuggers is disabled on Linux kernels prior to 4.8. \"\n\t\t\t\t\"A bug in ptrace call allows a full bypass of the seccomp filter. \"\n\t\t\t\t\"Your current kernel version is %d.%d.\\n\", major, minor);\n\t\t\texit(1);\n\t\t}\n\n\t\targ_allow_debuggers = 1;\n\t\tchar *cmd = strdup(\"noblacklist ${PATH}/strace\");\n\t\tif (!cmd)\n\t\t\terrExit(\"strdup\");\n\t\tprofile_add(cmd);\n\t}\n\n\t// profile builder\n\tif (check_arg(argc, argv, \"--build\", 0)) // supports both --build and --build=filename\n\t\trun_builder(argc, argv); // this function will not return\n\n\t// check argv[0] symlink wrapper if this is not a login shell\n\tif (*argv[0] != '-')\n\t\trun_symlink(argc, argv, 0); // if symlink detected, this function will not return\n\n\t// check if we already have a sandbox running\n\t// If LXC is detected, start firejail sandbox\n\t// otherwise try to detect a PID namespace by looking under /proc for specific kernel processes and:\n\t//\t- start the application in a /bin/bash shell\n\tif (check_namespace_virt() == 0) {\n\t\tEUID_ROOT();\n\t\tint rv = check_kernel_procs();\n\t\tEUID_USER();\n\t\tif (rv == 0) {\n\t\t\tif (check_arg(argc, argv, \"--version\", 1)) {\n\t\t\t\tprintf(\"firejail version %s\\n\", VERSION);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t// start the program directly without sandboxing\n\t\t\trun_no_sandbox(argc, argv);\n\t\t\t// it will never get here!\n\t\t\tassert(0);\n\t\t}\n\t}\n\tEUID_ASSERT();\n\n\n\t// check firejail directories\n\tEUID_ROOT();\n\tdelete_run_files(sandbox_pid);\n\tEUID_USER();\n\n\t//check if the parent is sshd daemon\n\tint parent_sshd = 0;\n\t{\n\t\tpid_t ppid = getppid();\n\t\tEUID_ROOT();\n\t\tchar *comm = pid_proc_comm(ppid);\n\t\tEUID_USER();\n\t\tif (comm) {\n\t\t\tif (strcmp(comm, \"sshd\") == 0) {\n\t\t\t\targ_quiet = 1;\n\t\t\t\tparent_sshd = 1;\n\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t\t{EUID_ROOT();\n\t\t\t\tFILE *fp = fopen(\"/firelog\", \"w\");\n\t\t\t\tif (fp) {\n\t\t\t\t\tint i;\n\t\t\t\t\tfprintf(fp, \"argc %d: \", argc);\n\t\t\t\t\tfor (i = 0; i < argc; i++)\n\t\t\t\t\t\tfprintf(fp, \"#%s# \", argv[i]);\n\t\t\t\t\tfprintf(fp, \"\\n\");\n\t\t\t\t\tfclose(fp);\n\t\t\t\t}\n\t\t\t\tEUID_USER();}\n#endif\n\t\t\t\t// run sftp and scp directly without any sandboxing\n\t\t\t\t// regular login has argv[0] == \"-firejail\"\n\t\t\t\tif (*argv[0] != '-') {\n\t\t\t\t\tif (strcmp(argv[1], \"-c\") == 0 && argc > 2) {\n\t\t\t\t\t\tif (strcmp(argv[2], \"/usr/lib/openssh/sftp-server\") == 0 ||\n\t\t\t\t\t\t    strncmp(argv[2], \"scp \", 4) == 0) {\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t\t\t\t\t{EUID_ROOT();\n\t\t\t\t\t\t\tFILE *fp = fopen(\"/firelog\", \"a\");\n\t\t\t\t\t\t\tif (fp) {\n\t\t\t\t\t\t\t\tfprintf(fp, \"run without a sandbox\\n\");\n\t\t\t\t\t\t\t\tfclose(fp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tEUID_USER();}\n#endif\n\n\t\t\t\t\t\t\tdrop_privs(1);\n\t\t\t\t\t\t\tumask(orig_umask);\n\t\t\t\t\t\t\tint rv = system(argv[2]);\n\t\t\t\t\t\t\texit(rv);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(comm);\n\t\t}\n\t}\n\tEUID_ASSERT();\n\n\t// is this a login shell, or a command passed by sshd, insert command line options from /etc/firejail/login.users\n\tif (*argv[0] == '-' || parent_sshd) {\n\t\tif (argc == 1)\n\t\t\tlogin_shell = 1;\n\t\tfullargc = restricted_shell(cfg.username);\n\t\tif (fullargc) {\n\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t{EUID_ROOT();\n\t\t\tFILE *fp = fopen(\"/firelog\", \"a\");\n\t\t\tif (fp) {\n\t\t\t\tfprintf(fp, \"fullargc %d: \",  fullargc);\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < fullargc; i++)\n\t\t\t\t\tfprintf(fp, \"#%s# \", fullargv[i]);\n\t\t\t\tfprintf(fp, \"\\n\");\n\t\t\t\tfclose(fp);\n\t\t\t}\n\t\t\tEUID_USER();}\n#endif\n\n\t\t\tint j;\n\t\t\tfor (i = 1, j = fullargc; i < argc && j < MAX_ARGS; i++, j++, fullargc++)\n\t\t\t\tfullargv[j] = argv[i];\n\n\t\t\t// replace argc/argv with fullargc/fullargv\n\t\t\targv = fullargv;\n\t\t\targc = j;\n\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t{EUID_ROOT();\n\t\t\tFILE *fp = fopen(\"/firelog\", \"a\");\n\t\t\tif (fp) {\n\t\t\t\tfprintf(fp, \"argc %d: \", argc);\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < argc; i++)\n\t\t\t\t\tfprintf(fp, \"#%s# \", argv[i]);\n\t\t\t\tfprintf(fp, \"\\n\");\n\t\t\t\tfclose(fp);\n\t\t\t}\n\t\t\tEUID_USER();}\n#endif\n\t\t}\n\t}\n\telse {\n\t\t// check --output option and execute it;\n\t\tcheck_output(argc, argv); // the function will not return if --output or --output-stderr option was found\n\t}\n\tEUID_ASSERT();\n\n\n\t// check for force-nonewprivs in /etc/firejail/firejail.config file\n\tif (checkcfg(CFG_FORCE_NONEWPRIVS))\n\t\targ_nonewprivs = 1;\n\n\t// parse arguments\n\tfor (i = 1; i < argc; i++) {\n\t\trun_cmd_and_exit(i, argc, argv); // will exit if the command is recognized\n\n\t\tif (strcmp(argv[i], \"--debug\") == 0 && !arg_quiet)\n\t\t\targ_debug = 1;\n\t\telse if (strcmp(argv[i], \"--debug-blacklists\") == 0)\n\t\t\targ_debug_blacklists = 1;\n\t\telse if (strcmp(argv[i], \"--debug-whitelists\") == 0)\n\t\t\targ_debug_whitelists = 1;\n\t\telse if (strcmp(argv[i], \"--debug-private-lib\") == 0)\n\t\t\targ_debug_private_lib = 1;\n\t\telse if (strcmp(argv[i], \"--quiet\") == 0) {\n\t\t\targ_quiet = 1;\n\t\t\targ_debug = 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--allow-debuggers\") == 0) {\n\t\t\t// already handled\n\t\t}\n\n\n\t\t//*************************************\n\t\t// x11\n\t\t//*************************************\n\n#ifdef HAVE_X11\n\t\telse if (strncmp(argv[i], \"--xephyr-screen=\", 16) == 0) {\n\t\t\tif (checkcfg(CFG_X11))\n\t\t\t\t; // the processing is done directly in x11.c\n\t\t\telse\n\t\t\t\texit_err_feature(\"x11\");\n\t\t}\n#endif\n\t\t//*************************************\n\t\t// filtering\n\t\t//*************************************\n#ifdef HAVE_APPARMOR\n\t\telse if (strcmp(argv[i], \"--apparmor\") == 0)\n\t\t\targ_apparmor = 1;\n#endif\n#ifdef HAVE_SECCOMP\n\t\telse if (strncmp(argv[i], \"--protocol=\", 11) == 0) {\n\t\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\t\tif (cfg.protocol) {\n\t\t\t\t\tfwarning(\"two protocol lists are present, \\\"%s\\\" will be installed\\n\", cfg.protocol);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// store list\n\t\t\t\t\tcfg.protocol = strdup(argv[i] + 11);\n\t\t\t\t\tif (!cfg.protocol)\n\t\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\texit_err_feature(\"seccomp\");\n\t\t}\n\t\telse if (strcmp(argv[i], \"--seccomp\") == 0) {\n\t\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\t\tif (arg_seccomp) {\n\t\t\t\t\tfprintf(stderr, \"Error: seccomp already enabled\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\targ_seccomp = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\texit_err_feature(\"seccomp\");\n\t\t}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Config cfg;",
      "int arg_debug = 0;",
      "int arg_debug_blacklists = 0;",
      "int arg_debug_whitelists = 0;",
      "int arg_debug_private_lib = 0;",
      "int arg_seccomp = 0;",
      "int arg_nonewprivs = 0;",
      "int arg_quiet = 0;",
      "int arg_apparmor = 0;",
      "int arg_allow_debuggers = 0;",
      "int login_shell = 0;",
      "char *fullargv[MAX_ARGS];",
      "int fullargc = 0;",
      "pid_t sandbox_pid;",
      "mode_t orig_umask = 022;",
      "unsigned long long start_timestamp;",
      "else if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11))",
      "FILE *fp = fopen(fname, \"r\");",
      "else if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0)",
      "else if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);",
      "else if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);",
      "else if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0)"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: seccomp already enabled\\n\""
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp\") == 0) {\n\t\t\tif",
          "args": [
            "checkcfg(CFG_SECCOMP)"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_SECCOMP"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/checkcfg.c",
          "lines": "35-213",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *xpra_extra_params = \"\";",
            "char *xvfb_screen = \"800x600x24\";",
            "char *xvfb_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *xpra_extra_params = \"\";\nchar *xvfb_screen = \"800x600x24\";\nchar *xvfb_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i] + 11"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"two protocol lists are present, \\\"%s\\\" will be installed\\n\"",
            "cfg.protocol"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--allow-debuggers\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--quiet\""
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--debug-private-lib\""
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--debug-whitelists\""
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--debug-blacklists\""
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--debug\""
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_cmd_and_exit",
          "args": [
            "i",
            "argc",
            "argv"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "run_cmd_and_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "336-375",
          "snippet": "static void run_cmd_and_exit(int i, int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t//*************************************\n\t// basic arguments\n\t//*************************************\n\tif (strcmp(argv[i], \"--help\") == 0 ||\n\t    strcmp(argv[i], \"-?\") == 0) {\n\t\tusage();\n\t\texit(0);\n\t}\n\telse if (strcmp(argv[i], \"--version\") == 0) {\n\t\tprintf(\"firejail version %s\\n\", VERSION);\n\t\tprintf(\"\\n\");\n\t\tprint_compiletime_support();\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n#ifdef HAVE_OVERLAYFS\n\telse if (strcmp(argv[i], \"--overlay-clean\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (remove_overlay_directory()) {\n\t\t\t\tfprintf(stderr, \"Error: cannot remove overlay directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\texit_err_feature(\"overlayfs\");\n\t\texit(0);\n\t}\n#endif\n#ifdef HAVE_X11\n\telse if (strcmp(argv[i], \"--x11\") == 0) {\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tx11_start(argc, argv);\n\t\t\texit(0);\n\t\t}\n\t\telse\n\t\t\texit_err_feature(\"x11\");\n\t}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "else if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11))",
            "else if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0)",
            "else if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);",
            "else if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);",
            "else if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nelse if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11));\nelse if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0);\nelse if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);\nelse if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);\nelse if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0);\n\nstatic void run_cmd_and_exit(int i, int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t//*************************************\n\t// basic arguments\n\t//*************************************\n\tif (strcmp(argv[i], \"--help\") == 0 ||\n\t    strcmp(argv[i], \"-?\") == 0) {\n\t\tusage();\n\t\texit(0);\n\t}\n\telse if (strcmp(argv[i], \"--version\") == 0) {\n\t\tprintf(\"firejail version %s\\n\", VERSION);\n\t\tprintf(\"\\n\");\n\t\tprint_compiletime_support();\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n#ifdef HAVE_OVERLAYFS\n\telse if (strcmp(argv[i], \"--overlay-clean\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (remove_overlay_directory()) {\n\t\t\t\tfprintf(stderr, \"Error: cannot remove overlay directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\texit_err_feature(\"overlayfs\");\n\t\texit(0);\n\t}\n#endif\n#ifdef HAVE_X11\n\telse if (strcmp(argv[i], \"--x11\") == 0) {\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tx11_start(argc, argv);\n\t\t\texit(0);\n\t\t}\n\t\telse\n\t\t\texit_err_feature(\"x11\");\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_output",
          "args": [
            "argc",
            "argv"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "check_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/output.c",
          "lines": "25-109",
          "snippet": "void check_output(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\tint i;\n\tint outindex = 0;\n\tint enable_stderr = 0;\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--output=\", 9) == 0) {\n\t\t\toutindex = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(argv[i], \"--output-stderr=\", 16) == 0) {\n\t\t\toutindex = i;\n\t\t\tenable_stderr = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!outindex)\n\t\treturn;\n\n\n\t// check filename\n\tdrop_privs(0);\n\tchar *outfile = argv[outindex];\n\toutfile += (enable_stderr)? 16:9;\n\tinvalid_filename(outfile, 0); // no globbing\n\n\t// do not accept directories, links, and files with \"..\"\n\tif (strstr(outfile, \"..\") || is_link(outfile) || is_dir(outfile)) {\n\t\tfprintf(stderr, \"Error: invalid output file. Links, directories and files with \\\"..\\\" are not allowed.\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(outfile, &s) == 0) {\n\t\t// check permissions\n\t\tif (s.st_uid != getuid() || s.st_gid != getgid()) {\n\t\t\tfprintf(stderr, \"Error: the output file needs to be owned by the current user.\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// check hard links\n\t\tif (s.st_nlink != 1) {\n\t\t\tfprintf(stderr, \"Error: no hard links allowed.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// build the new command line\n\tint len = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tlen += strlen(argv[i]) + 1; // + ' '\n\t}\n\tlen += 100 + strlen(LIBDIR) + strlen(outfile); // tee command\n\n\tchar *cmd = malloc(len + 1); // + '\\0'\n\tif (!cmd)\n\t\terrExit(\"malloc\");\n\n\tchar *ptr = cmd;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--output=\", 9) == 0)\n\t\t\tcontinue;\n\t\tif (strncmp(argv[i], \"--output-stderr=\", 16) == 0)\n\t\t\tcontinue;\n\t\tptr += sprintf(ptr, \"%s \", argv[i]);\n\t}\n\n\tif (enable_stderr)\n\t\tsprintf(ptr, \"2>&1 | %s/firejail/ftee %s\", LIBDIR, outfile);\n\telse\n\t\tsprintf(ptr, \" | %s/firejail/ftee %s\", LIBDIR, outfile);\n\n\t// run command\n\tchar *a[4];\n\ta[0] = \"/bin/bash\";\n\ta[1] = \"-c\";\n\ta[2] = cmd;\n\ta[3] = NULL;\n\texecvp(a[0], a);\n\n\tperror(\"execvp\");\n\texit(1);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid check_output(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\tint i;\n\tint outindex = 0;\n\tint enable_stderr = 0;\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--output=\", 9) == 0) {\n\t\t\toutindex = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(argv[i], \"--output-stderr=\", 16) == 0) {\n\t\t\toutindex = i;\n\t\t\tenable_stderr = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!outindex)\n\t\treturn;\n\n\n\t// check filename\n\tdrop_privs(0);\n\tchar *outfile = argv[outindex];\n\toutfile += (enable_stderr)? 16:9;\n\tinvalid_filename(outfile, 0); // no globbing\n\n\t// do not accept directories, links, and files with \"..\"\n\tif (strstr(outfile, \"..\") || is_link(outfile) || is_dir(outfile)) {\n\t\tfprintf(stderr, \"Error: invalid output file. Links, directories and files with \\\"..\\\" are not allowed.\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(outfile, &s) == 0) {\n\t\t// check permissions\n\t\tif (s.st_uid != getuid() || s.st_gid != getgid()) {\n\t\t\tfprintf(stderr, \"Error: the output file needs to be owned by the current user.\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// check hard links\n\t\tif (s.st_nlink != 1) {\n\t\t\tfprintf(stderr, \"Error: no hard links allowed.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// build the new command line\n\tint len = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tlen += strlen(argv[i]) + 1; // + ' '\n\t}\n\tlen += 100 + strlen(LIBDIR) + strlen(outfile); // tee command\n\n\tchar *cmd = malloc(len + 1); // + '\\0'\n\tif (!cmd)\n\t\terrExit(\"malloc\");\n\n\tchar *ptr = cmd;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--output=\", 9) == 0)\n\t\t\tcontinue;\n\t\tif (strncmp(argv[i], \"--output-stderr=\", 16) == 0)\n\t\t\tcontinue;\n\t\tptr += sprintf(ptr, \"%s \", argv[i]);\n\t}\n\n\tif (enable_stderr)\n\t\tsprintf(ptr, \"2>&1 | %s/firejail/ftee %s\", LIBDIR, outfile);\n\telse\n\t\tsprintf(ptr, \" | %s/firejail/ftee %s\", LIBDIR, outfile);\n\n\t// run command\n\tchar *a[4];\n\ta[0] = \"/bin/bash\";\n\ta[1] = \"-c\";\n\ta[2] = cmd;\n\ta[3] = NULL;\n\texecvp(a[0], a);\n\n\tperror(\"execvp\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"#%s# \"",
            "argv[i]"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"argc %d: \"",
            "argc"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/firelog\"",
            "\"a\""
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"#%s# \"",
            "fullargv[i]"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"fullargc %d: \"",
            "fullargc"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restricted_shell",
          "args": [
            "cfg.username"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "restricted_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restricted_shell.c",
          "lines": "27-132",
          "snippet": "int restricted_shell(const char *user) {\n\tEUID_ASSERT();\n\tassert(user);\n\n\t// open profile file:\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/login.users\", SYSCONFDIR) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(fname, \"r\");\n\tfree(fname);\n\tif (fp == NULL)\n\t\treturn 0;\n\n\tint lineno = 0;\n\tchar buf[MAX_READ];\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\tlineno++;\n\n\t\t// remove empty spaces at the beginning of the line\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t') {\n\t\t\tptr++;\n\t\t}\n\t\tif (*ptr == '\\n' || *ptr == '#')\n\t\t\tcontinue;\n\n\t\t//\n\t\t// parse line\n\t\t//\n\n\t\t// extract users\n\t\tchar *usr = ptr;\n\t\tchar *args = strchr(usr, ':');\n\t\tif (args == NULL) {\n\t\t\tfprintf(stderr, \"Error: users.conf line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\t*args = '\\0';\n\t\targs++;\n\t\tptr = strchr(args, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// extract firejail command line arguments\n\t\tchar *ptr2 = args;\n\t\tint found = 0;\n\t\twhile (*ptr2 != '\\0') {\n\t\t\tif (*ptr2 != ' ' && *ptr2 != '\\t') {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr2++;\n\t\t}\n\t\t// if nothing follows, continue\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\t// user name globbing\n\t\tif (fnmatch(usr, user, 0) == 0) {\n\t\t    \t// process program arguments\n\n\t\t    \tfullargv[0] = \"firejail\";\n\t\t    \tint i;\n\t\t    \tptr = args;\n\t\t    \tfor (i = 1; i < MAX_ARGS; i++) {\n\t\t    \t\t// skip blanks\n\t\t    \t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t    \t\t\tptr++;\n\t\t    \t\tfullargv[i] = ptr;\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t\t{EUID_ROOT();\n\t\t\t\tFILE *fp = fopen(\"/firelog\", \"a\");\n\t\t\t\tif (fp) {\n\t\t\t\t\tfprintf(fp, \"i %d ptr #%s#\\n\", i, fullargv[i]);\n\t\t\t\t\tfclose(fp);\n\t\t\t\t}\n\t\t\t\tEUID_USER();}\n#endif\n\n\t\t    \t\tif (*ptr != '\\0') {\n\t\t    \t\t\t// go to the end of the word\n\t\t\t    \t\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0')\n\t\t\t    \t\t\tptr++;\n\t\t    \t\t\t*ptr ='\\0';\n\t\t    \t\t\tfullargv[i] = strdup(fullargv[i]);\n\t\t    \t\t\tif (fullargv[i] == NULL)\n\t\t    \t\t\t\terrExit(\"strdup\");\n\t\t    \t\t\tptr++;\n\t\t    \t\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t    \t\t\t\tptr++;\n\t\t    \t\t\tif (*ptr != '\\0')\n\t\t\t    \t\t\tcontinue;\n\t\t    \t\t}\n\t    \t\t\tfullargv[i] = strdup(fullargv[i]);\n\t\t\t\tfclose(fp);\n\t\t    \t\treturn i + 1;\n\t\t\t}\n\t\t\tfprintf(stderr, \"Error: too many program arguments in users.conf line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfclose(fp);\n\n\treturn 0;\n}",
          "includes": [
            "#include <fnmatch.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 4096\t// maximum line length"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fnmatch.h>\n#include \"firejail.h\"\n\n#define MAX_READ 4096\t// maximum line length\n\nint restricted_shell(const char *user) {\n\tEUID_ASSERT();\n\tassert(user);\n\n\t// open profile file:\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/login.users\", SYSCONFDIR) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(fname, \"r\");\n\tfree(fname);\n\tif (fp == NULL)\n\t\treturn 0;\n\n\tint lineno = 0;\n\tchar buf[MAX_READ];\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\tlineno++;\n\n\t\t// remove empty spaces at the beginning of the line\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t') {\n\t\t\tptr++;\n\t\t}\n\t\tif (*ptr == '\\n' || *ptr == '#')\n\t\t\tcontinue;\n\n\t\t//\n\t\t// parse line\n\t\t//\n\n\t\t// extract users\n\t\tchar *usr = ptr;\n\t\tchar *args = strchr(usr, ':');\n\t\tif (args == NULL) {\n\t\t\tfprintf(stderr, \"Error: users.conf line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\t*args = '\\0';\n\t\targs++;\n\t\tptr = strchr(args, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// extract firejail command line arguments\n\t\tchar *ptr2 = args;\n\t\tint found = 0;\n\t\twhile (*ptr2 != '\\0') {\n\t\t\tif (*ptr2 != ' ' && *ptr2 != '\\t') {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr2++;\n\t\t}\n\t\t// if nothing follows, continue\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\t// user name globbing\n\t\tif (fnmatch(usr, user, 0) == 0) {\n\t\t    \t// process program arguments\n\n\t\t    \tfullargv[0] = \"firejail\";\n\t\t    \tint i;\n\t\t    \tptr = args;\n\t\t    \tfor (i = 1; i < MAX_ARGS; i++) {\n\t\t    \t\t// skip blanks\n\t\t    \t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t    \t\t\tptr++;\n\t\t    \t\tfullargv[i] = ptr;\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t\t{EUID_ROOT();\n\t\t\t\tFILE *fp = fopen(\"/firelog\", \"a\");\n\t\t\t\tif (fp) {\n\t\t\t\t\tfprintf(fp, \"i %d ptr #%s#\\n\", i, fullargv[i]);\n\t\t\t\t\tfclose(fp);\n\t\t\t\t}\n\t\t\t\tEUID_USER();}\n#endif\n\n\t\t    \t\tif (*ptr != '\\0') {\n\t\t    \t\t\t// go to the end of the word\n\t\t\t    \t\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0')\n\t\t\t    \t\t\tptr++;\n\t\t    \t\t\t*ptr ='\\0';\n\t\t    \t\t\tfullargv[i] = strdup(fullargv[i]);\n\t\t    \t\t\tif (fullargv[i] == NULL)\n\t\t    \t\t\t\terrExit(\"strdup\");\n\t\t    \t\t\tptr++;\n\t\t    \t\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t    \t\t\t\tptr++;\n\t\t    \t\t\tif (*ptr != '\\0')\n\t\t\t    \t\t\tcontinue;\n\t\t    \t\t}\n\t    \t\t\tfullargv[i] = strdup(fullargv[i]);\n\t\t\t\tfclose(fp);\n\t\t    \t\treturn i + 1;\n\t\t\t}\n\t\t\tfprintf(stderr, \"Error: too many program arguments in users.conf line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfclose(fp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comm"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "argv[2]"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "system",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "574-582",
          "snippet": "int system(const char *command) {\n\tif (!orig_system)\n\t\torig_system = (orig_system_t)dlsym(RTLD_NEXT, \"system\");\n\n\tint rv = orig_system(command);\n\tprintf(\"%u:%s:system %s:%d\\n\", pid(), name(), command, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_system_t orig_system = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_system_t orig_system = NULL;\n\nint system(const char *command) {\n\tif (!orig_system)\n\t\torig_system = (orig_system_t)dlsym(RTLD_NEXT, \"system\");\n\n\tint rv = orig_system(command);\n\tprintf(\"%u:%s:system %s:%d\\n\", pid(), name(), command, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "orig_umask"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "extract_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "240-256",
          "snippet": "static void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "1"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "121-142",
          "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"run without a sandbox\\n\""
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[2]",
            "\"scp \"",
            "4"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"/usr/lib/openssh/sftp-server\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"-c\""
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"#%s# \"",
            "argv[i]"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"argc %d: \"",
            "argc"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "comm",
            "\"sshd\""
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_proc_comm",
          "args": [
            "ppid"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "pid_proc_comm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "128-164",
          "snippet": "char *pid_proc_comm(const pid_t pid) {\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/comm\", pid) == -1)\n\t\treturn NULL;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn NULL;\n\t}\n\tfree(fname);\n\n\t// read file\n\tchar buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// remove \\n\n\tchar *ptr = strchr(buffer, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\t// return a malloc copy of the command line\n\tchar *rv = strdup(buffer);\n\tif (!rv)\n\t\treturn NULL;\n\tif (strlen(rv) == 0) {\n\t\tfree(rv);\n\t\treturn NULL;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define BUFLEN 4096",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define BUFLEN 4096\n#define BUFLEN 4096\n\nchar *pid_proc_comm(const pid_t pid) {\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/comm\", pid) == -1)\n\t\treturn NULL;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn NULL;\n\t}\n\tfree(fname);\n\n\t// read file\n\tchar buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// remove \\n\n\tchar *ptr = strchr(buffer, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\t// return a malloc copy of the command line\n\tchar *rv = strdup(buffer);\n\tif (!rv)\n\t\treturn NULL;\n\tif (strlen(rv) == 0) {\n\t\tfree(rv);\n\t\treturn NULL;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getppid",
          "args": [],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delete_run_files",
          "args": [
            "sandbox_pid"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "delete_run_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/run_files.c",
          "lines": "70-76",
          "snippet": "void delete_run_files(pid_t pid) {\n\tdelete_bandwidth_run_file(pid);\n\tdelete_network_run_file(pid);\n\tdelete_name_run_file(pid);\n\tdelete_x11_run_file(pid);\n\tdelete_profile_run_file(pid);\n}",
          "includes": [
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nvoid delete_run_files(pid_t pid) {\n\tdelete_bandwidth_run_file(pid);\n\tdelete_network_run_file(pid);\n\tdelete_name_run_file(pid);\n\tdelete_x11_run_file(pid);\n\tdelete_profile_run_file(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_no_sandbox",
          "args": [
            "argc",
            "argv"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "run_no_sandbox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/no_sandbox.c",
          "lines": "162-234",
          "snippet": "void run_no_sandbox(int argc, char **argv) {\n\tEUID_ASSERT();\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\t// process limited subset of options\n\tint i;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--debug\") == 0)\n\t\t\targ_debug = 1;\n\t\telse if (strncmp(argv[i], \"--shell=\", 8) == 0)\n\t\t\tfwarning(\"shell-related command line options are disregarded - using SHELL environment variable\\n\");\n\t}\n\n\t// use $SHELL to get shell used in sandbox, guess shell otherwise\n\tcfg.shell = guess_shell();\n\tif (!cfg.shell) {\n\t\tfprintf(stderr, \"Error: unable to guess your shell, please set SHELL environment variable\\n\");\n\t\texit(1);\n\t}\n\telse if (arg_debug)\n\t\tprintf(\"Selecting %s as shell\\n\", cfg.shell);\n\n\tint prog_index = 0;\n\t// find first non option arg:\n\t//\t- first argument not starting with --,\n\t//\t- whatever follows after -c (example: firejail -c ls)\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-c\") == 0) {\n\t\t\tprog_index = i + 1;\n\t\t\tif (prog_index == argc) {\n\t\t\t\tfprintf(stderr, \"Error: option -c requires an argument\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t// check first argument not starting with --\n\t\tif (strncmp(argv[i],\"--\",2) != 0) {\n\t\t\tprog_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// if shell is /usr/bin/firejail, replace it with /bin/bash\n\tif (strcmp(cfg.shell, PATH_FIREJAIL) == 0) {\n\t\tcfg.shell = \"/bin/bash\";\n\t\tprog_index = 0;\n\t}\n\n\tif (prog_index == 0) {\n\t\tcfg.command_line = cfg.shell;\n\t\tcfg.window_title = cfg.shell;\n\t} else {\n\t\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, prog_index);\n\t}\n\n\tcfg.original_argv = argv;\n\tcfg.original_program_index = prog_index;\n\n\tchar *command;\n\tif (prog_index == 0)\n\t\tcommand = cfg.shell;\n\telse\n\t\tcommand = argv[prog_index];\n\tfwarning(\"an existing sandbox was detected. \"\n\t\t\"%s will run without any additional sandboxing features\\n\", command);\n\n\targ_quiet = 1;\n\n\tstart_application(1, NULL);\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid run_no_sandbox(int argc, char **argv) {\n\tEUID_ASSERT();\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\t// process limited subset of options\n\tint i;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--debug\") == 0)\n\t\t\targ_debug = 1;\n\t\telse if (strncmp(argv[i], \"--shell=\", 8) == 0)\n\t\t\tfwarning(\"shell-related command line options are disregarded - using SHELL environment variable\\n\");\n\t}\n\n\t// use $SHELL to get shell used in sandbox, guess shell otherwise\n\tcfg.shell = guess_shell();\n\tif (!cfg.shell) {\n\t\tfprintf(stderr, \"Error: unable to guess your shell, please set SHELL environment variable\\n\");\n\t\texit(1);\n\t}\n\telse if (arg_debug)\n\t\tprintf(\"Selecting %s as shell\\n\", cfg.shell);\n\n\tint prog_index = 0;\n\t// find first non option arg:\n\t//\t- first argument not starting with --,\n\t//\t- whatever follows after -c (example: firejail -c ls)\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-c\") == 0) {\n\t\t\tprog_index = i + 1;\n\t\t\tif (prog_index == argc) {\n\t\t\t\tfprintf(stderr, \"Error: option -c requires an argument\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t// check first argument not starting with --\n\t\tif (strncmp(argv[i],\"--\",2) != 0) {\n\t\t\tprog_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// if shell is /usr/bin/firejail, replace it with /bin/bash\n\tif (strcmp(cfg.shell, PATH_FIREJAIL) == 0) {\n\t\tcfg.shell = \"/bin/bash\";\n\t\tprog_index = 0;\n\t}\n\n\tif (prog_index == 0) {\n\t\tcfg.command_line = cfg.shell;\n\t\tcfg.window_title = cfg.shell;\n\t} else {\n\t\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, prog_index);\n\t}\n\n\tcfg.original_argv = argv;\n\tcfg.original_program_index = prog_index;\n\n\tchar *command;\n\tif (prog_index == 0)\n\t\tcommand = cfg.shell;\n\telse\n\t\tcommand = argv[prog_index];\n\tfwarning(\"an existing sandbox was detected. \"\n\t\t\"%s will run without any additional sandboxing features\\n\", command);\n\n\targ_quiet = 1;\n\n\tstart_application(1, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"firejail version %s\\n\"",
            "VERSION"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_arg",
          "args": [
            "argc",
            "argv",
            "\"--version\"",
            "1"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "check_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "837-862",
          "snippet": "static int check_arg(int argc, char **argv, const char *argument, int strict) {\n\tint i;\n\tint found = 0;\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strict) {\n\t\t\tif (strcmp(argv[i], argument) == 0) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (strncmp(argv[i], argument, strlen(argument)) == 0) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// detect end of firejail params\n\t\tif (strcmp(argv[i], \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(argv[i], \"--\", 2) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "else if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11))",
            "else if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0)",
            "else if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);",
            "else if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);",
            "else if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nelse if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11));\nelse if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0);\nelse if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);\nelse if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);\nelse if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0);\n\nstatic int check_arg(int argc, char **argv, const char *argument, int strict) {\n\tint i;\n\tint found = 0;\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strict) {\n\t\t\tif (strcmp(argv[i], argument) == 0) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (strncmp(argv[i], argument, strlen(argument)) == 0) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// detect end of firejail params\n\t\tif (strcmp(argv[i], \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(argv[i], \"--\", 2) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_kernel_procs",
          "args": [],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "check_kernel_procs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/no_sandbox.c",
          "lines": "87-160",
          "snippet": "int check_kernel_procs(void) {\n\t// we run this function with EUID set in order to detect grsecurity\n\t// only user processes are available in /proc when running grsecurity\n\t// EUID_ASSERT();\n\n\tchar *kern_proc[] = {\n\t\t\"kthreadd\",\n\t\t\"ksoftirqd\",\n\t\t\"kworker\",\n\t\t\"rcu_sched\",\n\t\t\"rcu_bh\",\n\t\tNULL\t// NULL terminated list\n\t};\n\tint i;\n\n\tif (arg_debug)\n\t\tprintf(\"Looking for kernel processes\\n\");\n\n\t// look at the first 10 processes\n\t// if a kernel process is found, return 1\n\tfor (i = 1; i <= 10; i++) {\n\t\tstruct stat s;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/comm\", i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// open file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfwarning(\"cannot open %s\\n\", fname);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// read file\n\t\tchar buf[100];\n\t\tif (fgets(buf, 10, fp) == NULL) {\n\t\t\tfwarning(\"cannot read %s\\n\", fname);\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\t// clean /n\n\t\tchar *ptr;\n\t\tif ((ptr = strchr(buf, '\\n')) != NULL)\n\t\t\t*ptr = '\\0';\n\n\t\t// check process name against the kernel list\n\t\tint j = 0;\n\t\twhile (kern_proc[j] != NULL) {\n\t\t\tif (strncmp(buf, kern_proc[j], strlen(kern_proc[j])) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s process, we are not running in a sandbox\\n\", buf);\n\t\t\t\tfclose(fp);\n\t\t\t\tfree(fname);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"No kernel processes found, we are already running in a sandbox\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint check_kernel_procs(void) {\n\t// we run this function with EUID set in order to detect grsecurity\n\t// only user processes are available in /proc when running grsecurity\n\t// EUID_ASSERT();\n\n\tchar *kern_proc[] = {\n\t\t\"kthreadd\",\n\t\t\"ksoftirqd\",\n\t\t\"kworker\",\n\t\t\"rcu_sched\",\n\t\t\"rcu_bh\",\n\t\tNULL\t// NULL terminated list\n\t};\n\tint i;\n\n\tif (arg_debug)\n\t\tprintf(\"Looking for kernel processes\\n\");\n\n\t// look at the first 10 processes\n\t// if a kernel process is found, return 1\n\tfor (i = 1; i <= 10; i++) {\n\t\tstruct stat s;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/comm\", i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// open file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfwarning(\"cannot open %s\\n\", fname);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// read file\n\t\tchar buf[100];\n\t\tif (fgets(buf, 10, fp) == NULL) {\n\t\t\tfwarning(\"cannot read %s\\n\", fname);\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\t// clean /n\n\t\tchar *ptr;\n\t\tif ((ptr = strchr(buf, '\\n')) != NULL)\n\t\t\t*ptr = '\\0';\n\n\t\t// check process name against the kernel list\n\t\tint j = 0;\n\t\twhile (kern_proc[j] != NULL) {\n\t\t\tif (strncmp(buf, kern_proc[j], strlen(kern_proc[j])) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s process, we are not running in a sandbox\\n\", buf);\n\t\t\t\tfclose(fp);\n\t\t\t\tfree(fname);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"No kernel processes found, we are already running in a sandbox\\n\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_namespace_virt",
          "args": [],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "check_namespace_virt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/no_sandbox.c",
          "lines": "40-83",
          "snippet": "int check_namespace_virt(void) {\n\tEUID_ASSERT();\n\n\t// check container environment variable\n\tchar *str = getenv(\"container\");\n\tif (str && is_container(str))\n\t\treturn 1;\n\n\t// check PID 1 container environment variable\n\tEUID_ROOT();\n\tFILE *fp = fopen(\"/proc/1/environ\", \"r\");\n\tif (fp) {\n\t\tint c = 0;\n\t\twhile (c != EOF) {\n\t\t\t// read one line\n\t\t\tchar buf[MAX_BUF];\n\t\t\tint i = 0;\n\t\t\twhile ((c = fgetc(fp)) != EOF) {\n\t\t\t\tif (c == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[i] = (char) c;\n\t\t\t\tif (++i == (MAX_BUF - 1))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf[i] = '\\0';\n\n\t\t\t// check env var name\n\t\t\tif (strncmp(buf, \"container=\", 10) == 0) {\n\t\t\t\t// found it\n\t\t\t\tif (is_container(buf + 10)) {\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tEUID_USER();\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"i %d c %d, buf #%s#\\n\", i, c, buf);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tEUID_USER();\n\treturn 0;\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nint check_namespace_virt(void) {\n\tEUID_ASSERT();\n\n\t// check container environment variable\n\tchar *str = getenv(\"container\");\n\tif (str && is_container(str))\n\t\treturn 1;\n\n\t// check PID 1 container environment variable\n\tEUID_ROOT();\n\tFILE *fp = fopen(\"/proc/1/environ\", \"r\");\n\tif (fp) {\n\t\tint c = 0;\n\t\twhile (c != EOF) {\n\t\t\t// read one line\n\t\t\tchar buf[MAX_BUF];\n\t\t\tint i = 0;\n\t\t\twhile ((c = fgetc(fp)) != EOF) {\n\t\t\t\tif (c == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[i] = (char) c;\n\t\t\t\tif (++i == (MAX_BUF - 1))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf[i] = '\\0';\n\n\t\t\t// check env var name\n\t\t\tif (strncmp(buf, \"container=\", 10) == 0) {\n\t\t\t\t// found it\n\t\t\t\tif (is_container(buf + 10)) {\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tEUID_USER();\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"i %d c %d, buf #%s#\\n\", i, c, buf);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tEUID_USER();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_symlink",
          "args": [
            "argc",
            "argv",
            "0"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "run_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/run_symlink.c",
          "lines": "25-116",
          "snippet": "void run_symlink(int argc, char **argv, int run_as_is) {\n\tEUID_ASSERT();\n\n\tchar *program = strrchr(argv[0], '/');\n\tif (program)\n\t\tprogram += 1;\n\telse\n\t\tprogram = argv[0];\n\tif (strcmp(program, \"firejail\") == 0) // this is a regular \"firejail program\" sandbox starting\n\t\treturn;\n\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\t// find the real program by looking in PATH\n\tchar *p = getenv(\"PATH\");\n\tif (!p) {\n\t\tfprintf(stderr, \"Error: PATH environment variable not set\\n\");\n\t\texit(1);\n\t}\n\n\tchar *path = strdup(p);\n\tif (!path)\n\t\terrExit(\"strdup\");\n\n\tchar *selfpath = realpath(\"/proc/self/exe\", NULL);\n\tif (!selfpath)\n\t\terrExit(\"realpath\");\n\n\t// look in path for our program\n\tchar *tok = strtok(path, \":\");\n\tint found = 0;\n\twhile (tok) {\n\t\tchar *name;\n\t\tif (asprintf(&name, \"%s/%s\", tok, program) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tstruct stat s;\n\t\tif (stat(name, &s) == 0) {\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(name, NULL);\n\t\t\tif (!rp)\n\t\t\t\terrExit(\"realpath\");\n\n\t\t\tif (strcmp(selfpath, rp) != 0) {\n\t\t\t\tprogram = strdup(name);\n\t\t\t\tfound = 1;\n\t\t\t\tfree(rp);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfree(rp);\n\t\t}\n\n\t\tfree(name);\n\t\ttok = strtok(NULL, \":\");\n\t}\n\tif (!found) {\n\t\tfprintf(stderr, \"Error: cannot find the program in the path\\n\");\n\t\texit(1);\n\t}\n\n\tfree(selfpath);\n\n\t// restore original umask\n\tumask(orig_umask);\n\n\t// desktop integration is not supported for root user; instead, the original program is started\n\tif (getuid() == 0 || run_as_is) {\n\t\targv[0] = program;\n\t\texecv(program, argv);\n\t\texit(1);\n\t}\n\n\t// start the argv[0] program in a new sandbox\n\tchar *a[3 + argc];\n\ta[0] =PATH_FIREJAIL;\n\ta[1] = program;\n\tint i;\n\tfor (i = 0; i < (argc - 1); i++) {\n\t\ta[i + 2] = argv[i + 1];\n\t}\n\ta[i + 2] = NULL;\n\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\texecvp(a[0], a);\n\n\tperror(\"execvp\");\n\texit(1);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid run_symlink(int argc, char **argv, int run_as_is) {\n\tEUID_ASSERT();\n\n\tchar *program = strrchr(argv[0], '/');\n\tif (program)\n\t\tprogram += 1;\n\telse\n\t\tprogram = argv[0];\n\tif (strcmp(program, \"firejail\") == 0) // this is a regular \"firejail program\" sandbox starting\n\t\treturn;\n\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\t// find the real program by looking in PATH\n\tchar *p = getenv(\"PATH\");\n\tif (!p) {\n\t\tfprintf(stderr, \"Error: PATH environment variable not set\\n\");\n\t\texit(1);\n\t}\n\n\tchar *path = strdup(p);\n\tif (!path)\n\t\terrExit(\"strdup\");\n\n\tchar *selfpath = realpath(\"/proc/self/exe\", NULL);\n\tif (!selfpath)\n\t\terrExit(\"realpath\");\n\n\t// look in path for our program\n\tchar *tok = strtok(path, \":\");\n\tint found = 0;\n\twhile (tok) {\n\t\tchar *name;\n\t\tif (asprintf(&name, \"%s/%s\", tok, program) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tstruct stat s;\n\t\tif (stat(name, &s) == 0) {\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(name, NULL);\n\t\t\tif (!rp)\n\t\t\t\terrExit(\"realpath\");\n\n\t\t\tif (strcmp(selfpath, rp) != 0) {\n\t\t\t\tprogram = strdup(name);\n\t\t\t\tfound = 1;\n\t\t\t\tfree(rp);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfree(rp);\n\t\t}\n\n\t\tfree(name);\n\t\ttok = strtok(NULL, \":\");\n\t}\n\tif (!found) {\n\t\tfprintf(stderr, \"Error: cannot find the program in the path\\n\");\n\t\texit(1);\n\t}\n\n\tfree(selfpath);\n\n\t// restore original umask\n\tumask(orig_umask);\n\n\t// desktop integration is not supported for root user; instead, the original program is started\n\tif (getuid() == 0 || run_as_is) {\n\t\targv[0] = program;\n\t\texecv(program, argv);\n\t\texit(1);\n\t}\n\n\t// start the argv[0] program in a new sandbox\n\tchar *a[3 + argc];\n\ta[0] =PATH_FIREJAIL;\n\ta[1] = program;\n\tint i;\n\tfor (i = 0; i < (argc - 1); i++) {\n\t\ta[i + 2] = argv[i + 1];\n\t}\n\ta[i + 2] = NULL;\n\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\texecvp(a[0], a);\n\n\tperror(\"execvp\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_builder",
          "args": [
            "argc",
            "argv"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "run_builder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "864-882",
          "snippet": "static void run_builder(int argc, char **argv) {\n\tEUID_ASSERT();\n\t(void) argc;\n\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\tumask(orig_umask);\n\n\targv[0] = LIBDIR \"/firejail/fbuilder\";\n\texecvp(argv[0], argv);\n\n\tperror(\"execvp\");\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "mode_t orig_umask = 022;",
            "else if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11))",
            "else if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0)",
            "else if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);",
            "else if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);",
            "else if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nmode_t orig_umask = 022;\nelse if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11));\nelse if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0);\nelse if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);\nelse if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);\nelse if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0);\n\nstatic void run_builder(int argc, char **argv) {\n\tEUID_ASSERT();\n\t(void) argc;\n\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\tumask(orig_umask);\n\n\targv[0] = LIBDIR \"/firejail/fbuilder\";\n\texecvp(argv[0], argv);\n\n\tperror(\"execvp\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_add",
          "args": [
            "cmd"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "1364-1383",
          "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"noblacklist ${PATH}/strace\""
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --allow-debuggers is disabled on Linux kernels prior to 4.8. \"\n\t\t\t\t\"A bug in ptrace call allows a full bypass of the seccomp filter. \"\n\t\t\t\t\"Your current kernel version is %d.%d.\\n\"",
            "major",
            "minor"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot extract Linux kernel version: %s\\n\"",
            "u.version"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "u.release",
            "\"%d.%d\"",
            "&major",
            "&minor"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"uname\""
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uname",
          "args": [
            "&u"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "lockfd_directory"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock",
          "args": [
            "lockfd_directory",
            "LOCK_UN"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preproc_clean_run",
          "args": [],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "preproc_clean_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/preproc.c",
          "lines": "139-191",
          "snippet": "void preproc_clean_run(void) {\n\tint max_pids=32769;\n\tint start_pid = 100;\n\t// extract real max_pids\n\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\tif (fp) {\n\t\tint val;\n\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\tif (val > 4194304)\t// this is the max value supported on 64 bit Linux kernels\n\t\t\t\tval = 4194304;\n\t\t\tif (val >= max_pids)\n\t\t\t\tmax_pids = val + 1;\n\t\t}\n\t\tfclose(fp);\n\t}\n\tint *pidarr = malloc(max_pids * sizeof(int));\n\tif (!pidarr)\n\t\terrExit(\"malloc\");\n\n\tmemset(pidarr, 0, max_pids * sizeof(int));\n\n\t// open /proc directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// read /proc and populate pidarr with all active processes\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\n\t\tif (pid < start_pid)\n\t\t\tcontinue;\n\t\tpidarr[pid] = 1;\n\t}\n\tclosedir(dir);\n\n\t// clean profile and name directories\n\tclean_dir(RUN_FIREJAIL_PROFILE_DIR, pidarr, start_pid, max_pids);\n\tclean_dir(RUN_FIREJAIL_NAME_DIR, pidarr, start_pid, max_pids);\n\n\tfree(pidarr);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid preproc_clean_run(void) {\n\tint max_pids=32769;\n\tint start_pid = 100;\n\t// extract real max_pids\n\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\tif (fp) {\n\t\tint val;\n\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\tif (val > 4194304)\t// this is the max value supported on 64 bit Linux kernels\n\t\t\t\tval = 4194304;\n\t\t\tif (val >= max_pids)\n\t\t\t\tmax_pids = val + 1;\n\t\t}\n\t\tfclose(fp);\n\t}\n\tint *pidarr = malloc(max_pids * sizeof(int));\n\tif (!pidarr)\n\t\terrExit(\"malloc\");\n\n\tmemset(pidarr, 0, max_pids * sizeof(int));\n\n\t// open /proc directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// read /proc and populate pidarr with all active processes\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\n\t\tif (pid < start_pid)\n\t\t\tcontinue;\n\t\tpidarr[pid] = 1;\n\t}\n\tclosedir(dir);\n\n\t// clean profile and name directories\n\tclean_dir(RUN_FIREJAIL_PROFILE_DIR, pidarr, start_pid, max_pids);\n\tclean_dir(RUN_FIREJAIL_NAME_DIR, pidarr, start_pid, max_pids);\n\n\tfree(pidarr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock",
          "args": [
            "lockfd_directory",
            "LOCK_EX"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "lockfd_directory",
            "0",
            "0"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "RUN_DIRECTORY_LOCK_FILE",
            "O_WRONLY | O_CREAT",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "freopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "346-353",
          "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "container_name",
            "\"firejail\""
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"container\""
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preproc_build_firejail_dir",
          "args": [],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "preproc_build_firejail_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/preproc.c",
          "lines": "29-75",
          "snippet": "void preproc_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_PROFILE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_PROFILE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_LIB_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_LIB_DIR, 0755);\n\t}\n\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\tcreate_empty_file_as_root(RUN_RO_FILE, S_IRUSR);\n\tcreate_empty_dir_as_root(RUN_RO_DIR, S_IRUSR);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid preproc_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_PROFILE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_PROFILE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_LIB_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_LIB_DIR, 0755);\n\t}\n\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\tcreate_empty_file_as_root(RUN_RO_FILE, S_IRUSR);\n\tcreate_empty_dir_as_root(RUN_RO_DIR, S_IRUSR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atexit",
          "args": [
            "clear_atexit"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getticks",
          "args": [],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "getticks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "113-125",
          "snippet": "static inline unsigned long long getticks(void) {\n#if defined(__x86_64__)\n\tunsigned a, d;\n\tasm volatile(\"rdtsc\" : \"=a\" (a), \"=d\" (d));\n\treturn ((unsigned long long)a) | (((unsigned long long)d) << 32);\n#elif defined(__i386__)\n\tunsigned long long ret;\n\t__asm__ __volatile__(\"rdtsc\" : \"=A\" (ret));\n\treturn ret;\n#else\n\treturn 0; // not implemented\n#endif\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline unsigned long long getticks(void) {\n#if defined(__x86_64__)\n\tunsigned a, d;\n\tasm volatile(\"rdtsc\" : \"=a\" (a), \"=d\" (d));\n\treturn ((unsigned long long)a) | (((unsigned long long)d) << 32);\n#elif defined(__i386__)\n\tunsigned long long ret;\n\t__asm__ __volatile__(\"rdtsc\" : \"=A\" (ret));\n\treturn ret;\n#else\n\treturn 0; // not implemented\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cfg.homedir"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cfg",
          "args": [
            "argc",
            "argv"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "init_cfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "235-287",
          "snippet": "static void init_cfg(int argc, char **argv) {\n\tEUID_ASSERT();\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tcfg.original_argv = argv;\n\tcfg.original_argc = argc;\n\tcfg.bridge0.devsandbox = \"eth0\";\n\tcfg.bridge1.devsandbox = \"eth1\";\n\tcfg.bridge2.devsandbox = \"eth2\";\n\tcfg.bridge3.devsandbox = \"eth3\";\n\n\t// extract user data\n\tEUID_ROOT(); // rise permissions for grsecurity\n\tstruct passwd *pw = getpwuid(getuid());\n\tif (!pw)\n\t\terrExit(\"getpwuid\");\n\tEUID_USER();\n\tcfg.username = strdup(pw->pw_name);\n\tif (!cfg.username)\n\t\terrExit(\"strdup\");\n\n\t// build home directory name\n\tcfg.homedir = NULL;\n\tif (pw->pw_dir != NULL) {\n\t\tcfg.homedir = clean_pathname(pw->pw_dir);\n\t\tassert(cfg.homedir);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: user %s doesn't have a user directory assigned\\n\", cfg.username);\n\t\texit(1);\n\t}\n\n\tcfg.cwd = getcwd(NULL, 0);\n\tif (!cfg.cwd && errno != ENOENT)\n\t\terrExit(\"getcwd\");\n\n\t// check user database\n\tif (!firejail_user_check(cfg.username)) {\n\t\tfprintf(stderr, \"Error: the user is not allowed to use Firejail. \"\n\t\t\t\"Please add the user in %s/firejail.users file, \"\n\t\t\t\"either by running \\\"sudo firecfg\\\", or by editing the file directly.\\n\"\n\t\t\t\"See \\\"man firejail-users\\\" for more details.\\n\", SYSCONFDIR);\n\n\t\t// attempt to run the program as is\n\t\trun_symlink(argc, argv, 1);\n\t\texit(1);\n\t}\n\n\t// initialize random number generator\n\tsandbox_pid = getpid();\n\ttime_t t = time(NULL);\n\tsrand(t ^ sandbox_pid);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Config cfg;",
            "pid_t sandbox_pid;",
            "else if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11))",
            "else if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0)",
            "else if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);",
            "else if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);",
            "else if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nConfig cfg;\npid_t sandbox_pid;\nelse if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11));\nelse if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0);\nelse if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);\nelse if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);\nelse if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0);\n\nstatic void init_cfg(int argc, char **argv) {\n\tEUID_ASSERT();\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tcfg.original_argv = argv;\n\tcfg.original_argc = argc;\n\tcfg.bridge0.devsandbox = \"eth0\";\n\tcfg.bridge1.devsandbox = \"eth1\";\n\tcfg.bridge2.devsandbox = \"eth2\";\n\tcfg.bridge3.devsandbox = \"eth3\";\n\n\t// extract user data\n\tEUID_ROOT(); // rise permissions for grsecurity\n\tstruct passwd *pw = getpwuid(getuid());\n\tif (!pw)\n\t\terrExit(\"getpwuid\");\n\tEUID_USER();\n\tcfg.username = strdup(pw->pw_name);\n\tif (!cfg.username)\n\t\terrExit(\"strdup\");\n\n\t// build home directory name\n\tcfg.homedir = NULL;\n\tif (pw->pw_dir != NULL) {\n\t\tcfg.homedir = clean_pathname(pw->pw_dir);\n\t\tassert(cfg.homedir);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: user %s doesn't have a user directory assigned\\n\", cfg.username);\n\t\texit(1);\n\t}\n\n\tcfg.cwd = getcwd(NULL, 0);\n\tif (!cfg.cwd && errno != ENOENT)\n\t\terrExit(\"getcwd\");\n\n\t// check user database\n\tif (!firejail_user_check(cfg.username)) {\n\t\tfprintf(stderr, \"Error: the user is not allowed to use Firejail. \"\n\t\t\t\"Please add the user in %s/firejail.users file, \"\n\t\t\t\"either by running \\\"sudo firecfg\\\", or by editing the file directly.\\n\"\n\t\t\t\"See \\\"man firejail-users\\\" for more details.\\n\", SYSCONFDIR);\n\n\t\t// attempt to run the program as is\n\t\trun_symlink(argc, argv, 1);\n\t\texit(1);\n\t}\n\n\t// initialize random number generator\n\tsandbox_pid = getpid();\n\ttime_t t = time(NULL);\n\tsrand(t ^ sandbox_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_INIT",
          "args": [],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_INIT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "54-57",
          "snippet": "static inline void EUID_INIT(void) {\n\tfirejail_uid = getuid();\n\tfirejail_gid = getgid();\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_INIT(void) {\n\tfirejail_uid = getuid();\n\tfirejail_gid = getgid();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nConfig cfg;\nint arg_debug = 0;\nint arg_debug_blacklists = 0;\nint arg_debug_whitelists = 0;\nint arg_debug_private_lib = 0;\nint arg_seccomp = 0;\nint arg_nonewprivs = 0;\nint arg_quiet = 0;\nint arg_apparmor = 0;\nint arg_allow_debuggers = 0;\nint login_shell = 0;\nchar *fullargv[MAX_ARGS];\nint fullargc = 0;\npid_t sandbox_pid;\nmode_t orig_umask = 022;\nunsigned long long start_timestamp;\nelse if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11));\nFILE *fp = fopen(fname, \"r\");\nelse if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0);\nelse if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);\nelse if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);\nelse if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0);\n\nint main(int argc, char **argv) {\n\tint i;\n\tint prog_index = -1;\t\t\t  // index in argv where the program command starts\n\tint lockfd_network = -1;\n\tint lockfd_directory = -1;\n\tint option_cgroup = 0;\n\tint custom_profile = 0;\t// custom profile loaded\n\tint arg_caps_cmdline = 0; \t// caps requested on command line (used to break out of --chroot)\n\n\t// drop permissions by default and rise them when required\n\tEUID_INIT();\n\tEUID_USER();\n\n\t// sanitize the umask\n\torig_umask = umask(022);\n\n\t// check if the user is allowed to use firejail\n\tinit_cfg(argc, argv);\n\tassert(cfg.homedir);\n\n\t// get starting timestamp, process --quiet\n\tstart_timestamp = getticks();\n\tif (check_arg(argc, argv, \"--quiet\", 1))\n\t\targ_quiet = 1;\n\n\t// cleanup at exit\n\tEUID_ROOT();\n\tatexit(clear_atexit);\n\n\t// build /run/firejail directory structure\n\tpreproc_build_firejail_dir();\n\tchar *container_name = getenv(\"container\");\n\tif (!container_name || strcmp(container_name, \"firejail\")) {\n\t\tlockfd_directory = open(RUN_DIRECTORY_LOCK_FILE, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);\n\t\tif (lockfd_directory != -1) {\n\t\t\tint rv = fchown(lockfd_directory, 0, 0);\n\t\t\t(void) rv;\n\t\t\tflock(lockfd_directory, LOCK_EX);\n\t\t}\n\t\tpreproc_clean_run();\n\t\tflock(lockfd_directory, LOCK_UN);\n\t\tclose(lockfd_directory);\n\t}\n\tEUID_USER();\n\n\n\t// process allow-debuggers\n\tif (check_arg(argc, argv, \"--allow-debuggers\", 1)) {\n\t\t// check kernel version\n\t\tstruct utsname u;\n\t\tint rv = uname(&u);\n\t\tif (rv != 0)\n\t\t\terrExit(\"uname\");\n\t\tint major;\n\t\tint minor;\n\t\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\t\texit(1);\n\t\t}\n\t\tif (major < 4 || (major == 4 && minor < 8)) {\n\t\t\tfprintf(stderr, \"Error: --allow-debuggers is disabled on Linux kernels prior to 4.8. \"\n\t\t\t\t\"A bug in ptrace call allows a full bypass of the seccomp filter. \"\n\t\t\t\t\"Your current kernel version is %d.%d.\\n\", major, minor);\n\t\t\texit(1);\n\t\t}\n\n\t\targ_allow_debuggers = 1;\n\t\tchar *cmd = strdup(\"noblacklist ${PATH}/strace\");\n\t\tif (!cmd)\n\t\t\terrExit(\"strdup\");\n\t\tprofile_add(cmd);\n\t}\n\n\t// profile builder\n\tif (check_arg(argc, argv, \"--build\", 0)) // supports both --build and --build=filename\n\t\trun_builder(argc, argv); // this function will not return\n\n\t// check argv[0] symlink wrapper if this is not a login shell\n\tif (*argv[0] != '-')\n\t\trun_symlink(argc, argv, 0); // if symlink detected, this function will not return\n\n\t// check if we already have a sandbox running\n\t// If LXC is detected, start firejail sandbox\n\t// otherwise try to detect a PID namespace by looking under /proc for specific kernel processes and:\n\t//\t- start the application in a /bin/bash shell\n\tif (check_namespace_virt() == 0) {\n\t\tEUID_ROOT();\n\t\tint rv = check_kernel_procs();\n\t\tEUID_USER();\n\t\tif (rv == 0) {\n\t\t\tif (check_arg(argc, argv, \"--version\", 1)) {\n\t\t\t\tprintf(\"firejail version %s\\n\", VERSION);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t// start the program directly without sandboxing\n\t\t\trun_no_sandbox(argc, argv);\n\t\t\t// it will never get here!\n\t\t\tassert(0);\n\t\t}\n\t}\n\tEUID_ASSERT();\n\n\n\t// check firejail directories\n\tEUID_ROOT();\n\tdelete_run_files(sandbox_pid);\n\tEUID_USER();\n\n\t//check if the parent is sshd daemon\n\tint parent_sshd = 0;\n\t{\n\t\tpid_t ppid = getppid();\n\t\tEUID_ROOT();\n\t\tchar *comm = pid_proc_comm(ppid);\n\t\tEUID_USER();\n\t\tif (comm) {\n\t\t\tif (strcmp(comm, \"sshd\") == 0) {\n\t\t\t\targ_quiet = 1;\n\t\t\t\tparent_sshd = 1;\n\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t\t{EUID_ROOT();\n\t\t\t\tFILE *fp = fopen(\"/firelog\", \"w\");\n\t\t\t\tif (fp) {\n\t\t\t\t\tint i;\n\t\t\t\t\tfprintf(fp, \"argc %d: \", argc);\n\t\t\t\t\tfor (i = 0; i < argc; i++)\n\t\t\t\t\t\tfprintf(fp, \"#%s# \", argv[i]);\n\t\t\t\t\tfprintf(fp, \"\\n\");\n\t\t\t\t\tfclose(fp);\n\t\t\t\t}\n\t\t\t\tEUID_USER();}\n#endif\n\t\t\t\t// run sftp and scp directly without any sandboxing\n\t\t\t\t// regular login has argv[0] == \"-firejail\"\n\t\t\t\tif (*argv[0] != '-') {\n\t\t\t\t\tif (strcmp(argv[1], \"-c\") == 0 && argc > 2) {\n\t\t\t\t\t\tif (strcmp(argv[2], \"/usr/lib/openssh/sftp-server\") == 0 ||\n\t\t\t\t\t\t    strncmp(argv[2], \"scp \", 4) == 0) {\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t\t\t\t\t{EUID_ROOT();\n\t\t\t\t\t\t\tFILE *fp = fopen(\"/firelog\", \"a\");\n\t\t\t\t\t\t\tif (fp) {\n\t\t\t\t\t\t\t\tfprintf(fp, \"run without a sandbox\\n\");\n\t\t\t\t\t\t\t\tfclose(fp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tEUID_USER();}\n#endif\n\n\t\t\t\t\t\t\tdrop_privs(1);\n\t\t\t\t\t\t\tumask(orig_umask);\n\t\t\t\t\t\t\tint rv = system(argv[2]);\n\t\t\t\t\t\t\texit(rv);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(comm);\n\t\t}\n\t}\n\tEUID_ASSERT();\n\n\t// is this a login shell, or a command passed by sshd, insert command line options from /etc/firejail/login.users\n\tif (*argv[0] == '-' || parent_sshd) {\n\t\tif (argc == 1)\n\t\t\tlogin_shell = 1;\n\t\tfullargc = restricted_shell(cfg.username);\n\t\tif (fullargc) {\n\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t{EUID_ROOT();\n\t\t\tFILE *fp = fopen(\"/firelog\", \"a\");\n\t\t\tif (fp) {\n\t\t\t\tfprintf(fp, \"fullargc %d: \",  fullargc);\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < fullargc; i++)\n\t\t\t\t\tfprintf(fp, \"#%s# \", fullargv[i]);\n\t\t\t\tfprintf(fp, \"\\n\");\n\t\t\t\tfclose(fp);\n\t\t\t}\n\t\t\tEUID_USER();}\n#endif\n\n\t\t\tint j;\n\t\t\tfor (i = 1, j = fullargc; i < argc && j < MAX_ARGS; i++, j++, fullargc++)\n\t\t\t\tfullargv[j] = argv[i];\n\n\t\t\t// replace argc/argv with fullargc/fullargv\n\t\t\targv = fullargv;\n\t\t\targc = j;\n\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t{EUID_ROOT();\n\t\t\tFILE *fp = fopen(\"/firelog\", \"a\");\n\t\t\tif (fp) {\n\t\t\t\tfprintf(fp, \"argc %d: \", argc);\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < argc; i++)\n\t\t\t\t\tfprintf(fp, \"#%s# \", argv[i]);\n\t\t\t\tfprintf(fp, \"\\n\");\n\t\t\t\tfclose(fp);\n\t\t\t}\n\t\t\tEUID_USER();}\n#endif\n\t\t}\n\t}\n\telse {\n\t\t// check --output option and execute it;\n\t\tcheck_output(argc, argv); // the function will not return if --output or --output-stderr option was found\n\t}\n\tEUID_ASSERT();\n\n\n\t// check for force-nonewprivs in /etc/firejail/firejail.config file\n\tif (checkcfg(CFG_FORCE_NONEWPRIVS))\n\t\targ_nonewprivs = 1;\n\n\t// parse arguments\n\tfor (i = 1; i < argc; i++) {\n\t\trun_cmd_and_exit(i, argc, argv); // will exit if the command is recognized\n\n\t\tif (strcmp(argv[i], \"--debug\") == 0 && !arg_quiet)\n\t\t\targ_debug = 1;\n\t\telse if (strcmp(argv[i], \"--debug-blacklists\") == 0)\n\t\t\targ_debug_blacklists = 1;\n\t\telse if (strcmp(argv[i], \"--debug-whitelists\") == 0)\n\t\t\targ_debug_whitelists = 1;\n\t\telse if (strcmp(argv[i], \"--debug-private-lib\") == 0)\n\t\t\targ_debug_private_lib = 1;\n\t\telse if (strcmp(argv[i], \"--quiet\") == 0) {\n\t\t\targ_quiet = 1;\n\t\t\targ_debug = 0;\n\t\t}\n\t\telse if (strcmp(argv[i], \"--allow-debuggers\") == 0) {\n\t\t\t// already handled\n\t\t}\n\n\n\t\t//*************************************\n\t\t// x11\n\t\t//*************************************\n\n#ifdef HAVE_X11\n\t\telse if (strncmp(argv[i], \"--xephyr-screen=\", 16) == 0) {\n\t\t\tif (checkcfg(CFG_X11))\n\t\t\t\t; // the processing is done directly in x11.c\n\t\t\telse\n\t\t\t\texit_err_feature(\"x11\");\n\t\t}\n#endif\n\t\t//*************************************\n\t\t// filtering\n\t\t//*************************************\n#ifdef HAVE_APPARMOR\n\t\telse if (strcmp(argv[i], \"--apparmor\") == 0)\n\t\t\targ_apparmor = 1;\n#endif\n#ifdef HAVE_SECCOMP\n\t\telse if (strncmp(argv[i], \"--protocol=\", 11) == 0) {\n\t\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\t\tif (cfg.protocol) {\n\t\t\t\t\tfwarning(\"two protocol lists are present, \\\"%s\\\" will be installed\\n\", cfg.protocol);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// store list\n\t\t\t\t\tcfg.protocol = strdup(argv[i] + 11);\n\t\t\t\t\tif (!cfg.protocol)\n\t\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\texit_err_feature(\"seccomp\");\n\t\t}\n\t\telse if (strcmp(argv[i], \"--seccomp\") == 0) {\n\t\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\t\tif (arg_seccomp) {\n\t\t\t\t\tfprintf(stderr, \"Error: seccomp already enabled\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\targ_seccomp = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\texit_err_feature(\"seccomp\");\n\t\t}"
  },
  {
    "function_name": "run_builder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "864-882",
    "snippet": "static void run_builder(int argc, char **argv) {\n\tEUID_ASSERT();\n\t(void) argc;\n\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\tumask(orig_umask);\n\n\targv[0] = LIBDIR \"/firejail/fbuilder\";\n\texecvp(argv[0], argv);\n\n\tperror(\"execvp\");\n\texit(1);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "mode_t orig_umask = 022;",
      "else if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11))",
      "else if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0)",
      "else if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);",
      "else if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);",
      "else if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0)"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "argv[0]",
            "argv"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "orig_umask"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "extract_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "240-256",
          "snippet": "static void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setresuid\""
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "-1",
            "getuid()",
            "getuid()"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "setresuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "658-666",
          "snippet": "int setresuid(uid_t ruid, uid_t euid, uid_t suid) {\n\tif (!orig_setresuid)\n\t\torig_setresuid = (orig_setresuid_t)dlsym(RTLD_NEXT, \"setresuid\");\n\n\tint rv = orig_setresuid(ruid, euid, suid);\n\tprintf(\"%u:%s:setresuid %d %d %d:%d\\n\", pid(), name(), ruid, euid, suid, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_setresuid_t orig_setresuid = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_setresuid_t orig_setresuid = NULL;\n\nint setresuid(uid_t ruid, uid_t euid, uid_t suid) {\n\tif (!orig_setresuid)\n\t\torig_setresuid = (orig_setresuid_t)dlsym(RTLD_NEXT, \"setresuid\");\n\n\tint rv = orig_setresuid(ruid, euid, suid);\n\tprintf(\"%u:%s:setresuid %d %d %d:%d\\n\", pid(), name(), ruid, euid, suid, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setresgid\""
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "-1",
            "getgid()",
            "getgid()"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "setresgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "670-678",
          "snippet": "int setresgid(gid_t rgid, gid_t egid, gid_t sgid) {\n\tif (!orig_setresgid)\n\t\torig_setresgid = (orig_setresgid_t)dlsym(RTLD_NEXT, \"setresgid\");\n\n\tint rv = orig_setresgid(rgid, egid, sgid);\n\tprintf(\"%u:%s:setresgid %d %d %d:%d\\n\", pid(), name(), rgid, egid, sgid, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_setresgid_t orig_setresgid = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_setresgid_t orig_setresgid = NULL;\n\nint setresgid(gid_t rgid, gid_t egid, gid_t sgid) {\n\tif (!orig_setresgid)\n\t\torig_setresgid = (orig_setresgid_t)dlsym(RTLD_NEXT, \"setresgid\");\n\n\tint rv = orig_setresgid(rgid, egid, sgid);\n\tprintf(\"%u:%s:setresgid %d %d %d:%d\\n\", pid(), name(), rgid, egid, sgid, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nmode_t orig_umask = 022;\nelse if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11));\nelse if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0);\nelse if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);\nelse if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);\nelse if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0);\n\nstatic void run_builder(int argc, char **argv) {\n\tEUID_ASSERT();\n\t(void) argc;\n\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\tumask(orig_umask);\n\n\targv[0] = LIBDIR \"/firejail/fbuilder\";\n\texecvp(argv[0], argv);\n\n\tperror(\"execvp\");\n\texit(1);\n}"
  },
  {
    "function_name": "check_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "837-862",
    "snippet": "static int check_arg(int argc, char **argv, const char *argument, int strict) {\n\tint i;\n\tint found = 0;\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strict) {\n\t\t\tif (strcmp(argv[i], argument) == 0) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (strncmp(argv[i], argument, strlen(argument)) == 0) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// detect end of firejail params\n\t\tif (strcmp(argv[i], \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(argv[i], \"--\", 2) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "else if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11))",
      "else if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0)",
      "else if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);",
      "else if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);",
      "else if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0)"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--\"",
            "2"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "argument",
            "strlen(argument)"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argument"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "argument"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nelse if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11));\nelse if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0);\nelse if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);\nelse if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);\nelse if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0);\n\nstatic int check_arg(int argc, char **argv, const char *argument, int strict) {\n\tint i;\n\tint found = 0;\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strict) {\n\t\t\tif (strcmp(argv[i], argument) == 0) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (strncmp(argv[i], argument, strlen(argument)) == 0) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// detect end of firejail params\n\t\tif (strcmp(argv[i], \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(argv[i], \"--\", 2) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "guess_shell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "810-835",
    "snippet": "char *guess_shell(void) {\n\tchar *shell = NULL;\n\tstruct stat s;\n\n\tshell = getenv(\"SHELL\");\n\tif (shell) {\n\t\tinvalid_filename(shell, 0); // no globbing\n\t\tif (!is_dir(shell) && strstr(shell, \"..\") == NULL && stat(shell, &s) == 0 && access(shell, X_OK) == 0)\n\t\t\treturn shell;\n\t}\n\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], X_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "access",
          "args": [
            "shells[i]",
            "X_OK"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "478-485",
          "snippet": "int access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_access_t orig_access = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_access_t orig_access = NULL;\n\nint access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "shells[i]",
            "&s"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "shell",
            "\"..\""
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dir",
          "args": [
            "shell"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/ftee/main.c",
          "lines": "139-166",
          "snippet": "static int is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\texit(1);\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"ftee.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"ftee.h\"\n\nstatic int is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\texit(1);\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalid_filename",
          "args": [
            "shell",
            "0"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SHELL\""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nchar *guess_shell(void) {\n\tchar *shell = NULL;\n\tstruct stat s;\n\n\tshell = getenv(\"SHELL\");\n\tif (shell) {\n\t\tinvalid_filename(shell, 0); // no globbing\n\t\tif (!is_dir(shell) && strstr(shell, \"..\") == NULL && stat(shell, &s) == 0 && access(shell, X_OK) == 0)\n\t\t\treturn shell;\n\t}\n\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], X_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}"
  },
  {
    "function_name": "run_cmd_and_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "336-375",
    "snippet": "static void run_cmd_and_exit(int i, int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t//*************************************\n\t// basic arguments\n\t//*************************************\n\tif (strcmp(argv[i], \"--help\") == 0 ||\n\t    strcmp(argv[i], \"-?\") == 0) {\n\t\tusage();\n\t\texit(0);\n\t}\n\telse if (strcmp(argv[i], \"--version\") == 0) {\n\t\tprintf(\"firejail version %s\\n\", VERSION);\n\t\tprintf(\"\\n\");\n\t\tprint_compiletime_support();\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n#ifdef HAVE_OVERLAYFS\n\telse if (strcmp(argv[i], \"--overlay-clean\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (remove_overlay_directory()) {\n\t\t\t\tfprintf(stderr, \"Error: cannot remove overlay directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\texit_err_feature(\"overlayfs\");\n\t\texit(0);\n\t}\n#endif\n#ifdef HAVE_X11\n\telse if (strcmp(argv[i], \"--x11\") == 0) {\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tx11_start(argc, argv);\n\t\t\texit(0);\n\t\t}\n\t\telse\n\t\t\texit_err_feature(\"x11\");\n\t}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "else if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11))",
      "else if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0)",
      "else if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);",
      "else if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);",
      "else if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0)"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_start",
          "args": [
            "argc",
            "argv"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "1037-1057",
          "snippet": "void x11_start(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\n\t// check xpra\n\tif (program_in_path(\"xpra\"))\n\t\tx11_start_xpra(argc, argv);\n\telse if (program_in_path(\"Xephyr\"))\n\t\tx11_start_xephyr(argc, argv);\n\telse {\n\t\tfprintf(stderr, \"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\texit(0);\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\n\t// check xpra\n\tif (program_in_path(\"xpra\"))\n\t\tx11_start_xpra(argc, argv);\n\telse if (program_in_path(\"Xephyr\"))\n\t\tx11_start_xephyr(argc, argv);\n\telse {\n\t\tfprintf(stderr, \"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\texit(0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11\") == 0) {\n\t\tif",
          "args": [
            "checkcfg(CFG_X11)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_X11"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/checkcfg.c",
          "lines": "35-213",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *xpra_extra_params = \"\";",
            "char *xvfb_screen = \"800x600x24\";",
            "char *xvfb_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *xpra_extra_params = \"\";\nchar *xvfb_screen = \"800x600x24\";\nchar *xvfb_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot remove overlay directory\\n\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_overlay_directory",
          "args": [],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "remove_overlay_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "900-957",
          "snippet": "int remove_overlay_directory(void) {\n\tEUID_ASSERT();\n\tstruct stat s;\n\tsleep(1);\n\n\tchar *path;\n\tif (asprintf(&path, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (lstat(path, &s) == 0) {\n\t\t// deal with obvious problems such as symlinks and root ownership\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", path);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", path);\n\t\t\texit(1);\n\t\t}\n\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// open ~/.firejail, fails if there is any symlink\n\t\t\tint fd = safe_fd(path, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\t\tif (fd == -1)\n\t\t\t\terrExit(\"safe_fd\");\n\t\t\t// chdir to ~/.firejail\n\t\t\tif (fchdir(fd) == -1)\n\t\t\t\terrExit(\"fchdir\");\n\t\t\tclose(fd);\n\n\t\t\tEUID_ROOT();\n\t\t\t// FTW_PHYS - do not follow symbolic links\n\t\t\tif (nftw(\".\", remove_callback, 64, FTW_DEPTH | FTW_PHYS) == -1)\n\t\t\t\terrExit(\"nftw\");\n\n\t\t\tEUID_USER();\n\t\t\t// remove ~/.firejail\n\t\t\tif (rmdir(path) == -1)\n\t\t\t\terrExit(\"rmdir\");\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t\t// check if ~/.firejail was deleted\n\t\tif (stat(path, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint remove_overlay_directory(void) {\n\tEUID_ASSERT();\n\tstruct stat s;\n\tsleep(1);\n\n\tchar *path;\n\tif (asprintf(&path, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (lstat(path, &s) == 0) {\n\t\t// deal with obvious problems such as symlinks and root ownership\n\t\tif (!S_ISDIR(s.st_mode)) {\n\t\t\tif (S_ISLNK(s.st_mode))\n\t\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", path);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", path);\n\t\t\texit(1);\n\t\t}\n\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// open ~/.firejail, fails if there is any symlink\n\t\t\tint fd = safe_fd(path, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\t\tif (fd == -1)\n\t\t\t\terrExit(\"safe_fd\");\n\t\t\t// chdir to ~/.firejail\n\t\t\tif (fchdir(fd) == -1)\n\t\t\t\terrExit(\"fchdir\");\n\t\t\tclose(fd);\n\n\t\t\tEUID_ROOT();\n\t\t\t// FTW_PHYS - do not follow symbolic links\n\t\t\tif (nftw(\".\", remove_callback, 64, FTW_DEPTH | FTW_PHYS) == -1)\n\t\t\t\terrExit(\"nftw\");\n\n\t\t\tEUID_USER();\n\t\t\t// remove ~/.firejail\n\t\t\tif (rmdir(path) == -1)\n\t\t\t\terrExit(\"rmdir\");\n#ifdef HAVE_GCOV\n\t\t\t__gcov_flush();\n#endif\n\t\t\t_exit(0);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t\t// check if ~/.firejail was deleted\n\t\tif (stat(path, &s) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean\") == 0) {\n\t\tif",
          "args": [
            "checkcfg(CFG_OVERLAYFS)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_compiletime_support",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "print_compiletime_support",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/checkcfg.c",
          "lines": "238-327",
          "snippet": "void print_compiletime_support(void) {\n\tprintf(\"Compile time support:\\n\");\n\tprintf(\"\\t- AppArmor support is %s\\n\",\n#ifdef HAVE_APPARMOR\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- AppImage support is %s\\n\",\n#ifdef LOOP_CTL_GET_FREE\t// test for older kernels; this definition is found in /usr/include/linux/loop.h\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- chroot support is %s\\n\",\n#ifdef HAVE_CHROOT\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- file and directory whitelisting support is %s\\n\",\n#ifdef HAVE_WHITELIST\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- file transfer support is %s\\n\",\n#ifdef HAVE_FILE_TRANSFER\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- networking support is %s\\n\",\n#ifdef HAVE_NETWORK\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- overlayfs support is %s\\n\",\n#ifdef HAVE_OVERLAYFS\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- private-home support is %s\\n\",\n#ifdef HAVE_PRIVATE_HOME\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- seccomp-bpf support is %s\\n\",\n#ifdef HAVE_SECCOMP\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- user namespace support is %s\\n\",\n#ifdef HAVE_USERNS\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- X11 sandboxing support is %s\\n\",\n#ifdef HAVE_X11\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nvoid print_compiletime_support(void) {\n\tprintf(\"Compile time support:\\n\");\n\tprintf(\"\\t- AppArmor support is %s\\n\",\n#ifdef HAVE_APPARMOR\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- AppImage support is %s\\n\",\n#ifdef LOOP_CTL_GET_FREE\t// test for older kernels; this definition is found in /usr/include/linux/loop.h\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- chroot support is %s\\n\",\n#ifdef HAVE_CHROOT\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- file and directory whitelisting support is %s\\n\",\n#ifdef HAVE_WHITELIST\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- file transfer support is %s\\n\",\n#ifdef HAVE_FILE_TRANSFER\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- networking support is %s\\n\",\n#ifdef HAVE_NETWORK\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- overlayfs support is %s\\n\",\n#ifdef HAVE_OVERLAYFS\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- private-home support is %s\\n\",\n#ifdef HAVE_PRIVATE_HOME\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- seccomp-bpf support is %s\\n\",\n#ifdef HAVE_SECCOMP\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- user namespace support is %s\\n\",\n#ifdef HAVE_USERNS\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n\n\tprintf(\"\\t- X11 sandboxing support is %s\\n\",\n#ifdef HAVE_X11\n\t\t\"enabled\"\n#else\n\t\t\"disabled\"\n#endif\n\t\t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"firejail version %s\\n\"",
            "VERSION"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--version\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firecfg/main.c",
          "lines": "60-63",
          "snippet": "static void usage(void) {\n\tprintf(\"firecfg - version %s\\n\\n\", VERSION);\n\tputs(usage_str);\n}",
          "includes": [
            "#include \"../include/firejail_user.h\"",
            "#include \"firecfg.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *usage_str =\n\t\"Firecfg is the desktop configuration utility for Firejail software. The utility\\n\"\n\t\"creates several symbolic links to firejail executable. This allows the user to\\n\"\n\t\"sandbox applications automatically, just by clicking on a regular desktop\\n\"\n\t\"menus and icons.\\n\\n\"\n\t\"The symbolic links are placed in /usr/local/bin. For more information, see\\n\"\n\t\"DESKTOP INTEGRATION section in man 1 firejail.\\n\\n\"\n\t\"Usage: firecfg [OPTIONS]\\n\\n\"\n\t\"   --add-users user [user] - add the users to Firejail user access database.\\n\\n\"\n\t\"   --bindir=directory - install in directory instead of /usr/local/bin.\\n\\n\"\n\t\"   --clean - remove all firejail symbolic links.\\n\\n\"\n\t\"   --debug - print debug messages.\\n\\n\"\n\t\"   --fix - fix .desktop files.\\n\\n\"\n\t\"   --fix-sound - create ~/.config/pulse/client.conf file.\\n\\n\"\n\t\"   --help, -? - this help screen.\\n\\n\"\n\t\"   --list - list all firejail symbolic links.\\n\\n\"\n\t\"   --version - print program version and exit.\\n\\n\"\n\t\"Example:\\n\\n\"\n\t\"   $ sudo firecfg\\n\"\n\t\"   /usr/local/bin/firefox created\\n\"\n\t\"   /usr/local/bin/vlc created\\n\"\n\t\"   [...]\\n\"\n\t\"   $ firecfg --list\\n\"\n\t\"   /usr/local/bin/firefox\\n\"\n\t\"   /usr/local/bin/vlc\\n\"\n\t\"   [...]\\n\"\n\t\"   $ sudo firecfg --clean\\n\"\n\t\"   /usr/local/bin/firefox removed\\n\"\n\t\"   /usr/local/bin/vlc removed\\n\"\n\t\"   [...]\\n\"\n\t\"\\n\"\n\t\"License GPL version 2 or later\\n\"\n\t\"Homepage: https://firejail.wordpress.com\\n\\n\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/firejail_user.h\"\n#include \"firecfg.h\"\n\nstatic char *usage_str =\n\t\"Firecfg is the desktop configuration utility for Firejail software. The utility\\n\"\n\t\"creates several symbolic links to firejail executable. This allows the user to\\n\"\n\t\"sandbox applications automatically, just by clicking on a regular desktop\\n\"\n\t\"menus and icons.\\n\\n\"\n\t\"The symbolic links are placed in /usr/local/bin. For more information, see\\n\"\n\t\"DESKTOP INTEGRATION section in man 1 firejail.\\n\\n\"\n\t\"Usage: firecfg [OPTIONS]\\n\\n\"\n\t\"   --add-users user [user] - add the users to Firejail user access database.\\n\\n\"\n\t\"   --bindir=directory - install in directory instead of /usr/local/bin.\\n\\n\"\n\t\"   --clean - remove all firejail symbolic links.\\n\\n\"\n\t\"   --debug - print debug messages.\\n\\n\"\n\t\"   --fix - fix .desktop files.\\n\\n\"\n\t\"   --fix-sound - create ~/.config/pulse/client.conf file.\\n\\n\"\n\t\"   --help, -? - this help screen.\\n\\n\"\n\t\"   --list - list all firejail symbolic links.\\n\\n\"\n\t\"   --version - print program version and exit.\\n\\n\"\n\t\"Example:\\n\\n\"\n\t\"   $ sudo firecfg\\n\"\n\t\"   /usr/local/bin/firefox created\\n\"\n\t\"   /usr/local/bin/vlc created\\n\"\n\t\"   [...]\\n\"\n\t\"   $ firecfg --list\\n\"\n\t\"   /usr/local/bin/firefox\\n\"\n\t\"   /usr/local/bin/vlc\\n\"\n\t\"   [...]\\n\"\n\t\"   $ sudo firecfg --clean\\n\"\n\t\"   /usr/local/bin/firefox removed\\n\"\n\t\"   /usr/local/bin/vlc removed\\n\"\n\t\"   [...]\\n\"\n\t\"\\n\"\n\t\"License GPL version 2 or later\\n\"\n\t\"Homepage: https://firejail.wordpress.com\\n\\n\";\n\nstatic void usage(void) {\n\tprintf(\"firecfg - version %s\\n\\n\", VERSION);\n\tputs(usage_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-?\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--help\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nelse if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11));\nelse if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0);\nelse if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);\nelse if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);\nelse if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0);\n\nstatic void run_cmd_and_exit(int i, int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t//*************************************\n\t// basic arguments\n\t//*************************************\n\tif (strcmp(argv[i], \"--help\") == 0 ||\n\t    strcmp(argv[i], \"-?\") == 0) {\n\t\tusage();\n\t\texit(0);\n\t}\n\telse if (strcmp(argv[i], \"--version\") == 0) {\n\t\tprintf(\"firejail version %s\\n\", VERSION);\n\t\tprintf(\"\\n\");\n\t\tprint_compiletime_support();\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n#ifdef HAVE_OVERLAYFS\n\telse if (strcmp(argv[i], \"--overlay-clean\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (remove_overlay_directory()) {\n\t\t\t\tfprintf(stderr, \"Error: cannot remove overlay directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\texit_err_feature(\"overlayfs\");\n\t\texit(0);\n\t}\n#endif\n#ifdef HAVE_X11\n\telse if (strcmp(argv[i], \"--x11\") == 0) {\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tx11_start(argc, argv);\n\t\t\texit(0);\n\t\t}\n\t\telse\n\t\t\texit_err_feature(\"x11\");\n\t}"
  },
  {
    "function_name": "exit_err_feature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "329-332",
    "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s feature is disabled in Firejail configuration file\\n\"",
            "feature"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
  },
  {
    "function_name": "check_user_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "303-325",
    "snippet": "void check_user_namespace(void) {\n\tEUID_ASSERT();\n\tif (getuid() == 0)\n\t\tgoto errout;\n\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0)\n\t\targ_noroot = 1;\n\telse\n\t\tgoto errout;\n\n\treturn;\n\nerrout:\n\tfwarning(\"noroot option is not available\\n\");\n\targ_noroot = 0;\n\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int arg_noroot = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"noroot option is not available\\n\""
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/proc/self/gid_map\"",
            "&s3"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_noroot = 0;\n\nvoid check_user_namespace(void) {\n\tEUID_ASSERT();\n\tif (getuid() == 0)\n\t\tgoto errout;\n\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0)\n\t\targ_noroot = 1;\n\telse\n\t\tgoto errout;\n\n\treturn;\n\nerrout:\n\tfwarning(\"noroot option is not available\\n\");\n\targ_noroot = 0;\n\n}"
  },
  {
    "function_name": "check_network",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "289-300",
    "snippet": "static void check_network(Bridge *br) {\n\tassert(br);\n\tif (br->macvlan == 0) // for bridge devices check network range or arp-scan and assign address\n\t\tnet_configure_sandbox_ip(br);\n\telse if (br->ipsandbox) { // for macvlan check network range\n\t\tchar *rv = in_netrange(br->ipsandbox, br->ip, br->mask);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"%s\", rv);\n\t\t\texit(1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "rv"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "br->ipsandbox",
            "br->ip",
            "br->mask"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "in_netrange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "73-81",
          "snippet": "static inline char *in_netrange(uint32_t ip, uint32_t ifip, uint32_t ifmask) {\n\tif ((ip & ifmask) != (ifip & ifmask))\n\t\treturn \"Error: the IP address is not in the interface range\\n\";\n\telse if ((ip & ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\telse if ((ip | ~ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\treturn NULL;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline char *in_netrange(uint32_t ip, uint32_t ifip, uint32_t ifmask) {\n\tif ((ip & ifmask) != (ifip & ifmask))\n\t\treturn \"Error: the IP address is not in the interface range\\n\";\n\telse if ((ip & ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\telse if ((ip | ~ifmask) == ip)\n\t\treturn \"Error: the IP address is a network address\\n\";\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_configure_sandbox_ip",
          "args": [
            "br"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "net_configure_sandbox_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network_main.c",
          "lines": "112-135",
          "snippet": "void net_configure_sandbox_ip(Bridge *br) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\tif (br->arg_ip_none)\n\t\tbr->ipsandbox = 0;\n\telse if (br->ipsandbox) {\n\t\t// check network range\n\t\tchar *rv = in_netrange(br->ipsandbox, br->ip, br->mask);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"%s\", rv);\n\t\t\texit(1);\n\t\t}\n\t\t// send an ARP request and check if there is anybody on this IP address\n\t\tif (arp_check(br->dev, br->ipsandbox)) {\n\t\t\tfprintf(stderr, \"Error: IP address %d.%d.%d.%d is already in use\\n\", PRINT_IP(br->ipsandbox));\n\t\t\texit(1);\n\t\t}\n\t}\n\telse\n\t\t// ip address assigned by arp-scan for a bridge device\n\t\tbr->ipsandbox = arp_assign(br->dev, br); //br->ip, br->mask);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <stdarg.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_configure_sandbox_ip(Bridge *br) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\tif (br->arg_ip_none)\n\t\tbr->ipsandbox = 0;\n\telse if (br->ipsandbox) {\n\t\t// check network range\n\t\tchar *rv = in_netrange(br->ipsandbox, br->ip, br->mask);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"%s\", rv);\n\t\t\texit(1);\n\t\t}\n\t\t// send an ARP request and check if there is anybody on this IP address\n\t\tif (arp_check(br->dev, br->ipsandbox)) {\n\t\t\tfprintf(stderr, \"Error: IP address %d.%d.%d.%d is already in use\\n\", PRINT_IP(br->ipsandbox));\n\t\t\texit(1);\n\t\t}\n\t}\n\telse\n\t\t// ip address assigned by arp-scan for a bridge device\n\t\tbr->ipsandbox = arp_assign(br->dev, br); //br->ip, br->mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void check_network(Bridge *br) {\n\tassert(br);\n\tif (br->macvlan == 0) // for bridge devices check network range or arp-scan and assign address\n\t\tnet_configure_sandbox_ip(br);\n\telse if (br->ipsandbox) { // for macvlan check network range\n\t\tchar *rv = in_netrange(br->ipsandbox, br->ip, br->mask);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"%s\", rv);\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "init_cfg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "235-287",
    "snippet": "static void init_cfg(int argc, char **argv) {\n\tEUID_ASSERT();\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tcfg.original_argv = argv;\n\tcfg.original_argc = argc;\n\tcfg.bridge0.devsandbox = \"eth0\";\n\tcfg.bridge1.devsandbox = \"eth1\";\n\tcfg.bridge2.devsandbox = \"eth2\";\n\tcfg.bridge3.devsandbox = \"eth3\";\n\n\t// extract user data\n\tEUID_ROOT(); // rise permissions for grsecurity\n\tstruct passwd *pw = getpwuid(getuid());\n\tif (!pw)\n\t\terrExit(\"getpwuid\");\n\tEUID_USER();\n\tcfg.username = strdup(pw->pw_name);\n\tif (!cfg.username)\n\t\terrExit(\"strdup\");\n\n\t// build home directory name\n\tcfg.homedir = NULL;\n\tif (pw->pw_dir != NULL) {\n\t\tcfg.homedir = clean_pathname(pw->pw_dir);\n\t\tassert(cfg.homedir);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: user %s doesn't have a user directory assigned\\n\", cfg.username);\n\t\texit(1);\n\t}\n\n\tcfg.cwd = getcwd(NULL, 0);\n\tif (!cfg.cwd && errno != ENOENT)\n\t\terrExit(\"getcwd\");\n\n\t// check user database\n\tif (!firejail_user_check(cfg.username)) {\n\t\tfprintf(stderr, \"Error: the user is not allowed to use Firejail. \"\n\t\t\t\"Please add the user in %s/firejail.users file, \"\n\t\t\t\"either by running \\\"sudo firecfg\\\", or by editing the file directly.\\n\"\n\t\t\t\"See \\\"man firejail-users\\\" for more details.\\n\", SYSCONFDIR);\n\n\t\t// attempt to run the program as is\n\t\trun_symlink(argc, argv, 1);\n\t\texit(1);\n\t}\n\n\t// initialize random number generator\n\tsandbox_pid = getpid();\n\ttime_t t = time(NULL);\n\tsrand(t ^ sandbox_pid);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Config cfg;",
      "pid_t sandbox_pid;",
      "else if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11))",
      "else if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0)",
      "else if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);",
      "else if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);",
      "else if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0)"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srand",
          "args": [
            "t ^ sandbox_pid"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "extract_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1094-1110",
          "snippet": "unsigned extract_timeout(const char *str) {\n\tunsigned s;\n\tunsigned m;\n\tunsigned h;\n\tint rv = sscanf(str, \"%02u:%02u:%02u\", &h, &m, &s);\n\tif (rv != 3) {\n\t\tfprintf(stderr, \"Error: invalid timeout, please use a hh:mm:ss format\\n\");\n\t\texit(1);\n\t}\n\tunsigned timeout = h * 3600 + m * 60 + s;\n\tif (timeout == 0) {\n\t\tfprintf(stderr, \"Error: invalid timeout\\n\");\n\t\texit(1);\n\t}\n\n\treturn timeout;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nunsigned extract_timeout(const char *str) {\n\tunsigned s;\n\tunsigned m;\n\tunsigned h;\n\tint rv = sscanf(str, \"%02u:%02u:%02u\", &h, &m, &s);\n\tif (rv != 3) {\n\t\tfprintf(stderr, \"Error: invalid timeout, please use a hh:mm:ss format\\n\");\n\t\texit(1);\n\t}\n\tunsigned timeout = h * 3600 + m * 60 + s;\n\tif (timeout == 0) {\n\t\tfprintf(stderr, \"Error: invalid timeout\\n\");\n\t\texit(1);\n\t}\n\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_symlink",
          "args": [
            "argc",
            "argv",
            "1"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "run_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/run_symlink.c",
          "lines": "25-116",
          "snippet": "void run_symlink(int argc, char **argv, int run_as_is) {\n\tEUID_ASSERT();\n\n\tchar *program = strrchr(argv[0], '/');\n\tif (program)\n\t\tprogram += 1;\n\telse\n\t\tprogram = argv[0];\n\tif (strcmp(program, \"firejail\") == 0) // this is a regular \"firejail program\" sandbox starting\n\t\treturn;\n\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\t// find the real program by looking in PATH\n\tchar *p = getenv(\"PATH\");\n\tif (!p) {\n\t\tfprintf(stderr, \"Error: PATH environment variable not set\\n\");\n\t\texit(1);\n\t}\n\n\tchar *path = strdup(p);\n\tif (!path)\n\t\terrExit(\"strdup\");\n\n\tchar *selfpath = realpath(\"/proc/self/exe\", NULL);\n\tif (!selfpath)\n\t\terrExit(\"realpath\");\n\n\t// look in path for our program\n\tchar *tok = strtok(path, \":\");\n\tint found = 0;\n\twhile (tok) {\n\t\tchar *name;\n\t\tif (asprintf(&name, \"%s/%s\", tok, program) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tstruct stat s;\n\t\tif (stat(name, &s) == 0) {\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(name, NULL);\n\t\t\tif (!rp)\n\t\t\t\terrExit(\"realpath\");\n\n\t\t\tif (strcmp(selfpath, rp) != 0) {\n\t\t\t\tprogram = strdup(name);\n\t\t\t\tfound = 1;\n\t\t\t\tfree(rp);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfree(rp);\n\t\t}\n\n\t\tfree(name);\n\t\ttok = strtok(NULL, \":\");\n\t}\n\tif (!found) {\n\t\tfprintf(stderr, \"Error: cannot find the program in the path\\n\");\n\t\texit(1);\n\t}\n\n\tfree(selfpath);\n\n\t// restore original umask\n\tumask(orig_umask);\n\n\t// desktop integration is not supported for root user; instead, the original program is started\n\tif (getuid() == 0 || run_as_is) {\n\t\targv[0] = program;\n\t\texecv(program, argv);\n\t\texit(1);\n\t}\n\n\t// start the argv[0] program in a new sandbox\n\tchar *a[3 + argc];\n\ta[0] =PATH_FIREJAIL;\n\ta[1] = program;\n\tint i;\n\tfor (i = 0; i < (argc - 1); i++) {\n\t\ta[i + 2] = argv[i + 1];\n\t}\n\ta[i + 2] = NULL;\n\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\texecvp(a[0], a);\n\n\tperror(\"execvp\");\n\texit(1);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid run_symlink(int argc, char **argv, int run_as_is) {\n\tEUID_ASSERT();\n\n\tchar *program = strrchr(argv[0], '/');\n\tif (program)\n\t\tprogram += 1;\n\telse\n\t\tprogram = argv[0];\n\tif (strcmp(program, \"firejail\") == 0) // this is a regular \"firejail program\" sandbox starting\n\t\treturn;\n\n\t// drop privileges\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n\n\t// find the real program by looking in PATH\n\tchar *p = getenv(\"PATH\");\n\tif (!p) {\n\t\tfprintf(stderr, \"Error: PATH environment variable not set\\n\");\n\t\texit(1);\n\t}\n\n\tchar *path = strdup(p);\n\tif (!path)\n\t\terrExit(\"strdup\");\n\n\tchar *selfpath = realpath(\"/proc/self/exe\", NULL);\n\tif (!selfpath)\n\t\terrExit(\"realpath\");\n\n\t// look in path for our program\n\tchar *tok = strtok(path, \":\");\n\tint found = 0;\n\twhile (tok) {\n\t\tchar *name;\n\t\tif (asprintf(&name, \"%s/%s\", tok, program) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tstruct stat s;\n\t\tif (stat(name, &s) == 0) {\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(name, NULL);\n\t\t\tif (!rp)\n\t\t\t\terrExit(\"realpath\");\n\n\t\t\tif (strcmp(selfpath, rp) != 0) {\n\t\t\t\tprogram = strdup(name);\n\t\t\t\tfound = 1;\n\t\t\t\tfree(rp);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfree(rp);\n\t\t}\n\n\t\tfree(name);\n\t\ttok = strtok(NULL, \":\");\n\t}\n\tif (!found) {\n\t\tfprintf(stderr, \"Error: cannot find the program in the path\\n\");\n\t\texit(1);\n\t}\n\n\tfree(selfpath);\n\n\t// restore original umask\n\tumask(orig_umask);\n\n\t// desktop integration is not supported for root user; instead, the original program is started\n\tif (getuid() == 0 || run_as_is) {\n\t\targv[0] = program;\n\t\texecv(program, argv);\n\t\texit(1);\n\t}\n\n\t// start the argv[0] program in a new sandbox\n\tchar *a[3 + argc];\n\ta[0] =PATH_FIREJAIL;\n\ta[1] = program;\n\tint i;\n\tfor (i = 0; i < (argc - 1); i++) {\n\t\ta[i + 2] = argv[i + 1];\n\t}\n\ta[i + 2] = NULL;\n\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\texecvp(a[0], a);\n\n\tperror(\"execvp\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: the user is not allowed to use Firejail. \"\n\t\t\t\"Please add the user in %s/firejail.users file, \"\n\t\t\t\"either by running \\\"sudo firecfg\\\", or by editing the file directly.\\n\"\n\t\t\t\"See \\\"man firejail-users\\\" for more details.\\n\"",
            "SYSCONFDIR"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firejail_user_check",
          "args": [
            "cfg.username"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "firejail_user_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/firejail_user.c",
          "lines": "103-152",
          "snippet": "int firejail_user_check(const char *name) {\n\tassert(name);\n\tinit_uid_gid_min();\n\n\t// root is allowed to run firejail by default\n\tif (strcmp(name, \"root\") == 0)\n\t\treturn 1;\n\n\t// user nobody is never allowed\n\tif (strcmp(name, \"nobody\") == 0)\n\t\treturn 0;\n\n\t// check file existence\n\tchar *fname = get_fname();\n\tassert(fname);\n\tif (access(fname, F_OK) == -1 && errno == ENOENT) {\n\t\t// assume the user doesn't care about access checking\n\t\tfree(fname);\n\t\treturn 1;\n\t}\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fname);\n\t\tperror(\"fopen\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// lines starting with # are comments\n\t\tif (*buf == '#')\n\t\t\tcontinue;\n\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// compare\n\t\tif (strcmp(buf, name) == 0) {\n\t\t\tfclose(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 0;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/common.h\"\n\n#define MAXBUF 4098\n\nint firejail_user_check(const char *name) {\n\tassert(name);\n\tinit_uid_gid_min();\n\n\t// root is allowed to run firejail by default\n\tif (strcmp(name, \"root\") == 0)\n\t\treturn 1;\n\n\t// user nobody is never allowed\n\tif (strcmp(name, \"nobody\") == 0)\n\t\treturn 0;\n\n\t// check file existence\n\tchar *fname = get_fname();\n\tassert(fname);\n\tif (access(fname, F_OK) == -1 && errno == ENOENT) {\n\t\t// assume the user doesn't care about access checking\n\t\tfree(fname);\n\t\treturn 1;\n\t}\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fname);\n\t\tperror(\"fopen\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// lines starting with # are comments\n\t\tif (*buf == '#')\n\t\t\tcontinue;\n\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// compare\n\t\tif (strcmp(buf, name) == 0) {\n\t\t\tfclose(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"getcwd\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getcwd",
          "args": [
            "NULL",
            "0"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: user %s doesn't have a user directory assigned\\n\"",
            "cfg.username"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cfg.homedir"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_pathname",
          "args": [
            "pw->pw_dir"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "clean_pathname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "550-582",
          "snippet": "char *clean_pathname(const char *path) {\n\tassert(path);\n\tsize_t len = strlen(path);\n\tassert(len + 1 != 0 && path[len] == '\\0');\n\n\tchar *rv = malloc(len + 1);\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\n\tif (len > 0) {\n\t\tsize_t i, j, cnt;\n\t\tfor (i = 0, j = 0, cnt = 0; i < len; i++) {\n\t\t\tif (path[i] == '/')\n\t\t\t\tcnt++;\n\t\t\telse\n\t\t\t\tcnt = 0;\n\n\t\t\tif (cnt < 2) {\n\t\t\t\trv[j] = path[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\trv[j] = '\\0';\n\n\t\t// remove a trailing slash\n\t\tif (j > 1 && rv[j - 1] == '/')\n\t\t\trv[j - 1] = '\\0';\n\t}\n\telse\n\t\t*rv = '\\0';\n\n\treturn rv;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *clean_pathname(const char *path) {\n\tassert(path);\n\tsize_t len = strlen(path);\n\tassert(len + 1 != 0 && path[len] == '\\0');\n\n\tchar *rv = malloc(len + 1);\n\tif (!rv)\n\t\terrExit(\"malloc\");\n\n\tif (len > 0) {\n\t\tsize_t i, j, cnt;\n\t\tfor (i = 0, j = 0, cnt = 0; i < len; i++) {\n\t\t\tif (path[i] == '/')\n\t\t\t\tcnt++;\n\t\t\telse\n\t\t\t\tcnt = 0;\n\n\t\t\tif (cnt < 2) {\n\t\t\t\trv[j] = path[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\trv[j] = '\\0';\n\n\t\t// remove a trailing slash\n\t\tif (j > 1 && rv[j - 1] == '/')\n\t\t\trv[j - 1] = '\\0';\n\t}\n\telse\n\t\t*rv = '\\0';\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "pw->pw_name"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"getpwuid\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "getuid()"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cfg",
            "0",
            "sizeof(cfg)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nConfig cfg;\npid_t sandbox_pid;\nelse if (strcmp(argv[i], \"--x11=xpra\") == 0) {\n\t\tif (checkcfg(CFG_X11));\nelse if (strncmp(argv[i], \"--join=\", 7) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0);\nelse if (strcmp(argv[i], \"--nonewprivs\") == 0)\n\t\t\targ_nonewprivs = 1;\n\t\telse if (strncmp(argv[i], \"--env=\", 6) == 0)\n\t\t\tenv_store(argv[i] + 6, SETENV);\nelse if (strncmp(argv[i], \"--rmenv=\", 8) == 0)\n\t\t\tenv_store(argv[i] + 8, RMENV);\nelse if (strncmp(argv[i], \"--dns=\", 6) == 0) {\n\t\t\tif (check_ip46_address(argv[i] + 6) == 0);\n\nstatic void init_cfg(int argc, char **argv) {\n\tEUID_ASSERT();\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tcfg.original_argv = argv;\n\tcfg.original_argc = argc;\n\tcfg.bridge0.devsandbox = \"eth0\";\n\tcfg.bridge1.devsandbox = \"eth1\";\n\tcfg.bridge2.devsandbox = \"eth2\";\n\tcfg.bridge3.devsandbox = \"eth3\";\n\n\t// extract user data\n\tEUID_ROOT(); // rise permissions for grsecurity\n\tstruct passwd *pw = getpwuid(getuid());\n\tif (!pw)\n\t\terrExit(\"getpwuid\");\n\tEUID_USER();\n\tcfg.username = strdup(pw->pw_name);\n\tif (!cfg.username)\n\t\terrExit(\"strdup\");\n\n\t// build home directory name\n\tcfg.homedir = NULL;\n\tif (pw->pw_dir != NULL) {\n\t\tcfg.homedir = clean_pathname(pw->pw_dir);\n\t\tassert(cfg.homedir);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: user %s doesn't have a user directory assigned\\n\", cfg.username);\n\t\texit(1);\n\t}\n\n\tcfg.cwd = getcwd(NULL, 0);\n\tif (!cfg.cwd && errno != ENOENT)\n\t\terrExit(\"getcwd\");\n\n\t// check user database\n\tif (!firejail_user_check(cfg.username)) {\n\t\tfprintf(stderr, \"Error: the user is not allowed to use Firejail. \"\n\t\t\t\"Please add the user in %s/firejail.users file, \"\n\t\t\t\"either by running \\\"sudo firecfg\\\", or by editing the file directly.\\n\"\n\t\t\t\"See \\\"man firejail-users\\\" for more details.\\n\", SYSCONFDIR);\n\n\t\t// attempt to run the program as is\n\t\trun_symlink(argc, argv, 1);\n\t\texit(1);\n\t}\n\n\t// initialize random number generator\n\tsandbox_pid = getpid();\n\ttime_t t = time(NULL);\n\tsrand(t ^ sandbox_pid);\n}"
  },
  {
    "function_name": "require_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "225-232",
    "snippet": "static pid_t require_pid(const char *name) {\n\tpid_t pid;\n\tif (read_pid(name,&pid)) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox %s\\n\", name);\n\t\texit(1);\n\t}\n\treturn pid;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "pid_t pid = require_pid(argv[i] + 18);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find sandbox %s\\n\"",
            "name"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_pid",
          "args": [
            "name",
            "&pid"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "read_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "209-223",
          "snippet": "static int read_pid(const char *name, pid_t *pid) {\n\tchar *endptr;\n\terrno = 0;\n\tlong int pidtmp = strtol(name, &endptr, 10);\n\tif ((errno == ERANGE && (pidtmp == LONG_MAX || pidtmp == LONG_MIN))\n\t\t|| (errno != 0 && pidtmp == 0)) {\n\t\treturn extract_pid(name,pid);\n\t}\n\t// endptr points to '\\0' char in name if the entire string is valid\n\tif (endptr == NULL || endptr[0]!='\\0') {\n\t\treturn extract_pid(name,pid);\n\t}\n\t*pid =(pid_t)pidtmp;\n\treturn 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid = require_pid(argv[i] + 18);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\npid_t pid = require_pid(argv[i] + 18);\n\nstatic int read_pid(const char *name, pid_t *pid) {\n\tchar *endptr;\n\terrno = 0;\n\tlong int pidtmp = strtol(name, &endptr, 10);\n\tif ((errno == ERANGE && (pidtmp == LONG_MAX || pidtmp == LONG_MIN))\n\t\t|| (errno != 0 && pidtmp == 0)) {\n\t\treturn extract_pid(name,pid);\n\t}\n\t// endptr points to '\\0' char in name if the entire string is valid\n\tif (endptr == NULL || endptr[0]!='\\0') {\n\t\treturn extract_pid(name,pid);\n\t}\n\t*pid =(pid_t)pidtmp;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\npid_t pid = require_pid(argv[i] + 18);\n\nstatic pid_t require_pid(const char *name) {\n\tpid_t pid;\n\tif (read_pid(name,&pid)) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox %s\\n\", name);\n\t\texit(1);\n\t}\n\treturn pid;\n}"
  },
  {
    "function_name": "read_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "209-223",
    "snippet": "static int read_pid(const char *name, pid_t *pid) {\n\tchar *endptr;\n\terrno = 0;\n\tlong int pidtmp = strtol(name, &endptr, 10);\n\tif ((errno == ERANGE && (pidtmp == LONG_MAX || pidtmp == LONG_MIN))\n\t\t|| (errno != 0 && pidtmp == 0)) {\n\t\treturn extract_pid(name,pid);\n\t}\n\t// endptr points to '\\0' char in name if the entire string is valid\n\tif (endptr == NULL || endptr[0]!='\\0') {\n\t\treturn extract_pid(name,pid);\n\t}\n\t*pid =(pid_t)pidtmp;\n\treturn 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "pid_t pid = require_pid(argv[i] + 18);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "extract_pid",
          "args": [
            "name",
            "pid"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "extract_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "192-206",
          "snippet": "static int extract_pid(const char *name, pid_t *pid) {\n\tint retval = 0;\n\tEUID_ASSERT();\n\tif (!name || strlen(name) == 0) {\n\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\texit(1);\n\t}\n\n\tEUID_ROOT();\n\tif (name2pid(name, pid)) {\n\t\tretval = 1;\n\t}\n\tEUID_USER();\n\treturn retval;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t pid = require_pid(argv[i] + 18);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\npid_t pid = require_pid(argv[i] + 18);\n\nstatic int extract_pid(const char *name, pid_t *pid) {\n\tint retval = 0;\n\tEUID_ASSERT();\n\tif (!name || strlen(name) == 0) {\n\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\texit(1);\n\t}\n\n\tEUID_ROOT();\n\tif (name2pid(name, pid)) {\n\t\tretval = 1;\n\t}\n\tEUID_USER();\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "name",
            "&endptr",
            "10"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\npid_t pid = require_pid(argv[i] + 18);\n\nstatic int read_pid(const char *name, pid_t *pid) {\n\tchar *endptr;\n\terrno = 0;\n\tlong int pidtmp = strtol(name, &endptr, 10);\n\tif ((errno == ERANGE && (pidtmp == LONG_MAX || pidtmp == LONG_MIN))\n\t\t|| (errno != 0 && pidtmp == 0)) {\n\t\treturn extract_pid(name,pid);\n\t}\n\t// endptr points to '\\0' char in name if the entire string is valid\n\tif (endptr == NULL || endptr[0]!='\\0') {\n\t\treturn extract_pid(name,pid);\n\t}\n\t*pid =(pid_t)pidtmp;\n\treturn 0;\n}"
  },
  {
    "function_name": "extract_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "192-206",
    "snippet": "static int extract_pid(const char *name, pid_t *pid) {\n\tint retval = 0;\n\tEUID_ASSERT();\n\tif (!name || strlen(name) == 0) {\n\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\texit(1);\n\t}\n\n\tEUID_ROOT();\n\tif (name2pid(name, pid)) {\n\t\tretval = 1;\n\t}\n\tEUID_USER();\n\treturn retval;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "pid_t pid = require_pid(argv[i] + 18);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "name2pid",
          "args": [
            "name",
            "pid"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "name2pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "63-126",
          "snippet": "int name2pid(const char *name, pid_t *pid) {\n\tpid_t parent = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir))) {\n\t\tpid_t newpid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (newpid == parent)\n\t\t\tcontinue;\n\n\t\t// check if this is a firejail executable\n\t\tchar *comm = pid_proc_comm(newpid);\n\t\tif (comm) {\n\t\t\tif (strcmp(comm, \"firejail\")) {\n\t\t\t\tfree(comm);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t}\n\n\t\t// look for the sandbox name in /run/firejail/name/<PID>\n\t\t// todo: use RUN_FIREJAIL_NAME_DIR define from src/firejail/firejail.h\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/run/firejail/name/%d\", newpid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\tif (fgets(buf, BUFLEN, fp)) {\n\t\t\t\t// remove \\n\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\t\tif (strcmp(buf, name) == 0) {\n\t\t\t\t\t\t// we found it!\n\t\t\t\t\t\tfclose(fp);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\t*pid = newpid;\n\t\t\t\t\t\tclosedir(dir);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"Error: invalid %s\\n\", fname);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tfree(fname);\n\t}\n\tclosedir(dir);\n\treturn 1;\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define BUFLEN 4096",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define BUFLEN 4096\n#define BUFLEN 4096\n\nint name2pid(const char *name, pid_t *pid) {\n\tpid_t parent = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir))) {\n\t\tpid_t newpid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (newpid == parent)\n\t\t\tcontinue;\n\n\t\t// check if this is a firejail executable\n\t\tchar *comm = pid_proc_comm(newpid);\n\t\tif (comm) {\n\t\t\tif (strcmp(comm, \"firejail\")) {\n\t\t\t\tfree(comm);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(comm);\n\t\t}\n\n\t\t// look for the sandbox name in /run/firejail/name/<PID>\n\t\t// todo: use RUN_FIREJAIL_NAME_DIR define from src/firejail/firejail.h\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/run/firejail/name/%d\", newpid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\tif (fgets(buf, BUFLEN, fp)) {\n\t\t\t\t// remove \\n\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\t\tif (strcmp(buf, name) == 0) {\n\t\t\t\t\t\t// we found it!\n\t\t\t\t\t\tfclose(fp);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\t*pid = newpid;\n\t\t\t\t\t\tclosedir(dir);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"Error: invalid %s\\n\", fname);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tfree(fname);\n\t}\n\tclosedir(dir);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid sandbox name\\n\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\npid_t pid = require_pid(argv[i] + 18);\n\nstatic int extract_pid(const char *name, pid_t *pid) {\n\tint retval = 0;\n\tEUID_ASSERT();\n\tif (!name || strlen(name) == 0) {\n\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\texit(1);\n\t}\n\n\tEUID_ROOT();\n\tif (name2pid(name, pid)) {\n\t\tretval = 1;\n\t}\n\tEUID_USER();\n\treturn retval;\n}"
  },
  {
    "function_name": "install_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "173-189",
    "snippet": "static void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// block SIGTERM while handling SIGINT\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGTERM);\n\tsga.sa_handler = my_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGINT, &sga, NULL);\n\n\t// block SIGINT while handling SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGINT);\n\tsga.sa_handler = my_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGTERM",
            "&sga",
            "NULL"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&sga.sa_mask",
            "SIGINT"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sga.sa_mask"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGINT",
            "&sga",
            "NULL"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&sga.sa_mask",
            "SIGTERM"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sga.sa_mask"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// block SIGTERM while handling SIGINT\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGTERM);\n\tsga.sa_handler = my_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGINT, &sga, NULL);\n\n\t// block SIGINT while handling SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGINT);\n\tsga.sa_handler = my_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}"
  },
  {
    "function_name": "my_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "160-171",
    "snippet": "static void my_handler(int s) {\n\tfmessage(\"\\nParent received signal %d, shutting down the child process...\\n\", s);\n\tlogsignal(s);\n\tif (waitpid(child, NULL, WNOHANG) == 0) {\n\t\tif (has_handler(child, s)) // signals are not delivered if there is no handler yet\n\t\t\tkill(child, s);\n\t\telse\n\t\t\tkill(child, SIGKILL);\n\t\twaitpid(child, NULL, 0);\n\t}\n\tmyexit(s);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pid_t child = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "myexit",
          "args": [
            "s"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "146-158",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command)\n\t\tfmessage(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tdelete_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command)\n\t\tfmessage(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tdelete_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "child",
            "SIGKILL"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "child",
            "s"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_handler",
          "args": [
            "child",
            "s"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "has_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1274-1303",
          "snippet": "int has_handler(pid_t pid, int signal) {\n\tif (signal > 0 && signal <= SIGRTMAX) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tEUID_ROOT();\n\t\tFILE *fp = fopen(fname, \"re\");\n\t\tEUID_USER();\n\t\tfree(fname);\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\twhile (fgets(buf, BUFLEN, fp)) {\n\t\t\t\tif (strncmp(buf, \"SigCgt:\", 7) == 0) {\n\t\t\t\t\tchar *ptr = buf + 7;\n\t\t\t\t\tunsigned long long val;\n\t\t\t\t\tif (sscanf(ptr, \"%llx\", &val) != 1) {\n\t\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tval >>= (signal - 1);\n\t\t\t\t\tval &= 1;\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\treturn val;  // 1 if process has a handler for the signal, else 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nint has_handler(pid_t pid, int signal) {\n\tif (signal > 0 && signal <= SIGRTMAX) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tEUID_ROOT();\n\t\tFILE *fp = fopen(fname, \"re\");\n\t\tEUID_USER();\n\t\tfree(fname);\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\twhile (fgets(buf, BUFLEN, fp)) {\n\t\t\t\tif (strncmp(buf, \"SigCgt:\", 7) == 0) {\n\t\t\t\t\tchar *ptr = buf + 7;\n\t\t\t\t\tunsigned long long val;\n\t\t\t\t\tif (sscanf(ptr, \"%llx\", &val) != 1) {\n\t\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tval >>= (signal - 1);\n\t\t\t\t\tval &= 1;\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\treturn val;  // 1 if process has a handler for the signal, else 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "WNOHANG"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logsignal",
          "args": [
            "s"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "logsignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "200-207",
          "snippet": "void logsignal(int s) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"Signal %d caught\", s);\n\tcloselog();\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logsignal(int s) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"Signal %d caught\", s);\n\tcloselog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"\\nParent received signal %d, shutting down the child process...\\n\"",
            "s"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/main.c",
          "lines": "27-36",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/firejail/util.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_quiet = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"fnet.h\"\n\nint arg_quiet = 0;\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/firejail/util.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic pid_t child = 0;\n\nstatic void my_handler(int s) {\n\tfmessage(\"\\nParent received signal %d, shutting down the child process...\\n\", s);\n\tlogsignal(s);\n\tif (waitpid(child, NULL, WNOHANG) == 0) {\n\t\tif (has_handler(child, s)) // signals are not delivered if there is no handler yet\n\t\t\tkill(child, s);\n\t\telse\n\t\t\tkill(child, SIGKILL);\n\t\twaitpid(child, NULL, 0);\n\t}\n\tmyexit(s);\n}"
  },
  {
    "function_name": "myexit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "146-158",
    "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command)\n\t\tfmessage(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tdelete_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int arg_command = 0;",
      "pid_t sandbox_pid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "rv"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_stdin",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "flush_stdin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "959-969",
          "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appimage_clear",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "appimage_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/appimage.c",
          "lines": "149-190",
          "snippet": "void appimage_clear(void) {\n\tint rv;\n\n\tEUID_ROOT();\n\tif (mntdir) {\n\t\tint i;\n\t\tint rv = 0;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\trv = umount2(mntdir, MNT_FORCE);\n\t\t\tif (rv == 0) {\n\t\t\t\tfmessage(\"AppImage unmounted\\n\");\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rv == -1 && errno == EBUSY) {\n\t\t\t\tfwarning(\"EBUSY error trying to unmount %s\\n\", mntdir);\n\t\t\t\tsleep(2);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// rv = -1\n\t\t\tif (!arg_quiet) {\n\t\t\t\tfwarning(\"error trying to unmount %s\\n\", mntdir);\n\t\t\t\tperror(\"umount\");\n\t\t\t}\n\t\t}\n\n\t\tif (rv == 0) {\n\t\t\trmdir(mntdir);\n\t\t\tfree(mntdir);\n\t\t}\n\t}\n\n\tif (devloop) {\n\t\tint lfd = open(devloop, O_RDONLY);\n\t\tif (lfd != -1) {\n\t\t\trv = ioctl(lfd, LOOP_CLR_FD, 0);\n\t\t\t(void) rv;\n\t\t\tclose(lfd);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <errno.h>",
            "#include <linux/loop.h>",
            "#include <fcntl.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *devloop = NULL;",
            "static char *mntdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <linux/loop.h>\n#include <fcntl.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic char *devloop = NULL;\nstatic char *mntdir = NULL;\n\nvoid appimage_clear(void) {\n\tint rv;\n\n\tEUID_ROOT();\n\tif (mntdir) {\n\t\tint i;\n\t\tint rv = 0;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\trv = umount2(mntdir, MNT_FORCE);\n\t\t\tif (rv == 0) {\n\t\t\t\tfmessage(\"AppImage unmounted\\n\");\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rv == -1 && errno == EBUSY) {\n\t\t\t\tfwarning(\"EBUSY error trying to unmount %s\\n\", mntdir);\n\t\t\t\tsleep(2);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// rv = -1\n\t\t\tif (!arg_quiet) {\n\t\t\t\tfwarning(\"error trying to unmount %s\\n\", mntdir);\n\t\t\t\tperror(\"umount\");\n\t\t\t}\n\t\t}\n\n\t\tif (rv == 0) {\n\t\t\trmdir(mntdir);\n\t\t\tfree(mntdir);\n\t\t}\n\t}\n\n\tif (devloop) {\n\t\tint lfd = open(devloop, O_RDONLY);\n\t\tif (lfd != -1) {\n\t\t\trv = ioctl(lfd, LOOP_CLR_FD, 0);\n\t\t\t(void) rv;\n\t\t\tclose(lfd);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_run_files",
          "args": [
            "sandbox_pid"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "delete_run_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/run_files.c",
          "lines": "70-76",
          "snippet": "void delete_run_files(pid_t pid) {\n\tdelete_bandwidth_run_file(pid);\n\tdelete_network_run_file(pid);\n\tdelete_name_run_file(pid);\n\tdelete_x11_run_file(pid);\n\tdelete_profile_run_file(pid);\n}",
          "includes": [
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nvoid delete_run_files(pid_t pid) {\n\tdelete_bandwidth_run_file(pid);\n\tdelete_network_run_file(pid);\n\tdelete_name_run_file(pid);\n\tdelete_x11_run_file(pid);\n\tdelete_profile_run_file(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"\\nParent is shutting down, bye...\\n\""
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/main.c",
          "lines": "27-36",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/firejail/util.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_quiet = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"fnet.h\"\n\nint arg_quiet = 0;\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/firejail/util.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logmsg",
          "args": [
            "\"exiting...\""
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "logmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "210-217",
          "snippet": "void logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command)\n\t\tfmessage(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tdelete_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv);\n}"
  },
  {
    "function_name": "clear_atexit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
    "lines": "141-144",
    "snippet": "static void clear_atexit(void) {\n\tEUID_ROOT();\n\tdelete_run_files(getpid());\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <net/if.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/prctl.h>",
      "#include <sys/file.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <dirent.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sched.h>",
      "#include <sys/utsname.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/pid.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delete_run_files",
          "args": [
            "getpid()"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "delete_run_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/run_files.c",
          "lines": "70-76",
          "snippet": "void delete_run_files(pid_t pid) {\n\tdelete_bandwidth_run_file(pid);\n\tdelete_network_run_file(pid);\n\tdelete_name_run_file(pid);\n\tdelete_x11_run_file(pid);\n\tdelete_profile_run_file(pid);\n}",
          "includes": [
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nvoid delete_run_files(pid_t pid) {\n\tdelete_bandwidth_run_file(pid);\n\tdelete_network_run_file(pid);\n\tdelete_name_run_file(pid);\n\tdelete_x11_run_file(pid);\n\tdelete_profile_run_file(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void clear_atexit(void) {\n\tEUID_ROOT();\n\tdelete_run_files(getpid());\n}"
  }
]