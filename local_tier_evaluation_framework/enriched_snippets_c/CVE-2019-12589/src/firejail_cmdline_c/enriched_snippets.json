[
  {
    "function_name": "build_appimage_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cmdline.c",
    "lines": "164-212",
    "snippet": "void build_appimage_cmdline(char **command_line, char **window_title, int argc, char **argv, int index, char *apprun_path) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tif (arg_debug)\n\t\tprintf(\"Building AppImage command line: %s\\n\", *command_line);\n\n\n\tint len1 = cmdline_length(argc, argv, index);  // length of argv w/o changes\n\tint len2 = cmdline_length(1, &argv[index], 0); // apptest.AppImage\n\tint len3 = cmdline_length(1, &apprun_path, 0); // /run/firejail/appimage/.appimage-23304/AppRun\n\tint len4 = (len1 - len2 + len3) + 1;           // apptest.AppImage is replaced by /path/to/AppRun\n\n\tif (len4 > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t// save created apprun in cfg.command_line\n\tchar *tmp1 = strdup(*command_line);\n\tif (!tmp1)\n\t\terrExit(\"strdup\");\n\n\t// TODO: deal with extra allocated memory.\n\tchar *command_line_tmp = malloc(len1 + len3 + 1);\n\tif (!command_line_tmp)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len1 + len3 + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\n\t// run default quote_cmdline\n\tquote_cmdline(command_line_tmp, *window_title, len1, argc, argv, index);\n\n\tassert(command_line_tmp);\n\tassert(*window_title);\n\n\t// 'fix' command_line now\n\tif (asprintf(command_line, \"'%s' %s\", tmp1, command_line_tmp + len2) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (arg_debug)\n\t\tprintf(\"AppImage quoted command line: %s\\n\", *command_line);\n\n\t// free strdup\n\tfree(tmp1);\n\tfree(command_line_tmp);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <assert.h>",
      "#include <linux/limits.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <string.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "command_line_tmp"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp1"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"AppImage quoted command line: %s\\n\"",
            "*command_line"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "command_line",
            "\"'%s' %s\"",
            "tmp1",
            "command_line_tmp + len2"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "*window_title"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "command_line_tmp"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quote_cmdline",
          "args": [
            "command_line_tmp",
            "*window_title",
            "len1",
            "argc",
            "argv",
            "index"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "quote_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cmdline.c",
          "lines": "67-135",
          "snippet": "static void quote_cmdline(char *command_line, char *window_title, int len, int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\tchar *ptr1 = command_line;\n\tchar *ptr2 = window_title;\n\n\tfor (i = 0; i < argcnt; i++) {\n\n\t\t// enclose args by single quotes,\n\t\t// and since single quote can't be represented in single quoted text\n\t\t// each occurrence of it should be enclosed by double quotes\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\t// single quote\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes) {\n\t\t\t\t\t// close quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\t// previous char was single quote too\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'') {\n\t\t\t\t\tptr1--;\n\t\t\t\t\tsprintf(ptr1, \"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\t// this first in series\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(ptr1, \"\\\"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\tptr1 += strlen(ptr1);\n\t\t\t\tin_quotes = false;\n\t\t\t}\n\t\t\t// anything other\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!in_quotes) {\n\t\t\t\t\t// open quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\tptr1[0] = argv[i + index][j];\n\t\t\t\tptr1++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\t// close quotes\n\t\tif (in_quotes) {\n\t\t\tptr1[0] = '\\'';\n\t\t\tptr1++;\n\t\t}\n\t\t// handle empty argument case\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tsprintf(ptr1, \"\\'\\'\");\n\t\t\tptr1 += strlen(ptr1);\n\t\t}\n\t\t// add space\n\t\tsprintf(ptr1, \" \");\n\t\tptr1 += strlen(ptr1);\n\n\t\tsprintf(ptr2, \"%s \", argv[i + index]);\n\t\tptr2 += strlen(ptr2);\n\t}\n\n\tassert((unsigned) len == strlen(command_line));\n}",
          "includes": [
            "#include <errno.h>",
            "#include <assert.h>",
            "#include <linux/limits.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <string.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nstatic void quote_cmdline(char *command_line, char *window_title, int len, int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\tchar *ptr1 = command_line;\n\tchar *ptr2 = window_title;\n\n\tfor (i = 0; i < argcnt; i++) {\n\n\t\t// enclose args by single quotes,\n\t\t// and since single quote can't be represented in single quoted text\n\t\t// each occurrence of it should be enclosed by double quotes\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\t// single quote\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes) {\n\t\t\t\t\t// close quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\t// previous char was single quote too\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'') {\n\t\t\t\t\tptr1--;\n\t\t\t\t\tsprintf(ptr1, \"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\t// this first in series\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(ptr1, \"\\\"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\tptr1 += strlen(ptr1);\n\t\t\t\tin_quotes = false;\n\t\t\t}\n\t\t\t// anything other\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!in_quotes) {\n\t\t\t\t\t// open quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\tptr1[0] = argv[i + index][j];\n\t\t\t\tptr1++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\t// close quotes\n\t\tif (in_quotes) {\n\t\t\tptr1[0] = '\\'';\n\t\t\tptr1++;\n\t\t}\n\t\t// handle empty argument case\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tsprintf(ptr1, \"\\'\\'\");\n\t\t\tptr1 += strlen(ptr1);\n\t\t}\n\t\t// add space\n\t\tsprintf(ptr1, \" \");\n\t\tptr1 += strlen(ptr1);\n\n\t\tsprintf(ptr2, \"%s \", argv[i + index]);\n\t\tptr2 += strlen(ptr2);\n\t}\n\n\tassert((unsigned) len == strlen(command_line));\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len1 + len3 + 1"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len1 + len3 + 1"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "*command_line"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"cmdline_length\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmdline_length",
          "args": [
            "1",
            "&apprun_path",
            "0"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "cmdline_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cmdline.c",
          "lines": "29-65",
          "snippet": "static int cmdline_length(int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tint len = 0;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\n\tfor (i = 0; i < argcnt; i++) {\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'')\n\t\t\t\t\tlen++;\n\t\t\t\telse\n\t\t\t\t\tlen += 3;\n\t\t\t\tin_quotes = false;\n\t\t\t} else {\n\t\t\t\tif (!in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tlen++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\tif (in_quotes) {\n\t\t\tlen++;\n\t\t}\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tlen += 2;\n\t\t}\n\t\tlen++;\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <assert.h>",
            "#include <linux/limits.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <string.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nstatic int cmdline_length(int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tint len = 0;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\n\tfor (i = 0; i < argcnt; i++) {\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'')\n\t\t\t\t\tlen++;\n\t\t\t\telse\n\t\t\t\t\tlen += 3;\n\t\t\t\tin_quotes = false;\n\t\t\t} else {\n\t\t\t\tif (!in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tlen++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\tif (in_quotes) {\n\t\t\tlen++;\n\t\t}\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tlen += 2;\n\t\t}\n\t\tlen++;\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Building AppImage command line: %s\\n\"",
            "*command_line"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index != -1"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nvoid build_appimage_cmdline(char **command_line, char **window_title, int argc, char **argv, int index, char *apprun_path) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tif (arg_debug)\n\t\tprintf(\"Building AppImage command line: %s\\n\", *command_line);\n\n\n\tint len1 = cmdline_length(argc, argv, index);  // length of argv w/o changes\n\tint len2 = cmdline_length(1, &argv[index], 0); // apptest.AppImage\n\tint len3 = cmdline_length(1, &apprun_path, 0); // /run/firejail/appimage/.appimage-23304/AppRun\n\tint len4 = (len1 - len2 + len3) + 1;           // apptest.AppImage is replaced by /path/to/AppRun\n\n\tif (len4 > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t// save created apprun in cfg.command_line\n\tchar *tmp1 = strdup(*command_line);\n\tif (!tmp1)\n\t\terrExit(\"strdup\");\n\n\t// TODO: deal with extra allocated memory.\n\tchar *command_line_tmp = malloc(len1 + len3 + 1);\n\tif (!command_line_tmp)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len1 + len3 + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\n\t// run default quote_cmdline\n\tquote_cmdline(command_line_tmp, *window_title, len1, argc, argv, index);\n\n\tassert(command_line_tmp);\n\tassert(*window_title);\n\n\t// 'fix' command_line now\n\tif (asprintf(command_line, \"'%s' %s\", tmp1, command_line_tmp + len2) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (arg_debug)\n\t\tprintf(\"AppImage quoted command line: %s\\n\", *command_line);\n\n\t// free strdup\n\tfree(tmp1);\n\tfree(command_line_tmp);\n}"
  },
  {
    "function_name": "build_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cmdline.c",
    "lines": "137-162",
    "snippet": "void build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tif (arg_debug)\n\t\tprintf(\"Building quoted command line: %s\\n\", *command_line);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <assert.h>",
      "#include <linux/limits.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <string.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "*window_title"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "*command_line"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Building quoted command line: %s\\n\"",
            "*command_line"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quote_cmdline",
          "args": [
            "*command_line",
            "*window_title",
            "len",
            "argc",
            "argv",
            "index"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "quote_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cmdline.c",
          "lines": "67-135",
          "snippet": "static void quote_cmdline(char *command_line, char *window_title, int len, int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\tchar *ptr1 = command_line;\n\tchar *ptr2 = window_title;\n\n\tfor (i = 0; i < argcnt; i++) {\n\n\t\t// enclose args by single quotes,\n\t\t// and since single quote can't be represented in single quoted text\n\t\t// each occurrence of it should be enclosed by double quotes\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\t// single quote\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes) {\n\t\t\t\t\t// close quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\t// previous char was single quote too\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'') {\n\t\t\t\t\tptr1--;\n\t\t\t\t\tsprintf(ptr1, \"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\t// this first in series\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(ptr1, \"\\\"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\tptr1 += strlen(ptr1);\n\t\t\t\tin_quotes = false;\n\t\t\t}\n\t\t\t// anything other\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!in_quotes) {\n\t\t\t\t\t// open quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\tptr1[0] = argv[i + index][j];\n\t\t\t\tptr1++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\t// close quotes\n\t\tif (in_quotes) {\n\t\t\tptr1[0] = '\\'';\n\t\t\tptr1++;\n\t\t}\n\t\t// handle empty argument case\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tsprintf(ptr1, \"\\'\\'\");\n\t\t\tptr1 += strlen(ptr1);\n\t\t}\n\t\t// add space\n\t\tsprintf(ptr1, \" \");\n\t\tptr1 += strlen(ptr1);\n\n\t\tsprintf(ptr2, \"%s \", argv[i + index]);\n\t\tptr2 += strlen(ptr2);\n\t}\n\n\tassert((unsigned) len == strlen(command_line));\n}",
          "includes": [
            "#include <errno.h>",
            "#include <assert.h>",
            "#include <linux/limits.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <string.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nstatic void quote_cmdline(char *command_line, char *window_title, int len, int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\tchar *ptr1 = command_line;\n\tchar *ptr2 = window_title;\n\n\tfor (i = 0; i < argcnt; i++) {\n\n\t\t// enclose args by single quotes,\n\t\t// and since single quote can't be represented in single quoted text\n\t\t// each occurrence of it should be enclosed by double quotes\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\t// single quote\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes) {\n\t\t\t\t\t// close quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\t// previous char was single quote too\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'') {\n\t\t\t\t\tptr1--;\n\t\t\t\t\tsprintf(ptr1, \"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\t// this first in series\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(ptr1, \"\\\"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\tptr1 += strlen(ptr1);\n\t\t\t\tin_quotes = false;\n\t\t\t}\n\t\t\t// anything other\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!in_quotes) {\n\t\t\t\t\t// open quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\tptr1[0] = argv[i + index][j];\n\t\t\t\tptr1++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\t// close quotes\n\t\tif (in_quotes) {\n\t\t\tptr1[0] = '\\'';\n\t\t\tptr1++;\n\t\t}\n\t\t// handle empty argument case\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tsprintf(ptr1, \"\\'\\'\");\n\t\t\tptr1 += strlen(ptr1);\n\t\t}\n\t\t// add space\n\t\tsprintf(ptr1, \" \");\n\t\tptr1 += strlen(ptr1);\n\n\t\tsprintf(ptr2, \"%s \", argv[i + index]);\n\t\tptr2 += strlen(ptr2);\n\t}\n\n\tassert((unsigned) len == strlen(command_line));\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len + 1"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len + 1"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"cmdline_length\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmdline_length",
          "args": [
            "argc",
            "argv",
            "index"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "cmdline_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cmdline.c",
          "lines": "29-65",
          "snippet": "static int cmdline_length(int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tint len = 0;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\n\tfor (i = 0; i < argcnt; i++) {\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'')\n\t\t\t\t\tlen++;\n\t\t\t\telse\n\t\t\t\t\tlen += 3;\n\t\t\t\tin_quotes = false;\n\t\t\t} else {\n\t\t\t\tif (!in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tlen++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\tif (in_quotes) {\n\t\t\tlen++;\n\t\t}\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tlen += 2;\n\t\t}\n\t\tlen++;\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <assert.h>",
            "#include <linux/limits.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <string.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nstatic int cmdline_length(int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tint len = 0;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\n\tfor (i = 0; i < argcnt; i++) {\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'')\n\t\t\t\t\tlen++;\n\t\t\t\telse\n\t\t\t\t\tlen += 3;\n\t\t\t\tin_quotes = false;\n\t\t\t} else {\n\t\t\t\tif (!in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tlen++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\tif (in_quotes) {\n\t\t\tlen++;\n\t\t}\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tlen += 2;\n\t\t}\n\t\tlen++;\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index != -1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nvoid build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tif (arg_debug)\n\t\tprintf(\"Building quoted command line: %s\\n\", *command_line);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}"
  },
  {
    "function_name": "quote_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cmdline.c",
    "lines": "67-135",
    "snippet": "static void quote_cmdline(char *command_line, char *window_title, int len, int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\tchar *ptr1 = command_line;\n\tchar *ptr2 = window_title;\n\n\tfor (i = 0; i < argcnt; i++) {\n\n\t\t// enclose args by single quotes,\n\t\t// and since single quote can't be represented in single quoted text\n\t\t// each occurrence of it should be enclosed by double quotes\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\t// single quote\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes) {\n\t\t\t\t\t// close quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\t// previous char was single quote too\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'') {\n\t\t\t\t\tptr1--;\n\t\t\t\t\tsprintf(ptr1, \"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\t// this first in series\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(ptr1, \"\\\"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\tptr1 += strlen(ptr1);\n\t\t\t\tin_quotes = false;\n\t\t\t}\n\t\t\t// anything other\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!in_quotes) {\n\t\t\t\t\t// open quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\tptr1[0] = argv[i + index][j];\n\t\t\t\tptr1++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\t// close quotes\n\t\tif (in_quotes) {\n\t\t\tptr1[0] = '\\'';\n\t\t\tptr1++;\n\t\t}\n\t\t// handle empty argument case\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tsprintf(ptr1, \"\\'\\'\");\n\t\t\tptr1 += strlen(ptr1);\n\t\t}\n\t\t// add space\n\t\tsprintf(ptr1, \" \");\n\t\tptr1 += strlen(ptr1);\n\n\t\tsprintf(ptr2, \"%s \", argv[i + index]);\n\t\tptr2 += strlen(ptr2);\n\t}\n\n\tassert((unsigned) len == strlen(command_line));\n}",
    "includes": [
      "#include <errno.h>",
      "#include <assert.h>",
      "#include <linux/limits.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <string.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(unsigned) len == strlen(command_line)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "command_line"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr2",
            "\"%s \"",
            "argv[i + index]"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr1",
            "\" \""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr1",
            "\"\\'\\'\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr1",
            "\"\\\"\\'\\\"\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr1",
            "\"\\'\\\"\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index != -1"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nstatic void quote_cmdline(char *command_line, char *window_title, int len, int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\tchar *ptr1 = command_line;\n\tchar *ptr2 = window_title;\n\n\tfor (i = 0; i < argcnt; i++) {\n\n\t\t// enclose args by single quotes,\n\t\t// and since single quote can't be represented in single quoted text\n\t\t// each occurrence of it should be enclosed by double quotes\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\t// single quote\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes) {\n\t\t\t\t\t// close quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\t// previous char was single quote too\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'') {\n\t\t\t\t\tptr1--;\n\t\t\t\t\tsprintf(ptr1, \"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\t// this first in series\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(ptr1, \"\\\"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\tptr1 += strlen(ptr1);\n\t\t\t\tin_quotes = false;\n\t\t\t}\n\t\t\t// anything other\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!in_quotes) {\n\t\t\t\t\t// open quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\tptr1[0] = argv[i + index][j];\n\t\t\t\tptr1++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\t// close quotes\n\t\tif (in_quotes) {\n\t\t\tptr1[0] = '\\'';\n\t\t\tptr1++;\n\t\t}\n\t\t// handle empty argument case\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tsprintf(ptr1, \"\\'\\'\");\n\t\t\tptr1 += strlen(ptr1);\n\t\t}\n\t\t// add space\n\t\tsprintf(ptr1, \" \");\n\t\tptr1 += strlen(ptr1);\n\n\t\tsprintf(ptr2, \"%s \", argv[i + index]);\n\t\tptr2 += strlen(ptr2);\n\t}\n\n\tassert((unsigned) len == strlen(command_line));\n}"
  },
  {
    "function_name": "cmdline_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cmdline.c",
    "lines": "29-65",
    "snippet": "static int cmdline_length(int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tint len = 0;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\n\tfor (i = 0; i < argcnt; i++) {\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'')\n\t\t\t\t\tlen++;\n\t\t\t\telse\n\t\t\t\t\tlen += 3;\n\t\t\t\tin_quotes = false;\n\t\t\t} else {\n\t\t\t\tif (!in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tlen++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\tif (in_quotes) {\n\t\t\tlen++;\n\t\t}\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tlen += 2;\n\t\t}\n\t\tlen++;\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <assert.h>",
      "#include <linux/limits.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <string.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i + index]"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index != -1"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nstatic int cmdline_length(int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tint len = 0;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\n\tfor (i = 0; i < argcnt; i++) {\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'')\n\t\t\t\t\tlen++;\n\t\t\t\telse\n\t\t\t\t\tlen += 3;\n\t\t\t\tin_quotes = false;\n\t\t\t} else {\n\t\t\t\tif (!in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tlen++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\tif (in_quotes) {\n\t\t\tlen++;\n\t\t}\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tlen += 2;\n\t\t}\n\t\tlen++;\n\t}\n\n\treturn len;\n}"
  }
]