[
  {
    "function_name": "dbus_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/dbus.c",
    "lines": "49-92",
    "snippet": "void dbus_test(void) {\n\t// check the session bus\n\tchar *str = getenv(\"DBUS_SESSION_BUS_ADDRESS\");\n\tif (str) {\n\t\tint rv = 0;\n\t\tchar *bus = strdup(str);\n\t\tif (!bus)\n\t\t\terrExit(\"strdup\");\n\t\tchar *sockfile;\n\t\tif ((sockfile = strstr(bus, \"unix:abstract=\")) != NULL) {\n\t\t\tsockfile += 13;\n\t\t\t*sockfile = '@';\n\t\t\tchar *ptr = strchr(sockfile, ',');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\trv = check_unix(sockfile);\n\t\t\t*sockfile = '@';\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"MAYBE: D-Bus socket %s is available\\n\", sockfile);\n\t\t\telse if (rv == -1)\n\t\t\t\tprintf(\"GOOD: cannot connect to D-Bus socket %s\\n\", sockfile);\n\t\t}\n\t\telse if ((sockfile = strstr(bus, \"unix:path=\")) != NULL) {\n\t\t\tsockfile += 10;\n\t\t\tchar *ptr = strchr(sockfile, ',');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\trv = check_unix(sockfile);\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"MAYBE: D-Bus socket %s is available\\n\", sockfile);\n\t\t\telse if (rv == -1)\n\t\t\t\tprintf(\"GOOD: cannot connect to D-Bus socket %s\\n\", sockfile);\n\t\t}\n\t\telse if ((sockfile = strstr(bus, \"tcp:host=\")) != NULL)\n\t\t\tprintf(\"UGLY: session bus configured for TCP communication.\\n\");\n\t\telse\n\t\t\tprintf(\"GOOD: cannot find a D-Bus socket\\n\");\n\n\n\t\tfree(bus);\n\t}\n\telse\n\t\tprintf(\"GOOD: DBUS_SESSION_BUS_ADDRESS environment variable not configured.\");\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include \"faudit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"GOOD: DBUS_SESSION_BUS_ADDRESS environment variable not configured.\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "bus"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"GOOD: cannot find a D-Bus socket\\n\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"UGLY: session bus configured for TCP communication.\\n\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "bus",
            "\"tcp:host=\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"GOOD: cannot connect to D-Bus socket %s\\n\"",
            "sockfile"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"MAYBE: D-Bus socket %s is available\\n\"",
            "sockfile"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_unix",
          "args": [
            "sockfile"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "check_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/dbus.c",
          "lines": "25-47",
          "snippet": "int check_unix(const char *sockfile) {\n\tassert(sockfile);\n\tint rv = -1;\n\n\t// open socket\n\tint sock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1)\n\t\treturn rv;\n\n\t// connect\n\tstruct sockaddr_un remote;\n\tmemset(&remote, 0, sizeof(struct sockaddr_un));\n\tremote.sun_family = AF_UNIX;\n\tstrncpy(remote.sun_path, sockfile, sizeof(remote.sun_path));\n\tint len = strlen(remote.sun_path) + sizeof(remote.sun_family);\n\tif (*sockfile == '@')\n\t\tremote.sun_path[0] = '\\0';\n\tif (connect(sock, (struct sockaddr *)&remote, len) == 0)\n\t\trv = 0;\n\n\tclose(sock);\n\treturn rv;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include \"faudit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include <sys/socket.h>\n#include \"faudit.h\"\n\nint check_unix(const char *sockfile) {\n\tassert(sockfile);\n\tint rv = -1;\n\n\t// open socket\n\tint sock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1)\n\t\treturn rv;\n\n\t// connect\n\tstruct sockaddr_un remote;\n\tmemset(&remote, 0, sizeof(struct sockaddr_un));\n\tremote.sun_family = AF_UNIX;\n\tstrncpy(remote.sun_path, sockfile, sizeof(remote.sun_path));\n\tint len = strlen(remote.sun_path) + sizeof(remote.sun_family);\n\tif (*sockfile == '@')\n\t\tremote.sun_path[0] = '\\0';\n\tif (connect(sock, (struct sockaddr *)&remote, len) == 0)\n\t\trv = 0;\n\n\tclose(sock);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "sockfile",
            "','"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "bus",
            "\"unix:path=\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"GOOD: cannot connect to D-Bus socket %s\\n\"",
            "sockfile"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"MAYBE: D-Bus socket %s is available\\n\"",
            "sockfile"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "sockfile",
            "','"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "bus",
            "\"unix:abstract=\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DBUS_SESSION_BUS_ADDRESS\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include <sys/socket.h>\n#include \"faudit.h\"\n\nvoid dbus_test(void) {\n\t// check the session bus\n\tchar *str = getenv(\"DBUS_SESSION_BUS_ADDRESS\");\n\tif (str) {\n\t\tint rv = 0;\n\t\tchar *bus = strdup(str);\n\t\tif (!bus)\n\t\t\terrExit(\"strdup\");\n\t\tchar *sockfile;\n\t\tif ((sockfile = strstr(bus, \"unix:abstract=\")) != NULL) {\n\t\t\tsockfile += 13;\n\t\t\t*sockfile = '@';\n\t\t\tchar *ptr = strchr(sockfile, ',');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\trv = check_unix(sockfile);\n\t\t\t*sockfile = '@';\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"MAYBE: D-Bus socket %s is available\\n\", sockfile);\n\t\t\telse if (rv == -1)\n\t\t\t\tprintf(\"GOOD: cannot connect to D-Bus socket %s\\n\", sockfile);\n\t\t}\n\t\telse if ((sockfile = strstr(bus, \"unix:path=\")) != NULL) {\n\t\t\tsockfile += 10;\n\t\t\tchar *ptr = strchr(sockfile, ',');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\trv = check_unix(sockfile);\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"MAYBE: D-Bus socket %s is available\\n\", sockfile);\n\t\t\telse if (rv == -1)\n\t\t\t\tprintf(\"GOOD: cannot connect to D-Bus socket %s\\n\", sockfile);\n\t\t}\n\t\telse if ((sockfile = strstr(bus, \"tcp:host=\")) != NULL)\n\t\t\tprintf(\"UGLY: session bus configured for TCP communication.\\n\");\n\t\telse\n\t\t\tprintf(\"GOOD: cannot find a D-Bus socket\\n\");\n\n\n\t\tfree(bus);\n\t}\n\telse\n\t\tprintf(\"GOOD: DBUS_SESSION_BUS_ADDRESS environment variable not configured.\");\n}"
  },
  {
    "function_name": "check_unix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/dbus.c",
    "lines": "25-47",
    "snippet": "int check_unix(const char *sockfile) {\n\tassert(sockfile);\n\tint rv = -1;\n\n\t// open socket\n\tint sock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1)\n\t\treturn rv;\n\n\t// connect\n\tstruct sockaddr_un remote;\n\tmemset(&remote, 0, sizeof(struct sockaddr_un));\n\tremote.sun_family = AF_UNIX;\n\tstrncpy(remote.sun_path, sockfile, sizeof(remote.sun_path));\n\tint len = strlen(remote.sun_path) + sizeof(remote.sun_family);\n\tif (*sockfile == '@')\n\t\tremote.sun_path[0] = '\\0';\n\tif (connect(sock, (struct sockaddr *)&remote, len) == 0)\n\t\trv = 0;\n\n\tclose(sock);\n\treturn rv;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include \"faudit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sock",
            "(struct sockaddr *)&remote",
            "len"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "491-499",
          "snippet": "int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {\n\tif (!orig_connect)\n\t\torig_connect = (orig_connect_t)dlsym(RTLD_NEXT, \"connect\");\n\n \tint rv = orig_connect(sockfd, addr, addrlen);\n\tprint_sockaddr(sockfd, \"connect\", addr, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_connect_t orig_connect = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_connect_t orig_connect = NULL;\n\nint connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {\n\tif (!orig_connect)\n\t\torig_connect = (orig_connect_t)dlsym(RTLD_NEXT, \"connect\");\n\n \tint rv = orig_connect(sockfd, addr, addrlen);\n\tprint_sockaddr(sockfd, \"connect\", addr, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "remote.sun_path"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "remote.sun_path",
            "sockfile",
            "sizeof(remote.sun_path)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&remote",
            "0",
            "sizeof(struct sockaddr_un)"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "sockfile"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include <sys/socket.h>\n#include \"faudit.h\"\n\nint check_unix(const char *sockfile) {\n\tassert(sockfile);\n\tint rv = -1;\n\n\t// open socket\n\tint sock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1)\n\t\treturn rv;\n\n\t// connect\n\tstruct sockaddr_un remote;\n\tmemset(&remote, 0, sizeof(struct sockaddr_un));\n\tremote.sun_family = AF_UNIX;\n\tstrncpy(remote.sun_path, sockfile, sizeof(remote.sun_path));\n\tint len = strlen(remote.sun_path) + sizeof(remote.sun_family);\n\tif (*sockfile == '@')\n\t\tremote.sun_path[0] = '\\0';\n\tif (connect(sock, (struct sockaddr *)&remote, len) == 0)\n\t\trv = 0;\n\n\tclose(sock);\n\treturn rv;\n}"
  }
]