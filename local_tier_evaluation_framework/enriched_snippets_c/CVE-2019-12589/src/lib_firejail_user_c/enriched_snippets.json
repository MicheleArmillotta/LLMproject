[
  {
    "function_name": "firejail_user_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/firejail_user.c",
    "lines": "155-189",
    "snippet": "void firejail_user_add(const char *name) {\n\tassert(name);\n\n\t// is this a real user?\n\tstruct passwd *pw = getpwnam(name);\n\tif (!pw) {\n\t\tfprintf(stderr, \"Error: user %s not found on this system.\\n\", name);\n\t\texit(1);\n\t}\n\n\t// check the user is not already in the database\n\tchar *fname = get_fname();\n\tassert(fname);\n\tif (access(fname, F_OK) == 0) {\n\t\tif (firejail_user_check(name)) {\n\t\t\tprintf(\"User %s already in the database\\n\", name);\n\t\t\tfree(fname);\n\t\t\treturn;\n\t\t}\n\t}\n\telse\n\t\tprintf(\"Creating %s\\n\", fname);\n\n\tFILE *fp = fopen(fname, \"a+\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fname);\n\t\tperror(\"fopen\");\n\t\tfree(fname);\n\t\treturn;\n\t}\n\tfree(fname);\n\n\tfprintf(fp, \"%s\\n\", name);\n\tfclose(fp);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"%s\\n\"",
            "name"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fopen\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open %s\\n\"",
            "fname"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"a+\""
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Creating %s\\n\"",
            "fname"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"User %s already in the database\\n\"",
            "name"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firejail_user_check",
          "args": [
            "name"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "firejail_user_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/firejail_user.c",
          "lines": "103-152",
          "snippet": "int firejail_user_check(const char *name) {\n\tassert(name);\n\tinit_uid_gid_min();\n\n\t// root is allowed to run firejail by default\n\tif (strcmp(name, \"root\") == 0)\n\t\treturn 1;\n\n\t// user nobody is never allowed\n\tif (strcmp(name, \"nobody\") == 0)\n\t\treturn 0;\n\n\t// check file existence\n\tchar *fname = get_fname();\n\tassert(fname);\n\tif (access(fname, F_OK) == -1 && errno == ENOENT) {\n\t\t// assume the user doesn't care about access checking\n\t\tfree(fname);\n\t\treturn 1;\n\t}\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fname);\n\t\tperror(\"fopen\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// lines starting with # are comments\n\t\tif (*buf == '#')\n\t\t\tcontinue;\n\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// compare\n\t\tif (strcmp(buf, name) == 0) {\n\t\t\tfclose(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 0;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/common.h\"\n\n#define MAXBUF 4098\n\nint firejail_user_check(const char *name) {\n\tassert(name);\n\tinit_uid_gid_min();\n\n\t// root is allowed to run firejail by default\n\tif (strcmp(name, \"root\") == 0)\n\t\treturn 1;\n\n\t// user nobody is never allowed\n\tif (strcmp(name, \"nobody\") == 0)\n\t\treturn 0;\n\n\t// check file existence\n\tchar *fname = get_fname();\n\tassert(fname);\n\tif (access(fname, F_OK) == -1 && errno == ENOENT) {\n\t\t// assume the user doesn't care about access checking\n\t\tfree(fname);\n\t\treturn 1;\n\t}\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fname);\n\t\tperror(\"fopen\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// lines starting with # are comments\n\t\tif (*buf == '#')\n\t\t\tcontinue;\n\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// compare\n\t\tif (strcmp(buf, name) == 0) {\n\t\t\tfclose(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "fname",
            "F_OK"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "478-485",
          "snippet": "int access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_access_t orig_access = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_access_t orig_access = NULL;\n\nint access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fname",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "get_fname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/firejail_user.c",
          "lines": "94-99",
          "snippet": "static inline char *get_fname(void) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/firejail.users\", SYSCONFDIR) == -1)\n\t\terrExit(\"asprintf\");\n\treturn fname;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/common.h\"\n\nstatic inline char *get_fname(void) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/firejail.users\", SYSCONFDIR) == -1)\n\t\terrExit(\"asprintf\");\n\treturn fname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: user %s not found on this system.\\n\"",
            "name"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "name"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/common.h\"\n\nvoid firejail_user_add(const char *name) {\n\tassert(name);\n\n\t// is this a real user?\n\tstruct passwd *pw = getpwnam(name);\n\tif (!pw) {\n\t\tfprintf(stderr, \"Error: user %s not found on this system.\\n\", name);\n\t\texit(1);\n\t}\n\n\t// check the user is not already in the database\n\tchar *fname = get_fname();\n\tassert(fname);\n\tif (access(fname, F_OK) == 0) {\n\t\tif (firejail_user_check(name)) {\n\t\t\tprintf(\"User %s already in the database\\n\", name);\n\t\t\tfree(fname);\n\t\t\treturn;\n\t\t}\n\t}\n\telse\n\t\tprintf(\"Creating %s\\n\", fname);\n\n\tFILE *fp = fopen(fname, \"a+\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fname);\n\t\tperror(\"fopen\");\n\t\tfree(fname);\n\t\treturn;\n\t}\n\tfree(fname);\n\n\tfprintf(fp, \"%s\\n\", name);\n\tfclose(fp);\n}"
  },
  {
    "function_name": "firejail_user_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/firejail_user.c",
    "lines": "103-152",
    "snippet": "int firejail_user_check(const char *name) {\n\tassert(name);\n\tinit_uid_gid_min();\n\n\t// root is allowed to run firejail by default\n\tif (strcmp(name, \"root\") == 0)\n\t\treturn 1;\n\n\t// user nobody is never allowed\n\tif (strcmp(name, \"nobody\") == 0)\n\t\treturn 0;\n\n\t// check file existence\n\tchar *fname = get_fname();\n\tassert(fname);\n\tif (access(fname, F_OK) == -1 && errno == ENOENT) {\n\t\t// assume the user doesn't care about access checking\n\t\tfree(fname);\n\t\treturn 1;\n\t}\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fname);\n\t\tperror(\"fopen\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// lines starting with # are comments\n\t\tif (*buf == '#')\n\t\t\tcontinue;\n\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// compare\n\t\tif (strcmp(buf, name) == 0) {\n\t\t\tfclose(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 0;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [
      "#define MAXBUF 4098"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "name"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fp"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fopen\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot read %s\\n\"",
            "fname"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "fname",
            "F_OK"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "478-485",
          "snippet": "int access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_access_t orig_access = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_access_t orig_access = NULL;\n\nint access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fname",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "get_fname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/firejail_user.c",
          "lines": "94-99",
          "snippet": "static inline char *get_fname(void) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/firejail.users\", SYSCONFDIR) == -1)\n\t\terrExit(\"asprintf\");\n\treturn fname;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/common.h\"\n\nstatic inline char *get_fname(void) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/firejail.users\", SYSCONFDIR) == -1)\n\t\terrExit(\"asprintf\");\n\treturn fname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"nobody\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"root\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_uid_gid_min",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "init_uid_gid_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/firejail_user.c",
          "lines": "40-90",
          "snippet": "static void init_uid_gid_min(void) {\n\tif (uid_min != 0 && gid_min != 0)\n\t\treturn;\n\n\t// read the real values from login.def\n\tFILE *fp = fopen(\"/etc/login.defs\", \"r\");\n\tif (!fp)\n\t\tgoto errexit;\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// comments\n\t\tif (*buf == '#')\n\t\t\tcontinue;\n\t\t// skip empty space\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\n\t\tif (strncmp(ptr, \"UID_MIN\", 7) == 0) {\n\t\t\tint rv = sscanf(ptr + 7, \"%d\", &uid_min);\n\t\t\tif (rv != 1 || uid_min < 0) {\n\t\t\t\tfclose(fp);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(ptr, \"GID_MIN\", 7) == 0) {\n\t\t\tint rv = sscanf(ptr + 7, \"%d\", &gid_min);\n\t\t\tif (rv != 1 || gid_min < 0) {\n\t\t\t\tfclose(fp);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\n\t\tif (uid_min != 0 && gid_min != 0)\n\t\t\tbreak;\n\n\t}\n\tfclose(fp);\n\n\tif (uid_min == 0 || gid_min == 0)\n\t\tgoto errexit;\n//printf(\"uid_min %d, gid_min %d\\n\", uid_min, gid_min);\n\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot read UID_MIN and/or GID_MIN from /etc/login.defs, using 1000 by default\\n\");\n\tuid_min = 1000;\n\tgid_min = 1000;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [
            "int uid_min = 0;",
            "int gid_min = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/common.h\"\n\n#define MAXBUF 4098\n\nint uid_min = 0;\nint gid_min = 0;\n\nstatic void init_uid_gid_min(void) {\n\tif (uid_min != 0 && gid_min != 0)\n\t\treturn;\n\n\t// read the real values from login.def\n\tFILE *fp = fopen(\"/etc/login.defs\", \"r\");\n\tif (!fp)\n\t\tgoto errexit;\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// comments\n\t\tif (*buf == '#')\n\t\t\tcontinue;\n\t\t// skip empty space\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\n\t\tif (strncmp(ptr, \"UID_MIN\", 7) == 0) {\n\t\t\tint rv = sscanf(ptr + 7, \"%d\", &uid_min);\n\t\t\tif (rv != 1 || uid_min < 0) {\n\t\t\t\tfclose(fp);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(ptr, \"GID_MIN\", 7) == 0) {\n\t\t\tint rv = sscanf(ptr + 7, \"%d\", &gid_min);\n\t\t\tif (rv != 1 || gid_min < 0) {\n\t\t\t\tfclose(fp);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\n\t\tif (uid_min != 0 && gid_min != 0)\n\t\t\tbreak;\n\n\t}\n\tfclose(fp);\n\n\tif (uid_min == 0 || gid_min == 0)\n\t\tgoto errexit;\n//printf(\"uid_min %d, gid_min %d\\n\", uid_min, gid_min);\n\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot read UID_MIN and/or GID_MIN from /etc/login.defs, using 1000 by default\\n\");\n\tuid_min = 1000;\n\tgid_min = 1000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/common.h\"\n\n#define MAXBUF 4098\n\nint firejail_user_check(const char *name) {\n\tassert(name);\n\tinit_uid_gid_min();\n\n\t// root is allowed to run firejail by default\n\tif (strcmp(name, \"root\") == 0)\n\t\treturn 1;\n\n\t// user nobody is never allowed\n\tif (strcmp(name, \"nobody\") == 0)\n\t\treturn 0;\n\n\t// check file existence\n\tchar *fname = get_fname();\n\tassert(fname);\n\tif (access(fname, F_OK) == -1 && errno == ENOENT) {\n\t\t// assume the user doesn't care about access checking\n\t\tfree(fname);\n\t\treturn 1;\n\t}\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot read %s\\n\", fname);\n\t\tperror(\"fopen\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// lines starting with # are comments\n\t\tif (*buf == '#')\n\t\t\tcontinue;\n\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// compare\n\t\tif (strcmp(buf, name) == 0) {\n\t\t\tfclose(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 0;\n}"
  },
  {
    "function_name": "get_fname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/firejail_user.c",
    "lines": "94-99",
    "snippet": "static inline char *get_fname(void) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/firejail.users\", SYSCONFDIR) == -1)\n\t\terrExit(\"asprintf\");\n\treturn fname;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/firejail.users\"",
            "SYSCONFDIR"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/common.h\"\n\nstatic inline char *get_fname(void) {\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/firejail.users\", SYSCONFDIR) == -1)\n\t\terrExit(\"asprintf\");\n\treturn fname;\n}"
  },
  {
    "function_name": "init_uid_gid_min",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/firejail_user.c",
    "lines": "40-90",
    "snippet": "static void init_uid_gid_min(void) {\n\tif (uid_min != 0 && gid_min != 0)\n\t\treturn;\n\n\t// read the real values from login.def\n\tFILE *fp = fopen(\"/etc/login.defs\", \"r\");\n\tif (!fp)\n\t\tgoto errexit;\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// comments\n\t\tif (*buf == '#')\n\t\t\tcontinue;\n\t\t// skip empty space\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\n\t\tif (strncmp(ptr, \"UID_MIN\", 7) == 0) {\n\t\t\tint rv = sscanf(ptr + 7, \"%d\", &uid_min);\n\t\t\tif (rv != 1 || uid_min < 0) {\n\t\t\t\tfclose(fp);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(ptr, \"GID_MIN\", 7) == 0) {\n\t\t\tint rv = sscanf(ptr + 7, \"%d\", &gid_min);\n\t\t\tif (rv != 1 || gid_min < 0) {\n\t\t\t\tfclose(fp);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\n\t\tif (uid_min != 0 && gid_min != 0)\n\t\t\tbreak;\n\n\t}\n\tfclose(fp);\n\n\tif (uid_min == 0 || gid_min == 0)\n\t\tgoto errexit;\n//printf(\"uid_min %d, gid_min %d\\n\", uid_min, gid_min);\n\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot read UID_MIN and/or GID_MIN from /etc/login.defs, using 1000 by default\\n\");\n\tuid_min = 1000;\n\tgid_min = 1000;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [
      "#define MAXBUF 4098"
    ],
    "globals_used": [
      "int uid_min = 0;",
      "int gid_min = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot read UID_MIN and/or GID_MIN from /etc/login.defs, using 1000 by default\\n\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr + 7",
            "\"%d\"",
            "&gid_min"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"GID_MIN\"",
            "7"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr + 7",
            "\"%d\"",
            "&uid_min"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"UID_MIN\"",
            "7"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fp"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/etc/login.defs\"",
            "\"r\""
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/common.h\"\n\n#define MAXBUF 4098\n\nint uid_min = 0;\nint gid_min = 0;\n\nstatic void init_uid_gid_min(void) {\n\tif (uid_min != 0 && gid_min != 0)\n\t\treturn;\n\n\t// read the real values from login.def\n\tFILE *fp = fopen(\"/etc/login.defs\", \"r\");\n\tif (!fp)\n\t\tgoto errexit;\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// comments\n\t\tif (*buf == '#')\n\t\t\tcontinue;\n\t\t// skip empty space\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\n\t\tif (strncmp(ptr, \"UID_MIN\", 7) == 0) {\n\t\t\tint rv = sscanf(ptr + 7, \"%d\", &uid_min);\n\t\t\tif (rv != 1 || uid_min < 0) {\n\t\t\t\tfclose(fp);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(ptr, \"GID_MIN\", 7) == 0) {\n\t\t\tint rv = sscanf(ptr + 7, \"%d\", &gid_min);\n\t\t\tif (rv != 1 || gid_min < 0) {\n\t\t\t\tfclose(fp);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\n\t\tif (uid_min != 0 && gid_min != 0)\n\t\t\tbreak;\n\n\t}\n\tfclose(fp);\n\n\tif (uid_min == 0 || gid_min == 0)\n\t\tgoto errexit;\n//printf(\"uid_min %d, gid_min %d\\n\", uid_min, gid_min);\n\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot read UID_MIN and/or GID_MIN from /etc/login.defs, using 1000 by default\\n\");\n\tuid_min = 1000;\n\tgid_min = 1000;\n}"
  }
]