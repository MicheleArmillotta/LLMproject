[
  {
    "function_name": "route",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/route.c",
    "lines": "184-209",
    "snippet": "void route(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1) {\n\t\t\t\tchar *fname;\n\t\t\t\tif (asprintf(&fname, \"/proc/%d/net/fib_trie\", child) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\textract_if(fname);\n\t\t\t\tfree(fname);\n\n\t\t\t\tif (asprintf(&fname, \"/proc/%d/net/route\", child) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprint_route(fname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <arpa/inet.h>",
      "#include <assert.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_route",
          "args": [
            "fname"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "print_route",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/route.c",
          "lines": "114-182",
          "snippet": "static void print_route(const char *fname) {\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tprintf(\"  Route table:\\n\");\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove blanks, \\n\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// remove table header\n\t\t//Iface\tDestination\tGateway \tFlags\tRefCnt\tUse\tMetric\tMask\t\tMTU\tWindow\tIRTT\n\t\tif (strncmp(start, \"Iface\", 5) == 0)\n\t\t\tcontinue;\n\n\t\t// extract data\n\t\tchar ifname[64];\n\t\tchar destination[64];\n\t\tchar gateway[64];\n\t\tchar flags[64];\n\t\tchar refcnt[64];\n\t\tchar use[64];\n\t\tchar metric[64];\n\t\tchar mask[64];\n\t\tint rv = sscanf(start, \"%63s %63s %63s %63s %63s %63s %63s %63s\\n\", ifname, destination, gateway, flags, refcnt, use, metric, mask);\n\t\tif (rv != 8)\n\t\t\tcontinue;\n\n\t\t// destination ip\n\t\tuint32_t destip;\n\t\tsscanf(destination, \"%x\", &destip);\n\t\tdestip = ntohl(destip);\n\t\tuint32_t destmask;\n\t\tsscanf(mask, \"%x\", &destmask);\n\t\tdestmask = ntohl(destmask);\n\t\tuint32_t gw;\n\t\tsscanf(gateway, \"%x\", &gw);\n\t\tgw = ntohl(gw);\n\n//\t\tprintf(\"#%s# #%s# #%s# #%s# #%s# #%s# #%s# #%s#\\n\", ifname, destination, gateway, flags, refcnt, use, metric, mask);\n\t\tif (gw != 0)\n\t\t\tprintf(\"     %d.%d.%d.%d/%u via %d.%d.%d.%d, dev %s, metric %s\\n\",\n\t\t\t\tPRINT_IP(destip), mask2bits(destmask),\n\t\t\t\tPRINT_IP(gw),\n\t\t\t\tifname,\n\t\t\t\tmetric);\n\t\telse { // this is an interface\n\t\t\tIfList *ifentry = list_find(destip, destmask);\n\t\t\tif (ifentry) {\n\t\t\t\tprintf(\"     %d.%d.%d.%d/%u, dev %s, scope link src %d.%d.%d.%d\\n\",\n\t\t\t\t\tPRINT_IP(destip), mask2bits(destmask),\n\t\t\t\t\tifname,\n\t\t\t\t\tPRINT_IP(ifentry->ip));\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <assert.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <assert.h>\n#include \"firemon.h\"\n\n#define MAXBUF 4096\n\nstatic void print_route(const char *fname) {\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tprintf(\"  Route table:\\n\");\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove blanks, \\n\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// remove table header\n\t\t//Iface\tDestination\tGateway \tFlags\tRefCnt\tUse\tMetric\tMask\t\tMTU\tWindow\tIRTT\n\t\tif (strncmp(start, \"Iface\", 5) == 0)\n\t\t\tcontinue;\n\n\t\t// extract data\n\t\tchar ifname[64];\n\t\tchar destination[64];\n\t\tchar gateway[64];\n\t\tchar flags[64];\n\t\tchar refcnt[64];\n\t\tchar use[64];\n\t\tchar metric[64];\n\t\tchar mask[64];\n\t\tint rv = sscanf(start, \"%63s %63s %63s %63s %63s %63s %63s %63s\\n\", ifname, destination, gateway, flags, refcnt, use, metric, mask);\n\t\tif (rv != 8)\n\t\t\tcontinue;\n\n\t\t// destination ip\n\t\tuint32_t destip;\n\t\tsscanf(destination, \"%x\", &destip);\n\t\tdestip = ntohl(destip);\n\t\tuint32_t destmask;\n\t\tsscanf(mask, \"%x\", &destmask);\n\t\tdestmask = ntohl(destmask);\n\t\tuint32_t gw;\n\t\tsscanf(gateway, \"%x\", &gw);\n\t\tgw = ntohl(gw);\n\n//\t\tprintf(\"#%s# #%s# #%s# #%s# #%s# #%s# #%s# #%s#\\n\", ifname, destination, gateway, flags, refcnt, use, metric, mask);\n\t\tif (gw != 0)\n\t\t\tprintf(\"     %d.%d.%d.%d/%u via %d.%d.%d.%d, dev %s, metric %s\\n\",\n\t\t\t\tPRINT_IP(destip), mask2bits(destmask),\n\t\t\t\tPRINT_IP(gw),\n\t\t\t\tifname,\n\t\t\t\tmetric);\n\t\telse { // this is an interface\n\t\t\tIfList *ifentry = list_find(destip, destmask);\n\t\t\tif (ifentry) {\n\t\t\t\tprintf(\"     %d.%d.%d.%d/%u, dev %s, scope link src %d.%d.%d.%d\\n\",\n\t\t\t\t\tPRINT_IP(destip), mask2bits(destmask),\n\t\t\t\t\tifname,\n\t\t\t\t\tPRINT_IP(ifentry->ip));\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/net/route\"",
            "child"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_if",
          "args": [
            "fname"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "extract_if",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/route.c",
          "lines": "43-112",
          "snippet": "static void extract_if(const char *fname) {\n\t// clear interface list\n\twhile (ifs) {\n\t\tIfList *tmp = ifs->next;\n\t\tfree(ifs);\n\t\tifs = tmp;\n\t}\n\tassert(ifs == NULL);\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tchar buf[MAXBUF];\n\tint state = 0;\t// 0 -wait for Local\n\t\t\t//\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove blanks, \\n\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tif (state == 0) {\n\t\t\tif (strncmp(buf, \"Local:\", 6) == 0) {\n\t\t\t\tstate = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (state == 1) {\n\t\t\t// remove broadcast addresses\n\t\t\tif (strstr(start,\"BROADCAST\"))\n\t\t\t\tcontinue;\n\t\t\telse if (*start == '+')\n\t\t\t\tcontinue;\n\t\t\telse if (*start == '|') {\n\t\t\t\tmemset(last_start, 0, MAXBUF + 1);\n\t\t\t\tstrncpy(last_start, start, MAXBUF);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (strstr(buf, \"LOCAL\")) {\n//\t\t\t\tprintf(\"%s %s\\n\", last_start, start);\n\t\t\t\tunsigned mbits;\n\t\t\t\tsscanf(start, \"/%u\", &mbits);\n\t\t\t\tif (mbits != 32)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tunsigned a, b, c, d;\n\t\t\t\tif (sscanf(last_start, \"|-- %u.%u.%u.%u\", &a, &b, &c, &d) != 4 || a > 255 || b > 255 || c > 255 || d > 255)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tIfList *newif = malloc(sizeof(IfList));\n\t\t\t\tif (!newif)\n\t\t\t\t\terrExit(\"malloc\");\n\t\t\t\tnewif->ip = a * 0x1000000 + b * 0x10000 + c * 0x100 + d;\n\t\t\t\tnewif->next = ifs;\n\t\t\t\tifs = newif;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <assert.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4096"
          ],
          "globals_used": [
            "static IfList *ifs = NULL;",
            "static char last_start[MAXBUF + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <assert.h>\n#include \"firemon.h\"\n\n#define MAXBUF 4096\n\nstatic IfList *ifs = NULL;\nstatic char last_start[MAXBUF + 1];\n\nstatic void extract_if(const char *fname) {\n\t// clear interface list\n\twhile (ifs) {\n\t\tIfList *tmp = ifs->next;\n\t\tfree(ifs);\n\t\tifs = tmp;\n\t}\n\tassert(ifs == NULL);\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tchar buf[MAXBUF];\n\tint state = 0;\t// 0 -wait for Local\n\t\t\t//\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove blanks, \\n\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tif (state == 0) {\n\t\t\tif (strncmp(buf, \"Local:\", 6) == 0) {\n\t\t\t\tstate = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (state == 1) {\n\t\t\t// remove broadcast addresses\n\t\t\tif (strstr(start,\"BROADCAST\"))\n\t\t\t\tcontinue;\n\t\t\telse if (*start == '+')\n\t\t\t\tcontinue;\n\t\t\telse if (*start == '|') {\n\t\t\t\tmemset(last_start, 0, MAXBUF + 1);\n\t\t\t\tstrncpy(last_start, start, MAXBUF);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (strstr(buf, \"LOCAL\")) {\n//\t\t\t\tprintf(\"%s %s\\n\", last_start, start);\n\t\t\t\tunsigned mbits;\n\t\t\t\tsscanf(start, \"/%u\", &mbits);\n\t\t\t\tif (mbits != 32)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tunsigned a, b, c, d;\n\t\t\t\tif (sscanf(last_start, \"|-- %u.%u.%u.%u\", &a, &b, &c, &d) != 4 || a > 255 || b > 255 || c > 255 || d > 255)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tIfList *newif = malloc(sizeof(IfList));\n\t\t\t\tif (!newif)\n\t\t\t\t\terrExit(\"malloc\");\n\t\t\t\tnewif->ip = a * 0x1000000 + b * 0x10000 + c * 0x100 + d;\n\t\t\t\tnewif->next = ifs;\n\t\t\t\tifs = newif;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/net/fib_trie\"",
            "child"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_child",
          "args": [
            "i"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "65-87",
          "snippet": "int find_child(int id) {\n\tint i;\n\tint first_child = -1;\n\n\t// find the first child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 2 && pids[i].parent == id) {\n\t\t\tfirst_child = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (first_child == -1)\n\t\treturn -1;\n\n\t// find the second child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 3 && pids[i].parent == first_child)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nint find_child(int id) {\n\tint i;\n\tint first_child = -1;\n\n\t// find the first child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 2 && pids[i].parent == id) {\n\t\t\tfirst_child = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (first_child == -1)\n\t\treturn -1;\n\n\t// find the second child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 3 && pids[i].parent == first_child)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_print_list",
          "args": [
            "i",
            "arg_nowrap"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "pid_print_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "271-273",
          "snippet": "void pid_print_list(unsigned index, int nowrap) {\n\tprint_elem(index, nowrap);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\nvoid pid_print_list(unsigned index, int nowrap) {\n\tprint_elem(index, nowrap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_read",
          "args": [
            "pid"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "pid_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "304-428",
          "snippet": "void pid_read(pid_t mon_pid) {\n\tif (pids == NULL) {\n\t\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\t\tif (fp) {\n\t\t\tint val;\n\t\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\t\tif (val >= max_pids)\n\t\t\t\t\tmax_pids = val + 1;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tpids = malloc(sizeof(Process) * max_pids);\n\t\tif (pids == NULL)\n\t\t\terrExit(\"malloc\");\n\t}\n\tmemset(pids, 0, sizeof(Process) * max_pids);\n\tpid_t mypid = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpid_t child = -1;\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (child < 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == mypid)\n\t\t\tcontinue;\n\n\t\t// skip PID 1 just in case we run a sandbox-in-sandbox\n\t\tif (pid == 1)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[PIDS_BUFLEN];\n\t\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"Name:\", 5) == 0) {\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif ((strcmp(ptr, \"firejail\") == 0) && (mon_pid == 0 || mon_pid == pid)) {\n\t\t\t\t\tif (pid_proc_cmdline_x11_xpra_xephyr(pid))\n\t\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t}\n\t\t\tif (strncmp(buf, \"State:\", 6) == 0) {\n\t\t\t\tif (strstr(buf, \"(zombie)\"))\n\t\t\t\t\tpids[pid].zombie = 1;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tunsigned parent = atoi(ptr);\n\t\t\t\tparent %= max_pids;\n\t\t\t\tif (pids[parent].level > 0) {\n\t\t\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t\t\t}\n\t\t\t\tpids[pid].parent = parent;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\t\tchar *ptr = buf + 4;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tpids[pid].uid = atoi(ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\n\tpid_t pid;\n\tfor (pid = 0; pid < max_pids; pid++) {\n\t\tint parent = pids[pid].parent;\n\t\tif (pids[parent].level > 0) {\n\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [
            "#define PIDS_BUFLEN 4096"
          ],
          "globals_used": [
            "Process *pids = NULL;",
            "int max_pids=32769;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\n#define PIDS_BUFLEN 4096\n\nProcess *pids = NULL;\nint max_pids=32769;\n\nvoid pid_read(pid_t mon_pid) {\n\tif (pids == NULL) {\n\t\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\t\tif (fp) {\n\t\t\tint val;\n\t\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\t\tif (val >= max_pids)\n\t\t\t\t\tmax_pids = val + 1;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tpids = malloc(sizeof(Process) * max_pids);\n\t\tif (pids == NULL)\n\t\t\terrExit(\"malloc\");\n\t}\n\tmemset(pids, 0, sizeof(Process) * max_pids);\n\tpid_t mypid = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpid_t child = -1;\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (child < 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == mypid)\n\t\t\tcontinue;\n\n\t\t// skip PID 1 just in case we run a sandbox-in-sandbox\n\t\tif (pid == 1)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[PIDS_BUFLEN];\n\t\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"Name:\", 5) == 0) {\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif ((strcmp(ptr, \"firejail\") == 0) && (mon_pid == 0 || mon_pid == pid)) {\n\t\t\t\t\tif (pid_proc_cmdline_x11_xpra_xephyr(pid))\n\t\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t}\n\t\t\tif (strncmp(buf, \"State:\", 6) == 0) {\n\t\t\t\tif (strstr(buf, \"(zombie)\"))\n\t\t\t\t\tpids[pid].zombie = 1;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tunsigned parent = atoi(ptr);\n\t\t\t\tparent %= max_pids;\n\t\t\t\tif (pids[parent].level > 0) {\n\t\t\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t\t\t}\n\t\t\t\tpids[pid].parent = parent;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\t\tchar *ptr = buf + 4;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tpids[pid].uid = atoi(ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\n\tpid_t pid;\n\tfor (pid = 0; pid < max_pids; pid++) {\n\t\tint parent = pids[pid].parent;\n\t\tif (pids[parent].level > 0) {\n\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <arpa/inet.h>\n#include <assert.h>\n#include \"firemon.h\"\n\nvoid route(pid_t pid, int print_procs) {\n\tpid_read(pid);\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1) {\n\t\t\t\tchar *fname;\n\t\t\t\tif (asprintf(&fname, \"/proc/%d/net/fib_trie\", child) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\textract_if(fname);\n\t\t\t\tfree(fname);\n\n\t\t\t\tif (asprintf(&fname, \"/proc/%d/net/route\", child) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprint_route(fname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "print_route",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/route.c",
    "lines": "114-182",
    "snippet": "static void print_route(const char *fname) {\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tprintf(\"  Route table:\\n\");\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove blanks, \\n\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// remove table header\n\t\t//Iface\tDestination\tGateway \tFlags\tRefCnt\tUse\tMetric\tMask\t\tMTU\tWindow\tIRTT\n\t\tif (strncmp(start, \"Iface\", 5) == 0)\n\t\t\tcontinue;\n\n\t\t// extract data\n\t\tchar ifname[64];\n\t\tchar destination[64];\n\t\tchar gateway[64];\n\t\tchar flags[64];\n\t\tchar refcnt[64];\n\t\tchar use[64];\n\t\tchar metric[64];\n\t\tchar mask[64];\n\t\tint rv = sscanf(start, \"%63s %63s %63s %63s %63s %63s %63s %63s\\n\", ifname, destination, gateway, flags, refcnt, use, metric, mask);\n\t\tif (rv != 8)\n\t\t\tcontinue;\n\n\t\t// destination ip\n\t\tuint32_t destip;\n\t\tsscanf(destination, \"%x\", &destip);\n\t\tdestip = ntohl(destip);\n\t\tuint32_t destmask;\n\t\tsscanf(mask, \"%x\", &destmask);\n\t\tdestmask = ntohl(destmask);\n\t\tuint32_t gw;\n\t\tsscanf(gateway, \"%x\", &gw);\n\t\tgw = ntohl(gw);\n\n//\t\tprintf(\"#%s# #%s# #%s# #%s# #%s# #%s# #%s# #%s#\\n\", ifname, destination, gateway, flags, refcnt, use, metric, mask);\n\t\tif (gw != 0)\n\t\t\tprintf(\"     %d.%d.%d.%d/%u via %d.%d.%d.%d, dev %s, metric %s\\n\",\n\t\t\t\tPRINT_IP(destip), mask2bits(destmask),\n\t\t\t\tPRINT_IP(gw),\n\t\t\t\tifname,\n\t\t\t\tmetric);\n\t\telse { // this is an interface\n\t\t\tIfList *ifentry = list_find(destip, destmask);\n\t\t\tif (ifentry) {\n\t\t\t\tprintf(\"     %d.%d.%d.%d/%u, dev %s, scope link src %d.%d.%d.%d\\n\",\n\t\t\t\t\tPRINT_IP(destip), mask2bits(destmask),\n\t\t\t\t\tifname,\n\t\t\t\t\tPRINT_IP(ifentry->ip));\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n}",
    "includes": [
      "#include <arpa/inet.h>",
      "#include <assert.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [
      "#define MAXBUF 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"     %d.%d.%d.%d/%u, dev %s, scope link src %d.%d.%d.%d\\n\"",
            "PRINT_IP(destip)",
            "mask2bits(destmask)",
            "ifname",
            "PRINT_IP(ifentry->ip)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "ifentry->ip"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mask2bits",
          "args": [
            "destmask"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "mask2bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "47-59",
          "snippet": "static inline uint8_t mask2bits(uint32_t mask) {\n\tuint32_t tmp = 0x80000000;\n\tint i;\n\tuint8_t rv = 0;\n\n\tfor (i = 0; i < 32; i++, tmp >>= 1) {\n\t\tif (tmp & mask)\n\t\t\trv++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline uint8_t mask2bits(uint32_t mask) {\n\tuint32_t tmp = 0x80000000;\n\tint i;\n\tuint8_t rv = 0;\n\n\tfor (i = 0; i < 32; i++, tmp >>= 1) {\n\t\tif (tmp & mask)\n\t\t\trv++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "destip"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_find",
          "args": [
            "destip",
            "destmask"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "list_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/route.c",
          "lines": "32-41",
          "snippet": "static IfList *list_find(uint32_t ip, uint32_t mask) {\n\tIfList *ptr = ifs;\n\twhile (ptr) {\n\t\tif ((ptr->ip & mask) == (ip & mask))\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <assert.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static IfList *ifs = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <assert.h>\n#include \"firemon.h\"\n\nstatic IfList *ifs = NULL;\n\nstatic IfList *list_find(uint32_t ip, uint32_t mask) {\n\tIfList *ptr = ifs;\n\twhile (ptr) {\n\t\tif ((ptr->ip & mask) == (ip & mask))\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"     %d.%d.%d.%d/%u via %d.%d.%d.%d, dev %s, metric %s\\n\"",
            "PRINT_IP(destip)",
            "mask2bits(destmask)",
            "PRINT_IP(gw)",
            "ifname",
            "metric"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "gw"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "destip"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "gw"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "gateway",
            "\"%x\"",
            "&gw"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "destmask"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "mask",
            "\"%x\"",
            "&destmask"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "destip"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "destination",
            "\"%x\"",
            "&destip"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "start",
            "\"%63s %63s %63s %63s %63s %63s %63s %63s\\n\"",
            "ifname",
            "destination",
            "gateway",
            "flags",
            "refcnt",
            "use",
            "metric",
            "mask"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "start",
            "\"Iface\"",
            "5"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "'\\n'"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fp"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  Route table:\\n\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <arpa/inet.h>\n#include <assert.h>\n#include \"firemon.h\"\n\n#define MAXBUF 4096\n\nstatic void print_route(const char *fname) {\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tprintf(\"  Route table:\\n\");\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove blanks, \\n\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// remove table header\n\t\t//Iface\tDestination\tGateway \tFlags\tRefCnt\tUse\tMetric\tMask\t\tMTU\tWindow\tIRTT\n\t\tif (strncmp(start, \"Iface\", 5) == 0)\n\t\t\tcontinue;\n\n\t\t// extract data\n\t\tchar ifname[64];\n\t\tchar destination[64];\n\t\tchar gateway[64];\n\t\tchar flags[64];\n\t\tchar refcnt[64];\n\t\tchar use[64];\n\t\tchar metric[64];\n\t\tchar mask[64];\n\t\tint rv = sscanf(start, \"%63s %63s %63s %63s %63s %63s %63s %63s\\n\", ifname, destination, gateway, flags, refcnt, use, metric, mask);\n\t\tif (rv != 8)\n\t\t\tcontinue;\n\n\t\t// destination ip\n\t\tuint32_t destip;\n\t\tsscanf(destination, \"%x\", &destip);\n\t\tdestip = ntohl(destip);\n\t\tuint32_t destmask;\n\t\tsscanf(mask, \"%x\", &destmask);\n\t\tdestmask = ntohl(destmask);\n\t\tuint32_t gw;\n\t\tsscanf(gateway, \"%x\", &gw);\n\t\tgw = ntohl(gw);\n\n//\t\tprintf(\"#%s# #%s# #%s# #%s# #%s# #%s# #%s# #%s#\\n\", ifname, destination, gateway, flags, refcnt, use, metric, mask);\n\t\tif (gw != 0)\n\t\t\tprintf(\"     %d.%d.%d.%d/%u via %d.%d.%d.%d, dev %s, metric %s\\n\",\n\t\t\t\tPRINT_IP(destip), mask2bits(destmask),\n\t\t\t\tPRINT_IP(gw),\n\t\t\t\tifname,\n\t\t\t\tmetric);\n\t\telse { // this is an interface\n\t\t\tIfList *ifentry = list_find(destip, destmask);\n\t\t\tif (ifentry) {\n\t\t\t\tprintf(\"     %d.%d.%d.%d/%u, dev %s, scope link src %d.%d.%d.%d\\n\",\n\t\t\t\t\tPRINT_IP(destip), mask2bits(destmask),\n\t\t\t\t\tifname,\n\t\t\t\t\tPRINT_IP(ifentry->ip));\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n}"
  },
  {
    "function_name": "extract_if",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/route.c",
    "lines": "43-112",
    "snippet": "static void extract_if(const char *fname) {\n\t// clear interface list\n\twhile (ifs) {\n\t\tIfList *tmp = ifs->next;\n\t\tfree(ifs);\n\t\tifs = tmp;\n\t}\n\tassert(ifs == NULL);\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tchar buf[MAXBUF];\n\tint state = 0;\t// 0 -wait for Local\n\t\t\t//\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove blanks, \\n\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tif (state == 0) {\n\t\t\tif (strncmp(buf, \"Local:\", 6) == 0) {\n\t\t\t\tstate = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (state == 1) {\n\t\t\t// remove broadcast addresses\n\t\t\tif (strstr(start,\"BROADCAST\"))\n\t\t\t\tcontinue;\n\t\t\telse if (*start == '+')\n\t\t\t\tcontinue;\n\t\t\telse if (*start == '|') {\n\t\t\t\tmemset(last_start, 0, MAXBUF + 1);\n\t\t\t\tstrncpy(last_start, start, MAXBUF);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (strstr(buf, \"LOCAL\")) {\n//\t\t\t\tprintf(\"%s %s\\n\", last_start, start);\n\t\t\t\tunsigned mbits;\n\t\t\t\tsscanf(start, \"/%u\", &mbits);\n\t\t\t\tif (mbits != 32)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tunsigned a, b, c, d;\n\t\t\t\tif (sscanf(last_start, \"|-- %u.%u.%u.%u\", &a, &b, &c, &d) != 4 || a > 255 || b > 255 || c > 255 || d > 255)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tIfList *newif = malloc(sizeof(IfList));\n\t\t\t\tif (!newif)\n\t\t\t\t\terrExit(\"malloc\");\n\t\t\t\tnewif->ip = a * 0x1000000 + b * 0x10000 + c * 0x100 + d;\n\t\t\t\tnewif->next = ifs;\n\t\t\t\tifs = newif;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\n}",
    "includes": [
      "#include <arpa/inet.h>",
      "#include <assert.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [
      "#define MAXBUF 4096"
    ],
    "globals_used": [
      "static IfList *ifs = NULL;",
      "static char last_start[MAXBUF + 1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(IfList)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "last_start",
            "\"|-- %u.%u.%u.%u\"",
            "&a",
            "&b",
            "&c",
            "&d"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "start",
            "\"/%u\"",
            "&mbits"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "\"LOCAL\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "last_start",
            "start",
            "MAXBUF"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "last_start",
            "0",
            "MAXBUF + 1"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "start",
            "\"BROADCAST\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"Local:\"",
            "6"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "'\\n'"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fp"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ifs == NULL"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ifs"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <arpa/inet.h>\n#include <assert.h>\n#include \"firemon.h\"\n\n#define MAXBUF 4096\n\nstatic IfList *ifs = NULL;\nstatic char last_start[MAXBUF + 1];\n\nstatic void extract_if(const char *fname) {\n\t// clear interface list\n\twhile (ifs) {\n\t\tIfList *tmp = ifs->next;\n\t\tfree(ifs);\n\t\tifs = tmp;\n\t}\n\tassert(ifs == NULL);\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tchar buf[MAXBUF];\n\tint state = 0;\t// 0 -wait for Local\n\t\t\t//\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove blanks, \\n\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\tchar *start = ptr;\n\t\tif (*start == '\\0')\n\t\t\tcontinue;\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tif (state == 0) {\n\t\t\tif (strncmp(buf, \"Local:\", 6) == 0) {\n\t\t\t\tstate = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (state == 1) {\n\t\t\t// remove broadcast addresses\n\t\t\tif (strstr(start,\"BROADCAST\"))\n\t\t\t\tcontinue;\n\t\t\telse if (*start == '+')\n\t\t\t\tcontinue;\n\t\t\telse if (*start == '|') {\n\t\t\t\tmemset(last_start, 0, MAXBUF + 1);\n\t\t\t\tstrncpy(last_start, start, MAXBUF);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (strstr(buf, \"LOCAL\")) {\n//\t\t\t\tprintf(\"%s %s\\n\", last_start, start);\n\t\t\t\tunsigned mbits;\n\t\t\t\tsscanf(start, \"/%u\", &mbits);\n\t\t\t\tif (mbits != 32)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tunsigned a, b, c, d;\n\t\t\t\tif (sscanf(last_start, \"|-- %u.%u.%u.%u\", &a, &b, &c, &d) != 4 || a > 255 || b > 255 || c > 255 || d > 255)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tIfList *newif = malloc(sizeof(IfList));\n\t\t\t\tif (!newif)\n\t\t\t\t\terrExit(\"malloc\");\n\t\t\t\tnewif->ip = a * 0x1000000 + b * 0x10000 + c * 0x100 + d;\n\t\t\t\tnewif->next = ifs;\n\t\t\t\tifs = newif;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\n}"
  },
  {
    "function_name": "list_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/route.c",
    "lines": "32-41",
    "snippet": "static IfList *list_find(uint32_t ip, uint32_t mask) {\n\tIfList *ptr = ifs;\n\twhile (ptr) {\n\t\tif ((ptr->ip & mask) == (ip & mask))\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <arpa/inet.h>",
      "#include <assert.h>",
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static IfList *ifs = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <arpa/inet.h>\n#include <assert.h>\n#include \"firemon.h\"\n\nstatic IfList *ifs = NULL;\n\nstatic IfList *list_find(uint32_t ip, uint32_t mask) {\n\tIfList *ptr = ifs;\n\twhile (ptr) {\n\t\tif ((ptr->ip & mask) == (ip & mask))\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}"
  }
]