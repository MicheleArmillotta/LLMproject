[
  {
    "function_name": "restrict_users",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
    "lines": "388-409",
    "snippet": "void restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_run();\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}",
    "includes": [
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sanitize_group",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
          "lines": "301-386",
          "snippet": "static void sanitize_group(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/group\", &s) == -1)\n\t\treturn;\n\tassert(gid_min);\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/group, GID_MIN %d\\n\", gid_min);\n\tif (is_link(\"/etc/group\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/group\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/group\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_GROUP_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tgid_t mygid = getgid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\n\t\t// sample line:\n\t\t// \tpulse:x:115:netblue,bingo\n\t\t// drop lines with uid > 1000 and not the current user group\n\t\tchar *ptr = buf;\n\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint gid;\n\t\tint rv = sscanf(ptr, \"%d:\", &gid);\n\t\tif (rv == 0 || gid < 0)\n\t\t\tgoto errout;\n\t\tassert(gid_min);\n\t\tif (gid < gid_min || gid == 65534) { // on Debian platforms 65534 is group nogroup\n\t\t\tif (copy_line(fpout, buf, ptr))\n\t\t\t\tgoto errout;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((gid_t) gid != mygid) {\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tif (copy_line(fpout, buf, ptr))\n\t\t\tgoto errout;\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new group file\n\tif (mount(RUN_GROUP_FILE, \"/etc/group\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/group\");\n\n\treturn;\n\nerrout:\n\tfwarning(\"failed to clean up /etc/group\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\n#define MAXBUF 1024\n\nstatic void sanitize_group(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/group\", &s) == -1)\n\t\treturn;\n\tassert(gid_min);\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/group, GID_MIN %d\\n\", gid_min);\n\tif (is_link(\"/etc/group\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/group\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/group\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_GROUP_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tgid_t mygid = getgid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\n\t\t// sample line:\n\t\t// \tpulse:x:115:netblue,bingo\n\t\t// drop lines with uid > 1000 and not the current user group\n\t\tchar *ptr = buf;\n\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint gid;\n\t\tint rv = sscanf(ptr, \"%d:\", &gid);\n\t\tif (rv == 0 || gid < 0)\n\t\t\tgoto errout;\n\t\tassert(gid_min);\n\t\tif (gid < gid_min || gid == 65534) { // on Debian platforms 65534 is group nogroup\n\t\t\tif (copy_line(fpout, buf, ptr))\n\t\t\t\tgoto errout;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((gid_t) gid != mygid) {\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tif (copy_line(fpout, buf, ptr))\n\t\t\tgoto errout;\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new group file\n\tif (mount(RUN_GROUP_FILE, \"/etc/group\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/group\");\n\n\treturn;\n\nerrout:\n\tfwarning(\"failed to clean up /etc/group\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitize_passwd",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_passwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
          "lines": "166-256",
          "snippet": "static void sanitize_passwd(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/passwd\", &s) == -1)\n\t\treturn;\n\tassert(uid_min);\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/passwd, UID_MIN %d\\n\", uid_min);\n\tif (is_link(\"/etc/passwd\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/passwd\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/passwd\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_PASSWD_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tuid_t myuid = getuid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\n\t\t// sample line:\n\t\t// \twww-data:x:33:33:www-data:/var/www:/bin/sh\n\t\t// drop lines with uid > 1000 and not the current user\n\t\tchar *ptr = buf;\n\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tchar *ptr1 = ptr;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint uid;\n\t\tint rv = sscanf(ptr, \"%d:\", &uid);\n\t\tif (rv == 0 || uid < 0)\n\t\t\tgoto errout;\n\t\tassert(uid_min);\n\t\tif (uid < uid_min || uid == 65534) { // on Debian platforms user nobody is 65534\n\t\t\tfprintf(fpout, \"%s\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((uid_t) uid != myuid) {\n\t\t\t// store user name - necessary to process /etc/group\n\t\t\t*ptr1 = '\\0';\n\t\t\tchar *user = strdup(buf);\n\t\t\tif (!user)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tulist_add(user);\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tfprintf(fpout, \"%s\", buf);\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new password file\n\tif (mount(RUN_PASSWD_FILE, \"/etc/passwd\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/passwd\");\n\n\treturn;\n\nerrout:\n\tfwarning(\"failed to clean up /etc/passwd\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\n#define MAXBUF 1024\n\nstatic void sanitize_passwd(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/passwd\", &s) == -1)\n\t\treturn;\n\tassert(uid_min);\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/passwd, UID_MIN %d\\n\", uid_min);\n\tif (is_link(\"/etc/passwd\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/passwd\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/passwd\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_PASSWD_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tuid_t myuid = getuid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\n\t\t// sample line:\n\t\t// \twww-data:x:33:33:www-data:/var/www:/bin/sh\n\t\t// drop lines with uid > 1000 and not the current user\n\t\tchar *ptr = buf;\n\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tchar *ptr1 = ptr;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint uid;\n\t\tint rv = sscanf(ptr, \"%d:\", &uid);\n\t\tif (rv == 0 || uid < 0)\n\t\t\tgoto errout;\n\t\tassert(uid_min);\n\t\tif (uid < uid_min || uid == 65534) { // on Debian platforms user nobody is 65534\n\t\t\tfprintf(fpout, \"%s\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((uid_t) uid != myuid) {\n\t\t\t// store user name - necessary to process /etc/group\n\t\t\t*ptr1 = '\\0';\n\t\t\tchar *user = strdup(buf);\n\t\t\tif (!user)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tulist_add(user);\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tfprintf(fpout, \"%s\", buf);\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new password file\n\tif (mount(RUN_PASSWD_FILE, \"/etc/passwd\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/passwd\");\n\n\treturn;\n\nerrout:\n\tfwarning(\"failed to clean up /etc/passwd\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitize_run",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
          "lines": "116-164",
          "snippet": "static void sanitize_run(void) {\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /run/user directory\\n\");\n\n\tchar *runuser;\n\tif (asprintf(&runuser, \"/run/user/%u\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(runuser, &s) == -1) {\n\t\t// cannot find /user/run/$UID directory, just return\n\t\tif (arg_debug)\n\t\t\tprintf(\"Cannot find %s directory\\n\", runuser);\n\t\tfree(runuser);\n\t\treturn;\n\t}\n\n\tif (mkdir(RUN_WHITELIST_RUN_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the /run/user/$UID directory\n\tif (mount(runuser, RUN_WHITELIST_RUN_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs on /run/user\n\tif (mount(\"tmpfs\", \"/run/user\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /run/user\");\n\n\t// create new user directory\n\tif (mkdir(runuser, 0700) == -1)\n\t\terrExit(\"mkdir\");\n\tfs_logger2(\"mkdir\", runuser);\n\n\t// set mode and ownership\n\tif (set_perms(runuser, getuid(), getgid(), 0700))\n\t\terrExit(\"set_perms\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_RUN_DIR, runuser, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask mirrored /run/user/$UID directory\n\tif (mount(\"tmpfs\", RUN_WHITELIST_RUN_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_RUN_DIR);\n\n\tfree(runuser);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nstatic void sanitize_run(void) {\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /run/user directory\\n\");\n\n\tchar *runuser;\n\tif (asprintf(&runuser, \"/run/user/%u\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(runuser, &s) == -1) {\n\t\t// cannot find /user/run/$UID directory, just return\n\t\tif (arg_debug)\n\t\t\tprintf(\"Cannot find %s directory\\n\", runuser);\n\t\tfree(runuser);\n\t\treturn;\n\t}\n\n\tif (mkdir(RUN_WHITELIST_RUN_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the /run/user/$UID directory\n\tif (mount(runuser, RUN_WHITELIST_RUN_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs on /run/user\n\tif (mount(\"tmpfs\", \"/run/user\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /run/user\");\n\n\t// create new user directory\n\tif (mkdir(runuser, 0700) == -1)\n\t\terrExit(\"mkdir\");\n\tfs_logger2(\"mkdir\", runuser);\n\n\t// set mode and ownership\n\tif (set_perms(runuser, getuid(), getgid(), 0700))\n\t\terrExit(\"set_perms\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_RUN_DIR, runuser, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask mirrored /run/user/$UID directory\n\tif (mount(\"tmpfs\", RUN_WHITELIST_RUN_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_RUN_DIR);\n\n\tfree(runuser);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"tmpfs /home\""
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/home\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanitize_home",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_home",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
          "lines": "65-114",
          "snippet": "static void sanitize_home(void) {\n\tassert(getuid() != 0);\t// this code works only for regular users\n\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /home directory\\n\");\n\n\tstruct stat s;\n\tif (stat(cfg.homedir, &s) == -1) {\n\t\t// cannot find home directory, just return\n\t\tfwarning(\"cannot find home directory\\n\");\n\t\treturn;\n\t}\n\n\tif (mkdir(RUN_WHITELIST_HOME_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the user home directory\n\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs in the new home\n\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /home\");\n\n\t// create user home directory\n\tif (mkdir(cfg.homedir, 0755) == -1) {\n\t\tif (mkpath_as_root(cfg.homedir))\n\t\t\terrExit(\"mkpath\");\n\t\tif (mkdir(cfg.homedir, 0755) == -1)\n\t\t\terrExit(\"mkdir\");\n\t}\n\tfs_logger2(\"mkdir\", cfg.homedir);\n\n\t// set mode and ownership\n\tif (set_perms(cfg.homedir, s.st_uid, s.st_gid, s.st_mode))\n\t\terrExit(\"set_perms\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_HOME_DIR, cfg.homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask home dir under /run\n\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_DIR);\n\tif (!arg_private)\n\t\tfs_logger2(\"whitelist\", cfg.homedir);\n\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nstatic void sanitize_home(void) {\n\tassert(getuid() != 0);\t// this code works only for regular users\n\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /home directory\\n\");\n\n\tstruct stat s;\n\tif (stat(cfg.homedir, &s) == -1) {\n\t\t// cannot find home directory, just return\n\t\tfwarning(\"cannot find home directory\\n\");\n\t\treturn;\n\t}\n\n\tif (mkdir(RUN_WHITELIST_HOME_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the user home directory\n\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs in the new home\n\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /home\");\n\n\t// create user home directory\n\tif (mkdir(cfg.homedir, 0755) == -1) {\n\t\tif (mkpath_as_root(cfg.homedir))\n\t\t\terrExit(\"mkpath\");\n\t\tif (mkdir(cfg.homedir, 0755) == -1)\n\t\t\terrExit(\"mkdir\");\n\t}\n\tfs_logger2(\"mkdir\", cfg.homedir);\n\n\t// set mode and ownership\n\tif (set_perms(cfg.homedir, s.st_uid, s.st_gid, s.st_mode))\n\t\terrExit(\"set_perms\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_HOME_DIR, cfg.homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask home dir under /run\n\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_DIR);\n\tif (!arg_private)\n\t\tfs_logger2(\"whitelist\", cfg.homedir);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cfg.homedir",
            "\"/home/\"",
            "6"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nvoid restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_run();\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}"
  },
  {
    "function_name": "sanitize_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
    "lines": "301-386",
    "snippet": "static void sanitize_group(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/group\", &s) == -1)\n\t\treturn;\n\tassert(gid_min);\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/group, GID_MIN %d\\n\", gid_min);\n\tif (is_link(\"/etc/group\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/group\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/group\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_GROUP_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tgid_t mygid = getgid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\n\t\t// sample line:\n\t\t// \tpulse:x:115:netblue,bingo\n\t\t// drop lines with uid > 1000 and not the current user group\n\t\tchar *ptr = buf;\n\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint gid;\n\t\tint rv = sscanf(ptr, \"%d:\", &gid);\n\t\tif (rv == 0 || gid < 0)\n\t\t\tgoto errout;\n\t\tassert(gid_min);\n\t\tif (gid < gid_min || gid == 65534) { // on Debian platforms 65534 is group nogroup\n\t\t\tif (copy_line(fpout, buf, ptr))\n\t\t\t\tgoto errout;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((gid_t) gid != mygid) {\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tif (copy_line(fpout, buf, ptr))\n\t\t\tgoto errout;\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new group file\n\tif (mount(RUN_GROUP_FILE, \"/etc/group\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/group\");\n\n\treturn;\n\nerrout:\n\tfwarning(\"failed to clean up /etc/group\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAXBUF 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpout"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpin"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"failed to clean up /etc/group\\n\""
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"create /etc/group\""
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount\""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_GROUP_FILE",
            "\"/etc/group\"",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpout"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fpout",
            "0",
            "0",
            "0644"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpin"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_line",
          "args": [
            "fpout",
            "buf",
            "ptr"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "copy_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
          "lines": "259-299",
          "snippet": "static int copy_line(FILE *fpout, char *buf, char *ptr) {\n\t// fpout: GROUP_FILE\n\t// buf: pulse:x:115:netblue,bingo\n\t// ptr: 115:neblue,bingo\n\n\twhile (*ptr != ':' && *ptr != '\\0')\n\t\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn 1;\n\n\tptr++;\n\tif (*ptr == '\\n' || *ptr == '\\0') {\n\t\tfprintf(fpout, \"%s\", buf);\n\t\treturn 0;\n\t}\n\n\t// print what we have so far\n\tchar tmp = *ptr;\n\t*ptr = '\\0';\n\tfprintf(fpout, \"%s\", buf);\n\t*ptr = tmp;\n\n\t// tokenize\n\tchar *token = strtok(ptr, \",\\n\");\n\tint first = 1;\n\twhile (token) {\n\t\tchar *newtoken = strtok(NULL, \",\\n\");\n\t\tif (ulist_find(token)) {\n\t\t\t//skip\n\t\t\ttoken = newtoken;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first)\n\t\t\tfprintf(fpout, \",\");\n\t\tfirst = 0;\n\t\tfprintf(fpout, \"%s\", token);\n\t\ttoken = newtoken;\n\t}\n\tfprintf(fpout, \"\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nstatic int copy_line(FILE *fpout, char *buf, char *ptr) {\n\t// fpout: GROUP_FILE\n\t// buf: pulse:x:115:netblue,bingo\n\t// ptr: 115:neblue,bingo\n\n\twhile (*ptr != ':' && *ptr != '\\0')\n\t\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn 1;\n\n\tptr++;\n\tif (*ptr == '\\n' || *ptr == '\\0') {\n\t\tfprintf(fpout, \"%s\", buf);\n\t\treturn 0;\n\t}\n\n\t// print what we have so far\n\tchar tmp = *ptr;\n\t*ptr = '\\0';\n\tfprintf(fpout, \"%s\", buf);\n\t*ptr = tmp;\n\n\t// tokenize\n\tchar *token = strtok(ptr, \",\\n\");\n\tint first = 1;\n\twhile (token) {\n\t\tchar *newtoken = strtok(NULL, \",\\n\");\n\t\tif (ulist_find(token)) {\n\t\t\t//skip\n\t\t\ttoken = newtoken;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first)\n\t\t\tfprintf(fpout, \",\");\n\t\tfirst = 0;\n\t\tfprintf(fpout, \"%s\", token);\n\t\ttoken = newtoken;\n\t}\n\tfprintf(fpout, \"\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "gid_min"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%d:\"",
            "&gid"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fpin"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "RUN_GROUP_FILE",
            "\"w\""
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid /etc/group\\n\""
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "\"/etc/group\""
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "432-459",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Sanitizing /etc/group, GID_MIN %d\\n\"",
            "gid_min"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "gid_min"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/etc/group\"",
            "&s"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\n#define MAXBUF 1024\n\nstatic void sanitize_group(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/group\", &s) == -1)\n\t\treturn;\n\tassert(gid_min);\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/group, GID_MIN %d\\n\", gid_min);\n\tif (is_link(\"/etc/group\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/group\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/group\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_GROUP_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tgid_t mygid = getgid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\n\t\t// sample line:\n\t\t// \tpulse:x:115:netblue,bingo\n\t\t// drop lines with uid > 1000 and not the current user group\n\t\tchar *ptr = buf;\n\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint gid;\n\t\tint rv = sscanf(ptr, \"%d:\", &gid);\n\t\tif (rv == 0 || gid < 0)\n\t\t\tgoto errout;\n\t\tassert(gid_min);\n\t\tif (gid < gid_min || gid == 65534) { // on Debian platforms 65534 is group nogroup\n\t\t\tif (copy_line(fpout, buf, ptr))\n\t\t\t\tgoto errout;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((gid_t) gid != mygid) {\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tif (copy_line(fpout, buf, ptr))\n\t\t\tgoto errout;\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new group file\n\tif (mount(RUN_GROUP_FILE, \"/etc/group\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/group\");\n\n\treturn;\n\nerrout:\n\tfwarning(\"failed to clean up /etc/group\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}"
  },
  {
    "function_name": "copy_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
    "lines": "259-299",
    "snippet": "static int copy_line(FILE *fpout, char *buf, char *ptr) {\n\t// fpout: GROUP_FILE\n\t// buf: pulse:x:115:netblue,bingo\n\t// ptr: 115:neblue,bingo\n\n\twhile (*ptr != ':' && *ptr != '\\0')\n\t\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn 1;\n\n\tptr++;\n\tif (*ptr == '\\n' || *ptr == '\\0') {\n\t\tfprintf(fpout, \"%s\", buf);\n\t\treturn 0;\n\t}\n\n\t// print what we have so far\n\tchar tmp = *ptr;\n\t*ptr = '\\0';\n\tfprintf(fpout, \"%s\", buf);\n\t*ptr = tmp;\n\n\t// tokenize\n\tchar *token = strtok(ptr, \",\\n\");\n\tint first = 1;\n\twhile (token) {\n\t\tchar *newtoken = strtok(NULL, \",\\n\");\n\t\tif (ulist_find(token)) {\n\t\t\t//skip\n\t\t\ttoken = newtoken;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first)\n\t\t\tfprintf(fpout, \",\");\n\t\tfirst = 0;\n\t\tfprintf(fpout, \"%s\", token);\n\t\ttoken = newtoken;\n\t}\n\tfprintf(fpout, \"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"\\n\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"%s\"",
            "token"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\",\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_find",
          "args": [
            "token"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
          "lines": "52-63",
          "snippet": "static USER_LIST *ulist_find(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *ptr = ulist;\n\twhile (ptr) {\n\t\tif (strcmp(ptr->user, user) == 0)\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "USER_LIST *ulist = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nUSER_LIST *ulist = NULL;\n\nstatic USER_LIST *ulist_find(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *ptr = ulist;\n\twhile (ptr) {\n\t\tif (strcmp(ptr->user, user) == 0)\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\\n\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "ptr",
            "\",\\n\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"%s\"",
            "buf"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"%s\"",
            "buf"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nstatic int copy_line(FILE *fpout, char *buf, char *ptr) {\n\t// fpout: GROUP_FILE\n\t// buf: pulse:x:115:netblue,bingo\n\t// ptr: 115:neblue,bingo\n\n\twhile (*ptr != ':' && *ptr != '\\0')\n\t\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn 1;\n\n\tptr++;\n\tif (*ptr == '\\n' || *ptr == '\\0') {\n\t\tfprintf(fpout, \"%s\", buf);\n\t\treturn 0;\n\t}\n\n\t// print what we have so far\n\tchar tmp = *ptr;\n\t*ptr = '\\0';\n\tfprintf(fpout, \"%s\", buf);\n\t*ptr = tmp;\n\n\t// tokenize\n\tchar *token = strtok(ptr, \",\\n\");\n\tint first = 1;\n\twhile (token) {\n\t\tchar *newtoken = strtok(NULL, \",\\n\");\n\t\tif (ulist_find(token)) {\n\t\t\t//skip\n\t\t\ttoken = newtoken;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first)\n\t\t\tfprintf(fpout, \",\");\n\t\tfirst = 0;\n\t\tfprintf(fpout, \"%s\", token);\n\t\ttoken = newtoken;\n\t}\n\tfprintf(fpout, \"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "sanitize_passwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
    "lines": "166-256",
    "snippet": "static void sanitize_passwd(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/passwd\", &s) == -1)\n\t\treturn;\n\tassert(uid_min);\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/passwd, UID_MIN %d\\n\", uid_min);\n\tif (is_link(\"/etc/passwd\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/passwd\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/passwd\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_PASSWD_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tuid_t myuid = getuid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\n\t\t// sample line:\n\t\t// \twww-data:x:33:33:www-data:/var/www:/bin/sh\n\t\t// drop lines with uid > 1000 and not the current user\n\t\tchar *ptr = buf;\n\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tchar *ptr1 = ptr;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint uid;\n\t\tint rv = sscanf(ptr, \"%d:\", &uid);\n\t\tif (rv == 0 || uid < 0)\n\t\t\tgoto errout;\n\t\tassert(uid_min);\n\t\tif (uid < uid_min || uid == 65534) { // on Debian platforms user nobody is 65534\n\t\t\tfprintf(fpout, \"%s\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((uid_t) uid != myuid) {\n\t\t\t// store user name - necessary to process /etc/group\n\t\t\t*ptr1 = '\\0';\n\t\t\tchar *user = strdup(buf);\n\t\t\tif (!user)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tulist_add(user);\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tfprintf(fpout, \"%s\", buf);\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new password file\n\tif (mount(RUN_PASSWD_FILE, \"/etc/passwd\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/passwd\");\n\n\treturn;\n\nerrout:\n\tfwarning(\"failed to clean up /etc/passwd\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAXBUF 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpout"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpin"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"failed to clean up /etc/passwd\\n\""
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"create /etc/passwd\""
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_PASSWD_FILE",
            "\"/etc/passwd\"",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpout"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fpout",
            "0",
            "0",
            "0644"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpin"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"%s\"",
            "buf"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_add",
          "args": [
            "user"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
          "lines": "40-50",
          "snippet": "static void ulist_add(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *nlist = malloc(sizeof(USER_LIST));\n\tif (!nlist)\n\t\terrExit(\"malloc\");\n\tmemset(nlist, 0, sizeof(USER_LIST));\n\tnlist->user = user;\n\tnlist->next = ulist;\n\tulist = nlist;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "USER_LIST *ulist = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nUSER_LIST *ulist = NULL;\n\nstatic void ulist_add(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *nlist = malloc(sizeof(USER_LIST));\n\tif (!nlist)\n\t\terrExit(\"malloc\");\n\tmemset(nlist, 0, sizeof(USER_LIST));\n\tnlist->user = user;\n\tnlist->next = ulist;\n\tulist = nlist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buf"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"%s\"",
            "buf"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "uid_min"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%d:\"",
            "&uid"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fpin"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "RUN_PASSWD_FILE",
            "\"w\""
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid /etc/passwd\\n\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "\"/etc/passwd\""
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "432-459",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Sanitizing /etc/passwd, UID_MIN %d\\n\"",
            "uid_min"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "uid_min"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/etc/passwd\"",
            "&s"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\n#define MAXBUF 1024\n\nstatic void sanitize_passwd(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/passwd\", &s) == -1)\n\t\treturn;\n\tassert(uid_min);\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/passwd, UID_MIN %d\\n\", uid_min);\n\tif (is_link(\"/etc/passwd\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/passwd\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/passwd\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_PASSWD_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tuid_t myuid = getuid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\n\t\t// sample line:\n\t\t// \twww-data:x:33:33:www-data:/var/www:/bin/sh\n\t\t// drop lines with uid > 1000 and not the current user\n\t\tchar *ptr = buf;\n\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tchar *ptr1 = ptr;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint uid;\n\t\tint rv = sscanf(ptr, \"%d:\", &uid);\n\t\tif (rv == 0 || uid < 0)\n\t\t\tgoto errout;\n\t\tassert(uid_min);\n\t\tif (uid < uid_min || uid == 65534) { // on Debian platforms user nobody is 65534\n\t\t\tfprintf(fpout, \"%s\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((uid_t) uid != myuid) {\n\t\t\t// store user name - necessary to process /etc/group\n\t\t\t*ptr1 = '\\0';\n\t\t\tchar *user = strdup(buf);\n\t\t\tif (!user)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tulist_add(user);\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tfprintf(fpout, \"%s\", buf);\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new password file\n\tif (mount(RUN_PASSWD_FILE, \"/etc/passwd\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/passwd\");\n\n\treturn;\n\nerrout:\n\tfwarning(\"failed to clean up /etc/passwd\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}"
  },
  {
    "function_name": "sanitize_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
    "lines": "116-164",
    "snippet": "static void sanitize_run(void) {\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /run/user directory\\n\");\n\n\tchar *runuser;\n\tif (asprintf(&runuser, \"/run/user/%u\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(runuser, &s) == -1) {\n\t\t// cannot find /user/run/$UID directory, just return\n\t\tif (arg_debug)\n\t\t\tprintf(\"Cannot find %s directory\\n\", runuser);\n\t\tfree(runuser);\n\t\treturn;\n\t}\n\n\tif (mkdir(RUN_WHITELIST_RUN_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the /run/user/$UID directory\n\tif (mount(runuser, RUN_WHITELIST_RUN_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs on /run/user\n\tif (mount(\"tmpfs\", \"/run/user\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /run/user\");\n\n\t// create new user directory\n\tif (mkdir(runuser, 0700) == -1)\n\t\terrExit(\"mkdir\");\n\tfs_logger2(\"mkdir\", runuser);\n\n\t// set mode and ownership\n\tif (set_perms(runuser, getuid(), getgid(), 0700))\n\t\terrExit(\"set_perms\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_RUN_DIR, runuser, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask mirrored /run/user/$UID directory\n\tif (mount(\"tmpfs\", RUN_WHITELIST_RUN_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_RUN_DIR);\n\n\tfree(runuser);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "runuser"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_RUN_DIR"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_RUN_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_WHITELIST_RUN_DIR",
            "runuser",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"set_perms\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_perms",
          "args": [
            "runuser",
            "getuid()",
            "getgid()",
            "0700"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "set_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1047-1054",
          "snippet": "int set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "runuser",
            "0700"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "382-389",
          "snippet": "int mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdir_t orig_mkdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"tmpfs /run/user\""
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/run/user\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "runuser",
            "RUN_WHITELIST_RUN_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "runuser"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Cannot find %s directory\\n\"",
            "runuser"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "runuser",
            "&s"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&runuser",
            "\"/run/user/%u\"",
            "getuid()"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Cleaning /run/user directory\\n\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nstatic void sanitize_run(void) {\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /run/user directory\\n\");\n\n\tchar *runuser;\n\tif (asprintf(&runuser, \"/run/user/%u\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(runuser, &s) == -1) {\n\t\t// cannot find /user/run/$UID directory, just return\n\t\tif (arg_debug)\n\t\t\tprintf(\"Cannot find %s directory\\n\", runuser);\n\t\tfree(runuser);\n\t\treturn;\n\t}\n\n\tif (mkdir(RUN_WHITELIST_RUN_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the /run/user/$UID directory\n\tif (mount(runuser, RUN_WHITELIST_RUN_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs on /run/user\n\tif (mount(\"tmpfs\", \"/run/user\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /run/user\");\n\n\t// create new user directory\n\tif (mkdir(runuser, 0700) == -1)\n\t\terrExit(\"mkdir\");\n\tfs_logger2(\"mkdir\", runuser);\n\n\t// set mode and ownership\n\tif (set_perms(runuser, getuid(), getgid(), 0700))\n\t\terrExit(\"set_perms\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_RUN_DIR, runuser, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask mirrored /run/user/$UID directory\n\tif (mount(\"tmpfs\", RUN_WHITELIST_RUN_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_RUN_DIR);\n\n\tfree(runuser);\n}"
  },
  {
    "function_name": "sanitize_home",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
    "lines": "65-114",
    "snippet": "static void sanitize_home(void) {\n\tassert(getuid() != 0);\t// this code works only for regular users\n\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /home directory\\n\");\n\n\tstruct stat s;\n\tif (stat(cfg.homedir, &s) == -1) {\n\t\t// cannot find home directory, just return\n\t\tfwarning(\"cannot find home directory\\n\");\n\t\treturn;\n\t}\n\n\tif (mkdir(RUN_WHITELIST_HOME_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the user home directory\n\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs in the new home\n\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /home\");\n\n\t// create user home directory\n\tif (mkdir(cfg.homedir, 0755) == -1) {\n\t\tif (mkpath_as_root(cfg.homedir))\n\t\t\terrExit(\"mkpath\");\n\t\tif (mkdir(cfg.homedir, 0755) == -1)\n\t\t\terrExit(\"mkdir\");\n\t}\n\tfs_logger2(\"mkdir\", cfg.homedir);\n\n\t// set mode and ownership\n\tif (set_perms(cfg.homedir, s.st_uid, s.st_gid, s.st_mode))\n\t\terrExit(\"set_perms\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_HOME_DIR, cfg.homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask home dir under /run\n\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_DIR);\n\tif (!arg_private)\n\t\tfs_logger2(\"whitelist\", cfg.homedir);\n\n}",
    "includes": [
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"whitelist\"",
            "cfg.homedir"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_HOME_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_WHITELIST_HOME_DIR",
            "cfg.homedir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"set_perms\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_perms",
          "args": [
            "cfg.homedir",
            "s.st_uid",
            "s.st_gid",
            "s.st_mode"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "set_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1047-1054",
          "snippet": "int set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "cfg.homedir",
            "0755"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "382-389",
          "snippet": "int mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdir_t orig_mkdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkpath\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkpath_as_root",
          "args": [
            "cfg.homedir"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "mkpath_as_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "145-176",
          "snippet": "int mkpath_as_root(const char* path) {\n\tassert(path && *path);\n\n\t// work on a copy of the path\n\tchar *file_path = strdup(path);\n\tif (!file_path)\n\t\terrExit(\"strdup\");\n\n\tchar* p;\n\tint done = 0;\n\tfor (p=strchr(file_path+1, '/'); p; p=strchr(p+1, '/')) {\n\t\t*p='\\0';\n\t\tif (mkdir(file_path, 0755)==-1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tfree(file_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (set_perms(file_path, 0, 0, 0755))\n\t\t\t\terrExit(\"set_perms\");\n\t\t\tdone = 1;\n\t\t}\n\n\t\t*p='/';\n\t}\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(file_path);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint mkpath_as_root(const char* path) {\n\tassert(path && *path);\n\n\t// work on a copy of the path\n\tchar *file_path = strdup(path);\n\tif (!file_path)\n\t\terrExit(\"strdup\");\n\n\tchar* p;\n\tint done = 0;\n\tfor (p=strchr(file_path+1, '/'); p; p=strchr(p+1, '/')) {\n\t\t*p='\\0';\n\t\tif (mkdir(file_path, 0755)==-1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tfree(file_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (set_perms(file_path, 0, 0, 0755))\n\t\t\t\terrExit(\"set_perms\");\n\t\t\tdone = 1;\n\t\t}\n\n\t\t*p='/';\n\t}\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(file_path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"tmpfs /home\""
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/home\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "cfg.homedir",
            "RUN_WHITELIST_HOME_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"cannot find home directory\\n\""
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cfg.homedir",
            "&s"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Cleaning /home directory\\n\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getuid() != 0"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nstatic void sanitize_home(void) {\n\tassert(getuid() != 0);\t// this code works only for regular users\n\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /home directory\\n\");\n\n\tstruct stat s;\n\tif (stat(cfg.homedir, &s) == -1) {\n\t\t// cannot find home directory, just return\n\t\tfwarning(\"cannot find home directory\\n\");\n\t\treturn;\n\t}\n\n\tif (mkdir(RUN_WHITELIST_HOME_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the user home directory\n\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs in the new home\n\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /home\");\n\n\t// create user home directory\n\tif (mkdir(cfg.homedir, 0755) == -1) {\n\t\tif (mkpath_as_root(cfg.homedir))\n\t\t\terrExit(\"mkpath\");\n\t\tif (mkdir(cfg.homedir, 0755) == -1)\n\t\t\terrExit(\"mkdir\");\n\t}\n\tfs_logger2(\"mkdir\", cfg.homedir);\n\n\t// set mode and ownership\n\tif (set_perms(cfg.homedir, s.st_uid, s.st_gid, s.st_mode))\n\t\terrExit(\"set_perms\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_HOME_DIR, cfg.homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask home dir under /run\n\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_DIR);\n\tif (!arg_private)\n\t\tfs_logger2(\"whitelist\", cfg.homedir);\n\n}"
  },
  {
    "function_name": "ulist_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
    "lines": "52-63",
    "snippet": "static USER_LIST *ulist_find(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *ptr = ulist;\n\twhile (ptr) {\n\t\tif (strcmp(ptr->user, user) == 0)\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "USER_LIST *ulist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr->user",
            "user"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "user"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nUSER_LIST *ulist = NULL;\n\nstatic USER_LIST *ulist_find(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *ptr = ulist;\n\twhile (ptr) {\n\t\tif (strcmp(ptr->user, user) == 0)\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ulist_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restrict_users.c",
    "lines": "40-50",
    "snippet": "static void ulist_add(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *nlist = malloc(sizeof(USER_LIST));\n\tif (!nlist)\n\t\terrExit(\"malloc\");\n\tmemset(nlist, 0, sizeof(USER_LIST));\n\tnlist->user = user;\n\tnlist->next = ulist;\n\tulist = nlist;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"../include/firejail_user.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "USER_LIST *ulist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nlist",
            "0",
            "sizeof(USER_LIST)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(USER_LIST)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "user"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/firejail_user.h\"\n#include \"firejail.h\"\n\nUSER_LIST *ulist = NULL;\n\nstatic void ulist_add(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *nlist = malloc(sizeof(USER_LIST));\n\tif (!nlist)\n\t\terrExit(\"malloc\");\n\tmemset(nlist, 0, sizeof(USER_LIST));\n\tnlist->user = user;\n\tnlist->next = ulist;\n\tulist = nlist;\n}"
  }
]