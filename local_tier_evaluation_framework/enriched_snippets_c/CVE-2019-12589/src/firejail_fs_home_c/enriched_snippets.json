[
  {
    "function_name": "fs_private_home_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
    "lines": "471-540",
    "snippet": "void fs_private_home_list(void) {\n\ttimetrace_start();\n\n\tchar *homedir = cfg.homedir;\n\tchar *private_list = cfg.home_private_keep;\n\tassert(homedir);\n\tassert(private_list);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\n\t// create /run/firejail/mnt/home directory\n\tmkdir_attr(RUN_HOME_DIR, 0755, uid, gid);\n\tfs_logger_print();\t// save the current log\n\n\tif (arg_debug)\n\t\tprintf(\"Copying files in the new home:\\n\");\n\n\t// copy the list of files in the new home directory\n\tchar *dlist = strdup(cfg.home_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-home argument\\n\");\n\t\texit(1);\n\t}\n\tduplicate(ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tduplicate(ptr);\n\n\tfs_logger_print();\t// save the current log\n\tfree(dlist);\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_HOME_DIR, homedir);\n\n\tif (mount(RUN_HOME_DIR, homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"tmpfs\", homedir);\n\n\tif (uid != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\n\tskel(homedir, uid, gid);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Home directory installed in %0.2f ms\\n\", timetrace_end());\n\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <linux/limits.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Home directory installed in %0.2f ms\\n\"",
            "timetrace_end()"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetrace_end",
          "args": [],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "timetrace_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "319-327",
          "snippet": "float timetrace_end(void) {\n\tif (tt_not_implemented)\n\t\treturn 0;\n\n\tunsigned long long delta = getticks() - tt;\n\tassert(tt_1ms);\n\n\treturn (float) delta / (float) tt_1ms;\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tt_not_implemented = 0;",
            "static unsigned long long tt_1ms = 0;",
            "static unsigned long long tt = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic int tt_not_implemented = 0;\nstatic unsigned long long tt_1ms = 0;\nstatic unsigned long long tt = 0;\n\nfloat timetrace_end(void) {\n\tif (tt_not_implemented)\n\t\treturn 0;\n\n\tunsigned long long delta = getticks() - tt;\n\tassert(tt_1ms);\n\n\treturn (float) delta / (float) tt_1ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_asoundrc",
          "args": [],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "copy_asoundrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "198-216",
          "snippet": "static void copy_asoundrc(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void copy_asoundrc(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_xauthority",
          "args": [],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "copy_xauthority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "178-196",
          "snippet": "static void copy_xauthority(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_XAUTHORITY_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void copy_xauthority(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_XAUTHORITY_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skel",
          "args": [
            "homedir",
            "uid",
            "gid"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "skel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "34-106",
          "snippet": "static void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\n\t// zsh\n\tif (!arg_shell_none && (strcmp(cfg.shell,\"/usr/bin/zsh\") == 0 || strcmp(cfg.shell,\"/bin/zsh\") == 0)) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.zshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// csh\n\telse if (!arg_shell_none && strcmp(cfg.shell,\"/bin/csh\") == 0) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.cshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// bash etc.\n\telse {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.bashrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\n\t// zsh\n\tif (!arg_shell_none && (strcmp(cfg.shell,\"/usr/bin/zsh\") == 0 || strcmp(cfg.shell,\"/bin/zsh\") == 0)) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.zshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// csh\n\telse if (!arg_shell_none && strcmp(cfg.shell,\"/bin/csh\") == 0) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.cshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// bash etc.\n\telse {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.bashrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting home directory\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/home\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting a new /home directory\\n\""
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting home directory\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/root\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME",
            "\"mode=700,gid=0\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting a new /root directory\\n\""
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"tmpfs\"",
            "homedir"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_HOME_DIR",
            "homedir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mount-bind %s on top of %s\\n\"",
            "RUN_HOME_DIR",
            "homedir"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dlist"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger_print",
          "args": [],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "91-113",
          "snippet": "void fs_logger_print(void) {\n\tif (!head)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_FSLOGGER_FILE, \"a\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\tSET_PERMS_STREAM_NOERR(fp, getuid(), getgid(), 0644);\n\n\tFsMsg *ptr = head;\n\twhile (ptr) {\n\t\tfprintf(fp, \"%s\\n\", ptr->msg);\n\t\tFsMsg *next = ptr->next;\n\t\t// remove message\n\t\tfree(ptr->msg);\n\t\tfree(ptr);\n\t\tptr = next;\n\t}\n\thead = NULL;\n\tfclose(fp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FsMsg *head = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic FsMsg *head = NULL;\n\nvoid fs_logger_print(void) {\n\tif (!head)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_FSLOGGER_FILE, \"a\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\tSET_PERMS_STREAM_NOERR(fp, getuid(), getgid(), 0644);\n\n\tFsMsg *ptr = head;\n\twhile (ptr) {\n\t\tfprintf(fp, \"%s\\n\", ptr->msg);\n\t\tFsMsg *next = ptr->next;\n\t\t// remove message\n\t\tfree(ptr->msg);\n\t\tfree(ptr);\n\t\tptr = next;\n\t}\n\thead = NULL;\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "duplicate",
          "args": [
            "ptr"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "duplicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "434-463",
          "snippet": "static void duplicate(char *name) {\n\tchar *fname = check_dir_or_file(name);\n\n\tif (arg_debug)\n\t\tprintf(\"Private home: duplicating %s\\n\", fname);\n\tassert(strncmp(fname, cfg.homedir, strlen(cfg.homedir)) == 0);\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\telse if (S_ISDIR(s.st_mode)) {\n\t\t// create the directory in RUN_HOME_DIR\n\t\tchar *name;\n\t\tchar *ptr = strrchr(fname, '/');\n\t\tptr++;\n\t\tif (asprintf(&name, \"%s/%s\", RUN_HOME_DIR, ptr) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tmkdir_attr(name, 0755, getuid(), getgid());\n\t\tsbox_run(SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP, 3, PATH_FCOPY, fname, name);\n\t\tfree(name);\n\t}\n\telse\n\t\tsbox_run(SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP, 3, PATH_FCOPY, fname, RUN_HOME_DIR);\n\tfs_logger2(\"clone\", fname);\n\tfs_logger_print();\t// save the current log\n\n\tfree(fname);\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void duplicate(char *name) {\n\tchar *fname = check_dir_or_file(name);\n\n\tif (arg_debug)\n\t\tprintf(\"Private home: duplicating %s\\n\", fname);\n\tassert(strncmp(fname, cfg.homedir, strlen(cfg.homedir)) == 0);\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\telse if (S_ISDIR(s.st_mode)) {\n\t\t// create the directory in RUN_HOME_DIR\n\t\tchar *name;\n\t\tchar *ptr = strrchr(fname, '/');\n\t\tptr++;\n\t\tif (asprintf(&name, \"%s/%s\", RUN_HOME_DIR, ptr) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tmkdir_attr(name, 0755, getuid(), getgid());\n\t\tsbox_run(SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP, 3, PATH_FCOPY, fname, name);\n\t\tfree(name);\n\t}\n\telse\n\t\tsbox_run(SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP, 3, PATH_FCOPY, fname, RUN_HOME_DIR);\n\tfs_logger2(\"clone\", fname);\n\tfs_logger_print();\t// save the current log\n\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid private-home argument\\n\""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "dlist",
            "\",\""
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cfg.home_private_keep"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Copying files in the new home:\\n\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_attr",
          "args": [
            "RUN_HOME_DIR",
            "0755",
            "uid",
            "gid"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1056-1092",
          "snippet": "void mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid) {\n\tassert(fname);\n\tmode &= 07777;\n#if 0\n\tprintf(\"fname %s, uid %d, gid %d, mode %x - \", fname, uid, gid, (unsigned) mode);\n\tif (S_ISLNK(mode))\n\t\tprintf(\"l\");\n\telse if (S_ISDIR(mode))\n\t\tprintf(\"d\");\n\telse if (S_ISCHR(mode))\n\t\tprintf(\"c\");\n\telse if (S_ISBLK(mode))\n\t\tprintf(\"b\");\n\telse if (S_ISSOCK(mode))\n\t\tprintf(\"s\");\n\telse\n\t\tprintf(\"-\");\n\tprintf( (mode & S_IRUSR) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWUSR) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXUSR) ? \"x\" : \"-\");\n\tprintf( (mode & S_IRGRP) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWGRP) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXGRP) ? \"x\" : \"-\");\n\tprintf( (mode & S_IROTH) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWOTH) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXOTH) ? \"x\" : \"-\");\n\tprintf(\"\\n\");\n#endif\n\tif (mkdir(fname, mode) == -1 ||\n\t    chmod(fname, mode) == -1 ||\n\t    chown(fname, uid, gid)) {\n\t    \tfprintf(stderr, \"Error: failed to create %s directory\\n\", fname);\n\t\terrExit(\"mkdir/chmod\");\n\t}\n\n\tASSERT_PERMS(fname, uid, gid, mode);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid) {\n\tassert(fname);\n\tmode &= 07777;\n#if 0\n\tprintf(\"fname %s, uid %d, gid %d, mode %x - \", fname, uid, gid, (unsigned) mode);\n\tif (S_ISLNK(mode))\n\t\tprintf(\"l\");\n\telse if (S_ISDIR(mode))\n\t\tprintf(\"d\");\n\telse if (S_ISCHR(mode))\n\t\tprintf(\"c\");\n\telse if (S_ISBLK(mode))\n\t\tprintf(\"b\");\n\telse if (S_ISSOCK(mode))\n\t\tprintf(\"s\");\n\telse\n\t\tprintf(\"-\");\n\tprintf( (mode & S_IRUSR) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWUSR) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXUSR) ? \"x\" : \"-\");\n\tprintf( (mode & S_IRGRP) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWGRP) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXGRP) ? \"x\" : \"-\");\n\tprintf( (mode & S_IROTH) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWOTH) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXOTH) ? \"x\" : \"-\");\n\tprintf(\"\\n\");\n#endif\n\tif (mkdir(fname, mode) == -1 ||\n\t    chmod(fname, mode) == -1 ||\n\t    chown(fname, uid, gid)) {\n\t    \tfprintf(stderr, \"Error: failed to create %s directory\\n\", fname);\n\t\terrExit(\"mkdir/chmod\");\n\t}\n\n\tASSERT_PERMS(fname, uid, gid, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_asoundrc",
          "args": [],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "store_asoundrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "138-176",
          "snippet": "static int store_asoundrc(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_ASOUNDRC_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t// make sure the real path of the file is inside the home directory\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int store_asoundrc(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_ASOUNDRC_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t// make sure the real path of the file is inside the home directory\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_xauthority",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "store_xauthority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "108-136",
          "snippet": "static int store_xauthority(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfwarning(\"invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int store_xauthority(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfwarning(\"invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "private_list"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "homedir"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetrace_start",
          "args": [],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "timetrace_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "297-317",
          "snippet": "void timetrace_start(void) {\n\tif (tt_not_implemented)\n\t\treturn;\n\tunsigned long long t1 = getticks();\n\tif (t1 == 0) {\n\t\ttt_not_implemented = 1;\n\t\treturn;\n\t}\n\n\tif (tt_1ms == 0) {\n\t\tusleep(1000);\t// sleep 1 ms\n\t\tunsigned long long t2 = getticks();\n\t\ttt_1ms = t2 - t1;\n\t\tif (tt_1ms == 0) {\n\t\t\ttt_not_implemented = 1;\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttt = getticks();\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tt_not_implemented = 0;",
            "static unsigned long long tt_1ms = 0;",
            "static unsigned long long tt = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic int tt_not_implemented = 0;\nstatic unsigned long long tt_1ms = 0;\nstatic unsigned long long tt = 0;\n\nvoid timetrace_start(void) {\n\tif (tt_not_implemented)\n\t\treturn;\n\tunsigned long long t1 = getticks();\n\tif (t1 == 0) {\n\t\ttt_not_implemented = 1;\n\t\treturn;\n\t}\n\n\tif (tt_1ms == 0) {\n\t\tusleep(1000);\t// sleep 1 ms\n\t\tunsigned long long t2 = getticks();\n\t\ttt_1ms = t2 - t1;\n\t\tif (tt_1ms == 0) {\n\t\t\ttt_not_implemented = 1;\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttt = getticks();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private_home_list(void) {\n\ttimetrace_start();\n\n\tchar *homedir = cfg.homedir;\n\tchar *private_list = cfg.home_private_keep;\n\tassert(homedir);\n\tassert(private_list);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\n\t// create /run/firejail/mnt/home directory\n\tmkdir_attr(RUN_HOME_DIR, 0755, uid, gid);\n\tfs_logger_print();\t// save the current log\n\n\tif (arg_debug)\n\t\tprintf(\"Copying files in the new home:\\n\");\n\n\t// copy the list of files in the new home directory\n\tchar *dlist = strdup(cfg.home_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-home argument\\n\");\n\t\texit(1);\n\t}\n\tduplicate(ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tduplicate(ptr);\n\n\tfs_logger_print();\t// save the current log\n\tfree(dlist);\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_HOME_DIR, homedir);\n\n\tif (mount(RUN_HOME_DIR, homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"tmpfs\", homedir);\n\n\tif (uid != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\n\tskel(homedir, uid, gid);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Home directory installed in %0.2f ms\\n\", timetrace_end());\n\n}"
  },
  {
    "function_name": "duplicate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
    "lines": "434-463",
    "snippet": "static void duplicate(char *name) {\n\tchar *fname = check_dir_or_file(name);\n\n\tif (arg_debug)\n\t\tprintf(\"Private home: duplicating %s\\n\", fname);\n\tassert(strncmp(fname, cfg.homedir, strlen(cfg.homedir)) == 0);\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\telse if (S_ISDIR(s.st_mode)) {\n\t\t// create the directory in RUN_HOME_DIR\n\t\tchar *name;\n\t\tchar *ptr = strrchr(fname, '/');\n\t\tptr++;\n\t\tif (asprintf(&name, \"%s/%s\", RUN_HOME_DIR, ptr) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tmkdir_attr(name, 0755, getuid(), getgid());\n\t\tsbox_run(SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP, 3, PATH_FCOPY, fname, name);\n\t\tfree(name);\n\t}\n\telse\n\t\tsbox_run(SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP, 3, PATH_FCOPY, fname, RUN_HOME_DIR);\n\tfs_logger2(\"clone\", fname);\n\tfs_logger_print();\t// save the current log\n\n\tfree(fname);\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <linux/limits.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger_print",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "91-113",
          "snippet": "void fs_logger_print(void) {\n\tif (!head)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_FSLOGGER_FILE, \"a\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\tSET_PERMS_STREAM_NOERR(fp, getuid(), getgid(), 0644);\n\n\tFsMsg *ptr = head;\n\twhile (ptr) {\n\t\tfprintf(fp, \"%s\\n\", ptr->msg);\n\t\tFsMsg *next = ptr->next;\n\t\t// remove message\n\t\tfree(ptr->msg);\n\t\tfree(ptr);\n\t\tptr = next;\n\t}\n\thead = NULL;\n\tfclose(fp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FsMsg *head = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic FsMsg *head = NULL;\n\nvoid fs_logger_print(void) {\n\tif (!head)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_FSLOGGER_FILE, \"a\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\tSET_PERMS_STREAM_NOERR(fp, getuid(), getgid(), 0644);\n\n\tFsMsg *ptr = head;\n\twhile (ptr) {\n\t\tfprintf(fp, \"%s\\n\", ptr->msg);\n\t\tFsMsg *next = ptr->next;\n\t\t// remove message\n\t\tfree(ptr->msg);\n\t\tfree(ptr);\n\t\tptr = next;\n\t}\n\thead = NULL;\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"clone\"",
            "fname"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sbox_run",
          "args": [
            "SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP",
            "3",
            "PATH_FCOPY",
            "fname",
            "RUN_HOME_DIR"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "sbox_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sbox.c",
          "lines": "107-223",
          "snippet": "int sbox_run(unsigned filter, int num, ...) {\n\tEUID_ROOT();\n\n\tint i;\n\tva_list valist;\n\tva_start(valist, num);\n\n\t// build argument list\n\tchar *arg[num + 1];\n\tfor (i = 0; i < num; i++)\n\t\targ[i] = va_arg(valist, char*);\n\targ[i] = NULL;\n\tva_end(valist);\n\n\tif (arg_debug) {\n\t\tprintf(\"sbox run: \");\n\t\tfor (i = 0; i <= num; i++)\n\t\t\tprintf(\"%s \", arg[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// clean the new process\n\t\tclearenv();\n\n\t\tif (filter & SBOX_STDIN_FROM_FILE) {\n\t\t\tint fd;\n\t\t\tif((fd = open(SBOX_STDIN_FILE, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr,\"Error: cannot open %s\\n\", SBOX_STDIN_FILE);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tdup2(fd,STDIN_FILENO);\n\t\t\tclose(fd);\n\t\t}\n\t\telse if ((filter & SBOX_ALLOW_STDIN) == 0) {\n\t\t\tint fd = open(\"/dev/null\",O_RDWR, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse // the user could run the sandbox without /dev/null\n\t\t\t\tclose(STDIN_FILENO);\n\t\t}\n\n\t\t// close all other file descriptors\n\t\tint max = 20; // getdtablesize() is overkill for a firejail process\n\t\tfor (i = 3; i < max; i++)\n\t\t\tclose(i); // close open files\n\n\t\tumask(027);\n\n\t\t// apply filters\n\t\tif (filter & SBOX_CAPS_NONE) {\n\t\t\tcaps_drop_all();\n\t\t}\n\t\telse if (filter & SBOX_CAPS_NETWORK) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_NET_ADMIN;\n\t\t\tset |=  ((uint64_t) 1) << CAP_NET_RAW;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\t\telse if (filter & SBOX_CAPS_HIDEPID) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_SYS_PTRACE;\n\t\t\tset |=  ((uint64_t) 1) << CAP_SYS_PACCT;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\n\t\tif (filter & SBOX_SECCOMP) {\n\t\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\t\t}\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\t\t\tperror(\"prctl(PR_SET_SECCOMP)\");\n\t\t\t}\n\t\t}\n\n\t\tif (filter & SBOX_ROOT) {\n\t\t\t// elevate privileges in order to get grsecurity working\n\t\t\tif (setreuid(0, 0))\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0))\n\t\t\t\terrExit(\"setregid\");\n\t\t}\n\t\telse if (filter & SBOX_USER)\n\t\t\tdrop_privs(1);\n\n\t\tclearenv();\n\n\t\t// --quiet is passed as an environment variable\n\t\tif (arg_quiet)\n\t\t\tsetenv(\"FIREJAIL_QUIET\", \"yes\", 1);\n\n\t\tif (arg[0])\t// get rid of scan-build warning\n\t\t\texecvp(arg[0], arg);\n\t\telse\n\t\t\tassert(0);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tint status;\n\tif (waitpid(child, &status, 0) == -1 ) {\n\t\terrExit(\"waitpid\");\n\t}\n\tif (WIFEXITED(status) && status != 0) {\n\t\tfprintf(stderr, \"Error: failed to run %s\\n\", arg[0]);\n\t\texit(1);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"../include/seccomp.h\"",
            "#include <sys/wait.h>",
            "#include <stdarg.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sock_filter filter[] = {\n\tVALIDATE_ARCHITECTURE,\n\tEXAMINE_SYSCALL,\n\n#if defined(__x86_64__)\n#define X32_SYSCALL_BIT 0x40000000\n\t// handle X32 ABI\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, X32_SYSCALL_BIT, 1, 0),\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, 0, 1, 0),\n\tRETURN_ERRNO(EPERM),\n#endif\n\n\t// syscall list\n#ifdef SYS_mount\n\tBLACKLIST(SYS_mount),  // mount/unmount filesystems\n#endif\n#ifdef SYS_umount2\n\tBLACKLIST(SYS_umount2),\n#endif\n#ifdef SYS_ptrace\n\tBLACKLIST(SYS_ptrace), // trace processes\n#endif\n#ifdef SYS_kexec_file_load\n\tBLACKLIST(SYS_kexec_file_load),\n#endif\n#ifdef SYS_kexec_load\n\tBLACKLIST(SYS_kexec_load), // loading a different kernel\n#endif\n#ifdef SYS_name_to_handle_at\n\tBLACKLIST(SYS_name_to_handle_at),\n#endif\n#ifdef SYS_open_by_handle_at\n\tBLACKLIST(SYS_open_by_handle_at), // open by handle\n#endif\n#ifdef SYS_init_module\n\tBLACKLIST(SYS_init_module), // kernel module handling\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\tBLACKLIST(SYS_finit_module),\n#endif\n#ifdef SYS_create_module\n\tBLACKLIST(SYS_create_module),\n#endif\n#ifdef SYS_delete_module\n\tBLACKLIST(SYS_delete_module),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioperm\n\tBLACKLIST(SYS_ioperm),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioprio_set\n\tBLACKLIST(SYS_ioprio_set),\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\tBLACKLIST(SYS_ni_syscall),\n#endif\n#ifdef SYS_swapon\n\tBLACKLIST(SYS_swapon), // swap on/off\n#endif\n#ifdef SYS_swapoff\n\tBLACKLIST(SYS_swapoff),\n#endif\n#ifdef SYS_syslog\n\tBLACKLIST(SYS_syslog), // kernel printk control\n#endif\n\tRETURN_ALLOW\n};",
            "static struct sock_fprog prog = {\n\t.len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),\n\t.filter = filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/seccomp.h\"\n#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic struct sock_filter filter[] = {\n\tVALIDATE_ARCHITECTURE,\n\tEXAMINE_SYSCALL,\n\n#if defined(__x86_64__)\n#define X32_SYSCALL_BIT 0x40000000\n\t// handle X32 ABI\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, X32_SYSCALL_BIT, 1, 0),\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, 0, 1, 0),\n\tRETURN_ERRNO(EPERM),\n#endif\n\n\t// syscall list\n#ifdef SYS_mount\n\tBLACKLIST(SYS_mount),  // mount/unmount filesystems\n#endif\n#ifdef SYS_umount2\n\tBLACKLIST(SYS_umount2),\n#endif\n#ifdef SYS_ptrace\n\tBLACKLIST(SYS_ptrace), // trace processes\n#endif\n#ifdef SYS_kexec_file_load\n\tBLACKLIST(SYS_kexec_file_load),\n#endif\n#ifdef SYS_kexec_load\n\tBLACKLIST(SYS_kexec_load), // loading a different kernel\n#endif\n#ifdef SYS_name_to_handle_at\n\tBLACKLIST(SYS_name_to_handle_at),\n#endif\n#ifdef SYS_open_by_handle_at\n\tBLACKLIST(SYS_open_by_handle_at), // open by handle\n#endif\n#ifdef SYS_init_module\n\tBLACKLIST(SYS_init_module), // kernel module handling\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\tBLACKLIST(SYS_finit_module),\n#endif\n#ifdef SYS_create_module\n\tBLACKLIST(SYS_create_module),\n#endif\n#ifdef SYS_delete_module\n\tBLACKLIST(SYS_delete_module),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioperm\n\tBLACKLIST(SYS_ioperm),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioprio_set\n\tBLACKLIST(SYS_ioprio_set),\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\tBLACKLIST(SYS_ni_syscall),\n#endif\n#ifdef SYS_swapon\n\tBLACKLIST(SYS_swapon), // swap on/off\n#endif\n#ifdef SYS_swapoff\n\tBLACKLIST(SYS_swapoff),\n#endif\n#ifdef SYS_syslog\n\tBLACKLIST(SYS_syslog), // kernel printk control\n#endif\n\tRETURN_ALLOW\n};\nstatic struct sock_fprog prog = {\n\t.len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),\n\t.filter = filter,\n};\n\nint sbox_run(unsigned filter, int num, ...) {\n\tEUID_ROOT();\n\n\tint i;\n\tva_list valist;\n\tva_start(valist, num);\n\n\t// build argument list\n\tchar *arg[num + 1];\n\tfor (i = 0; i < num; i++)\n\t\targ[i] = va_arg(valist, char*);\n\targ[i] = NULL;\n\tva_end(valist);\n\n\tif (arg_debug) {\n\t\tprintf(\"sbox run: \");\n\t\tfor (i = 0; i <= num; i++)\n\t\t\tprintf(\"%s \", arg[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// clean the new process\n\t\tclearenv();\n\n\t\tif (filter & SBOX_STDIN_FROM_FILE) {\n\t\t\tint fd;\n\t\t\tif((fd = open(SBOX_STDIN_FILE, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr,\"Error: cannot open %s\\n\", SBOX_STDIN_FILE);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tdup2(fd,STDIN_FILENO);\n\t\t\tclose(fd);\n\t\t}\n\t\telse if ((filter & SBOX_ALLOW_STDIN) == 0) {\n\t\t\tint fd = open(\"/dev/null\",O_RDWR, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse // the user could run the sandbox without /dev/null\n\t\t\t\tclose(STDIN_FILENO);\n\t\t}\n\n\t\t// close all other file descriptors\n\t\tint max = 20; // getdtablesize() is overkill for a firejail process\n\t\tfor (i = 3; i < max; i++)\n\t\t\tclose(i); // close open files\n\n\t\tumask(027);\n\n\t\t// apply filters\n\t\tif (filter & SBOX_CAPS_NONE) {\n\t\t\tcaps_drop_all();\n\t\t}\n\t\telse if (filter & SBOX_CAPS_NETWORK) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_NET_ADMIN;\n\t\t\tset |=  ((uint64_t) 1) << CAP_NET_RAW;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\t\telse if (filter & SBOX_CAPS_HIDEPID) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_SYS_PTRACE;\n\t\t\tset |=  ((uint64_t) 1) << CAP_SYS_PACCT;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\n\t\tif (filter & SBOX_SECCOMP) {\n\t\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\t\t}\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\t\t\tperror(\"prctl(PR_SET_SECCOMP)\");\n\t\t\t}\n\t\t}\n\n\t\tif (filter & SBOX_ROOT) {\n\t\t\t// elevate privileges in order to get grsecurity working\n\t\t\tif (setreuid(0, 0))\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0))\n\t\t\t\terrExit(\"setregid\");\n\t\t}\n\t\telse if (filter & SBOX_USER)\n\t\t\tdrop_privs(1);\n\n\t\tclearenv();\n\n\t\t// --quiet is passed as an environment variable\n\t\tif (arg_quiet)\n\t\t\tsetenv(\"FIREJAIL_QUIET\", \"yes\", 1);\n\n\t\tif (arg[0])\t// get rid of scan-build warning\n\t\t\texecvp(arg[0], arg);\n\t\telse\n\t\t\tassert(0);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tint status;\n\tif (waitpid(child, &status, 0) == -1 ) {\n\t\terrExit(\"waitpid\");\n\t}\n\tif (WIFEXITED(status) && status != 0) {\n\t\tfprintf(stderr, \"Error: failed to run %s\\n\", arg[0]);\n\t\texit(1);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_attr",
          "args": [
            "name",
            "0755",
            "getuid()",
            "getgid()"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1056-1092",
          "snippet": "void mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid) {\n\tassert(fname);\n\tmode &= 07777;\n#if 0\n\tprintf(\"fname %s, uid %d, gid %d, mode %x - \", fname, uid, gid, (unsigned) mode);\n\tif (S_ISLNK(mode))\n\t\tprintf(\"l\");\n\telse if (S_ISDIR(mode))\n\t\tprintf(\"d\");\n\telse if (S_ISCHR(mode))\n\t\tprintf(\"c\");\n\telse if (S_ISBLK(mode))\n\t\tprintf(\"b\");\n\telse if (S_ISSOCK(mode))\n\t\tprintf(\"s\");\n\telse\n\t\tprintf(\"-\");\n\tprintf( (mode & S_IRUSR) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWUSR) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXUSR) ? \"x\" : \"-\");\n\tprintf( (mode & S_IRGRP) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWGRP) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXGRP) ? \"x\" : \"-\");\n\tprintf( (mode & S_IROTH) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWOTH) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXOTH) ? \"x\" : \"-\");\n\tprintf(\"\\n\");\n#endif\n\tif (mkdir(fname, mode) == -1 ||\n\t    chmod(fname, mode) == -1 ||\n\t    chown(fname, uid, gid)) {\n\t    \tfprintf(stderr, \"Error: failed to create %s directory\\n\", fname);\n\t\terrExit(\"mkdir/chmod\");\n\t}\n\n\tASSERT_PERMS(fname, uid, gid, mode);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid) {\n\tassert(fname);\n\tmode &= 07777;\n#if 0\n\tprintf(\"fname %s, uid %d, gid %d, mode %x - \", fname, uid, gid, (unsigned) mode);\n\tif (S_ISLNK(mode))\n\t\tprintf(\"l\");\n\telse if (S_ISDIR(mode))\n\t\tprintf(\"d\");\n\telse if (S_ISCHR(mode))\n\t\tprintf(\"c\");\n\telse if (S_ISBLK(mode))\n\t\tprintf(\"b\");\n\telse if (S_ISSOCK(mode))\n\t\tprintf(\"s\");\n\telse\n\t\tprintf(\"-\");\n\tprintf( (mode & S_IRUSR) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWUSR) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXUSR) ? \"x\" : \"-\");\n\tprintf( (mode & S_IRGRP) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWGRP) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXGRP) ? \"x\" : \"-\");\n\tprintf( (mode & S_IROTH) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWOTH) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXOTH) ? \"x\" : \"-\");\n\tprintf(\"\\n\");\n#endif\n\tif (mkdir(fname, mode) == -1 ||\n\t    chmod(fname, mode) == -1 ||\n\t    chown(fname, uid, gid)) {\n\t    \tfprintf(stderr, \"Error: failed to create %s directory\\n\", fname);\n\t\terrExit(\"mkdir/chmod\");\n\t}\n\n\tASSERT_PERMS(fname, uid, gid, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&name",
            "\"%s/%s\"",
            "RUN_HOME_DIR",
            "ptr"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "fname",
            "'/'"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "strncmp(fname, cfg.homedir, strlen(cfg.homedir)) == 0"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "cfg.homedir",
            "strlen(cfg.homedir)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg.homedir"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Private home: duplicating %s\\n\"",
            "fname"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_dir_or_file",
          "args": [
            "name"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "check_dir_or_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "372-432",
          "snippet": "static char *check_dir_or_file(const char *name) {\n\tassert(name);\n\n\t// basic checks\n\tinvalid_filename(name, 0); // no globbing\n\tif (arg_debug)\n\t\tprintf(\"Private home: checking %s\\n\", name);\n\n\t// expand home directory\n\tchar *fname = expand_macros(name);\n\tassert(fname);\n\n\t// If it doesn't start with '/', it must be relative to homedir\n\tif (fname[0] != '/') {\n\t\tchar* tmp;\n\t\tif (asprintf(&tmp, \"%s/%s\", cfg.homedir, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tfree(fname);\n\t\tfname = tmp;\n\t}\n\n\t// we allow only files in user home directory or symbolic links to files or directories owned by the user\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0 && S_ISLNK(s.st_mode)) {\n\t\tif (strncmp(fname, cfg.homedir, strlen(cfg.homedir)) != 0 || fname[strlen(cfg.homedir)] != '/')\n\t\t\tgoto errexit;\n\t\tif (stat(fname, &s) == 0) {\n\t\t\tif (s.st_uid != getuid()) {\n\t\t\t\tfprintf(stderr, \"Error: symbolic link %s to file or directory not owned by the user\\n\", fname);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\treturn fname;\n\t\t}\n\t\telse // dangling link\n\t\t\tgoto errexit;\n\t}\n\telse {\n\t\t// check the file is in user home directory, a full home directory is not allowed\n\t\tchar *rname = realpath(fname, NULL);\n\t\tif (!rname ||\n\t\t    strncmp(rname, cfg.homedir, strlen(cfg.homedir)) != 0 ||\n\t\t    strcmp(rname, cfg.homedir) == 0)\n\t\t\tgoto errexit;\n\n\t\t// only top files and directories in user home are allowed\n\t\tchar *ptr = rname + strlen(cfg.homedir);\n\t\tif (*ptr != '/')\n\t\t\tgoto errexit;\n\t\tptr = strchr(++ptr, '/');\n\t\tif (ptr) {\n\t\t\tfprintf(stderr, \"Error: only top files and directories in user home are allowed\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfree(fname);\n\t\treturn rname;\n\t}\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid file %s\\n\", name);\n\texit(1);\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic char *check_dir_or_file(const char *name) {\n\tassert(name);\n\n\t// basic checks\n\tinvalid_filename(name, 0); // no globbing\n\tif (arg_debug)\n\t\tprintf(\"Private home: checking %s\\n\", name);\n\n\t// expand home directory\n\tchar *fname = expand_macros(name);\n\tassert(fname);\n\n\t// If it doesn't start with '/', it must be relative to homedir\n\tif (fname[0] != '/') {\n\t\tchar* tmp;\n\t\tif (asprintf(&tmp, \"%s/%s\", cfg.homedir, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tfree(fname);\n\t\tfname = tmp;\n\t}\n\n\t// we allow only files in user home directory or symbolic links to files or directories owned by the user\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0 && S_ISLNK(s.st_mode)) {\n\t\tif (strncmp(fname, cfg.homedir, strlen(cfg.homedir)) != 0 || fname[strlen(cfg.homedir)] != '/')\n\t\t\tgoto errexit;\n\t\tif (stat(fname, &s) == 0) {\n\t\t\tif (s.st_uid != getuid()) {\n\t\t\t\tfprintf(stderr, \"Error: symbolic link %s to file or directory not owned by the user\\n\", fname);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\treturn fname;\n\t\t}\n\t\telse // dangling link\n\t\t\tgoto errexit;\n\t}\n\telse {\n\t\t// check the file is in user home directory, a full home directory is not allowed\n\t\tchar *rname = realpath(fname, NULL);\n\t\tif (!rname ||\n\t\t    strncmp(rname, cfg.homedir, strlen(cfg.homedir)) != 0 ||\n\t\t    strcmp(rname, cfg.homedir) == 0)\n\t\t\tgoto errexit;\n\n\t\t// only top files and directories in user home are allowed\n\t\tchar *ptr = rname + strlen(cfg.homedir);\n\t\tif (*ptr != '/')\n\t\t\tgoto errexit;\n\t\tptr = strchr(++ptr, '/');\n\t\tif (ptr) {\n\t\t\tfprintf(stderr, \"Error: only top files and directories in user home are allowed\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfree(fname);\n\t\treturn rname;\n\t}\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid file %s\\n\", name);\n\texit(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void duplicate(char *name) {\n\tchar *fname = check_dir_or_file(name);\n\n\tif (arg_debug)\n\t\tprintf(\"Private home: duplicating %s\\n\", fname);\n\tassert(strncmp(fname, cfg.homedir, strlen(cfg.homedir)) == 0);\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == -1) {\n\t\tfree(fname);\n\t\treturn;\n\t}\n\telse if (S_ISDIR(s.st_mode)) {\n\t\t// create the directory in RUN_HOME_DIR\n\t\tchar *name;\n\t\tchar *ptr = strrchr(fname, '/');\n\t\tptr++;\n\t\tif (asprintf(&name, \"%s/%s\", RUN_HOME_DIR, ptr) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tmkdir_attr(name, 0755, getuid(), getgid());\n\t\tsbox_run(SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP, 3, PATH_FCOPY, fname, name);\n\t\tfree(name);\n\t}\n\telse\n\t\tsbox_run(SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP, 3, PATH_FCOPY, fname, RUN_HOME_DIR);\n\tfs_logger2(\"clone\", fname);\n\tfs_logger_print();\t// save the current log\n\n\tfree(fname);\n}"
  },
  {
    "function_name": "check_dir_or_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
    "lines": "372-432",
    "snippet": "static char *check_dir_or_file(const char *name) {\n\tassert(name);\n\n\t// basic checks\n\tinvalid_filename(name, 0); // no globbing\n\tif (arg_debug)\n\t\tprintf(\"Private home: checking %s\\n\", name);\n\n\t// expand home directory\n\tchar *fname = expand_macros(name);\n\tassert(fname);\n\n\t// If it doesn't start with '/', it must be relative to homedir\n\tif (fname[0] != '/') {\n\t\tchar* tmp;\n\t\tif (asprintf(&tmp, \"%s/%s\", cfg.homedir, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tfree(fname);\n\t\tfname = tmp;\n\t}\n\n\t// we allow only files in user home directory or symbolic links to files or directories owned by the user\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0 && S_ISLNK(s.st_mode)) {\n\t\tif (strncmp(fname, cfg.homedir, strlen(cfg.homedir)) != 0 || fname[strlen(cfg.homedir)] != '/')\n\t\t\tgoto errexit;\n\t\tif (stat(fname, &s) == 0) {\n\t\t\tif (s.st_uid != getuid()) {\n\t\t\t\tfprintf(stderr, \"Error: symbolic link %s to file or directory not owned by the user\\n\", fname);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\treturn fname;\n\t\t}\n\t\telse // dangling link\n\t\t\tgoto errexit;\n\t}\n\telse {\n\t\t// check the file is in user home directory, a full home directory is not allowed\n\t\tchar *rname = realpath(fname, NULL);\n\t\tif (!rname ||\n\t\t    strncmp(rname, cfg.homedir, strlen(cfg.homedir)) != 0 ||\n\t\t    strcmp(rname, cfg.homedir) == 0)\n\t\t\tgoto errexit;\n\n\t\t// only top files and directories in user home are allowed\n\t\tchar *ptr = rname + strlen(cfg.homedir);\n\t\tif (*ptr != '/')\n\t\t\tgoto errexit;\n\t\tptr = strchr(++ptr, '/');\n\t\tif (ptr) {\n\t\t\tfprintf(stderr, \"Error: only top files and directories in user home are allowed\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfree(fname);\n\t\treturn rname;\n\t}\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid file %s\\n\", name);\n\texit(1);\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <linux/limits.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid file %s\\n\"",
            "name"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only top files and directories in user home are allowed\\n\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "++ptr",
            "'/'"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg.homedir"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rname",
            "cfg.homedir"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "rname",
            "cfg.homedir",
            "strlen(cfg.homedir)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "fname",
            "NULL"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: symbolic link %s to file or directory not owned by the user\\n\"",
            "fname"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "cfg.homedir",
            "strlen(cfg.homedir)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "s.st_mode"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&tmp",
            "\"%s/%s\"",
            "cfg.homedir",
            "fname"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_macros",
          "args": [
            "name"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Private home: checking %s\\n\"",
            "name"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_filename",
          "args": [
            "name",
            "0"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic char *check_dir_or_file(const char *name) {\n\tassert(name);\n\n\t// basic checks\n\tinvalid_filename(name, 0); // no globbing\n\tif (arg_debug)\n\t\tprintf(\"Private home: checking %s\\n\", name);\n\n\t// expand home directory\n\tchar *fname = expand_macros(name);\n\tassert(fname);\n\n\t// If it doesn't start with '/', it must be relative to homedir\n\tif (fname[0] != '/') {\n\t\tchar* tmp;\n\t\tif (asprintf(&tmp, \"%s/%s\", cfg.homedir, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tfree(fname);\n\t\tfname = tmp;\n\t}\n\n\t// we allow only files in user home directory or symbolic links to files or directories owned by the user\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0 && S_ISLNK(s.st_mode)) {\n\t\tif (strncmp(fname, cfg.homedir, strlen(cfg.homedir)) != 0 || fname[strlen(cfg.homedir)] != '/')\n\t\t\tgoto errexit;\n\t\tif (stat(fname, &s) == 0) {\n\t\t\tif (s.st_uid != getuid()) {\n\t\t\t\tfprintf(stderr, \"Error: symbolic link %s to file or directory not owned by the user\\n\", fname);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\treturn fname;\n\t\t}\n\t\telse // dangling link\n\t\t\tgoto errexit;\n\t}\n\telse {\n\t\t// check the file is in user home directory, a full home directory is not allowed\n\t\tchar *rname = realpath(fname, NULL);\n\t\tif (!rname ||\n\t\t    strncmp(rname, cfg.homedir, strlen(cfg.homedir)) != 0 ||\n\t\t    strcmp(rname, cfg.homedir) == 0)\n\t\t\tgoto errexit;\n\n\t\t// only top files and directories in user home are allowed\n\t\tchar *ptr = rname + strlen(cfg.homedir);\n\t\tif (*ptr != '/')\n\t\t\tgoto errexit;\n\t\tptr = strchr(++ptr, '/');\n\t\tif (ptr) {\n\t\t\tfprintf(stderr, \"Error: only top files and directories in user home are allowed\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfree(fname);\n\t\treturn rname;\n\t}\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid file %s\\n\", name);\n\texit(1);\n}"
  },
  {
    "function_name": "fs_check_private_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
    "lines": "353-367",
    "snippet": "void fs_check_private_dir(void) {\n\tEUID_ASSERT();\n\tinvalid_filename(cfg.home_private, 0); // no globbing\n\n\t// Expand the home directory\n\tchar *tmp = expand_macros(cfg.home_private);\n\tcfg.home_private = realpath(tmp, NULL);\n\tfree(tmp);\n\n\tif (!cfg.home_private\n\t || !is_dir(cfg.home_private)) {\n\t\tfprintf(stderr, \"Error: invalid private directory\\n\");\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <linux/limits.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid private directory\\n\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dir",
          "args": [
            "cfg.home_private"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "401-428",
          "snippet": "int is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "tmp",
            "NULL"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_macros",
          "args": [
            "cfg.home_private"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_filename",
          "args": [
            "cfg.home_private",
            "0"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_check_private_dir(void) {\n\tEUID_ASSERT();\n\tinvalid_filename(cfg.home_private, 0); // no globbing\n\n\t// Expand the home directory\n\tchar *tmp = expand_macros(cfg.home_private);\n\tcfg.home_private = realpath(tmp, NULL);\n\tfree(tmp);\n\n\tif (!cfg.home_private\n\t || !is_dir(cfg.home_private)) {\n\t\tfprintf(stderr, \"Error: invalid private directory\\n\");\n\t\texit(1);\n\t}\n}"
  },
  {
    "function_name": "fs_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
    "lines": "299-350",
    "snippet": "void fs_private(void) {\n\tchar *homedir = cfg.homedir;\n\tassert(homedir);\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\t// mask /home\n\tif (arg_debug)\n\t\tprintf(\"Mounting a new /home directory\\n\");\n\tif (u == 0 && arg_allusers) // allow --allusers when starting the sandbox as root\n\t\t;\n\telse {\n\t\tif (arg_allusers)\n\t\t\tfwarning(\"--allusers disabled by --private or --whitelist\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /home\");\n\t}\n\n\t// mask /root\n\tif (arg_debug)\n\t\tprintf(\"Mounting a new /root directory\\n\");\n\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\terrExit(\"mounting root directory\");\n\tfs_logger(\"tmpfs /root\");\n\n\tif (u != 0) {\n\t\t// create /home/user\n\t\tif (arg_debug)\n\t\t\tprintf(\"Create a new user directory\\n\");\n\t\tif (mkdir(homedir, S_IRWXU) == -1) {\n\t\t\tif (mkpath_as_root(homedir) == -1)\n\t\t\t\terrExit(\"mkpath\");\n\t\t\tif (mkdir(homedir, S_IRWXU) == -1 && errno != EEXIST)\n\t\t\t\terrExit(\"mkdir\");\n\t\t}\n\t\tif (chown(homedir, u, g) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger2(\"mkdir\", homedir);\n\t\tfs_logger2(\"tmpfs\", homedir);\n\t}\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <linux/limits.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_asoundrc",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "copy_asoundrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "198-216",
          "snippet": "static void copy_asoundrc(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void copy_asoundrc(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_xauthority",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "copy_xauthority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "178-196",
          "snippet": "static void copy_xauthority(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_XAUTHORITY_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void copy_xauthority(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_XAUTHORITY_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skel",
          "args": [
            "homedir",
            "u",
            "g"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "skel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "34-106",
          "snippet": "static void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\n\t// zsh\n\tif (!arg_shell_none && (strcmp(cfg.shell,\"/usr/bin/zsh\") == 0 || strcmp(cfg.shell,\"/bin/zsh\") == 0)) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.zshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// csh\n\telse if (!arg_shell_none && strcmp(cfg.shell,\"/bin/csh\") == 0) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.cshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// bash etc.\n\telse {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.bashrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\n\t// zsh\n\tif (!arg_shell_none && (strcmp(cfg.shell,\"/usr/bin/zsh\") == 0 || strcmp(cfg.shell,\"/bin/zsh\") == 0)) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.zshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// csh\n\telse if (!arg_shell_none && strcmp(cfg.shell,\"/bin/csh\") == 0) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.cshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// bash etc.\n\telse {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.bashrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"tmpfs\"",
            "homedir"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "homedir",
            "u",
            "g"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "homedir",
            "S_IRWXU"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "382-389",
          "snippet": "int mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdir_t orig_mkdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkpath\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkpath_as_root",
          "args": [
            "homedir"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "mkpath_as_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "145-176",
          "snippet": "int mkpath_as_root(const char* path) {\n\tassert(path && *path);\n\n\t// work on a copy of the path\n\tchar *file_path = strdup(path);\n\tif (!file_path)\n\t\terrExit(\"strdup\");\n\n\tchar* p;\n\tint done = 0;\n\tfor (p=strchr(file_path+1, '/'); p; p=strchr(p+1, '/')) {\n\t\t*p='\\0';\n\t\tif (mkdir(file_path, 0755)==-1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tfree(file_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (set_perms(file_path, 0, 0, 0755))\n\t\t\t\terrExit(\"set_perms\");\n\t\t\tdone = 1;\n\t\t}\n\n\t\t*p='/';\n\t}\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(file_path);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint mkpath_as_root(const char* path) {\n\tassert(path && *path);\n\n\t// work on a copy of the path\n\tchar *file_path = strdup(path);\n\tif (!file_path)\n\t\terrExit(\"strdup\");\n\n\tchar* p;\n\tint done = 0;\n\tfor (p=strchr(file_path+1, '/'); p; p=strchr(p+1, '/')) {\n\t\t*p='\\0';\n\t\tif (mkdir(file_path, 0755)==-1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tfree(file_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (set_perms(file_path, 0, 0, 0755))\n\t\t\t\terrExit(\"set_perms\");\n\t\t\tdone = 1;\n\t\t}\n\n\t\t*p='/';\n\t}\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(file_path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Create a new user directory\\n\""
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"tmpfs /root\""
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting root directory\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/root\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME",
            "\"mode=700,gid=0\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting a new /root directory\\n\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting home directory\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/home\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"--allusers disabled by --private or --whitelist\\n\""
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting a new /home directory\\n\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_asoundrc",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "store_asoundrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "138-176",
          "snippet": "static int store_asoundrc(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_ASOUNDRC_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t// make sure the real path of the file is inside the home directory\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int store_asoundrc(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_ASOUNDRC_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t// make sure the real path of the file is inside the home directory\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_xauthority",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "store_xauthority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "108-136",
          "snippet": "static int store_xauthority(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfwarning(\"invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int store_xauthority(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfwarning(\"invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "homedir"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private(void) {\n\tchar *homedir = cfg.homedir;\n\tassert(homedir);\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\t// mask /home\n\tif (arg_debug)\n\t\tprintf(\"Mounting a new /home directory\\n\");\n\tif (u == 0 && arg_allusers) // allow --allusers when starting the sandbox as root\n\t\t;\n\telse {\n\t\tif (arg_allusers)\n\t\t\tfwarning(\"--allusers disabled by --private or --whitelist\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /home\");\n\t}\n\n\t// mask /root\n\tif (arg_debug)\n\t\tprintf(\"Mounting a new /root directory\\n\");\n\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\terrExit(\"mounting root directory\");\n\tfs_logger(\"tmpfs /root\");\n\n\tif (u != 0) {\n\t\t// create /home/user\n\t\tif (arg_debug)\n\t\t\tprintf(\"Create a new user directory\\n\");\n\t\tif (mkdir(homedir, S_IRWXU) == -1) {\n\t\t\tif (mkpath_as_root(homedir) == -1)\n\t\t\t\terrExit(\"mkpath\");\n\t\t\tif (mkdir(homedir, S_IRWXU) == -1 && errno != EEXIST)\n\t\t\t\terrExit(\"mkdir\");\n\t\t}\n\t\tif (chown(homedir, u, g) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger2(\"mkdir\", homedir);\n\t\tfs_logger2(\"tmpfs\", homedir);\n\t}\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n\n}"
  },
  {
    "function_name": "fs_private_homedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
    "lines": "223-292",
    "snippet": "void fs_private_homedir(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_homedir = cfg.home_private;\n\tassert(homedir);\n\tassert(private_homedir);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\n\t// mount bind private_homedir on top of homedir\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_homedir, homedir);\n\t// get a file descriptor for private_homedir, fails if there is any symlink\n\tint fd = safe_fd(private_homedir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\t// check if new home directory is owned by the user\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != getuid()) {\n\t\tfprintf(stderr, \"Error: private directory is not owned by the current user\\n\");\n\t\texit(1);\n\t}\n\tif ((S_IRWXU & s.st_mode) != S_IRWXU)\n\t\tfwarning(\"no full permissions on private directory\\n\");\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(proc, homedir, NULL, MS_NOSUID | MS_NODEV | MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(proc);\n\tclose(fd);\n\n\tfs_logger3(\"mount-bind\", private_homedir, cfg.homedir);\n\tfs_logger2(\"whitelist\", cfg.homedir);\n// preserve mode and ownership\n//\tif (chown(homedir, s.st_uid, s.st_gid) == -1)\n//\t\terrExit(\"mount-bind chown\");\n//\tif (chmod(homedir, s.st_mode) == -1)\n//\t\terrExit(\"mount-bind chmod\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /root\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /home\");\n\t}\n\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <linux/limits.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_asoundrc",
          "args": [],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "copy_asoundrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "198-216",
          "snippet": "static void copy_asoundrc(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void copy_asoundrc(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_xauthority",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "copy_xauthority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "178-196",
          "snippet": "static void copy_xauthority(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_XAUTHORITY_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void copy_xauthority(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_XAUTHORITY_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skel",
          "args": [
            "homedir",
            "u",
            "g"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "skel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "34-106",
          "snippet": "static void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\n\t// zsh\n\tif (!arg_shell_none && (strcmp(cfg.shell,\"/usr/bin/zsh\") == 0 || strcmp(cfg.shell,\"/bin/zsh\") == 0)) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.zshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// csh\n\telse if (!arg_shell_none && strcmp(cfg.shell,\"/bin/csh\") == 0) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.cshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// bash etc.\n\telse {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.bashrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\n\t// zsh\n\tif (!arg_shell_none && (strcmp(cfg.shell,\"/usr/bin/zsh\") == 0 || strcmp(cfg.shell,\"/bin/zsh\") == 0)) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.zshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// csh\n\telse if (!arg_shell_none && strcmp(cfg.shell,\"/bin/csh\") == 0) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.cshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// bash etc.\n\telse {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.bashrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"tmpfs /home\""
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting home directory\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/home\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting a new /home directory\\n\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting home directory\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/root\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME",
            "\"mode=700,gid=0\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting a new /root directory\\n\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"whitelist\"",
            "cfg.homedir"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger3",
          "args": [
            "\"mount-bind\"",
            "private_homedir",
            "cfg.homedir"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "82-89",
          "snippet": "void fs_logger3(const char *msg1, const char *msg2, const char *msg3) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %s %s\", msg1, msg2, msg3) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger3(const char *msg1, const char *msg2, const char *msg3) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %s %s\", msg1, msg2, msg3) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "proc"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "proc",
            "homedir",
            "NULL",
            "MS_NOSUID | MS_NODEV | MS_BIND | MS_REC",
            "NULL"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&proc",
            "\"/proc/self/fd/%d\"",
            "fd"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"no full permissions on private directory\\n\""
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: private directory is not owned by the current user\\n\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&s"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"safe_fd\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_fd",
          "args": [
            "private_homedir",
            "O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "safe_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1143-1209",
          "snippet": "int safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define EMPTY_STRING (\"\")"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nint safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mount-bind %s on top of %s\\n\"",
            "private_homedir",
            "homedir"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_asoundrc",
          "args": [],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "store_asoundrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "138-176",
          "snippet": "static int store_asoundrc(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_ASOUNDRC_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t// make sure the real path of the file is inside the home directory\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int store_asoundrc(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_ASOUNDRC_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t// make sure the real path of the file is inside the home directory\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_xauthority",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "store_xauthority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "108-136",
          "snippet": "static int store_xauthority(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfwarning(\"invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int store_xauthority(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfwarning(\"invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "private_homedir"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "homedir"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private_homedir(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_homedir = cfg.home_private;\n\tassert(homedir);\n\tassert(private_homedir);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\n\t// mount bind private_homedir on top of homedir\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_homedir, homedir);\n\t// get a file descriptor for private_homedir, fails if there is any symlink\n\tint fd = safe_fd(private_homedir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\t// check if new home directory is owned by the user\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != getuid()) {\n\t\tfprintf(stderr, \"Error: private directory is not owned by the current user\\n\");\n\t\texit(1);\n\t}\n\tif ((S_IRWXU & s.st_mode) != S_IRWXU)\n\t\tfwarning(\"no full permissions on private directory\\n\");\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(proc, homedir, NULL, MS_NOSUID | MS_NODEV | MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(proc);\n\tclose(fd);\n\n\tfs_logger3(\"mount-bind\", private_homedir, cfg.homedir);\n\tfs_logger2(\"whitelist\", cfg.homedir);\n// preserve mode and ownership\n//\tif (chown(homedir, s.st_uid, s.st_gid) == -1)\n//\t\terrExit(\"mount-bind chown\");\n//\tif (chmod(homedir, s.st_mode) == -1)\n//\t\terrExit(\"mount-bind chmod\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /root\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /home\");\n\t}\n\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}"
  },
  {
    "function_name": "copy_asoundrc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
    "lines": "198-216",
    "snippet": "static void copy_asoundrc(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <linux/limits.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "src"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "359-366",
          "snippet": "int unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_unlink_t orig_unlink = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_unlink_t orig_unlink = NULL;\n\nint unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"clone\"",
            "dest"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_file_as_user",
          "args": [
            "src",
            "dest",
            "getuid()",
            "getgid()",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "316-335",
          "snippet": "void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is a symbolic link\\n\"",
            "dest"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "dest"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "432-459",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dest",
            "\"%s/.asoundrc\"",
            "cfg.homedir"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void copy_asoundrc(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_ASOUNDRC_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}"
  },
  {
    "function_name": "copy_xauthority",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
    "lines": "178-196",
    "snippet": "static void copy_xauthority(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_XAUTHORITY_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <linux/limits.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "src"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "359-366",
          "snippet": "int unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_unlink_t orig_unlink = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_unlink_t orig_unlink = NULL;\n\nint unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"clone\"",
            "dest"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_file_as_user",
          "args": [
            "src",
            "dest",
            "getuid()",
            "getgid()",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "316-335",
          "snippet": "void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s is a symbolic link\\n\"",
            "dest"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "dest"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "432-459",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dest",
            "\"%s/.Xauthority\"",
            "cfg.homedir"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void copy_xauthority(void) {\n\t// copy XAUTHORITY_FILE in the new home directory\n\tchar *src = RUN_XAUTHORITY_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// if destination is a symbolic link, exit the sandbox!!!\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n\t\texit(1);\n\t}\n\n\tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user\n\tfs_logger2(\"clone\", dest);\n\n\t// delete the temporary file\n\tunlink(src);\n}"
  },
  {
    "function_name": "store_asoundrc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
    "lines": "138-176",
    "snippet": "static int store_asoundrc(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_ASOUNDRC_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t// make sure the real path of the file is inside the home directory\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <linux/limits.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"clone\"",
            "dest"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_file_as_user",
          "args": [
            "src",
            "dest",
            "getuid()",
            "getgid()",
            "0644"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "316-335",
          "snippet": "void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rp"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "rp",
            "cfg.homedir",
            "strlen(cfg.homedir)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg.homedir"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: Cannot access %s\\n\"",
            "src"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "src",
            "NULL"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "src"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "432-459",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "src",
            "&s"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&src",
            "\"%s/.asoundrc\"",
            "cfg.homedir"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "getuid()",
            "getgid()",
            "0644"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "dest",
            "\"w\""
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int store_asoundrc(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_ASOUNDRC_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t// make sure the real path of the file is inside the home directory\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "store_xauthority",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
    "lines": "108-136",
    "snippet": "static int store_xauthority(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfwarning(\"invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <linux/limits.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"clone\"",
            "dest"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_file_as_user",
          "args": [
            "src",
            "dest",
            "getuid()",
            "getgid()",
            "0600"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "316-335",
          "snippet": "void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"invalid .Xauthority file\\n\""
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "src"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "432-459",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "src",
            "&s"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&src",
            "\"%s/.Xauthority\"",
            "cfg.homedir"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "getuid()",
            "getgid()",
            "0600"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "dest",
            "\"w\""
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int store_xauthority(void) {\n\t// put a copy of .Xauthority in XAUTHORITY_FILE\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\t// create an empty file as root, and change ownership to user\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfwarning(\"invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600); // regular user\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "skel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
    "lines": "34-106",
    "snippet": "static void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\n\t// zsh\n\tif (!arg_shell_none && (strcmp(cfg.shell,\"/usr/bin/zsh\") == 0 || strcmp(cfg.shell,\"/bin/zsh\") == 0)) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.zshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// csh\n\telse if (!arg_shell_none && strcmp(cfg.shell,\"/bin/csh\") == 0) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.cshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// bash etc.\n\telse {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.bashrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <linux/limits.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"clone\"",
            "fname"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"clone /etc/skel/.bashrc\""
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_file_as_user",
          "args": [
            "\"/etc/skel/.bashrc\"",
            "fname",
            "u",
            "g",
            "0644"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "316-335",
          "snippet": "void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode); // already a regular user\n\t\tif (rv)\n\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/etc/skel/.bashrc\"",
            "&s"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid %s file\\n\"",
            "fname"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "fname"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "432-459",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/.bashrc\"",
            "homedir"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_file_as_user",
          "args": [
            "fname",
            "0644"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "touch_file_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "377-398",
          "snippet": "void touch_file_as_user(const char *fname, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tFILE *fp = fopen(fname, \"wx\");\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, -1, -1, mode);\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid touch_file_as_user(const char *fname, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tFILE *fp = fopen(fname, \"wx\");\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, -1, -1, mode);\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid %s file\\n\"",
            "fname"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/.cshrc\"",
            "homedir"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cfg.shell",
            "\"/bin/csh\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid %s file\\n\"",
            "fname"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/.zshrc\"",
            "homedir"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cfg.shell",
            "\"/bin/zsh\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cfg.shell",
            "\"/usr/bin/zsh\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\n\t// zsh\n\tif (!arg_shell_none && (strcmp(cfg.shell,\"/usr/bin/zsh\") == 0 || strcmp(cfg.shell,\"/bin/zsh\") == 0)) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.zshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// csh\n\telse if (!arg_shell_none && strcmp(cfg.shell,\"/bin/csh\") == 0) {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.cshrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\telse {\n\t\t\ttouch_file_as_user(fname, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\t// bash etc.\n\telse {\n\t\t// copy skel files\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\t// don't copy it if we already have the file\n\t\tif (stat(fname, &s) == 0)\n\t\t\treturn;\n\t\tif (is_link(fname)) { // stat on dangling symlinks fails, try again using lstat\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tcopy_file_as_user(\"/etc/skel/.bashrc\", fname, u, g, 0644); // regular user\n\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n\t\t\tfs_logger2(\"clone\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n}"
  }
]