[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/main.c",
    "lines": "23-98",
    "snippet": "int main(int argc, char **argv) {\n\t// make test-arguments helper\n\tif (getenv(\"FIREJAIL_TEST_ARGUMENTS\")) {\n\t\tprintf(\"Arguments:\\n\");\n\n\t\tint i;\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tprintf(\"#%s#\\n\", argv[i]);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tif (argc != 1) {\n\t\tint i;\n\n\t\tfor (i = 1; i < argc; i++) {\n\t\t\tif (strcmp(argv[i], \"syscall\") == 0) {\n\t\t\t\tsyscall_helper(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\tprintf(\"\\n---------------- Firejail Audit: the GOOD, the BAD and the UGLY ----------------\\n\");\n\n\t// extract program name\n\tprog = realpath(argv[0], NULL);\n\tif (prog == NULL) {\n\t\tprog = strdup(\"faudit\");\n\t\tif (!prog)\n\t\t\terrExit(\"strdup\");\n\t}\n\tprintf(\"INFO: starting %s.\\n\", prog);\n\n\n\t// check pid namespace\n\tpid_test();\n\tprintf(\"\\n\");\n\n\t// check seccomp\n\tseccomp_test();\n\tprintf(\"\\n\");\n\n\t// check capabilities\n\tcaps_test();\n\tprintf(\"\\n\");\n\n\t// check some well-known problematic files and directories\n\tfiles_test();\n\tprintf(\"\\n\");\n\n\t// network\n\tnetwork_test();\n\tprintf(\"\\n\");\n\n\t// dbus\n\tdbus_test();\n\tprintf(\"\\n\");\n\n\t// x11 test\n\tx11_test();\n\tprintf(\"\\n\");\n\n\t// /dev test\n\tdev_test();\n\tprintf(\"\\n\");\n\n\n\tfree(prog);\n\tprintf(\"--------------------------------------------------------------------------------\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"faudit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *prog;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"--------------------------------------------------------------------------------\\n\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "prog"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_test",
          "args": [],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "dev_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/dev.c",
          "lines": "23-47",
          "snippet": "void dev_test(void) {\n\tDIR *dir;\n\tif (!(dir = opendir(\"/dev\"))) {\n\t\tfprintf(stderr, \"Error: cannot open /dev directory\\n\");\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\tprintf(\"INFO: files visible in /dev directory: \");\n\tint cnt = 0;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tprintf(\"%s, \", entry->d_name);\n\t\tcnt++;\n\t}\n\tprintf(\"\\n\");\n\n\tif (cnt > 20)\n\t\tprintf(\"MAYBE: /dev directory seems to be fully populated. Use --private-dev or --whitelist to restrict the access.\\n\");\n\telse\n\t\tprintf(\"GOOD: Access to /dev directory is restricted.\\n\");\n\tclosedir(dir);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include \"faudit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include \"faudit.h\"\n\nvoid dev_test(void) {\n\tDIR *dir;\n\tif (!(dir = opendir(\"/dev\"))) {\n\t\tfprintf(stderr, \"Error: cannot open /dev directory\\n\");\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\tprintf(\"INFO: files visible in /dev directory: \");\n\tint cnt = 0;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tprintf(\"%s, \", entry->d_name);\n\t\tcnt++;\n\t}\n\tprintf(\"\\n\");\n\n\tif (cnt > 20)\n\t\tprintf(\"MAYBE: /dev directory seems to be fully populated. Use --private-dev or --whitelist to restrict the access.\\n\");\n\telse\n\t\tprintf(\"GOOD: Access to /dev directory is restricted.\\n\");\n\tclosedir(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_test",
          "args": [],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "x11_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/x11.c",
          "lines": "25-63",
          "snippet": "void x11_test(void) {\n\t// check regular display 0 sockets\n\tif (check_unix(\"/tmp/.X11-unix/X0\") == 0)\n\t\tprintf(\"MAYBE: X11 socket /tmp/.X11-unix/X0 is available\\n\");\n\n\tif (check_unix(\"@/tmp/.X11-unix/X0\") == 0)\n\t\tprintf(\"MAYBE: X11 socket @/tmp/.X11-unix/X0 is available\\n\");\n\n\t// check all unix sockets in /tmp/.X11-unix directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp/.X11-unix\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp/.X11-unix\"))) {\n\t\t\t;\n\t\t}\n\t}\n\n\tif (dir == NULL)\n\t\tprintf(\"GOOD: cannot open /tmp/.X11-unix directory\\n\");\n\telse {\n\t\tstruct dirent *entry;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tif (strcmp(entry->d_name, \"X0\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \".\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tchar *name;\n\t\t\tif (asprintf(&name, \"/tmp/.X11-unix/%s\", entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (check_unix(name) == 0)\n\t\t\t\tprintf(\"MAYBE: X11 socket %s is available\\n\", name);\n\t\t\tfree(name);\n\t\t}\n\t\tclosedir(dir);\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/socket.h>",
            "#include \"faudit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/socket.h>\n#include \"faudit.h\"\n\nvoid x11_test(void) {\n\t// check regular display 0 sockets\n\tif (check_unix(\"/tmp/.X11-unix/X0\") == 0)\n\t\tprintf(\"MAYBE: X11 socket /tmp/.X11-unix/X0 is available\\n\");\n\n\tif (check_unix(\"@/tmp/.X11-unix/X0\") == 0)\n\t\tprintf(\"MAYBE: X11 socket @/tmp/.X11-unix/X0 is available\\n\");\n\n\t// check all unix sockets in /tmp/.X11-unix directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp/.X11-unix\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp/.X11-unix\"))) {\n\t\t\t;\n\t\t}\n\t}\n\n\tif (dir == NULL)\n\t\tprintf(\"GOOD: cannot open /tmp/.X11-unix directory\\n\");\n\telse {\n\t\tstruct dirent *entry;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tif (strcmp(entry->d_name, \"X0\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \".\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tchar *name;\n\t\t\tif (asprintf(&name, \"/tmp/.X11-unix/%s\", entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (check_unix(name) == 0)\n\t\t\t\tprintf(\"MAYBE: X11 socket %s is available\\n\", name);\n\t\t\tfree(name);\n\t\t}\n\t\tclosedir(dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_test",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "dbus_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/dbus.c",
          "lines": "49-92",
          "snippet": "void dbus_test(void) {\n\t// check the session bus\n\tchar *str = getenv(\"DBUS_SESSION_BUS_ADDRESS\");\n\tif (str) {\n\t\tint rv = 0;\n\t\tchar *bus = strdup(str);\n\t\tif (!bus)\n\t\t\terrExit(\"strdup\");\n\t\tchar *sockfile;\n\t\tif ((sockfile = strstr(bus, \"unix:abstract=\")) != NULL) {\n\t\t\tsockfile += 13;\n\t\t\t*sockfile = '@';\n\t\t\tchar *ptr = strchr(sockfile, ',');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\trv = check_unix(sockfile);\n\t\t\t*sockfile = '@';\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"MAYBE: D-Bus socket %s is available\\n\", sockfile);\n\t\t\telse if (rv == -1)\n\t\t\t\tprintf(\"GOOD: cannot connect to D-Bus socket %s\\n\", sockfile);\n\t\t}\n\t\telse if ((sockfile = strstr(bus, \"unix:path=\")) != NULL) {\n\t\t\tsockfile += 10;\n\t\t\tchar *ptr = strchr(sockfile, ',');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\trv = check_unix(sockfile);\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"MAYBE: D-Bus socket %s is available\\n\", sockfile);\n\t\t\telse if (rv == -1)\n\t\t\t\tprintf(\"GOOD: cannot connect to D-Bus socket %s\\n\", sockfile);\n\t\t}\n\t\telse if ((sockfile = strstr(bus, \"tcp:host=\")) != NULL)\n\t\t\tprintf(\"UGLY: session bus configured for TCP communication.\\n\");\n\t\telse\n\t\t\tprintf(\"GOOD: cannot find a D-Bus socket\\n\");\n\n\n\t\tfree(bus);\n\t}\n\telse\n\t\tprintf(\"GOOD: DBUS_SESSION_BUS_ADDRESS environment variable not configured.\");\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include \"faudit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include <sys/socket.h>\n#include \"faudit.h\"\n\nvoid dbus_test(void) {\n\t// check the session bus\n\tchar *str = getenv(\"DBUS_SESSION_BUS_ADDRESS\");\n\tif (str) {\n\t\tint rv = 0;\n\t\tchar *bus = strdup(str);\n\t\tif (!bus)\n\t\t\terrExit(\"strdup\");\n\t\tchar *sockfile;\n\t\tif ((sockfile = strstr(bus, \"unix:abstract=\")) != NULL) {\n\t\t\tsockfile += 13;\n\t\t\t*sockfile = '@';\n\t\t\tchar *ptr = strchr(sockfile, ',');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\trv = check_unix(sockfile);\n\t\t\t*sockfile = '@';\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"MAYBE: D-Bus socket %s is available\\n\", sockfile);\n\t\t\telse if (rv == -1)\n\t\t\t\tprintf(\"GOOD: cannot connect to D-Bus socket %s\\n\", sockfile);\n\t\t}\n\t\telse if ((sockfile = strstr(bus, \"unix:path=\")) != NULL) {\n\t\t\tsockfile += 10;\n\t\t\tchar *ptr = strchr(sockfile, ',');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\trv = check_unix(sockfile);\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"MAYBE: D-Bus socket %s is available\\n\", sockfile);\n\t\t\telse if (rv == -1)\n\t\t\t\tprintf(\"GOOD: cannot connect to D-Bus socket %s\\n\", sockfile);\n\t\t}\n\t\telse if ((sockfile = strstr(bus, \"tcp:host=\")) != NULL)\n\t\t\tprintf(\"UGLY: session bus configured for TCP communication.\\n\");\n\t\telse\n\t\t\tprintf(\"GOOD: cannot find a D-Bus socket\\n\");\n\n\n\t\tfree(bus);\n\t}\n\telse\n\t\tprintf(\"GOOD: DBUS_SESSION_BUS_ADDRESS environment variable not configured.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network_test",
          "args": [],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "network_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/network.c",
          "lines": "97-101",
          "snippet": "void network_test(void) {\n\tcheck_ssh();\n\tcheck_http();\n\tcheck_netlink();\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include \"faudit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include \"faudit.h\"\n\nvoid network_test(void) {\n\tcheck_ssh();\n\tcheck_http();\n\tcheck_netlink();\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_test",
          "args": [],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "files_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/files.c",
          "lines": "44-75",
          "snippet": "void files_test(void) {\n\tstruct passwd *pw = getpwuid(getuid());\n\tif (!pw) {\n\t\tfprintf(stderr, \"Error: cannot retrieve user account information\\n\");\n\t\treturn;\n\t}\n\n\tusername = strdup(pw->pw_name);\n\tif (!username)\n\t\terrExit(\"strdup\");\n\thomedir = strdup(pw->pw_dir);\n\tif (!homedir)\n\t\terrExit(\"strdup\");\n\n\t// check access to .ssh directory\n\tcheck_home_file(\".ssh\");\n\n\t// check access to .gnupg directory\n\tcheck_home_file(\".gnupg\");\n\n\t// check access to Firefox browser directory\n\tcheck_home_file(\".mozilla\");\n\n\t// check access to Chromium browser directory\n\tcheck_home_file(\".config/chromium\");\n\n\t// check access to Debian Icedove directory\n\tcheck_home_file(\".icedove\");\n\n\t// check access to Thunderbird directory\n\tcheck_home_file(\".thunderbird\");\n}",
          "includes": [
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include \"faudit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *username = NULL;",
            "static char *homedir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pwd.h>\n#include <fcntl.h>\n#include \"faudit.h\"\n\nstatic char *username = NULL;\nstatic char *homedir = NULL;\n\nvoid files_test(void) {\n\tstruct passwd *pw = getpwuid(getuid());\n\tif (!pw) {\n\t\tfprintf(stderr, \"Error: cannot retrieve user account information\\n\");\n\t\treturn;\n\t}\n\n\tusername = strdup(pw->pw_name);\n\tif (!username)\n\t\terrExit(\"strdup\");\n\thomedir = strdup(pw->pw_dir);\n\tif (!homedir)\n\t\terrExit(\"strdup\");\n\n\t// check access to .ssh directory\n\tcheck_home_file(\".ssh\");\n\n\t// check access to .gnupg directory\n\tcheck_home_file(\".gnupg\");\n\n\t// check access to Firefox browser directory\n\tcheck_home_file(\".mozilla\");\n\n\t// check access to Chromium browser directory\n\tcheck_home_file(\".config/chromium\");\n\n\t// check access to Debian Icedove directory\n\tcheck_home_file(\".icedove\");\n\n\t// check access to Thunderbird directory\n\tcheck_home_file(\".thunderbird\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "caps_test",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "caps_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/caps.c",
          "lines": "59-78",
          "snippet": "void caps_test(void) {\n\tuint64_t caps_val;\n\n\tif (extract_caps(&caps_val)) {\n\t\tprintf(\"SKIP: cannot extract capabilities on this platform.\\n\");\n\t\treturn;\n\t}\n\n\tif (caps_val) {\n\t\tprintf(\"BAD: the capability map is %llx, it should be all zero. \", (unsigned long long) caps_val);\n\t\tprintf(\"Use \\\"firejail --caps.drop=all\\\" to fix it.\\n\");\n\n\t\tif (check_capability(caps_val, CAP_SYS_ADMIN))\n\t\t\tprintf(\"UGLY: CAP_SYS_ADMIN is enabled.\\n\");\n\t\tif (check_capability(caps_val, CAP_SYS_BOOT))\n\t\t\tprintf(\"UGLY: CAP_SYS_BOOT is enabled.\\n\");\n\t}\n\telse\n\t\tprintf(\"GOOD: all capabilities are disabled.\\n\");\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include \"faudit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include \"faudit.h\"\n\nvoid caps_test(void) {\n\tuint64_t caps_val;\n\n\tif (extract_caps(&caps_val)) {\n\t\tprintf(\"SKIP: cannot extract capabilities on this platform.\\n\");\n\t\treturn;\n\t}\n\n\tif (caps_val) {\n\t\tprintf(\"BAD: the capability map is %llx, it should be all zero. \", (unsigned long long) caps_val);\n\t\tprintf(\"Use \\\"firejail --caps.drop=all\\\" to fix it.\\n\");\n\n\t\tif (check_capability(caps_val, CAP_SYS_ADMIN))\n\t\t\tprintf(\"UGLY: CAP_SYS_ADMIN is enabled.\\n\");\n\t\tif (check_capability(caps_val, CAP_SYS_BOOT))\n\t\t\tprintf(\"UGLY: CAP_SYS_BOOT is enabled.\\n\");\n\t}\n\telse\n\t\tprintf(\"GOOD: all capabilities are disabled.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_test",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/seccomp.c",
          "lines": "44-101",
          "snippet": "void seccomp_test(void) {\n\tint seccomp_status;\n\tint rv = extract_seccomp(&seccomp_status);\n\n\tif (rv) {\n\t\tprintf(\"INFO: cannot extract seccomp configuration on this platform.\\n\");\n\t\treturn;\n\t}\n\n\tif (seccomp_status == 0) {\n\t\tprintf(\"BAD: seccomp disabled. Use \\\"firejail --seccomp\\\" to enable it.\\n\");\n\t}\n\telse if (seccomp_status == 1)\n\t\tprintf(\"GOOD: seccomp strict mode - only  read, write, _exit, and sigreturn are allowed.\\n\");\n\telse if (seccomp_status == 2) {\n\t\tprintf(\"GOOD: seccomp BPF enabled.\\n\");\n\n\t\tprintf(\"checking syscalls: \"); fflush(0);\n\t\tprintf(\"mount... \"); fflush(0);\n\t\tsyscall_run(\"mount\");\n\n\t\tprintf(\"umount2... \"); fflush(0);\n\t\tsyscall_run(\"umount2\");\n\n\t\tprintf(\"ptrace... \"); fflush(0);\n\t\tsyscall_run(\"ptrace\");\n\n\t\tprintf(\"swapon... \"); fflush(0);\n\t\tsyscall_run(\"swapon\");\n\n\t\tprintf(\"swapoff... \"); fflush(0);\n\t\tsyscall_run(\"swapoff\");\n\n\t\tprintf(\"init_module... \"); fflush(0);\n\t\tsyscall_run(\"init_module\");\n\n\t\tprintf(\"delete_module... \"); fflush(0);\n\t\tsyscall_run(\"delete_module\");\n\n\t\tprintf(\"chroot... \"); fflush(0);\n\t\tsyscall_run(\"chroot\");\n\n\t\tprintf(\"pivot_root... \"); fflush(0);\n\t\tsyscall_run(\"pivot_root\");\n\n#if defined(__i386__) || defined(__x86_64__)\n\t\tprintf(\"iopl... \"); fflush(0);\n\t\tsyscall_run(\"iopl\");\n\n\t\tprintf(\"ioperm... \"); fflush(0);\n\t\tsyscall_run(\"ioperm\");\n#endif\n\t\tprintf(\"\\n\");\n\t}\n\telse\n\t\tfprintf(stderr, \"Error: unrecognized seccomp mode\\n\");\n\n}",
          "includes": [
            "#include \"faudit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faudit.h\"\n\nvoid seccomp_test(void) {\n\tint seccomp_status;\n\tint rv = extract_seccomp(&seccomp_status);\n\n\tif (rv) {\n\t\tprintf(\"INFO: cannot extract seccomp configuration on this platform.\\n\");\n\t\treturn;\n\t}\n\n\tif (seccomp_status == 0) {\n\t\tprintf(\"BAD: seccomp disabled. Use \\\"firejail --seccomp\\\" to enable it.\\n\");\n\t}\n\telse if (seccomp_status == 1)\n\t\tprintf(\"GOOD: seccomp strict mode - only  read, write, _exit, and sigreturn are allowed.\\n\");\n\telse if (seccomp_status == 2) {\n\t\tprintf(\"GOOD: seccomp BPF enabled.\\n\");\n\n\t\tprintf(\"checking syscalls: \"); fflush(0);\n\t\tprintf(\"mount... \"); fflush(0);\n\t\tsyscall_run(\"mount\");\n\n\t\tprintf(\"umount2... \"); fflush(0);\n\t\tsyscall_run(\"umount2\");\n\n\t\tprintf(\"ptrace... \"); fflush(0);\n\t\tsyscall_run(\"ptrace\");\n\n\t\tprintf(\"swapon... \"); fflush(0);\n\t\tsyscall_run(\"swapon\");\n\n\t\tprintf(\"swapoff... \"); fflush(0);\n\t\tsyscall_run(\"swapoff\");\n\n\t\tprintf(\"init_module... \"); fflush(0);\n\t\tsyscall_run(\"init_module\");\n\n\t\tprintf(\"delete_module... \"); fflush(0);\n\t\tsyscall_run(\"delete_module\");\n\n\t\tprintf(\"chroot... \"); fflush(0);\n\t\tsyscall_run(\"chroot\");\n\n\t\tprintf(\"pivot_root... \"); fflush(0);\n\t\tsyscall_run(\"pivot_root\");\n\n#if defined(__i386__) || defined(__x86_64__)\n\t\tprintf(\"iopl... \"); fflush(0);\n\t\tsyscall_run(\"iopl\");\n\n\t\tprintf(\"ioperm... \"); fflush(0);\n\t\tsyscall_run(\"ioperm\");\n#endif\n\t\tprintf(\"\\n\");\n\t}\n\telse\n\t\tfprintf(stderr, \"Error: unrecognized seccomp mode\\n\");\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_test",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "pid_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/pid.c",
          "lines": "22-99",
          "snippet": "void pid_test(void) {\n\tchar *kern_proc[] = {\n\t\t\"kthreadd\",\n\t\t\"ksoftirqd\",\n\t\t\"kworker\",\n\t\t\"rcu_sched\",\n\t\t\"rcu_bh\",\n\t\tNULL\t// NULL terminated list\n\t};\n\tint i;\n\n\t// look at the first 10 processes\n\tint not_visible = 1;\n\tfor (i = 1; i <= 10; i++) {\n\t\tstruct stat s;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/comm\", i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// open file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// read file\n\t\tchar buf[100];\n\t\tif (fgets(buf, 10, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\tnot_visible = 0;\n\n\t\t// clean /n\n\t\tchar *ptr;\n\t\tif ((ptr = strchr(buf, '\\n')) != NULL)\n\t\t\t*ptr = '\\0';\n\n\t\t// check process name against the kernel list\n\t\tint j = 0;\n\t\twhile (kern_proc[j] != NULL) {\n\t\t\tif (strncmp(buf, kern_proc[j], strlen(kern_proc[j])) == 0) {\n\t\t\t\tfclose(fp);\n\t\t\t\tfree(fname);\n\t\t\t\tprintf(\"BAD: Process %d is not running in a PID namespace. \", getpid());\n\t\t\t\tprintf(\"Are you sure you're running in a sandbox?\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t}\n\n\tpid_t pid = getpid();\n\tif (not_visible && pid > 100)\n\t\tprintf(\"BAD: Process %d is not running in a PID namespace.\\n\", pid);\n\telse\n\t\tprintf(\"GOOD: process %d is running in a PID namespace.\\n\", pid);\n\n\t// try to guess the type of container/sandbox\n\tchar *str = getenv(\"container\");\n\tif (str)\n\t\tprintf(\"INFO: container/sandbox %s.\\n\", str);\n\telse {\n\t\tstr = getenv(\"SNAP\");\n\t\tif (str)\n\t\t\tprintf(\"INFO: this is a snap package\\n\");\n\t}\n}",
          "includes": [
            "#include \"faudit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"faudit.h\"\n\nvoid pid_test(void) {\n\tchar *kern_proc[] = {\n\t\t\"kthreadd\",\n\t\t\"ksoftirqd\",\n\t\t\"kworker\",\n\t\t\"rcu_sched\",\n\t\t\"rcu_bh\",\n\t\tNULL\t// NULL terminated list\n\t};\n\tint i;\n\n\t// look at the first 10 processes\n\tint not_visible = 1;\n\tfor (i = 1; i <= 10; i++) {\n\t\tstruct stat s;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/comm\", i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// open file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// read file\n\t\tchar buf[100];\n\t\tif (fgets(buf, 10, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\tnot_visible = 0;\n\n\t\t// clean /n\n\t\tchar *ptr;\n\t\tif ((ptr = strchr(buf, '\\n')) != NULL)\n\t\t\t*ptr = '\\0';\n\n\t\t// check process name against the kernel list\n\t\tint j = 0;\n\t\twhile (kern_proc[j] != NULL) {\n\t\t\tif (strncmp(buf, kern_proc[j], strlen(kern_proc[j])) == 0) {\n\t\t\t\tfclose(fp);\n\t\t\t\tfree(fname);\n\t\t\t\tprintf(\"BAD: Process %d is not running in a PID namespace. \", getpid());\n\t\t\t\tprintf(\"Are you sure you're running in a sandbox?\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t}\n\n\tpid_t pid = getpid();\n\tif (not_visible && pid > 100)\n\t\tprintf(\"BAD: Process %d is not running in a PID namespace.\\n\", pid);\n\telse\n\t\tprintf(\"GOOD: process %d is running in a PID namespace.\\n\", pid);\n\n\t// try to guess the type of container/sandbox\n\tchar *str = getenv(\"container\");\n\tif (str)\n\t\tprintf(\"INFO: container/sandbox %s.\\n\", str);\n\telse {\n\t\tstr = getenv(\"SNAP\");\n\t\tif (str)\n\t\t\tprintf(\"INFO: this is a snap package\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"INFO: starting %s.\\n\"",
            "prog"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"faudit\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "argv[0]",
            "NULL"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n---------------- Firejail Audit: the GOOD, the BAD and the UGLY ----------------\\n\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_helper",
          "args": [
            "argc",
            "argv"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/faudit/syscall.c",
          "lines": "34-82",
          "snippet": "void syscall_helper(int argc, char **argv) {\n\t(void) argc;\n\n\tif (argc < 3)\n\t\treturn;\n\n\tif (strcmp(argv[2], \"mount\") == 0) {\n\t\tint rv = mount(NULL, NULL, NULL, 0, NULL);\n\t\t(void) rv;\n\t\tprintf(\"\\nUGLY: mount syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"umount2\") == 0) {\n\t\tumount2(NULL, 0);\n\t\tprintf(\"\\nUGLY: umount2 syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"ptrace\") == 0) {\n\t\tptrace(0, 0, NULL, NULL);\n\t\tprintf(\"\\nUGLY: ptrace syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"swapon\") == 0) {\n\t\tswapon(NULL, 0);\n\t\tprintf(\"\\nUGLY: swapon syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"swapoff\") == 0) {\n\t\tswapoff(NULL);\n\t\tprintf(\"\\nUGLY: swapoff syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"init_module\") == 0) {\n\t\tinit_module(NULL, 0, NULL);\n\t\tprintf(\"\\nUGLY: init_module syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"delete_module\") == 0) {\n\t\tdelete_module(NULL, 0);\n\t\tprintf(\"\\nUGLY: delete_module syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"chroot\") == 0) {\n\t\tint rv = chroot(\"/blablabla-57281292\");\n\t\t(void) rv;\n\t\tprintf(\"\\nUGLY: chroot syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"pivot_root\") == 0) {\n\t\tpivot_root(NULL, NULL);\n\t\tprintf(\"\\nUGLY: pivot_root syscall permitted.\\n\");\n\t}\n#if defined(__i386__) || defined(__x86_64__)\n\telse if (strcmp(argv[2], \"iopl\") == 0) {\n\t\tiopl(0L);\n\t\tprintf(\"\\nUGLY: iopl syscall permitted.\\n\");\n\t}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/io.h>",
            "#include <sys/swap.h>",
            "#include <sys/ptrace.h>",
            "#include \"faudit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/io.h>\n#include <sys/swap.h>\n#include <sys/ptrace.h>\n#include \"faudit.h\"\n\nvoid syscall_helper(int argc, char **argv) {\n\t(void) argc;\n\n\tif (argc < 3)\n\t\treturn;\n\n\tif (strcmp(argv[2], \"mount\") == 0) {\n\t\tint rv = mount(NULL, NULL, NULL, 0, NULL);\n\t\t(void) rv;\n\t\tprintf(\"\\nUGLY: mount syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"umount2\") == 0) {\n\t\tumount2(NULL, 0);\n\t\tprintf(\"\\nUGLY: umount2 syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"ptrace\") == 0) {\n\t\tptrace(0, 0, NULL, NULL);\n\t\tprintf(\"\\nUGLY: ptrace syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"swapon\") == 0) {\n\t\tswapon(NULL, 0);\n\t\tprintf(\"\\nUGLY: swapon syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"swapoff\") == 0) {\n\t\tswapoff(NULL);\n\t\tprintf(\"\\nUGLY: swapoff syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"init_module\") == 0) {\n\t\tinit_module(NULL, 0, NULL);\n\t\tprintf(\"\\nUGLY: init_module syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"delete_module\") == 0) {\n\t\tdelete_module(NULL, 0);\n\t\tprintf(\"\\nUGLY: delete_module syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"chroot\") == 0) {\n\t\tint rv = chroot(\"/blablabla-57281292\");\n\t\t(void) rv;\n\t\tprintf(\"\\nUGLY: chroot syscall permitted.\\n\");\n\t}\n\telse if (strcmp(argv[2], \"pivot_root\") == 0) {\n\t\tpivot_root(NULL, NULL);\n\t\tprintf(\"\\nUGLY: pivot_root syscall permitted.\\n\");\n\t}\n#if defined(__i386__) || defined(__x86_64__)\n\telse if (strcmp(argv[2], \"iopl\") == 0) {\n\t\tiopl(0L);\n\t\tprintf(\"\\nUGLY: iopl syscall permitted.\\n\");\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"syscall\""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"#%s#\\n\"",
            "argv[i]"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Arguments:\\n\""
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_TEST_ARGUMENTS\""
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"faudit.h\"\n\nchar *prog;\n\nint main(int argc, char **argv) {\n\t// make test-arguments helper\n\tif (getenv(\"FIREJAIL_TEST_ARGUMENTS\")) {\n\t\tprintf(\"Arguments:\\n\");\n\n\t\tint i;\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tprintf(\"#%s#\\n\", argv[i]);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tif (argc != 1) {\n\t\tint i;\n\n\t\tfor (i = 1; i < argc; i++) {\n\t\t\tif (strcmp(argv[i], \"syscall\") == 0) {\n\t\t\t\tsyscall_helper(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\tprintf(\"\\n---------------- Firejail Audit: the GOOD, the BAD and the UGLY ----------------\\n\");\n\n\t// extract program name\n\tprog = realpath(argv[0], NULL);\n\tif (prog == NULL) {\n\t\tprog = strdup(\"faudit\");\n\t\tif (!prog)\n\t\t\terrExit(\"strdup\");\n\t}\n\tprintf(\"INFO: starting %s.\\n\", prog);\n\n\n\t// check pid namespace\n\tpid_test();\n\tprintf(\"\\n\");\n\n\t// check seccomp\n\tseccomp_test();\n\tprintf(\"\\n\");\n\n\t// check capabilities\n\tcaps_test();\n\tprintf(\"\\n\");\n\n\t// check some well-known problematic files and directories\n\tfiles_test();\n\tprintf(\"\\n\");\n\n\t// network\n\tnetwork_test();\n\tprintf(\"\\n\");\n\n\t// dbus\n\tdbus_test();\n\tprintf(\"\\n\");\n\n\t// x11 test\n\tx11_test();\n\tprintf(\"\\n\");\n\n\t// /dev test\n\tdev_test();\n\tprintf(\"\\n\");\n\n\n\tfree(prog);\n\tprintf(\"--------------------------------------------------------------------------------\\n\");\n\n\treturn 0;\n}"
  }
]