[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/main.c",
    "lines": "42-99",
    "snippet": "int main(int argc, char **argv) {\n#if 0\n{\n//system(\"cat /proc/self/status\");\nint i;\nfor (i = 0; i < argc; i++)\n        printf(\"*%s* \", argv[i]);\nprintf(\"\\n\");\n}\n#endif\n\tif (argc < 2) {\n\t\tusage();\n\t\treturn 1;\n\t}\n\n\tchar *quiet = getenv(\"FIREJAIL_QUIET\");\n\tif (quiet && strcmp(quiet, \"yes\") == 0)\n\t\targ_quiet = 1;\n\n\tif (strcmp(argv[1], \"-h\") == 0 || strcmp(argv[1], \"--help\") == 0 || strcmp(argv[1], \"-?\") ==0) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\telse if (argc == 2 && strcmp(argv[1], \"debug-syscalls\") == 0)\n\t\tsyscall_print();\n\telse if (argc == 2 && strcmp(argv[1], \"debug-errnos\") == 0)\n\t\terrno_print();\n\telse if (argc == 2 && strcmp(argv[1], \"debug-protocols\") == 0)\n\t\tprotocol_print();\n\telse if (argc == 5 && strcmp(argv[1], \"protocol\") == 0 && strcmp(argv[2], \"build\") == 0)\n\t\tprotocol_build_filter(argv[3], argv[4]);\n\telse if (argc == 4 && strcmp(argv[1], \"secondary\") == 0 && strcmp(argv[2], \"32\") == 0)\n\t\tseccomp_secondary_32(argv[3]);\n\telse if (argc == 4 && strcmp(argv[1], \"secondary\") == 0 && strcmp(argv[2], \"block\") == 0)\n\t\tseccomp_secondary_block(argv[3]);\n\telse if (argc == 3 && strcmp(argv[1], \"default\") == 0)\n\t\tseccomp_default(argv[2], 0);\n\telse if (argc == 4 && strcmp(argv[1], \"default\") == 0 && strcmp(argv[3], \"allow-debuggers\") == 0)\n\t\tseccomp_default(argv[2], 1);\n\telse if (argc == 5 && strcmp(argv[1], \"drop\") == 0)\n\t\tseccomp_drop(argv[2], argv[3], argv[4], 0);\n\telse if (argc == 6 && strcmp(argv[1], \"drop\") == 0 && strcmp(argv[5], \"allow-debuggers\") == 0)\n\t\tseccomp_drop(argv[2], argv[3], argv[4], 1);\n\telse if (argc == 6 && strcmp(argv[1], \"default\") == 0 && strcmp(argv[2], \"drop\") == 0)\n\t\tseccomp_default_drop(argv[3], argv[4], argv[5], 0);\n\telse if (argc == 7 && strcmp(argv[1], \"default\") == 0 && strcmp(argv[2], \"drop\") == 0 && strcmp(argv[6], \"allow-debuggers\") == 0)\n\t\tseccomp_default_drop(argv[3], argv[4], argv[5], 1);\n\telse if (argc == 5 && strcmp(argv[1], \"keep\") == 0)\n\t\tseccomp_keep(argv[2], argv[3], argv[4]);\n\telse if (argc == 3 && strcmp(argv[1], \"memory-deny-write-execute\") == 0)\n\t\tmemory_deny_write_execute(argv[2]);\n\telse {\n\t\tfprintf(stderr, \"Error fseccomp: invalid arguments\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int arg_quiet = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: invalid arguments\\n\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_deny_write_execute",
          "args": [
            "argv[2]"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "memory_deny_write_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
          "lines": "209-278",
          "snippet": "void memory_deny_write_execute(const char *fname) {\n\t// open file\n\tint fd = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\tfilter_init(fd);\n\n\t// build filter\n\tstatic const struct sock_filter filter[] = {\n#ifdef block_syscall\n\t\t// block old multiplexing mmap syscall for i386\n\t\tBLACKLIST(block_syscall),\n#endif\n#ifdef filter_syscall\n\t\t// block mmap(,,x|PROT_WRITE|PROT_EXEC) so W&X memory can't be created\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, filter_syscall, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_WRITE|PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_WRITE|PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n\n\t\t// block mprotect(,,PROT_EXEC) so writable memory can't be turned into executable\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_mprotect, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n\n\t\t// same for pkey_mprotect(,,PROT_EXEC), where available\n#ifdef SYS_pkey_mprotect\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_pkey_mprotect, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n\n// shmat is not implemented as a syscall on some platforms (i386, powerpc64, powerpc64le)\n#ifdef SYS_shmat\n\t\t// block shmat(,,x|SHM_EXEC) so W&X shared memory can't be created\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_shmat, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, SHM_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SHM_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n#ifdef SYS_memfd_create\n\t\t// block memfd_create as it can be used to create\n\t\t// arbitrary memory contents which can be later mapped\n\t\t// as executable\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_memfd_create, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW\n#endif\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/shm.h>",
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid memory_deny_write_execute(const char *fname) {\n\t// open file\n\tint fd = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\tfilter_init(fd);\n\n\t// build filter\n\tstatic const struct sock_filter filter[] = {\n#ifdef block_syscall\n\t\t// block old multiplexing mmap syscall for i386\n\t\tBLACKLIST(block_syscall),\n#endif\n#ifdef filter_syscall\n\t\t// block mmap(,,x|PROT_WRITE|PROT_EXEC) so W&X memory can't be created\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, filter_syscall, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_WRITE|PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_WRITE|PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n\n\t\t// block mprotect(,,PROT_EXEC) so writable memory can't be turned into executable\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_mprotect, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n\n\t\t// same for pkey_mprotect(,,PROT_EXEC), where available\n#ifdef SYS_pkey_mprotect\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_pkey_mprotect, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n\n// shmat is not implemented as a syscall on some platforms (i386, powerpc64, powerpc64le)\n#ifdef SYS_shmat\n\t\t// block shmat(,,x|SHM_EXEC) so W&X shared memory can't be created\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_shmat, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, SHM_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SHM_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n#ifdef SYS_memfd_create\n\t\t// block memfd_create as it can be used to create\n\t\t// arbitrary memory contents which can be later mapped\n\t\t// as executable\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_memfd_create, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW\n#endif\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"memory-deny-write-execute\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_keep",
          "args": [
            "argv[2]",
            "argv[3]",
            "argv[4]"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_keep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
          "lines": "166-192",
          "snippet": "void seccomp_keep(const char *fname1, const char *fname2, char *list) {\n\t(void) fname2;\n\n\t// open file for pre-exec filter\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: whitelist also @default-keep\n\tfilter_init(fd);\n\t// these syscalls are used by firejail after the seccomp filter is initialized\n\tint r;\n\tr = syscall_check_list(\"@default-keep\", filter_add_whitelist, fd, 0, NULL);\n\tassert(r == 0);\n\n\tif (syscall_check_list(list, filter_add_whitelist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\n\tfilter_end_whitelist(fd);\n\n\t// close file\n\tclose(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/shm.h>",
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid seccomp_keep(const char *fname1, const char *fname2, char *list) {\n\t(void) fname2;\n\n\t// open file for pre-exec filter\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: whitelist also @default-keep\n\tfilter_init(fd);\n\t// these syscalls are used by firejail after the seccomp filter is initialized\n\tint r;\n\tr = syscall_check_list(\"@default-keep\", filter_add_whitelist, fd, 0, NULL);\n\tassert(r == 0);\n\n\tif (syscall_check_list(list, filter_add_whitelist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\n\tfilter_end_whitelist(fd);\n\n\t// close file\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"keep\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_default_drop",
          "args": [
            "argv[3]",
            "argv[4]",
            "argv[5]",
            "1"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_default_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
          "lines": "117-164",
          "snippet": "void seccomp_default_drop(const char *fname1, const char *fname2, char *list, int allow_debuggers) {\n\tassert(fname1);\n\tassert(fname2);\n\n\t// open file\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: blacklist @default, don't blacklist\n\t// any listed syscalls in @default-keep\n\tfilter_init(fd);\n\tadd_default_list(fd, allow_debuggers);\n\tchar *prelist, *postlist;\n\tsyscalls_in_list(list, \"@default-keep\", fd, &prelist, &postlist);\n\tif (prelist)\n\t\tif (syscall_check_list(prelist, filter_add_blacklist, fd, 0, NULL)) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n\n\tif (!postlist)\n\t\treturn;\n\n\t// open file for post-exec filter\n\tfd = open(fname2, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname2);\n\t\texit(1);\n\t}\n\n\t// build post-exec filter: blacklist remaining syscalls\n\tfilter_init(fd);\n\tif (syscall_check_list(postlist, filter_add_blacklist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/shm.h>",
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid seccomp_default_drop(const char *fname1, const char *fname2, char *list, int allow_debuggers) {\n\tassert(fname1);\n\tassert(fname2);\n\n\t// open file\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: blacklist @default, don't blacklist\n\t// any listed syscalls in @default-keep\n\tfilter_init(fd);\n\tadd_default_list(fd, allow_debuggers);\n\tchar *prelist, *postlist;\n\tsyscalls_in_list(list, \"@default-keep\", fd, &prelist, &postlist);\n\tif (prelist)\n\t\tif (syscall_check_list(prelist, filter_add_blacklist, fd, 0, NULL)) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n\n\tif (!postlist)\n\t\treturn;\n\n\t// open file for post-exec filter\n\tfd = open(fname2, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname2);\n\t\texit(1);\n\t}\n\n\t// build post-exec filter: blacklist remaining syscalls\n\tfilter_init(fd);\n\tif (syscall_check_list(postlist, filter_add_blacklist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[6]",
            "\"allow-debuggers\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"drop\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"default\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"drop\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"default\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_drop",
          "args": [
            "argv[2]",
            "argv[3]",
            "argv[4]",
            "1"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
          "lines": "69-114",
          "snippet": "void seccomp_drop(const char *fname1, const char *fname2, char *list, int allow_debuggers) {\n\tassert(fname1);\n\tassert(fname2);\n\t(void) allow_debuggers; // todo: to implemnet it\n\n\t// open file for pre-exec filter\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: don't blacklist any syscalls in @default-keep\n\tfilter_init(fd);\n\tchar *prelist, *postlist;\n\tsyscalls_in_list(list, \"@default-keep\", fd, &prelist, &postlist);\n\tif (prelist)\n\t\tif (syscall_check_list(prelist, filter_add_blacklist, fd, 0, NULL)) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\tfilter_end_blacklist(fd);\n\t// close file\n\tclose(fd);\n\n\tif (!postlist)\n\t\treturn;\n\n\t// open file for post-exec filter\n\tfd = open(fname2, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname2);\n\t\texit(1);\n\t}\n\n\t// build post-exec filter: blacklist remaining syscalls\n\tfilter_init(fd);\n\tif (syscall_check_list(postlist, filter_add_blacklist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/shm.h>",
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid seccomp_drop(const char *fname1, const char *fname2, char *list, int allow_debuggers) {\n\tassert(fname1);\n\tassert(fname2);\n\t(void) allow_debuggers; // todo: to implemnet it\n\n\t// open file for pre-exec filter\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: don't blacklist any syscalls in @default-keep\n\tfilter_init(fd);\n\tchar *prelist, *postlist;\n\tsyscalls_in_list(list, \"@default-keep\", fd, &prelist, &postlist);\n\tif (prelist)\n\t\tif (syscall_check_list(prelist, filter_add_blacklist, fd, 0, NULL)) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\tfilter_end_blacklist(fd);\n\t// close file\n\tclose(fd);\n\n\tif (!postlist)\n\t\treturn;\n\n\t// open file for post-exec filter\n\tfd = open(fname2, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname2);\n\t\texit(1);\n\t}\n\n\t// build post-exec filter: blacklist remaining syscalls\n\tfilter_init(fd);\n\tif (syscall_check_list(postlist, filter_add_blacklist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[5]",
            "\"allow-debuggers\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"drop\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"drop\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_default",
          "args": [
            "argv[2]",
            "1"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
          "lines": "49-66",
          "snippet": "void seccomp_default(const char *fname, int allow_debuggers) {\n\tassert(fname);\n\n\t// open file\n\tint fd = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// build filter (no post-exec filter needed because default list is fine for us)\n\tfilter_init(fd);\n\tadd_default_list(fd, allow_debuggers);\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/shm.h>",
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid seccomp_default(const char *fname, int allow_debuggers) {\n\tassert(fname);\n\n\t// open file\n\tint fd = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// build filter (no post-exec filter needed because default list is fine for us)\n\tfilter_init(fd);\n\tadd_default_list(fd, allow_debuggers);\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[3]",
            "\"allow-debuggers\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"default\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"default\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_secondary_block",
          "args": [
            "argv[3]"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_secondary_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_secondary.c",
          "lines": "122-152",
          "snippet": "void seccomp_secondary_block(const char *fname) {\n\tstruct sock_filter filter[] = {\n\t\t// block other architectures\n\t\tVALIDATE_ARCHITECTURE_KILL,\n\t\tEXAMINE_SYSCALL,\n#if defined(__x86_64__)\n\t\t// block x32\n\t\tHANDLE_X32_KILL,\n#endif\n\t\t// block personality(2) where domain != PER_LINUX or 0xffffffff (query current personality)\n\t\t// 0: if  personality(2), continue to 1, else goto 7 (allow)\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, SYS_personality, 0, jmp_from_to(0, 7)),\n\t\t// 1: get LSW of system call argument 0\n\t\tBPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(struct seccomp_data, args[0])) + LSW),\n\t\t// 2: if LSW(arg0) == PER_LINUX, goto step 4, else continue to 3\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, PER_LINUX, jmp_from_to(2, 4), 0),\n\t\t// 3: if LSW(arg0) == 0xffffffff, continue to 4, else goto 6 (kill)\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0xffffffff, 0, jmp_from_to(3, 6)),\n\t\t// 4: get MSW of system call argument 0\n\t\tBPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(struct seccomp_data, args[0])) + MSW),\n\t\t// 5: if MSW(arg0) == 0, goto 7 (allow) else continue to 6 (kill)\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0, jmp_from_to(5, 7), 0),\n\t\t// 6:\n\t\tKILL_PROCESS,\n\t\t// 7:\n\t\tRETURN_ALLOW\n\t};\n\n\t// save filter to file\n\twrite_filter(fname, sizeof(filter), filter);\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <sys/personality.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [
            "#define LSW 0",
            "#define MSW (sizeof(int))",
            "#define LSW (sizeof(int))",
            "#define MSW 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <sys/personality.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\n#define LSW 0\n#define MSW (sizeof(int))\n#define LSW (sizeof(int))\n#define MSW 0\n\nvoid seccomp_secondary_block(const char *fname) {\n\tstruct sock_filter filter[] = {\n\t\t// block other architectures\n\t\tVALIDATE_ARCHITECTURE_KILL,\n\t\tEXAMINE_SYSCALL,\n#if defined(__x86_64__)\n\t\t// block x32\n\t\tHANDLE_X32_KILL,\n#endif\n\t\t// block personality(2) where domain != PER_LINUX or 0xffffffff (query current personality)\n\t\t// 0: if  personality(2), continue to 1, else goto 7 (allow)\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, SYS_personality, 0, jmp_from_to(0, 7)),\n\t\t// 1: get LSW of system call argument 0\n\t\tBPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(struct seccomp_data, args[0])) + LSW),\n\t\t// 2: if LSW(arg0) == PER_LINUX, goto step 4, else continue to 3\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, PER_LINUX, jmp_from_to(2, 4), 0),\n\t\t// 3: if LSW(arg0) == 0xffffffff, continue to 4, else goto 6 (kill)\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0xffffffff, 0, jmp_from_to(3, 6)),\n\t\t// 4: get MSW of system call argument 0\n\t\tBPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(struct seccomp_data, args[0])) + MSW),\n\t\t// 5: if MSW(arg0) == 0, goto 7 (allow) else continue to 6 (kill)\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0, jmp_from_to(5, 7), 0),\n\t\t// 6:\n\t\tKILL_PROCESS,\n\t\t// 7:\n\t\tRETURN_ALLOW\n\t};\n\n\t// save filter to file\n\twrite_filter(fname, sizeof(filter), filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"block\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"secondary\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_secondary_32",
          "args": [
            "argv[3]"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_secondary_32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_secondary.c",
          "lines": "47-110",
          "snippet": "void seccomp_secondary_32(const char *fname) {\n\t// hardcoded syscall values\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE_32,\n\t\tEXAMINE_SYSCALL,\n\t\tBLACKLIST(21), // mount\n\t\tBLACKLIST(52), // umount2\n// todo: implement --allow-debuggers\n\t\tBLACKLIST(26), // ptrace\n\t\tBLACKLIST(283), // kexec_load\n\t\tBLACKLIST(341), // name_to_handle_at\n\t\tBLACKLIST(342), // open_by_handle_at\n\t\tBLACKLIST(127), // create_module\n\t\tBLACKLIST(128), // init_module\n\t\tBLACKLIST(350), // finit_module\n\t\tBLACKLIST(129), // delete_module\n\t\tBLACKLIST(110), // iopl\n\t\tBLACKLIST(101), // ioperm\n\t\tBLACKLIST(289), // ioprio_set\n\t\tBLACKLIST(87), // swapon\n\t\tBLACKLIST(115), // swapoff\n\t\tBLACKLIST(103), // syslog\n\t\tBLACKLIST(347), // process_vm_readv\n\t\tBLACKLIST(348), // process_vm_writev\n\t\tBLACKLIST(135), // sysfs\n\t\tBLACKLIST(149), // _sysctl\n\t\tBLACKLIST(124), // adjtimex\n\t\tBLACKLIST(343), // clock_adjtime\n\t\tBLACKLIST(253), // lookup_dcookie\n\t\tBLACKLIST(336), // perf_event_open\n\t\tBLACKLIST(338), // fanotify_init\n\t\tBLACKLIST(349), // kcmp\n\t\tBLACKLIST(286), // add_key\n\t\tBLACKLIST(287), // request_key\n\t\tBLACKLIST(288), // keyctl\n\t\tBLACKLIST(86), // uselib\n\t\tBLACKLIST(51), // acct\n\t\tBLACKLIST(123), // modify_ldt\n\t\tBLACKLIST(217), // pivot_root\n\t\tBLACKLIST(245), // io_setup\n\t\tBLACKLIST(246), // io_destroy\n\t\tBLACKLIST(247), // io_getevents\n\t\tBLACKLIST(248), // io_submit\n\t\tBLACKLIST(249), // io_cancel\n\t\tBLACKLIST(257), // remap_file_pages\n\t\tBLACKLIST(274), // mbind\n// breaking Firefox nightly when playing youtube videos\n// TODO: test again when firefox sandbox is finally released\n//\t\tBLACKLIST(275), // get_mempolicy\n\t\tBLACKLIST(276), // set_mempolicy\n\t\tBLACKLIST(294), // migrate_pages\n\t\tBLACKLIST(317), // move_pages\n\t\tBLACKLIST(316), // vmsplice\n\t\tBLACKLIST(61),  // chroot\n\t\tBLACKLIST(88), // reboot\n\t\tBLACKLIST(169), // nfsservctl\n\t\tBLACKLIST(130), // get_kernel_syms\n\n\t\tRETURN_ALLOW\n\t};\n\n\t// save filter to file\n\twrite_filter(fname, sizeof(filter), filter);\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <sys/personality.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <sys/personality.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid seccomp_secondary_32(const char *fname) {\n\t// hardcoded syscall values\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE_32,\n\t\tEXAMINE_SYSCALL,\n\t\tBLACKLIST(21), // mount\n\t\tBLACKLIST(52), // umount2\n// todo: implement --allow-debuggers\n\t\tBLACKLIST(26), // ptrace\n\t\tBLACKLIST(283), // kexec_load\n\t\tBLACKLIST(341), // name_to_handle_at\n\t\tBLACKLIST(342), // open_by_handle_at\n\t\tBLACKLIST(127), // create_module\n\t\tBLACKLIST(128), // init_module\n\t\tBLACKLIST(350), // finit_module\n\t\tBLACKLIST(129), // delete_module\n\t\tBLACKLIST(110), // iopl\n\t\tBLACKLIST(101), // ioperm\n\t\tBLACKLIST(289), // ioprio_set\n\t\tBLACKLIST(87), // swapon\n\t\tBLACKLIST(115), // swapoff\n\t\tBLACKLIST(103), // syslog\n\t\tBLACKLIST(347), // process_vm_readv\n\t\tBLACKLIST(348), // process_vm_writev\n\t\tBLACKLIST(135), // sysfs\n\t\tBLACKLIST(149), // _sysctl\n\t\tBLACKLIST(124), // adjtimex\n\t\tBLACKLIST(343), // clock_adjtime\n\t\tBLACKLIST(253), // lookup_dcookie\n\t\tBLACKLIST(336), // perf_event_open\n\t\tBLACKLIST(338), // fanotify_init\n\t\tBLACKLIST(349), // kcmp\n\t\tBLACKLIST(286), // add_key\n\t\tBLACKLIST(287), // request_key\n\t\tBLACKLIST(288), // keyctl\n\t\tBLACKLIST(86), // uselib\n\t\tBLACKLIST(51), // acct\n\t\tBLACKLIST(123), // modify_ldt\n\t\tBLACKLIST(217), // pivot_root\n\t\tBLACKLIST(245), // io_setup\n\t\tBLACKLIST(246), // io_destroy\n\t\tBLACKLIST(247), // io_getevents\n\t\tBLACKLIST(248), // io_submit\n\t\tBLACKLIST(249), // io_cancel\n\t\tBLACKLIST(257), // remap_file_pages\n\t\tBLACKLIST(274), // mbind\n// breaking Firefox nightly when playing youtube videos\n// TODO: test again when firefox sandbox is finally released\n//\t\tBLACKLIST(275), // get_mempolicy\n\t\tBLACKLIST(276), // set_mempolicy\n\t\tBLACKLIST(294), // migrate_pages\n\t\tBLACKLIST(317), // move_pages\n\t\tBLACKLIST(316), // vmsplice\n\t\tBLACKLIST(61),  // chroot\n\t\tBLACKLIST(88), // reboot\n\t\tBLACKLIST(169), // nfsservctl\n\t\tBLACKLIST(130), // get_kernel_syms\n\n\t\tRETURN_ALLOW\n\t};\n\n\t// save filter to file\n\twrite_filter(fname, sizeof(filter), filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"32\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"secondary\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "protocol_build_filter",
          "args": [
            "argv[3]",
            "argv[4]"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "protocol_build_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/protocol.c",
          "lines": "109-224",
          "snippet": "void protocol_build_filter(const char *prlist, const char *fname) {\n\tassert(prlist);\n\tassert(fname);\n\n#ifndef SYS_socket\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fseccomp: --protocol not supported on this platform\\n\");\n\treturn;\n#else\n\t// build the filter\n\tstruct sock_filter filter[32];\t// big enough\n\tmemset(&filter[0], 0, sizeof(filter));\n\tuint8_t *ptr = (uint8_t *) &filter[0];\n\n\t// header\n\tstruct sock_filter filter_start[] = {\n\t\tVALIDATE_ARCHITECTURE,\n\t\tEXAMINE_SYSCALL,\n\t\tONLY(SYS_socket),\n\t\tEXAMINE_ARGUMENT(0)\n\t};\n\tmemcpy(ptr, &filter_start[0], sizeof(filter_start));\n\tptr += sizeof(filter_start);\n\n#if 0\nprintf(\"entries %u\\n\", (unsigned) (sizeof(filter_start) / sizeof(struct sock_filter)));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\nprintf(\"whitelist_len %u, struct sock_filter len %u\\n\", whitelist_len, (unsigned) sizeof(struct sock_filter));\n#endif\n\n\n\t// parse list and add commands\n\tchar *tmplist = strdup(prlist);\n\tif (!tmplist)\n\t\terrExit(\"strdup\");\n\tchar *token = strtok(tmplist, \",\");\n\tif (!token)\n\t\terrExit(\"strtok\");\n\n\twhile (token) {\n\t\tstruct sock_filter *domain = find_protocol_domain(token);\n\t\tif (domain == NULL) {\n\t\t\tfprintf(stderr, \"Error fseccomp: %s is not a valid protocol\\n\", token);\n\t\t\texit(1);\n\t\t}\n\t\tmemcpy(ptr, domain, whitelist_len * sizeof(struct sock_filter));\n\t\tptr += whitelist_len * sizeof(struct sock_filter);\n\t\ttoken = strtok(NULL, \",\");\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\n\n\n\t}\n\tfree(tmplist);\n\n\t// add end of filter\n\tstruct sock_filter filter_end[] = {\n\t\tRETURN_ERRNO(ENOTSUP)\n\t};\n\tmemcpy(ptr, &filter_end[0], sizeof(filter_end));\n\tptr += sizeof(filter_end);\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\n\t// save filter to file\n\tint dst = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\tint size = (int) ((uintptr_t) ptr - (uintptr_t) (filter));\n\tint written = 0;\n\twhile (written < size) {\n\t\tint rv = write(dst, (unsigned char *) filter + written, size - written);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot write %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\twritten += rv;\n\t}\n\tclose(dst);\n#endif // SYS_socket\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};",
            "unsigned whitelist_len = sizeof(whitelist) / sizeof(struct sock_filter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nstatic char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};\nunsigned whitelist_len = sizeof(whitelist) / sizeof(struct sock_filter);\n\nvoid protocol_build_filter(const char *prlist, const char *fname) {\n\tassert(prlist);\n\tassert(fname);\n\n#ifndef SYS_socket\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fseccomp: --protocol not supported on this platform\\n\");\n\treturn;\n#else\n\t// build the filter\n\tstruct sock_filter filter[32];\t// big enough\n\tmemset(&filter[0], 0, sizeof(filter));\n\tuint8_t *ptr = (uint8_t *) &filter[0];\n\n\t// header\n\tstruct sock_filter filter_start[] = {\n\t\tVALIDATE_ARCHITECTURE,\n\t\tEXAMINE_SYSCALL,\n\t\tONLY(SYS_socket),\n\t\tEXAMINE_ARGUMENT(0)\n\t};\n\tmemcpy(ptr, &filter_start[0], sizeof(filter_start));\n\tptr += sizeof(filter_start);\n\n#if 0\nprintf(\"entries %u\\n\", (unsigned) (sizeof(filter_start) / sizeof(struct sock_filter)));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\nprintf(\"whitelist_len %u, struct sock_filter len %u\\n\", whitelist_len, (unsigned) sizeof(struct sock_filter));\n#endif\n\n\n\t// parse list and add commands\n\tchar *tmplist = strdup(prlist);\n\tif (!tmplist)\n\t\terrExit(\"strdup\");\n\tchar *token = strtok(tmplist, \",\");\n\tif (!token)\n\t\terrExit(\"strtok\");\n\n\twhile (token) {\n\t\tstruct sock_filter *domain = find_protocol_domain(token);\n\t\tif (domain == NULL) {\n\t\t\tfprintf(stderr, \"Error fseccomp: %s is not a valid protocol\\n\", token);\n\t\t\texit(1);\n\t\t}\n\t\tmemcpy(ptr, domain, whitelist_len * sizeof(struct sock_filter));\n\t\tptr += whitelist_len * sizeof(struct sock_filter);\n\t\ttoken = strtok(NULL, \",\");\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\n\n\n\t}\n\tfree(tmplist);\n\n\t// add end of filter\n\tstruct sock_filter filter_end[] = {\n\t\tRETURN_ERRNO(ENOTSUP)\n\t};\n\tmemcpy(ptr, &filter_end[0], sizeof(filter_end));\n\tptr += sizeof(filter_end);\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\n\t// save filter to file\n\tint dst = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\tint size = (int) ((uintptr_t) ptr - (uintptr_t) (filter));\n\tint written = 0;\n\twhile (written < size) {\n\t\tint rv = write(dst, (unsigned char *) filter + written, size - written);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot write %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\twritten += rv;\n\t}\n\tclose(dst);\n#endif // SYS_socket\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"build\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"protocol\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "protocol_print",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "protocol_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/protocol.c",
          "lines": "93-106",
          "snippet": "void protocol_print(void) {\n#ifndef SYS_socket\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fseccomp: firejail --protocol not supported on this platform\\n\");\n\treturn;\n#endif\n\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tprintf(\"%s, \", protocol[i]);\n\t\ti++;\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nstatic char *protocol[] = {\n\t\"unix\",\n\t\"inet\",\n\t\"inet6\",\n\t\"netlink\",\n\t\"packet\",\n\tNULL\n};\n\nvoid protocol_print(void) {\n#ifndef SYS_socket\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fseccomp: firejail --protocol not supported on this platform\\n\");\n\treturn;\n#endif\n\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tprintf(\"%s, \", protocol[i]);\n\t\ti++;\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"debug-protocols\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errno_print",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "errno_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/errno.c",
          "lines": "197-204",
          "snippet": "void errno_print(void) {\n\tint i;\n\tint elems = sizeof(errnolist) / sizeof(errnolist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tprintf(\"%d\\t- %s\\n\", errnolist[i].nr, errnolist[i].name);\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <errno.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrnoEntry errnolist[] = {\n//\n// code generated using tools/extract-errnos\n//\n\t{\"EPERM\", EPERM},\n\t{\"ENOENT\", ENOENT},\n\t{\"ESRCH\", ESRCH},\n\t{\"EINTR\", EINTR},\n\t{\"EIO\", EIO},\n\t{\"ENXIO\", ENXIO},\n\t{\"E2BIG\", E2BIG},\n\t{\"ENOEXEC\", ENOEXEC},\n\t{\"EBADF\", EBADF},\n\t{\"ECHILD\", ECHILD},\n\t{\"EAGAIN\", EAGAIN},\n\t{\"ENOMEM\", ENOMEM},\n\t{\"EACCES\", EACCES},\n\t{\"EFAULT\", EFAULT},\n\t{\"ENOTBLK\", ENOTBLK},\n\t{\"EBUSY\", EBUSY},\n\t{\"EEXIST\", EEXIST},\n\t{\"EXDEV\", EXDEV},\n\t{\"ENODEV\", ENODEV},\n\t{\"ENOTDIR\", ENOTDIR},\n\t{\"EISDIR\", EISDIR},\n\t{\"EINVAL\", EINVAL},\n\t{\"ENFILE\", ENFILE},\n\t{\"EMFILE\", EMFILE},\n\t{\"ENOTTY\", ENOTTY},\n\t{\"ETXTBSY\", ETXTBSY},\n\t{\"EFBIG\", EFBIG},\n\t{\"ENOSPC\", ENOSPC},\n\t{\"ESPIPE\", ESPIPE},\n\t{\"EROFS\", EROFS},\n\t{\"EMLINK\", EMLINK},\n\t{\"EPIPE\", EPIPE},\n\t{\"EDOM\", EDOM},\n\t{\"ERANGE\", ERANGE},\n\t{\"EDEADLK\", EDEADLK},\n\t{\"ENAMETOOLONG\", ENAMETOOLONG},\n\t{\"ENOLCK\", ENOLCK},\n\t{\"ENOSYS\", ENOSYS},\n\t{\"ENOTEMPTY\", ENOTEMPTY},\n\t{\"ELOOP\", ELOOP},\n\t{\"EWOULDBLOCK\", EWOULDBLOCK},\n\t{\"ENOMSG\", ENOMSG},\n\t{\"EIDRM\", EIDRM},\n\t{\"ECHRNG\", ECHRNG},\n\t{\"EL2NSYNC\", EL2NSYNC},\n\t{\"EL3HLT\", EL3HLT},\n\t{\"EL3RST\", EL3RST},\n\t{\"ELNRNG\", ELNRNG},\n\t{\"EUNATCH\", EUNATCH},\n\t{\"ENOCSI\", ENOCSI},\n\t{\"EL2HLT\", EL2HLT},\n\t{\"EBADE\", EBADE},\n\t{\"EBADR\", EBADR},\n\t{\"EXFULL\", EXFULL},\n\t{\"ENOANO\", ENOANO},\n\t{\"EBADRQC\", EBADRQC},\n\t{\"EBADSLT\", EBADSLT},\n\t{\"EDEADLOCK\", EDEADLOCK},\n\t{\"EBFONT\", EBFONT},\n\t{\"ENOSTR\", ENOSTR},\n\t{\"ENODATA\", ENODATA},\n\t{\"ETIME\", ETIME},\n\t{\"ENOSR\", ENOSR},\n\t{\"ENONET\", ENONET},\n\t{\"ENOPKG\", ENOPKG},\n\t{\"EREMOTE\", EREMOTE},\n\t{\"ENOLINK\", ENOLINK},\n\t{\"EADV\", EADV},\n\t{\"ESRMNT\", ESRMNT},\n\t{\"ECOMM\", ECOMM},\n\t{\"EPROTO\", EPROTO},\n\t{\"EMULTIHOP\", EMULTIHOP},\n\t{\"EDOTDOT\", EDOTDOT},\n\t{\"EBADMSG\", EBADMSG},\n\t{\"EOVERFLOW\", EOVERFLOW},\n\t{\"ENOTUNIQ\", ENOTUNIQ},\n\t{\"EBADFD\", EBADFD},\n\t{\"EREMCHG\", EREMCHG},\n\t{\"ELIBACC\", ELIBACC},\n\t{\"ELIBBAD\", ELIBBAD},\n\t{\"ELIBSCN\", ELIBSCN},\n\t{\"ELIBMAX\", ELIBMAX},\n\t{\"ELIBEXEC\", ELIBEXEC},\n\t{\"EILSEQ\", EILSEQ},\n\t{\"ERESTART\", ERESTART},\n\t{\"ESTRPIPE\", ESTRPIPE},\n\t{\"EUSERS\", EUSERS},\n\t{\"ENOTSOCK\", ENOTSOCK},\n\t{\"EDESTADDRREQ\", EDESTADDRREQ},\n\t{\"EMSGSIZE\", EMSGSIZE},\n\t{\"EPROTOTYPE\", EPROTOTYPE},\n\t{\"ENOPROTOOPT\", ENOPROTOOPT},\n\t{\"EPROTONOSUPPORT\", EPROTONOSUPPORT},\n\t{\"ESOCKTNOSUPPORT\", ESOCKTNOSUPPORT},\n\t{\"EOPNOTSUPP\", EOPNOTSUPP},\n\t{\"EPFNOSUPPORT\", EPFNOSUPPORT},\n\t{\"EAFNOSUPPORT\", EAFNOSUPPORT},\n\t{\"EADDRINUSE\", EADDRINUSE},\n\t{\"EADDRNOTAVAIL\", EADDRNOTAVAIL},\n\t{\"ENETDOWN\", ENETDOWN},\n\t{\"ENETUNREACH\", ENETUNREACH},\n\t{\"ENETRESET\", ENETRESET},\n\t{\"ECONNABORTED\", ECONNABORTED},\n\t{\"ECONNRESET\", ECONNRESET},\n\t{\"ENOBUFS\", ENOBUFS},\n\t{\"EISCONN\", EISCONN},\n\t{\"ENOTCONN\", ENOTCONN},\n\t{\"ESHUTDOWN\", ESHUTDOWN},\n\t{\"ETOOMANYREFS\", ETOOMANYREFS},\n\t{\"ETIMEDOUT\", ETIMEDOUT},\n\t{\"ECONNREFUSED\", ECONNREFUSED},\n\t{\"EHOSTDOWN\", EHOSTDOWN},\n\t{\"EHOSTUNREACH\", EHOSTUNREACH},\n\t{\"EALREADY\", EALREADY},\n\t{\"EINPROGRESS\", EINPROGRESS},\n\t{\"ESTALE\", ESTALE},\n\t{\"EUCLEAN\", EUCLEAN},\n\t{\"ENOTNAM\", ENOTNAM},\n\t{\"ENAVAIL\", ENAVAIL},\n\t{\"EISNAM\", EISNAM},\n\t{\"EREMOTEIO\", EREMOTEIO},\n\t{\"EDQUOT\", EDQUOT},\n\t{\"ENOMEDIUM\", ENOMEDIUM},\n\t{\"EMEDIUMTYPE\", EMEDIUMTYPE},\n\t{\"ECANCELED\", ECANCELED},\n\t{\"ENOKEY\", ENOKEY},\n\t{\"EKEYEXPIRED\", EKEYEXPIRED},\n\t{\"EKEYREVOKED\", EKEYREVOKED},\n\t{\"EKEYREJECTED\", EKEYREJECTED},\n\t{\"EOWNERDEAD\", EOWNERDEAD},\n\t{\"ENOTRECOVERABLE\", ENOTRECOVERABLE},\n\t{\"ERFKILL\", ERFKILL},\n\t{\"EHWPOISON\", EHWPOISON},\n\t{\"ENOTSUP\", ENOTSUP},\n#ifdef \tENOATTR\n\t{\"ENOATTR\", ENOATTR},\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include \"fseccomp.h\"\n\nstatic ErrnoEntry errnolist[] = {\n//\n// code generated using tools/extract-errnos\n//\n\t{\"EPERM\", EPERM},\n\t{\"ENOENT\", ENOENT},\n\t{\"ESRCH\", ESRCH},\n\t{\"EINTR\", EINTR},\n\t{\"EIO\", EIO},\n\t{\"ENXIO\", ENXIO},\n\t{\"E2BIG\", E2BIG},\n\t{\"ENOEXEC\", ENOEXEC},\n\t{\"EBADF\", EBADF},\n\t{\"ECHILD\", ECHILD},\n\t{\"EAGAIN\", EAGAIN},\n\t{\"ENOMEM\", ENOMEM},\n\t{\"EACCES\", EACCES},\n\t{\"EFAULT\", EFAULT},\n\t{\"ENOTBLK\", ENOTBLK},\n\t{\"EBUSY\", EBUSY},\n\t{\"EEXIST\", EEXIST},\n\t{\"EXDEV\", EXDEV},\n\t{\"ENODEV\", ENODEV},\n\t{\"ENOTDIR\", ENOTDIR},\n\t{\"EISDIR\", EISDIR},\n\t{\"EINVAL\", EINVAL},\n\t{\"ENFILE\", ENFILE},\n\t{\"EMFILE\", EMFILE},\n\t{\"ENOTTY\", ENOTTY},\n\t{\"ETXTBSY\", ETXTBSY},\n\t{\"EFBIG\", EFBIG},\n\t{\"ENOSPC\", ENOSPC},\n\t{\"ESPIPE\", ESPIPE},\n\t{\"EROFS\", EROFS},\n\t{\"EMLINK\", EMLINK},\n\t{\"EPIPE\", EPIPE},\n\t{\"EDOM\", EDOM},\n\t{\"ERANGE\", ERANGE},\n\t{\"EDEADLK\", EDEADLK},\n\t{\"ENAMETOOLONG\", ENAMETOOLONG},\n\t{\"ENOLCK\", ENOLCK},\n\t{\"ENOSYS\", ENOSYS},\n\t{\"ENOTEMPTY\", ENOTEMPTY},\n\t{\"ELOOP\", ELOOP},\n\t{\"EWOULDBLOCK\", EWOULDBLOCK},\n\t{\"ENOMSG\", ENOMSG},\n\t{\"EIDRM\", EIDRM},\n\t{\"ECHRNG\", ECHRNG},\n\t{\"EL2NSYNC\", EL2NSYNC},\n\t{\"EL3HLT\", EL3HLT},\n\t{\"EL3RST\", EL3RST},\n\t{\"ELNRNG\", ELNRNG},\n\t{\"EUNATCH\", EUNATCH},\n\t{\"ENOCSI\", ENOCSI},\n\t{\"EL2HLT\", EL2HLT},\n\t{\"EBADE\", EBADE},\n\t{\"EBADR\", EBADR},\n\t{\"EXFULL\", EXFULL},\n\t{\"ENOANO\", ENOANO},\n\t{\"EBADRQC\", EBADRQC},\n\t{\"EBADSLT\", EBADSLT},\n\t{\"EDEADLOCK\", EDEADLOCK},\n\t{\"EBFONT\", EBFONT},\n\t{\"ENOSTR\", ENOSTR},\n\t{\"ENODATA\", ENODATA},\n\t{\"ETIME\", ETIME},\n\t{\"ENOSR\", ENOSR},\n\t{\"ENONET\", ENONET},\n\t{\"ENOPKG\", ENOPKG},\n\t{\"EREMOTE\", EREMOTE},\n\t{\"ENOLINK\", ENOLINK},\n\t{\"EADV\", EADV},\n\t{\"ESRMNT\", ESRMNT},\n\t{\"ECOMM\", ECOMM},\n\t{\"EPROTO\", EPROTO},\n\t{\"EMULTIHOP\", EMULTIHOP},\n\t{\"EDOTDOT\", EDOTDOT},\n\t{\"EBADMSG\", EBADMSG},\n\t{\"EOVERFLOW\", EOVERFLOW},\n\t{\"ENOTUNIQ\", ENOTUNIQ},\n\t{\"EBADFD\", EBADFD},\n\t{\"EREMCHG\", EREMCHG},\n\t{\"ELIBACC\", ELIBACC},\n\t{\"ELIBBAD\", ELIBBAD},\n\t{\"ELIBSCN\", ELIBSCN},\n\t{\"ELIBMAX\", ELIBMAX},\n\t{\"ELIBEXEC\", ELIBEXEC},\n\t{\"EILSEQ\", EILSEQ},\n\t{\"ERESTART\", ERESTART},\n\t{\"ESTRPIPE\", ESTRPIPE},\n\t{\"EUSERS\", EUSERS},\n\t{\"ENOTSOCK\", ENOTSOCK},\n\t{\"EDESTADDRREQ\", EDESTADDRREQ},\n\t{\"EMSGSIZE\", EMSGSIZE},\n\t{\"EPROTOTYPE\", EPROTOTYPE},\n\t{\"ENOPROTOOPT\", ENOPROTOOPT},\n\t{\"EPROTONOSUPPORT\", EPROTONOSUPPORT},\n\t{\"ESOCKTNOSUPPORT\", ESOCKTNOSUPPORT},\n\t{\"EOPNOTSUPP\", EOPNOTSUPP},\n\t{\"EPFNOSUPPORT\", EPFNOSUPPORT},\n\t{\"EAFNOSUPPORT\", EAFNOSUPPORT},\n\t{\"EADDRINUSE\", EADDRINUSE},\n\t{\"EADDRNOTAVAIL\", EADDRNOTAVAIL},\n\t{\"ENETDOWN\", ENETDOWN},\n\t{\"ENETUNREACH\", ENETUNREACH},\n\t{\"ENETRESET\", ENETRESET},\n\t{\"ECONNABORTED\", ECONNABORTED},\n\t{\"ECONNRESET\", ECONNRESET},\n\t{\"ENOBUFS\", ENOBUFS},\n\t{\"EISCONN\", EISCONN},\n\t{\"ENOTCONN\", ENOTCONN},\n\t{\"ESHUTDOWN\", ESHUTDOWN},\n\t{\"ETOOMANYREFS\", ETOOMANYREFS},\n\t{\"ETIMEDOUT\", ETIMEDOUT},\n\t{\"ECONNREFUSED\", ECONNREFUSED},\n\t{\"EHOSTDOWN\", EHOSTDOWN},\n\t{\"EHOSTUNREACH\", EHOSTUNREACH},\n\t{\"EALREADY\", EALREADY},\n\t{\"EINPROGRESS\", EINPROGRESS},\n\t{\"ESTALE\", ESTALE},\n\t{\"EUCLEAN\", EUCLEAN},\n\t{\"ENOTNAM\", ENOTNAM},\n\t{\"ENAVAIL\", ENAVAIL},\n\t{\"EISNAM\", EISNAM},\n\t{\"EREMOTEIO\", EREMOTEIO},\n\t{\"EDQUOT\", EDQUOT},\n\t{\"ENOMEDIUM\", ENOMEDIUM},\n\t{\"EMEDIUMTYPE\", EMEDIUMTYPE},\n\t{\"ECANCELED\", ECANCELED},\n\t{\"ENOKEY\", ENOKEY},\n\t{\"EKEYEXPIRED\", EKEYEXPIRED},\n\t{\"EKEYREVOKED\", EKEYREVOKED},\n\t{\"EKEYREJECTED\", EKEYREJECTED},\n\t{\"EOWNERDEAD\", EOWNERDEAD},\n\t{\"ENOTRECOVERABLE\", ENOTRECOVERABLE},\n\t{\"ERFKILL\", ERFKILL},\n\t{\"EHWPOISON\", EHWPOISON},\n\t{\"ENOTSUP\", ENOTSUP},\n#ifdef \tENOATTR\n\t{\"ENOATTR\", ENOATTR},\n#endif\n};\n\nvoid errno_print(void) {\n\tint i;\n\tint elems = sizeof(errnolist) / sizeof(errnolist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tprintf(\"%d\\t- %s\\n\", errnolist[i].nr, errnolist[i].name);\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"debug-errnos\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_print",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "405-412",
          "snippet": "void syscall_print(void) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tprintf(\"%d\\t- %s\\n\", syslist[i].nr, syslist[i].name);\n\t}\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};\n\nvoid syscall_print(void) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tprintf(\"%d\\t- %s\\n\", syslist[i].nr, syslist[i].name);\n\t}\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"debug-syscalls\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/main.c",
          "lines": "23-40",
          "snippet": "static void usage(void) {\n\tprintf(\"Usage:\\n\");\n\tprintf(\"\\tfseccomp debug-syscalls\\n\");\n\tprintf(\"\\tfseccomp debug-errnos\\n\");\n\tprintf(\"\\tfseccomp debug-protocols\\n\");\n\tprintf(\"\\tfseccomp protocol build list file\\n\");\n\tprintf(\"\\tfseccomp secondary 64 file\\n\");\n\tprintf(\"\\tfseccomp secondary 32 file\\n\");\n\tprintf(\"\\tfseccomp secondary block file\\n\");\n\tprintf(\"\\tfseccomp default file\\n\");\n\tprintf(\"\\tfseccomp default file allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp drop file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp drop file1 file2 list allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp default drop file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp default drop file1 file2 list allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp keep file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp memory-deny-write-execute file\\n\");\n}",
          "includes": [
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fseccomp.h\"\n\nstatic void usage(void) {\n\tprintf(\"Usage:\\n\");\n\tprintf(\"\\tfseccomp debug-syscalls\\n\");\n\tprintf(\"\\tfseccomp debug-errnos\\n\");\n\tprintf(\"\\tfseccomp debug-protocols\\n\");\n\tprintf(\"\\tfseccomp protocol build list file\\n\");\n\tprintf(\"\\tfseccomp secondary 64 file\\n\");\n\tprintf(\"\\tfseccomp secondary 32 file\\n\");\n\tprintf(\"\\tfseccomp secondary block file\\n\");\n\tprintf(\"\\tfseccomp default file\\n\");\n\tprintf(\"\\tfseccomp default file allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp drop file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp drop file1 file2 list allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp default drop file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp default drop file1 file2 list allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp keep file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp memory-deny-write-execute file\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"-?\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"--help\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"-h\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "quiet",
            "\"yes\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_QUIET\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"*%s* \"",
            "argv[i]"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fseccomp.h\"\n\nint arg_quiet = 0;\n\nint main(int argc, char **argv) {\n#if 0\n{\n//system(\"cat /proc/self/status\");\nint i;\nfor (i = 0; i < argc; i++)\n        printf(\"*%s* \", argv[i]);\nprintf(\"\\n\");\n}\n#endif\n\tif (argc < 2) {\n\t\tusage();\n\t\treturn 1;\n\t}\n\n\tchar *quiet = getenv(\"FIREJAIL_QUIET\");\n\tif (quiet && strcmp(quiet, \"yes\") == 0)\n\t\targ_quiet = 1;\n\n\tif (strcmp(argv[1], \"-h\") == 0 || strcmp(argv[1], \"--help\") == 0 || strcmp(argv[1], \"-?\") ==0) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\telse if (argc == 2 && strcmp(argv[1], \"debug-syscalls\") == 0)\n\t\tsyscall_print();\n\telse if (argc == 2 && strcmp(argv[1], \"debug-errnos\") == 0)\n\t\terrno_print();\n\telse if (argc == 2 && strcmp(argv[1], \"debug-protocols\") == 0)\n\t\tprotocol_print();\n\telse if (argc == 5 && strcmp(argv[1], \"protocol\") == 0 && strcmp(argv[2], \"build\") == 0)\n\t\tprotocol_build_filter(argv[3], argv[4]);\n\telse if (argc == 4 && strcmp(argv[1], \"secondary\") == 0 && strcmp(argv[2], \"32\") == 0)\n\t\tseccomp_secondary_32(argv[3]);\n\telse if (argc == 4 && strcmp(argv[1], \"secondary\") == 0 && strcmp(argv[2], \"block\") == 0)\n\t\tseccomp_secondary_block(argv[3]);\n\telse if (argc == 3 && strcmp(argv[1], \"default\") == 0)\n\t\tseccomp_default(argv[2], 0);\n\telse if (argc == 4 && strcmp(argv[1], \"default\") == 0 && strcmp(argv[3], \"allow-debuggers\") == 0)\n\t\tseccomp_default(argv[2], 1);\n\telse if (argc == 5 && strcmp(argv[1], \"drop\") == 0)\n\t\tseccomp_drop(argv[2], argv[3], argv[4], 0);\n\telse if (argc == 6 && strcmp(argv[1], \"drop\") == 0 && strcmp(argv[5], \"allow-debuggers\") == 0)\n\t\tseccomp_drop(argv[2], argv[3], argv[4], 1);\n\telse if (argc == 6 && strcmp(argv[1], \"default\") == 0 && strcmp(argv[2], \"drop\") == 0)\n\t\tseccomp_default_drop(argv[3], argv[4], argv[5], 0);\n\telse if (argc == 7 && strcmp(argv[1], \"default\") == 0 && strcmp(argv[2], \"drop\") == 0 && strcmp(argv[6], \"allow-debuggers\") == 0)\n\t\tseccomp_default_drop(argv[3], argv[4], argv[5], 1);\n\telse if (argc == 5 && strcmp(argv[1], \"keep\") == 0)\n\t\tseccomp_keep(argv[2], argv[3], argv[4]);\n\telse if (argc == 3 && strcmp(argv[1], \"memory-deny-write-execute\") == 0)\n\t\tmemory_deny_write_execute(argv[2]);\n\telse {\n\t\tfprintf(stderr, \"Error fseccomp: invalid arguments\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/main.c",
    "lines": "23-40",
    "snippet": "static void usage(void) {\n\tprintf(\"Usage:\\n\");\n\tprintf(\"\\tfseccomp debug-syscalls\\n\");\n\tprintf(\"\\tfseccomp debug-errnos\\n\");\n\tprintf(\"\\tfseccomp debug-protocols\\n\");\n\tprintf(\"\\tfseccomp protocol build list file\\n\");\n\tprintf(\"\\tfseccomp secondary 64 file\\n\");\n\tprintf(\"\\tfseccomp secondary 32 file\\n\");\n\tprintf(\"\\tfseccomp secondary block file\\n\");\n\tprintf(\"\\tfseccomp default file\\n\");\n\tprintf(\"\\tfseccomp default file allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp drop file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp drop file1 file2 list allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp default drop file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp default drop file1 file2 list allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp keep file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp memory-deny-write-execute file\\n\");\n}",
    "includes": [
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp memory-deny-write-execute file\\n\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp keep file1 file2 list\\n\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp default drop file1 file2 list allow-debuggers\\n\""
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp default drop file1 file2 list\\n\""
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp drop file1 file2 list allow-debuggers\\n\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp drop file1 file2 list\\n\""
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp default file allow-debuggers\\n\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp default file\\n\""
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp secondary block file\\n\""
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp secondary 32 file\\n\""
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp secondary 64 file\\n\""
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp protocol build list file\\n\""
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp debug-protocols\\n\""
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp debug-errnos\\n\""
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfseccomp debug-syscalls\\n\""
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage:\\n\""
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fseccomp.h\"\n\nstatic void usage(void) {\n\tprintf(\"Usage:\\n\");\n\tprintf(\"\\tfseccomp debug-syscalls\\n\");\n\tprintf(\"\\tfseccomp debug-errnos\\n\");\n\tprintf(\"\\tfseccomp debug-protocols\\n\");\n\tprintf(\"\\tfseccomp protocol build list file\\n\");\n\tprintf(\"\\tfseccomp secondary 64 file\\n\");\n\tprintf(\"\\tfseccomp secondary 32 file\\n\");\n\tprintf(\"\\tfseccomp secondary block file\\n\");\n\tprintf(\"\\tfseccomp default file\\n\");\n\tprintf(\"\\tfseccomp default file allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp drop file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp drop file1 file2 list allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp default drop file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp default drop file1 file2 list allow-debuggers\\n\");\n\tprintf(\"\\tfseccomp keep file1 file2 list\\n\");\n\tprintf(\"\\tfseccomp memory-deny-write-execute file\\n\");\n}"
  }
]