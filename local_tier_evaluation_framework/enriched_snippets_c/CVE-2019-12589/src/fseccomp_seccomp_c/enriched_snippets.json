[
  {
    "function_name": "memory_deny_write_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
    "lines": "209-278",
    "snippet": "void memory_deny_write_execute(const char *fname) {\n\t// open file\n\tint fd = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\tfilter_init(fd);\n\n\t// build filter\n\tstatic const struct sock_filter filter[] = {\n#ifdef block_syscall\n\t\t// block old multiplexing mmap syscall for i386\n\t\tBLACKLIST(block_syscall),\n#endif\n#ifdef filter_syscall\n\t\t// block mmap(,,x|PROT_WRITE|PROT_EXEC) so W&X memory can't be created\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, filter_syscall, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_WRITE|PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_WRITE|PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n\n\t\t// block mprotect(,,PROT_EXEC) so writable memory can't be turned into executable\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_mprotect, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n\n\t\t// same for pkey_mprotect(,,PROT_EXEC), where available\n#ifdef SYS_pkey_mprotect\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_pkey_mprotect, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n\n// shmat is not implemented as a syscall on some platforms (i386, powerpc64, powerpc64le)\n#ifdef SYS_shmat\n\t\t// block shmat(,,x|SHM_EXEC) so W&X shared memory can't be created\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_shmat, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, SHM_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SHM_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n#ifdef SYS_memfd_create\n\t\t// block memfd_create as it can be used to create\n\t\t// arbitrary memory contents which can be later mapped\n\t\t// as executable\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_memfd_create, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW\n#endif\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/shm.h>",
      "#include <sys/mman.h>",
      "#include \"../include/seccomp.h\"",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_end_blacklist",
          "args": [
            "fd"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "filter_end_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "91-96",
          "snippet": "void filter_end_blacklist(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tRETURN_ALLOW\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid filter_end_blacklist(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tRETURN_ALLOW\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_to_file",
          "args": [
            "fd",
            "filter",
            "sizeof(filter)"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "24-37",
          "snippet": "void write_to_file(int fd, const void *data, int size) {\n\tassert(data);\n\tassert(size);\n\n\tint written = 0;\n\twhile (written < size) {\n\t\tint rv = write(fd, (unsigned char *) data + written, size - written);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot write seccomp file\\n\");\n\t\t\texit(1);\n\t\t}\n\t\twritten += rv;\n\t}\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid write_to_file(int fd, const void *data, int size) {\n\tassert(data);\n\tassert(size);\n\n\tint written = 0;\n\twhile (written < size) {\n\t\tint rv = write(fd, (unsigned char *) data + written, size - written);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot write seccomp file\\n\");\n\t\t\texit(1);\n\t\t}\n\t\twritten += rv;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_JUMP",
          "args": [
            "BPF_JMP+BPF_JEQ+BPF_K",
            "SYS_memfd_create",
            "0",
            "1"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JUMP",
          "args": [
            "BPF_JMP+BPF_JEQ+BPF_K",
            "SHM_EXEC",
            "0",
            "1"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_STMT",
          "args": [
            "BPF_ALU+BPF_AND+BPF_K",
            "SHM_EXEC"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXAMINE_ARGUMENT",
          "args": [
            "2"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JUMP",
          "args": [
            "BPF_JMP+BPF_JEQ+BPF_K",
            "SYS_shmat",
            "0",
            "5"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JUMP",
          "args": [
            "BPF_JMP+BPF_JEQ+BPF_K",
            "PROT_EXEC",
            "0",
            "1"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_STMT",
          "args": [
            "BPF_ALU+BPF_AND+BPF_K",
            "PROT_EXEC"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXAMINE_ARGUMENT",
          "args": [
            "2"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JUMP",
          "args": [
            "BPF_JMP+BPF_JEQ+BPF_K",
            "SYS_pkey_mprotect",
            "0",
            "5"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JUMP",
          "args": [
            "BPF_JMP+BPF_JEQ+BPF_K",
            "PROT_EXEC",
            "0",
            "1"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_STMT",
          "args": [
            "BPF_ALU+BPF_AND+BPF_K",
            "PROT_EXEC"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXAMINE_ARGUMENT",
          "args": [
            "2"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JUMP",
          "args": [
            "BPF_JMP+BPF_JEQ+BPF_K",
            "SYS_mprotect",
            "0",
            "5"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JUMP",
          "args": [
            "BPF_JMP+BPF_JEQ+BPF_K",
            "PROT_WRITE|PROT_EXEC",
            "0",
            "1"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_STMT",
          "args": [
            "BPF_ALU+BPF_AND+BPF_K",
            "PROT_WRITE|PROT_EXEC"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXAMINE_ARGUMENT",
          "args": [
            "2"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JUMP",
          "args": [
            "BPF_JMP+BPF_JEQ+BPF_K",
            "filter_syscall",
            "0",
            "5"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLACKLIST",
          "args": [
            "block_syscall"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_init",
          "args": [
            "fd"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "filter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "39-61",
          "snippet": "void filter_init(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE,\n#if defined(__x86_64__)\n\t\tEXAMINE_SYSCALL,\n\t\tHANDLE_X32\n#else\n\t\tEXAMINE_SYSCALL\n#endif\n\t};\n\n#if 0\n{\n\tint i;\n\tunsigned char *ptr = (unsigned char *) &filter[0];\n\tfor (i = 0; i < sizeof(filter); i++, ptr++)\n\t\tprintf(\"%x, \", (*ptr) & 0xff);\n\tprintf(\"\\n\");\n}\n#endif\n\n\twrite_to_file(fd, filter, sizeof(filter));\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid filter_init(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE,\n#if defined(__x86_64__)\n\t\tEXAMINE_SYSCALL,\n\t\tHANDLE_X32\n#else\n\t\tEXAMINE_SYSCALL\n#endif\n\t};\n\n#if 0\n{\n\tint i;\n\tunsigned char *ptr = (unsigned char *) &filter[0];\n\tfor (i = 0; i < sizeof(filter); i++, ptr++)\n\t\tprintf(\"%x, \", (*ptr) & 0xff);\n\tprintf(\"\\n\");\n}\n#endif\n\n\twrite_to_file(fd, filter, sizeof(filter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot open %s file\\n\"",
            "fname"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "fname",
            "O_CREAT|O_WRONLY|O_TRUNC",
            "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "freopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "346-353",
          "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid memory_deny_write_execute(const char *fname) {\n\t// open file\n\tint fd = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\tfilter_init(fd);\n\n\t// build filter\n\tstatic const struct sock_filter filter[] = {\n#ifdef block_syscall\n\t\t// block old multiplexing mmap syscall for i386\n\t\tBLACKLIST(block_syscall),\n#endif\n#ifdef filter_syscall\n\t\t// block mmap(,,x|PROT_WRITE|PROT_EXEC) so W&X memory can't be created\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, filter_syscall, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_WRITE|PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_WRITE|PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n\n\t\t// block mprotect(,,PROT_EXEC) so writable memory can't be turned into executable\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_mprotect, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n\n\t\t// same for pkey_mprotect(,,PROT_EXEC), where available\n#ifdef SYS_pkey_mprotect\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_pkey_mprotect, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, PROT_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, PROT_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n\n// shmat is not implemented as a syscall on some platforms (i386, powerpc64, powerpc64le)\n#ifdef SYS_shmat\n\t\t// block shmat(,,x|SHM_EXEC) so W&X shared memory can't be created\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_shmat, 0, 5),\n\t\tEXAMINE_ARGUMENT(2),\n\t\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, SHM_EXEC),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SHM_EXEC, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW,\n#endif\n#ifdef SYS_memfd_create\n\t\t// block memfd_create as it can be used to create\n\t\t// arbitrary memory contents which can be later mapped\n\t\t// as executable\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_memfd_create, 0, 1),\n\t\tKILL_PROCESS,\n\t\tRETURN_ALLOW\n#endif\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}"
  },
  {
    "function_name": "seccomp_keep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
    "lines": "166-192",
    "snippet": "void seccomp_keep(const char *fname1, const char *fname2, char *list) {\n\t(void) fname2;\n\n\t// open file for pre-exec filter\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: whitelist also @default-keep\n\tfilter_init(fd);\n\t// these syscalls are used by firejail after the seccomp filter is initialized\n\tint r;\n\tr = syscall_check_list(\"@default-keep\", filter_add_whitelist, fd, 0, NULL);\n\tassert(r == 0);\n\n\tif (syscall_check_list(list, filter_add_whitelist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\n\tfilter_end_whitelist(fd);\n\n\t// close file\n\tclose(fd);\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/shm.h>",
      "#include <sys/mman.h>",
      "#include \"../include/seccomp.h\"",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_end_whitelist",
          "args": [
            "fd"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "filter_end_whitelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "98-103",
          "snippet": "void filter_end_whitelist(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tKILL_PROCESS\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid filter_end_whitelist(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tKILL_PROCESS\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot build seccomp filter\\n\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_check_list",
          "args": [
            "list",
            "filter_add_whitelist",
            "fd",
            "0",
            "NULL"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_check_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "469-519",
          "snippet": "int syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nint syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "r == 0"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_init",
          "args": [
            "fd"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "filter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "39-61",
          "snippet": "void filter_init(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE,\n#if defined(__x86_64__)\n\t\tEXAMINE_SYSCALL,\n\t\tHANDLE_X32\n#else\n\t\tEXAMINE_SYSCALL\n#endif\n\t};\n\n#if 0\n{\n\tint i;\n\tunsigned char *ptr = (unsigned char *) &filter[0];\n\tfor (i = 0; i < sizeof(filter); i++, ptr++)\n\t\tprintf(\"%x, \", (*ptr) & 0xff);\n\tprintf(\"\\n\");\n}\n#endif\n\n\twrite_to_file(fd, filter, sizeof(filter));\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid filter_init(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE,\n#if defined(__x86_64__)\n\t\tEXAMINE_SYSCALL,\n\t\tHANDLE_X32\n#else\n\t\tEXAMINE_SYSCALL\n#endif\n\t};\n\n#if 0\n{\n\tint i;\n\tunsigned char *ptr = (unsigned char *) &filter[0];\n\tfor (i = 0; i < sizeof(filter); i++, ptr++)\n\t\tprintf(\"%x, \", (*ptr) & 0xff);\n\tprintf(\"\\n\");\n}\n#endif\n\n\twrite_to_file(fd, filter, sizeof(filter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot open %s file\\n\"",
            "fname1"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "fname1",
            "O_CREAT|O_WRONLY|O_TRUNC",
            "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "freopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "346-353",
          "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid seccomp_keep(const char *fname1, const char *fname2, char *list) {\n\t(void) fname2;\n\n\t// open file for pre-exec filter\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: whitelist also @default-keep\n\tfilter_init(fd);\n\t// these syscalls are used by firejail after the seccomp filter is initialized\n\tint r;\n\tr = syscall_check_list(\"@default-keep\", filter_add_whitelist, fd, 0, NULL);\n\tassert(r == 0);\n\n\tif (syscall_check_list(list, filter_add_whitelist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\n\tfilter_end_whitelist(fd);\n\n\t// close file\n\tclose(fd);\n}"
  },
  {
    "function_name": "seccomp_default_drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
    "lines": "117-164",
    "snippet": "void seccomp_default_drop(const char *fname1, const char *fname2, char *list, int allow_debuggers) {\n\tassert(fname1);\n\tassert(fname2);\n\n\t// open file\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: blacklist @default, don't blacklist\n\t// any listed syscalls in @default-keep\n\tfilter_init(fd);\n\tadd_default_list(fd, allow_debuggers);\n\tchar *prelist, *postlist;\n\tsyscalls_in_list(list, \"@default-keep\", fd, &prelist, &postlist);\n\tif (prelist)\n\t\tif (syscall_check_list(prelist, filter_add_blacklist, fd, 0, NULL)) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n\n\tif (!postlist)\n\t\treturn;\n\n\t// open file for post-exec filter\n\tfd = open(fname2, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname2);\n\t\texit(1);\n\t}\n\n\t// build post-exec filter: blacklist remaining syscalls\n\tfilter_init(fd);\n\tif (syscall_check_list(postlist, filter_add_blacklist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/shm.h>",
      "#include <sys/mman.h>",
      "#include \"../include/seccomp.h\"",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_end_blacklist",
          "args": [
            "fd"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "filter_end_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "91-96",
          "snippet": "void filter_end_blacklist(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tRETURN_ALLOW\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid filter_end_blacklist(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tRETURN_ALLOW\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot build seccomp filter\\n\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_check_list",
          "args": [
            "postlist",
            "filter_add_blacklist",
            "fd",
            "0",
            "NULL"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_check_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "469-519",
          "snippet": "int syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nint syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_init",
          "args": [
            "fd"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "filter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "39-61",
          "snippet": "void filter_init(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE,\n#if defined(__x86_64__)\n\t\tEXAMINE_SYSCALL,\n\t\tHANDLE_X32\n#else\n\t\tEXAMINE_SYSCALL\n#endif\n\t};\n\n#if 0\n{\n\tint i;\n\tunsigned char *ptr = (unsigned char *) &filter[0];\n\tfor (i = 0; i < sizeof(filter); i++, ptr++)\n\t\tprintf(\"%x, \", (*ptr) & 0xff);\n\tprintf(\"\\n\");\n}\n#endif\n\n\twrite_to_file(fd, filter, sizeof(filter));\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid filter_init(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE,\n#if defined(__x86_64__)\n\t\tEXAMINE_SYSCALL,\n\t\tHANDLE_X32\n#else\n\t\tEXAMINE_SYSCALL\n#endif\n\t};\n\n#if 0\n{\n\tint i;\n\tunsigned char *ptr = (unsigned char *) &filter[0];\n\tfor (i = 0; i < sizeof(filter); i++, ptr++)\n\t\tprintf(\"%x, \", (*ptr) & 0xff);\n\tprintf(\"\\n\");\n}\n#endif\n\n\twrite_to_file(fd, filter, sizeof(filter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot open %s file\\n\"",
            "fname2"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "fname2",
            "O_CREAT|O_WRONLY|O_TRUNC",
            "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "freopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "346-353",
          "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot build seccomp filter\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscalls_in_list",
          "args": [
            "list",
            "\"@default-keep\"",
            "fd",
            "&prelist",
            "&postlist"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "syscalls_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "571-591",
          "snippet": "void syscalls_in_list(const char *list, const char *slist, int fd, char **prelist, char **postlist) {\n\t(void) fd;\n\tSyscallCheckList sl;\n\t// these syscalls are used by firejail after the seccomp filter is initialized\n\tsl.slist = slist;\n\tsl.prelist = NULL;\n\tsl.postlist = NULL;\n\tsyscall_check_list(list, syscall_in_list, 0, 0, &sl);\n\tif (!arg_quiet) {\n\t\tprintf(\"Seccomp list in: %s,\", list);\n\t\tif (sl.slist)\n\t\t\tprintf(\" check list: %s,\", sl.slist);\n\t\tif (sl.prelist)\n\t\t\tprintf(\" prelist: %s,\", sl.prelist);\n\t\tif (sl.postlist)\n\t\t\tprintf(\" postlist: %s\", sl.postlist);\n\t\tprintf(\"\\n\");\n\t}\n\t*prelist = sl.prelist;\n\t*postlist = sl.postlist;\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nvoid syscalls_in_list(const char *list, const char *slist, int fd, char **prelist, char **postlist) {\n\t(void) fd;\n\tSyscallCheckList sl;\n\t// these syscalls are used by firejail after the seccomp filter is initialized\n\tsl.slist = slist;\n\tsl.prelist = NULL;\n\tsl.postlist = NULL;\n\tsyscall_check_list(list, syscall_in_list, 0, 0, &sl);\n\tif (!arg_quiet) {\n\t\tprintf(\"Seccomp list in: %s,\", list);\n\t\tif (sl.slist)\n\t\t\tprintf(\" check list: %s,\", sl.slist);\n\t\tif (sl.prelist)\n\t\t\tprintf(\" prelist: %s,\", sl.prelist);\n\t\tif (sl.postlist)\n\t\t\tprintf(\" postlist: %s\", sl.postlist);\n\t\tprintf(\"\\n\");\n\t}\n\t*prelist = sl.prelist;\n\t*postlist = sl.postlist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_default_list",
          "args": [
            "fd",
            "allow_debuggers"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "add_default_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
          "lines": "27-46",
          "snippet": "static void add_default_list(int fd, int allow_debuggers) {\n\tint r;\n\tif (!allow_debuggers)\n\t\tr = syscall_check_list(\"@default-nodebuggers\", filter_add_blacklist, fd, 0, NULL);\n\telse\n\t\tr = syscall_check_list(\"@default\", filter_add_blacklist, fd, 0, NULL);\n\n\tassert(r == 0);\n//#ifdef SYS_mknod - emoved in 0.9.29 - it breaks Zotero extension\n//\t\tfilter_add_blacklist(SYS_mknod, 0);\n//#endif\n// breaking Firefox nightly when playing youtube videos\n// TODO: test again when firefox sandbox is finally released\n//#ifdef SYS_get_mempolicy\n//\tfilter_add_blacklist(fd, SYS_get_mempolicy, 0);\n//#endif\n//#ifdef SYS_quotactl - in use by Firefox\n//\tfilter_add_blacklist(fd, SYS_quotactl, 0);\n//#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/shm.h>",
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nstatic void add_default_list(int fd, int allow_debuggers) {\n\tint r;\n\tif (!allow_debuggers)\n\t\tr = syscall_check_list(\"@default-nodebuggers\", filter_add_blacklist, fd, 0, NULL);\n\telse\n\t\tr = syscall_check_list(\"@default\", filter_add_blacklist, fd, 0, NULL);\n\n\tassert(r == 0);\n//#ifdef SYS_mknod - emoved in 0.9.29 - it breaks Zotero extension\n//\t\tfilter_add_blacklist(SYS_mknod, 0);\n//#endif\n// breaking Firefox nightly when playing youtube videos\n// TODO: test again when firefox sandbox is finally released\n//#ifdef SYS_get_mempolicy\n//\tfilter_add_blacklist(fd, SYS_get_mempolicy, 0);\n//#endif\n//#ifdef SYS_quotactl - in use by Firefox\n//\tfilter_add_blacklist(fd, SYS_quotactl, 0);\n//#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot open %s file\\n\"",
            "fname1"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname2"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname1"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid seccomp_default_drop(const char *fname1, const char *fname2, char *list, int allow_debuggers) {\n\tassert(fname1);\n\tassert(fname2);\n\n\t// open file\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: blacklist @default, don't blacklist\n\t// any listed syscalls in @default-keep\n\tfilter_init(fd);\n\tadd_default_list(fd, allow_debuggers);\n\tchar *prelist, *postlist;\n\tsyscalls_in_list(list, \"@default-keep\", fd, &prelist, &postlist);\n\tif (prelist)\n\t\tif (syscall_check_list(prelist, filter_add_blacklist, fd, 0, NULL)) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n\n\tif (!postlist)\n\t\treturn;\n\n\t// open file for post-exec filter\n\tfd = open(fname2, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname2);\n\t\texit(1);\n\t}\n\n\t// build post-exec filter: blacklist remaining syscalls\n\tfilter_init(fd);\n\tif (syscall_check_list(postlist, filter_add_blacklist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}"
  },
  {
    "function_name": "seccomp_drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
    "lines": "69-114",
    "snippet": "void seccomp_drop(const char *fname1, const char *fname2, char *list, int allow_debuggers) {\n\tassert(fname1);\n\tassert(fname2);\n\t(void) allow_debuggers; // todo: to implemnet it\n\n\t// open file for pre-exec filter\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: don't blacklist any syscalls in @default-keep\n\tfilter_init(fd);\n\tchar *prelist, *postlist;\n\tsyscalls_in_list(list, \"@default-keep\", fd, &prelist, &postlist);\n\tif (prelist)\n\t\tif (syscall_check_list(prelist, filter_add_blacklist, fd, 0, NULL)) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\tfilter_end_blacklist(fd);\n\t// close file\n\tclose(fd);\n\n\tif (!postlist)\n\t\treturn;\n\n\t// open file for post-exec filter\n\tfd = open(fname2, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname2);\n\t\texit(1);\n\t}\n\n\t// build post-exec filter: blacklist remaining syscalls\n\tfilter_init(fd);\n\tif (syscall_check_list(postlist, filter_add_blacklist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/shm.h>",
      "#include <sys/mman.h>",
      "#include \"../include/seccomp.h\"",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_end_blacklist",
          "args": [
            "fd"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "filter_end_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "91-96",
          "snippet": "void filter_end_blacklist(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tRETURN_ALLOW\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid filter_end_blacklist(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tRETURN_ALLOW\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot build seccomp filter\\n\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_check_list",
          "args": [
            "postlist",
            "filter_add_blacklist",
            "fd",
            "0",
            "NULL"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_check_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "469-519",
          "snippet": "int syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nint syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_init",
          "args": [
            "fd"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "filter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "39-61",
          "snippet": "void filter_init(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE,\n#if defined(__x86_64__)\n\t\tEXAMINE_SYSCALL,\n\t\tHANDLE_X32\n#else\n\t\tEXAMINE_SYSCALL\n#endif\n\t};\n\n#if 0\n{\n\tint i;\n\tunsigned char *ptr = (unsigned char *) &filter[0];\n\tfor (i = 0; i < sizeof(filter); i++, ptr++)\n\t\tprintf(\"%x, \", (*ptr) & 0xff);\n\tprintf(\"\\n\");\n}\n#endif\n\n\twrite_to_file(fd, filter, sizeof(filter));\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid filter_init(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE,\n#if defined(__x86_64__)\n\t\tEXAMINE_SYSCALL,\n\t\tHANDLE_X32\n#else\n\t\tEXAMINE_SYSCALL\n#endif\n\t};\n\n#if 0\n{\n\tint i;\n\tunsigned char *ptr = (unsigned char *) &filter[0];\n\tfor (i = 0; i < sizeof(filter); i++, ptr++)\n\t\tprintf(\"%x, \", (*ptr) & 0xff);\n\tprintf(\"\\n\");\n}\n#endif\n\n\twrite_to_file(fd, filter, sizeof(filter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot open %s file\\n\"",
            "fname2"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "fname2",
            "O_CREAT|O_WRONLY|O_TRUNC",
            "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "freopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "346-353",
          "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot build seccomp filter\\n\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscalls_in_list",
          "args": [
            "list",
            "\"@default-keep\"",
            "fd",
            "&prelist",
            "&postlist"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "syscalls_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "571-591",
          "snippet": "void syscalls_in_list(const char *list, const char *slist, int fd, char **prelist, char **postlist) {\n\t(void) fd;\n\tSyscallCheckList sl;\n\t// these syscalls are used by firejail after the seccomp filter is initialized\n\tsl.slist = slist;\n\tsl.prelist = NULL;\n\tsl.postlist = NULL;\n\tsyscall_check_list(list, syscall_in_list, 0, 0, &sl);\n\tif (!arg_quiet) {\n\t\tprintf(\"Seccomp list in: %s,\", list);\n\t\tif (sl.slist)\n\t\t\tprintf(\" check list: %s,\", sl.slist);\n\t\tif (sl.prelist)\n\t\t\tprintf(\" prelist: %s,\", sl.prelist);\n\t\tif (sl.postlist)\n\t\t\tprintf(\" postlist: %s\", sl.postlist);\n\t\tprintf(\"\\n\");\n\t}\n\t*prelist = sl.prelist;\n\t*postlist = sl.postlist;\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nvoid syscalls_in_list(const char *list, const char *slist, int fd, char **prelist, char **postlist) {\n\t(void) fd;\n\tSyscallCheckList sl;\n\t// these syscalls are used by firejail after the seccomp filter is initialized\n\tsl.slist = slist;\n\tsl.prelist = NULL;\n\tsl.postlist = NULL;\n\tsyscall_check_list(list, syscall_in_list, 0, 0, &sl);\n\tif (!arg_quiet) {\n\t\tprintf(\"Seccomp list in: %s,\", list);\n\t\tif (sl.slist)\n\t\t\tprintf(\" check list: %s,\", sl.slist);\n\t\tif (sl.prelist)\n\t\t\tprintf(\" prelist: %s,\", sl.prelist);\n\t\tif (sl.postlist)\n\t\t\tprintf(\" postlist: %s\", sl.postlist);\n\t\tprintf(\"\\n\");\n\t}\n\t*prelist = sl.prelist;\n\t*postlist = sl.postlist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot open %s file\\n\"",
            "fname1"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname2"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname1"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid seccomp_drop(const char *fname1, const char *fname2, char *list, int allow_debuggers) {\n\tassert(fname1);\n\tassert(fname2);\n\t(void) allow_debuggers; // todo: to implemnet it\n\n\t// open file for pre-exec filter\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: don't blacklist any syscalls in @default-keep\n\tfilter_init(fd);\n\tchar *prelist, *postlist;\n\tsyscalls_in_list(list, \"@default-keep\", fd, &prelist, &postlist);\n\tif (prelist)\n\t\tif (syscall_check_list(prelist, filter_add_blacklist, fd, 0, NULL)) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\tfilter_end_blacklist(fd);\n\t// close file\n\tclose(fd);\n\n\tif (!postlist)\n\t\treturn;\n\n\t// open file for post-exec filter\n\tfd = open(fname2, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname2);\n\t\texit(1);\n\t}\n\n\t// build post-exec filter: blacklist remaining syscalls\n\tfilter_init(fd);\n\tif (syscall_check_list(postlist, filter_add_blacklist, fd, 0, NULL)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}"
  },
  {
    "function_name": "seccomp_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
    "lines": "49-66",
    "snippet": "void seccomp_default(const char *fname, int allow_debuggers) {\n\tassert(fname);\n\n\t// open file\n\tint fd = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// build filter (no post-exec filter needed because default list is fine for us)\n\tfilter_init(fd);\n\tadd_default_list(fd, allow_debuggers);\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/shm.h>",
      "#include <sys/mman.h>",
      "#include \"../include/seccomp.h\"",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_end_blacklist",
          "args": [
            "fd"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "filter_end_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "91-96",
          "snippet": "void filter_end_blacklist(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tRETURN_ALLOW\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid filter_end_blacklist(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tRETURN_ALLOW\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_default_list",
          "args": [
            "fd",
            "allow_debuggers"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "add_default_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
          "lines": "27-46",
          "snippet": "static void add_default_list(int fd, int allow_debuggers) {\n\tint r;\n\tif (!allow_debuggers)\n\t\tr = syscall_check_list(\"@default-nodebuggers\", filter_add_blacklist, fd, 0, NULL);\n\telse\n\t\tr = syscall_check_list(\"@default\", filter_add_blacklist, fd, 0, NULL);\n\n\tassert(r == 0);\n//#ifdef SYS_mknod - emoved in 0.9.29 - it breaks Zotero extension\n//\t\tfilter_add_blacklist(SYS_mknod, 0);\n//#endif\n// breaking Firefox nightly when playing youtube videos\n// TODO: test again when firefox sandbox is finally released\n//#ifdef SYS_get_mempolicy\n//\tfilter_add_blacklist(fd, SYS_get_mempolicy, 0);\n//#endif\n//#ifdef SYS_quotactl - in use by Firefox\n//\tfilter_add_blacklist(fd, SYS_quotactl, 0);\n//#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/shm.h>",
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nstatic void add_default_list(int fd, int allow_debuggers) {\n\tint r;\n\tif (!allow_debuggers)\n\t\tr = syscall_check_list(\"@default-nodebuggers\", filter_add_blacklist, fd, 0, NULL);\n\telse\n\t\tr = syscall_check_list(\"@default\", filter_add_blacklist, fd, 0, NULL);\n\n\tassert(r == 0);\n//#ifdef SYS_mknod - emoved in 0.9.29 - it breaks Zotero extension\n//\t\tfilter_add_blacklist(SYS_mknod, 0);\n//#endif\n// breaking Firefox nightly when playing youtube videos\n// TODO: test again when firefox sandbox is finally released\n//#ifdef SYS_get_mempolicy\n//\tfilter_add_blacklist(fd, SYS_get_mempolicy, 0);\n//#endif\n//#ifdef SYS_quotactl - in use by Firefox\n//\tfilter_add_blacklist(fd, SYS_quotactl, 0);\n//#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_init",
          "args": [
            "fd"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "filter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "39-61",
          "snippet": "void filter_init(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE,\n#if defined(__x86_64__)\n\t\tEXAMINE_SYSCALL,\n\t\tHANDLE_X32\n#else\n\t\tEXAMINE_SYSCALL\n#endif\n\t};\n\n#if 0\n{\n\tint i;\n\tunsigned char *ptr = (unsigned char *) &filter[0];\n\tfor (i = 0; i < sizeof(filter); i++, ptr++)\n\t\tprintf(\"%x, \", (*ptr) & 0xff);\n\tprintf(\"\\n\");\n}\n#endif\n\n\twrite_to_file(fd, filter, sizeof(filter));\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid filter_init(int fd) {\n\tstruct sock_filter filter[] = {\n\t\tVALIDATE_ARCHITECTURE,\n#if defined(__x86_64__)\n\t\tEXAMINE_SYSCALL,\n\t\tHANDLE_X32\n#else\n\t\tEXAMINE_SYSCALL\n#endif\n\t};\n\n#if 0\n{\n\tint i;\n\tunsigned char *ptr = (unsigned char *) &filter[0];\n\tfor (i = 0; i < sizeof(filter); i++, ptr++)\n\t\tprintf(\"%x, \", (*ptr) & 0xff);\n\tprintf(\"\\n\");\n}\n#endif\n\n\twrite_to_file(fd, filter, sizeof(filter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: cannot open %s file\\n\"",
            "fname"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "fname",
            "O_CREAT|O_WRONLY|O_TRUNC",
            "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "freopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "346-353",
          "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid seccomp_default(const char *fname, int allow_debuggers) {\n\tassert(fname);\n\n\t// open file\n\tint fd = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// build filter (no post-exec filter needed because default list is fine for us)\n\tfilter_init(fd);\n\tadd_default_list(fd, allow_debuggers);\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}"
  },
  {
    "function_name": "add_default_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp.c",
    "lines": "27-46",
    "snippet": "static void add_default_list(int fd, int allow_debuggers) {\n\tint r;\n\tif (!allow_debuggers)\n\t\tr = syscall_check_list(\"@default-nodebuggers\", filter_add_blacklist, fd, 0, NULL);\n\telse\n\t\tr = syscall_check_list(\"@default\", filter_add_blacklist, fd, 0, NULL);\n\n\tassert(r == 0);\n//#ifdef SYS_mknod - emoved in 0.9.29 - it breaks Zotero extension\n//\t\tfilter_add_blacklist(SYS_mknod, 0);\n//#endif\n// breaking Firefox nightly when playing youtube videos\n// TODO: test again when firefox sandbox is finally released\n//#ifdef SYS_get_mempolicy\n//\tfilter_add_blacklist(fd, SYS_get_mempolicy, 0);\n//#endif\n//#ifdef SYS_quotactl - in use by Firefox\n//\tfilter_add_blacklist(fd, SYS_quotactl, 0);\n//#endif\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/shm.h>",
      "#include <sys/mman.h>",
      "#include \"../include/seccomp.h\"",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "r == 0"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_check_list",
          "args": [
            "\"@default\"",
            "filter_add_blacklist",
            "fd",
            "0",
            "NULL"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_check_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "469-519",
          "snippet": "int syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nint syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nstatic void add_default_list(int fd, int allow_debuggers) {\n\tint r;\n\tif (!allow_debuggers)\n\t\tr = syscall_check_list(\"@default-nodebuggers\", filter_add_blacklist, fd, 0, NULL);\n\telse\n\t\tr = syscall_check_list(\"@default\", filter_add_blacklist, fd, 0, NULL);\n\n\tassert(r == 0);\n//#ifdef SYS_mknod - emoved in 0.9.29 - it breaks Zotero extension\n//\t\tfilter_add_blacklist(SYS_mknod, 0);\n//#endif\n// breaking Firefox nightly when playing youtube videos\n// TODO: test again when firefox sandbox is finally released\n//#ifdef SYS_get_mempolicy\n//\tfilter_add_blacklist(fd, SYS_get_mempolicy, 0);\n//#endif\n//#ifdef SYS_quotactl - in use by Firefox\n//\tfilter_add_blacklist(fd, SYS_quotactl, 0);\n//#endif\n}"
  }
]