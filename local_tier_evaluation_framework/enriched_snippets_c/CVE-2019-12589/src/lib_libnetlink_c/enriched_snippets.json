[
  {
    "function_name": "__parse_rtattr_nested_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "758-769",
    "snippet": "int __parse_rtattr_nested_compat(struct rtattr *tb[], int max, struct rtattr *rta,\n\t\t\t         int len)\n{\n\tif ((int)RTA_PAYLOAD(rta) < len)\n\t\treturn -1;\n\tif (RTA_PAYLOAD(rta) >= RTA_ALIGN(len) + sizeof(struct rtattr)) {\n\t\trta = RTA_DATA(rta) + RTA_ALIGN(len);\n\t\treturn parse_rtattr_nested(tb, max, rta);\n\t}\n\tmemset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\treturn 0;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tb",
            "0",
            "sizeof(struct rtattr *) * (max + 1)"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_rtattr_nested",
          "args": [
            "tb",
            "max",
            "rta"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_ALIGN",
          "args": [
            "len"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "rta"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_ALIGN",
          "args": [
            "len"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_PAYLOAD",
          "args": [
            "rta"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_PAYLOAD",
          "args": [
            "rta"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint __parse_rtattr_nested_compat(struct rtattr *tb[], int max, struct rtattr *rta,\n\t\t\t         int len)\n{\n\tif ((int)RTA_PAYLOAD(rta) < len)\n\t\treturn -1;\n\tif (RTA_PAYLOAD(rta) >= RTA_ALIGN(len) + sizeof(struct rtattr)) {\n\t\trta = RTA_DATA(rta) + RTA_ALIGN(len);\n\t\treturn parse_rtattr_nested(tb, max, rta);\n\t}\n\tmemset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_rtattr_byindex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "743-756",
    "snippet": "int parse_rtattr_byindex(struct rtattr *tb[], int max, struct rtattr *rta, int len)\n{\n\tint i = 0;\n\n\tmemset(tb, 0, sizeof(struct rtattr *) * max);\n\twhile (RTA_OK(rta, len)) {\n\t\tif (rta->rta_type <= max && i < max)\n\t\t\ttb[i++] = rta;\n\t\trta = RTA_NEXT(rta,len);\n\t}\n\tif (len)\n\t\tfprintf(stderr, \"!!!Deficit %d, rta_len=%d\\n\", len, rta->rta_len);\n\treturn i;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"!!!Deficit %d, rta_len=%d\\n\"",
            "len",
            "rta->rta_len"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_NEXT",
          "args": [
            "rta",
            "len"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_OK",
          "args": [
            "rta",
            "len"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tb",
            "0",
            "sizeof(struct rtattr *) * max"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint parse_rtattr_byindex(struct rtattr *tb[], int max, struct rtattr *rta, int len)\n{\n\tint i = 0;\n\n\tmemset(tb, 0, sizeof(struct rtattr *) * max);\n\twhile (RTA_OK(rta, len)) {\n\t\tif (rta->rta_type <= max && i < max)\n\t\t\ttb[i++] = rta;\n\t\trta = RTA_NEXT(rta,len);\n\t}\n\tif (len)\n\t\tfprintf(stderr, \"!!!Deficit %d, rta_len=%d\\n\", len, rta->rta_len);\n\treturn i;\n}"
  },
  {
    "function_name": "parse_rtattr_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "726-741",
    "snippet": "int parse_rtattr_flags(struct rtattr *tb[], int max, struct rtattr *rta,\n\t\t       int len, unsigned short flags)\n{\n\tunsigned short type;\n\n\tmemset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\twhile (RTA_OK(rta, len)) {\n\t\ttype = rta->rta_type & ~flags;\n\t\tif ((type <= max) && (!tb[type]))\n\t\t\ttb[type] = rta;\n\t\trta = RTA_NEXT(rta,len);\n\t}\n\tif (len)\n\t\tfprintf(stderr, \"!!!Deficit %d, rta_len=%d\\n\", len, rta->rta_len);\n\treturn 0;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"!!!Deficit %d, rta_len=%d\\n\"",
            "len",
            "rta->rta_len"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_NEXT",
          "args": [
            "rta",
            "len"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_OK",
          "args": [
            "rta",
            "len"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tb",
            "0",
            "sizeof(struct rtattr *) * (max + 1)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint parse_rtattr_flags(struct rtattr *tb[], int max, struct rtattr *rta,\n\t\t       int len, unsigned short flags)\n{\n\tunsigned short type;\n\n\tmemset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\twhile (RTA_OK(rta, len)) {\n\t\ttype = rta->rta_type & ~flags;\n\t\tif ((type <= max) && (!tb[type]))\n\t\t\ttb[type] = rta;\n\t\trta = RTA_NEXT(rta,len);\n\t}\n\tif (len)\n\t\tfprintf(stderr, \"!!!Deficit %d, rta_len=%d\\n\", len, rta->rta_len);\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_rtattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "721-724",
    "snippet": "int parse_rtattr(struct rtattr *tb[], int max, struct rtattr *rta, int len)\n{\n\treturn parse_rtattr_flags(tb, max, rta, len, 0);\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_rtattr_flags",
          "args": [
            "tb",
            "max",
            "rta",
            "len",
            "0"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "parse_rtattr_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "726-741",
          "snippet": "int parse_rtattr_flags(struct rtattr *tb[], int max, struct rtattr *rta,\n\t\t       int len, unsigned short flags)\n{\n\tunsigned short type;\n\n\tmemset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\twhile (RTA_OK(rta, len)) {\n\t\ttype = rta->rta_type & ~flags;\n\t\tif ((type <= max) && (!tb[type]))\n\t\t\ttb[type] = rta;\n\t\trta = RTA_NEXT(rta,len);\n\t}\n\tif (len)\n\t\tfprintf(stderr, \"!!!Deficit %d, rta_len=%d\\n\", len, rta->rta_len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint parse_rtattr_flags(struct rtattr *tb[], int max, struct rtattr *rta,\n\t\t       int len, unsigned short flags)\n{\n\tunsigned short type;\n\n\tmemset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\twhile (RTA_OK(rta, len)) {\n\t\ttype = rta->rta_type & ~flags;\n\t\tif ((type <= max) && (!tb[type]))\n\t\t\ttb[type] = rta;\n\t\trta = RTA_NEXT(rta,len);\n\t}\n\tif (len)\n\t\tfprintf(stderr, \"!!!Deficit %d, rta_len=%d\\n\", len, rta->rta_len);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint parse_rtattr(struct rtattr *tb[], int max, struct rtattr *rta, int len)\n{\n\treturn parse_rtattr_flags(tb, max, rta, len, 0);\n}"
  },
  {
    "function_name": "rta_addattr_l",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "703-719",
    "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RTA_ALIGN",
          "args": [
            "len"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "rta->rta_len"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "RTA_DATA(subrta)",
            "data",
            "alen"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "subrta"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_ALIGN",
          "args": [
            "rta->rta_len"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\"",
            "maxlen"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_ALIGN",
          "args": [
            "len"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_ALIGN",
          "args": [
            "rta->rta_len"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_LENGTH",
          "args": [
            "alen"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
  },
  {
    "function_name": "rta_addattr32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "686-701",
    "snippet": "int rta_addattr32(struct rtattr *rta, int maxlen, int type, __u32 data)\n{\n\tint len = RTA_LENGTH(4);\n\tstruct rtattr *subrta;\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + len) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr32: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), &data, 4);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + len;\n\treturn 0;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "rta->rta_len"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "RTA_DATA(subrta)",
            "&data",
            "4"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "subrta"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_ALIGN",
          "args": [
            "rta->rta_len"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"rta_addattr32: Error! max allowed bound %d exceeded\\n\"",
            "maxlen"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_ALIGN",
          "args": [
            "rta->rta_len"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_LENGTH",
          "args": [
            "4"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr32(struct rtattr *rta, int maxlen, int type, __u32 data)\n{\n\tint len = RTA_LENGTH(4);\n\tstruct rtattr *subrta;\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + len) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr32: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), &data, 4);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + len;\n\treturn 0;\n}"
  },
  {
    "function_name": "addattr_nest_compat_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "677-684",
    "snippet": "int addattr_nest_compat_end(struct nlmsghdr *n, struct rtattr *start)\n{\n\tstruct rtattr *nest = (void *)start + NLMSG_ALIGN(start->rta_len);\n\n\tstart->rta_len = (void *)NLMSG_TAIL(n) - (void *)start;\n\taddattr_nest_end(n, nest);\n\treturn n->nlmsg_len;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addattr_nest_end",
          "args": [
            "n",
            "nest"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "addattr_nest_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "661-665",
          "snippet": "int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest)\n{\n\tnest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;\n\treturn n->nlmsg_len;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest)\n{\n\tnest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;\n\treturn n->nlmsg_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "n"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "start->rta_len"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint addattr_nest_compat_end(struct nlmsghdr *n, struct rtattr *start)\n{\n\tstruct rtattr *nest = (void *)start + NLMSG_ALIGN(start->rta_len);\n\n\tstart->rta_len = (void *)NLMSG_TAIL(n) - (void *)start;\n\taddattr_nest_end(n, nest);\n\treturn n->nlmsg_len;\n}"
  },
  {
    "function_name": "addattr_nest_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "667-675",
    "snippet": "struct rtattr *addattr_nest_compat(struct nlmsghdr *n, int maxlen, int type,\n\t\t\t\t   const void *data, int len)\n{\n\tstruct rtattr *start = NLMSG_TAIL(n);\n\n\taddattr_l(n, maxlen, type, data, len);\n\taddattr_nest(n, maxlen, type);\n\treturn start;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addattr_nest",
          "args": [
            "n",
            "maxlen",
            "type"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "addattr_nest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "653-659",
          "snippet": "struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type)\n{\n\tstruct rtattr *nest = NLMSG_TAIL(n);\n\n\taddattr_l(n, maxlen, type, NULL, 0);\n\treturn nest;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type)\n{\n\tstruct rtattr *nest = NLMSG_TAIL(n);\n\n\taddattr_l(n, maxlen, type, NULL, 0);\n\treturn nest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "n",
            "maxlen",
            "type",
            "data",
            "len"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "n"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct rtattr *addattr_nest_compat(struct nlmsghdr *n, int maxlen, int type,\n\t\t\t\t   const void *data, int len)\n{\n\tstruct rtattr *start = NLMSG_TAIL(n);\n\n\taddattr_l(n, maxlen, type, data, len);\n\taddattr_nest(n, maxlen, type);\n\treturn start;\n}"
  },
  {
    "function_name": "addattr_nest_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "661-665",
    "snippet": "int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest)\n{\n\tnest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;\n\treturn n->nlmsg_len;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "n"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest)\n{\n\tnest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;\n\treturn n->nlmsg_len;\n}"
  },
  {
    "function_name": "addattr_nest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "653-659",
    "snippet": "struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type)\n{\n\tstruct rtattr *nest = NLMSG_TAIL(n);\n\n\taddattr_l(n, maxlen, type, NULL, 0);\n\treturn nest;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "n",
            "maxlen",
            "type",
            "NULL",
            "0"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "n"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type)\n{\n\tstruct rtattr *nest = NLMSG_TAIL(n);\n\n\taddattr_l(n, maxlen, type, NULL, 0);\n\treturn nest;\n}"
  },
  {
    "function_name": "addraw_l",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "640-651",
    "snippet": "int addraw_l(struct nlmsghdr *n, int maxlen, const void *data, int len)\n{\n\tif ((int)(NLMSG_ALIGN(n->nlmsg_len) + NLMSG_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr, \"addraw_l ERROR: message exceeded bound of %d\\n\",maxlen);\n\t\treturn -1;\n\t}\n\n\tmemcpy(NLMSG_TAIL(n), data, len);\n\tmemset((void *) NLMSG_TAIL(n) + len, 0, NLMSG_ALIGN(len) - len);\n\tn->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + NLMSG_ALIGN(len);\n\treturn 0;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "len"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "n->nlmsg_len"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *) NLMSG_TAIL(n) + len",
            "0",
            "NLMSG_ALIGN(len) - len"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "len"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "n"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "NLMSG_TAIL(n)",
            "data",
            "len"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "n"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"addraw_l ERROR: message exceeded bound of %d\\n\"",
            "maxlen"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "len"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "n->nlmsg_len"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint addraw_l(struct nlmsghdr *n, int maxlen, const void *data, int len)\n{\n\tif ((int)(NLMSG_ALIGN(n->nlmsg_len) + NLMSG_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr, \"addraw_l ERROR: message exceeded bound of %d\\n\",maxlen);\n\t\treturn -1;\n\t}\n\n\tmemcpy(NLMSG_TAIL(n), data, len);\n\tmemset((void *) NLMSG_TAIL(n) + len, 0, NLMSG_ALIGN(len) - len);\n\tn->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + NLMSG_ALIGN(len);\n\treturn 0;\n}"
  },
  {
    "function_name": "addattr_l",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "589-636",
    "snippet": "int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,\n\t      int alen)\n{\n\n#if 0\nprintf(\"%d: %s\\n\", __LINE__, __FUNCTION__);\nprintf(\"\\ttype %d - \", type);\nif (type == IFLA_LINK) {\n\tprintf(\"IFLA_LINK\\n\");\n\tint i;\n\tprintf(\"\\tdata - \");\n\tfor (i = 0; i < alen; i++)\n\t\tprintf(\"%02x, \", *((unsigned char *)data + i));\n\tprintf(\"\\n\");\n}\nelse if (type == IFLA_IFNAME) {\n\tprintf(\"IFLA_IFNAME\\n\");\n\tprintf(\"\\tdata - #%s#\\n\", data);\n}\nelse if (type == IFLA_LINKINFO) printf(\"IFLA_LINKINFO\\n\");\nelse if (type == IFLA_ADDRESS) {\n\tprintf(\"IFLA_ADDRESS or IFLA_INFO_KIND\\n\");\n\tint i;\n\tprintf(\"\\tdata - \");\n\tfor (i = 0; i < alen; i++)\n\t\tprintf(\"%02x, \", *((unsigned char *)data + i));\n\tprintf(\"\\n\");\n}\nelse if (type == IFLA_BROADCAST) printf(\"IFLA_BROADCAST or IFLA_INFO_DATA\\n\");\n\nprintf(\"\\tdata length: %d\\n\", alen);\n#endif\n\n\tint len = RTA_LENGTH(alen);\n\tstruct rtattr *rta;\n\n\tif ((int)(NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr, \"addattr_l ERROR: message exceeded bound of %d\\n\",maxlen);\n\t\treturn -1;\n\t}\n\trta = NLMSG_TAIL(n);\n\trta->rta_type = type;\n\trta->rta_len = len;\n\tif (data)\n\t\tmemcpy(RTA_DATA(rta), data, alen);\n\tn->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RTA_ALIGN",
          "args": [
            "len"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "n->nlmsg_len"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "RTA_DATA(rta)",
            "data",
            "alen"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "rta"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "n"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"addattr_l ERROR: message exceeded bound of %d\\n\"",
            "maxlen"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_ALIGN",
          "args": [
            "len"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "n->nlmsg_len"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_LENGTH",
          "args": [
            "alen"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tdata length: %d\\n\"",
            "alen"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IFLA_BROADCAST or IFLA_INFO_DATA\\n\""
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%02x, \"",
            "*((unsigned char *)data + i)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tdata - \""
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IFLA_ADDRESS or IFLA_INFO_KIND\\n\""
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IFLA_LINKINFO\\n\""
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tdata - #%s#\\n\"",
            "data"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IFLA_IFNAME\\n\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%02x, \"",
            "*((unsigned char *)data + i)"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tdata - \""
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IFLA_LINK\\n\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\ttype %d - \"",
            "type"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%d: %s\\n\"",
            "__LINE__",
            "__FUNCTION__"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,\n\t      int alen)\n{\n\n#if 0\nprintf(\"%d: %s\\n\", __LINE__, __FUNCTION__);\nprintf(\"\\ttype %d - \", type);\nif (type == IFLA_LINK) {\n\tprintf(\"IFLA_LINK\\n\");\n\tint i;\n\tprintf(\"\\tdata - \");\n\tfor (i = 0; i < alen; i++)\n\t\tprintf(\"%02x, \", *((unsigned char *)data + i));\n\tprintf(\"\\n\");\n}\nelse if (type == IFLA_IFNAME) {\n\tprintf(\"IFLA_IFNAME\\n\");\n\tprintf(\"\\tdata - #%s#\\n\", data);\n}\nelse if (type == IFLA_LINKINFO) printf(\"IFLA_LINKINFO\\n\");\nelse if (type == IFLA_ADDRESS) {\n\tprintf(\"IFLA_ADDRESS or IFLA_INFO_KIND\\n\");\n\tint i;\n\tprintf(\"\\tdata - \");\n\tfor (i = 0; i < alen; i++)\n\t\tprintf(\"%02x, \", *((unsigned char *)data + i));\n\tprintf(\"\\n\");\n}\nelse if (type == IFLA_BROADCAST) printf(\"IFLA_BROADCAST or IFLA_INFO_DATA\\n\");\n\nprintf(\"\\tdata length: %d\\n\", alen);\n#endif\n\n\tint len = RTA_LENGTH(alen);\n\tstruct rtattr *rta;\n\n\tif ((int)(NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr, \"addattr_l ERROR: message exceeded bound of %d\\n\",maxlen);\n\t\treturn -1;\n\t}\n\trta = NLMSG_TAIL(n);\n\trta->rta_type = type;\n\trta->rta_len = len;\n\tif (data)\n\t\tmemcpy(RTA_DATA(rta), data, alen);\n\tn->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
  },
  {
    "function_name": "addattrstrz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "582-585",
    "snippet": "int addattrstrz(struct nlmsghdr *n, int maxlen, int type, const char *str)\n{\n\treturn addattr_l(n, maxlen, type, str, strlen(str)+1);\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "n",
            "maxlen",
            "type",
            "str",
            "strlen(str)+1"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint addattrstrz(struct nlmsghdr *n, int maxlen, int type, const char *str)\n{\n\treturn addattr_l(n, maxlen, type, str, strlen(str)+1);\n}"
  },
  {
    "function_name": "addattr64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "577-580",
    "snippet": "int addattr64(struct nlmsghdr *n, int maxlen, int type, __u64 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u64));\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "n",
            "maxlen",
            "type",
            "&data",
            "sizeof(__u64)"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint addattr64(struct nlmsghdr *n, int maxlen, int type, __u64 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u64));\n}"
  },
  {
    "function_name": "addattr32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "572-575",
    "snippet": "int addattr32(struct nlmsghdr *n, int maxlen, int type, __u32 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u32));\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "n",
            "maxlen",
            "type",
            "&data",
            "sizeof(__u32)"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint addattr32(struct nlmsghdr *n, int maxlen, int type, __u32 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u32));\n}"
  },
  {
    "function_name": "addattr16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "567-570",
    "snippet": "int addattr16(struct nlmsghdr *n, int maxlen, int type, __u16 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u16));\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "n",
            "maxlen",
            "type",
            "&data",
            "sizeof(__u16)"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint addattr16(struct nlmsghdr *n, int maxlen, int type, __u16 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u16));\n}"
  },
  {
    "function_name": "addattr8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "562-565",
    "snippet": "int addattr8(struct nlmsghdr *n, int maxlen, int type, __u8 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u8));\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "n",
            "maxlen",
            "type",
            "&data",
            "sizeof(__u8)"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint addattr8(struct nlmsghdr *n, int maxlen, int type, __u8 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u8));\n}"
  },
  {
    "function_name": "addattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "557-560",
    "snippet": "int addattr(struct nlmsghdr *n, int maxlen, int type)\n{\n\treturn addattr_l(n, maxlen, type, NULL, 0);\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "n",
            "maxlen",
            "type",
            "NULL",
            "0"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint addattr(struct nlmsghdr *n, int maxlen, int type)\n{\n\treturn addattr_l(n, maxlen, type, NULL, 0);\n}"
  },
  {
    "function_name": "rtnl_from_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "503-555",
    "snippet": "int rtnl_from_file(FILE *rtnl, rtnl_filter_t handler,\n\t\t   void *jarg)\n{\n\tint status;\n\tstruct sockaddr_nl nladdr;\n\tchar   buf[8192];\n\tstruct nlmsghdr *h = (void*)buf;\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = 0;\n\tnladdr.nl_groups = 0;\n\n\twhile (1) {\n\t\tint err, len;\n\t\tint l;\n\n\t\tstatus = fread(&buf, 1, sizeof(*h), rtnl);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tperror(\"rtnl_from_file: fread\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0)\n\t\t\treturn 0;\n\n\t\tlen = h->nlmsg_len;\n\t\tl = len - sizeof(*h);\n\n\t\tif (l < 0 || len > (int)sizeof(buf)) {\n\t\t\tfprintf(stderr, \"!!!malformed message: len=%d @%lu\\n\",\n\t\t\t\tlen, ftell(rtnl));\n\t\t\treturn -1;\n\t\t}\n\n\t\tstatus = fread(NLMSG_DATA(h), 1, NLMSG_ALIGN(l), rtnl);\n\n\t\tif (status < 0) {\n\t\t\tperror(\"rtnl_from_file: fread\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (status < l) {\n\t\t\tfprintf(stderr, \"rtnl-from_file: truncated message\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = handler(&nladdr, h, jarg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler",
          "args": [
            "&nladdr",
            "h",
            "jarg"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"rtnl-from_file: truncated message\\n\""
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"rtnl_from_file: fread\""
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "NLMSG_DATA(h)",
            "1",
            "NLMSG_ALIGN(l)",
            "rtnl"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "l"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "h"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"!!!malformed message: len=%d @%lu\\n\"",
            "len",
            "ftell(rtnl)"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftell",
          "args": [
            "rtnl"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"rtnl_from_file: fread\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&buf",
            "1",
            "sizeof(*h)",
            "rtnl"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&nladdr",
            "0",
            "sizeof(nladdr)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_from_file(FILE *rtnl, rtnl_filter_t handler,\n\t\t   void *jarg)\n{\n\tint status;\n\tstruct sockaddr_nl nladdr;\n\tchar   buf[8192];\n\tstruct nlmsghdr *h = (void*)buf;\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = 0;\n\tnladdr.nl_groups = 0;\n\n\twhile (1) {\n\t\tint err, len;\n\t\tint l;\n\n\t\tstatus = fread(&buf, 1, sizeof(*h), rtnl);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tperror(\"rtnl_from_file: fread\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0)\n\t\t\treturn 0;\n\n\t\tlen = h->nlmsg_len;\n\t\tl = len - sizeof(*h);\n\n\t\tif (l < 0 || len > (int)sizeof(buf)) {\n\t\t\tfprintf(stderr, \"!!!malformed message: len=%d @%lu\\n\",\n\t\t\t\tlen, ftell(rtnl));\n\t\t\treturn -1;\n\t\t}\n\n\t\tstatus = fread(NLMSG_DATA(h), 1, NLMSG_ALIGN(l), rtnl);\n\n\t\tif (status < 0) {\n\t\t\tperror(\"rtnl_from_file: fread\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (status < l) {\n\t\t\tfprintf(stderr, \"rtnl-from_file: truncated message\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = handler(&nladdr, h, jarg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n}"
  },
  {
    "function_name": "rtnl_listen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "428-501",
    "snippet": "int rtnl_listen(struct rtnl_handle *rtnl,\n\t\trtnl_filter_t handler,\n\t\tvoid *jarg)\n{\n\tint status;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov;\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[8192];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = 0;\n\tnladdr.nl_groups = 0;\n\n\tiov.iov_base = buf;\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\tif (errno == ENOBUFS)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"Sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint err;\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l<0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\terr = handler(&nladdr, h, jarg);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"!!!Remnant of size %d\\n\"",
            "status"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Message truncated\\n\""
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "len"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "len"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler",
          "args": [
            "&nladdr",
            "h",
            "jarg"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"!!!malformed message: len=%d\\n\"",
            "len"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Truncated message\\n\""
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Sender address length == %d\\n\"",
            "msg.msg_namelen"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"EOF on netlink\\n\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"netlink receive error %s (%d)\\n\"",
            "strerror(errno)",
            "errno"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recvmsg",
          "args": [
            "rtnl->fd",
            "&msg",
            "0"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&nladdr",
            "0",
            "sizeof(nladdr)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_listen(struct rtnl_handle *rtnl,\n\t\trtnl_filter_t handler,\n\t\tvoid *jarg)\n{\n\tint status;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov;\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[8192];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = 0;\n\tnladdr.nl_groups = 0;\n\n\tiov.iov_base = buf;\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\tif (errno == ENOBUFS)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"Sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint err;\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l<0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\terr = handler(&nladdr, h, jarg);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rtnl_talk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "309-425",
    "snippet": "int rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,\n\t      unsigned groups, struct nlmsghdr *answer)\n{\n\tint status;\n\tunsigned seq;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov = {\n\t\t.iov_base = (void*) n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[16384];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = peer;\n\tnladdr.nl_groups = groups;\n\n\tn->nlmsg_seq = seq = ++rtnl->seq;\n\n\tif (answer == NULL)\n\t\tn->nlmsg_flags |= NLM_F_ACK;\n\n\tstatus = sendmsg(rtnl->fd, &msg, 0);\n\n\tif (status < 0) {\n\t\tperror(\"Cannot talk to rtnetlink\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf,0,sizeof(buf));\n\n\tiov.iov_base = buf;\n\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l < 0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((pid_t)(nladdr.nl_pid) != peer ||\n\t\t\t    h->nlmsg_pid != rtnl->local.nl_pid ||\n\t\t\t    h->nlmsg_seq != seq) {\n\t\t\t\t/* Don't forget to skip that message. */\n\t\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\tif (l < (int)sizeof(struct nlmsgerr)) {\n\t\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (!err->error) {\n\t\t\t\t\t\tif (answer)\n\t\t\t\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfprintf(stderr, \"RTNETLINK answers: %s\\n\", strerror(-err->error));\n\t\t\t\t\terrno = -err->error;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (answer) {\n\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfprintf(stderr, \"Unexpected reply!!!\\n\");\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"!!!Remnant of size %d\\n\"",
            "status"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Message truncated\\n\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "len"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "len"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Unexpected reply!!!\\n\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "answer",
            "h",
            "h->nlmsg_len"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"RTNETLINK answers: %s\\n\"",
            "strerror(-err->error)"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-err->error"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "answer",
            "h",
            "h->nlmsg_len"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR truncated\\n\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "h"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "len"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_ALIGN",
          "args": [
            "len"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "nladdr.nl_pid"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"!!!malformed message: len=%d\\n\"",
            "len"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Truncated message\\n\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sender address length == %d\\n\"",
            "msg.msg_namelen"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"EOF on netlink\\n\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"netlink receive error %s (%d)\\n\"",
            "strerror(errno)",
            "errno"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recvmsg",
          "args": [
            "rtnl->fd",
            "&msg",
            "0"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(buf)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"Cannot talk to rtnetlink\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendmsg",
          "args": [
            "rtnl->fd",
            "&msg",
            "0"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&nladdr",
            "0",
            "sizeof(nladdr)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,\n\t      unsigned groups, struct nlmsghdr *answer)\n{\n\tint status;\n\tunsigned seq;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov = {\n\t\t.iov_base = (void*) n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[16384];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = peer;\n\tnladdr.nl_groups = groups;\n\n\tn->nlmsg_seq = seq = ++rtnl->seq;\n\n\tif (answer == NULL)\n\t\tn->nlmsg_flags |= NLM_F_ACK;\n\n\tstatus = sendmsg(rtnl->fd, &msg, 0);\n\n\tif (status < 0) {\n\t\tperror(\"Cannot talk to rtnetlink\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf,0,sizeof(buf));\n\n\tiov.iov_base = buf;\n\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l < 0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((pid_t)(nladdr.nl_pid) != peer ||\n\t\t\t    h->nlmsg_pid != rtnl->local.nl_pid ||\n\t\t\t    h->nlmsg_seq != seq) {\n\t\t\t\t/* Don't forget to skip that message. */\n\t\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\tif (l < (int)sizeof(struct nlmsgerr)) {\n\t\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (!err->error) {\n\t\t\t\t\t\tif (answer)\n\t\t\t\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfprintf(stderr, \"RTNETLINK answers: %s\\n\", strerror(-err->error));\n\t\t\t\t\terrno = -err->error;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (answer) {\n\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfprintf(stderr, \"Unexpected reply!!!\\n\");\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rtnl_dump_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "296-306",
    "snippet": "int rtnl_dump_filter(struct rtnl_handle *rth,\n\t\t     rtnl_filter_t filter,\n\t\t     void *arg1)\n{\n\tconst struct rtnl_dump_filter_arg a[2] = {\n\t\t{ .filter = filter, .arg1 = arg1, },\n\t\t{ .filter = NULL,   .arg1 = NULL, },\n\t};\n\n\treturn rtnl_dump_filter_l(rth, a);\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtnl_dump_filter_l",
          "args": [
            "rth",
            "a"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_dump_filter_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "202-294",
          "snippet": "int rtnl_dump_filter_l(struct rtnl_handle *rth,\n\t\t       const struct rtnl_dump_filter_arg *arg)\n{\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov;\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar buf[16384];\n\tint dump_intr = 0;\n\n\tiov.iov_base = buf;\n\twhile (1) {\n\t\tint status;\n\t\tconst struct rtnl_dump_filter_arg *a;\n\t\tint found_done = 0;\n\t\tint msglen = 0;\n\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rth->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (a = arg; a->filter; a++) {\n\t\t\tstruct nlmsghdr *h = (struct nlmsghdr*)buf;\n\t\t\tmsglen = status;\n\n\t\t\twhile (NLMSG_OK(h, (unsigned) msglen)) {\n\t\t\t\tint err;\n\n\t\t\t\tif (nladdr.nl_pid != 0 ||\n\t\t\t\t    h->nlmsg_pid != rth->local.nl_pid ||\n\t\t\t\t    h->nlmsg_seq != rth->dump)\n\t\t\t\t\tgoto skip_it;\n\n\t\t\t\tif (h->nlmsg_flags & NLM_F_DUMP_INTR)\n\t\t\t\t\tdump_intr = 1;\n\n\t\t\t\tif (h->nlmsg_type == NLMSG_DONE) {\n\t\t\t\t\tfound_done = 1;\n\t\t\t\t\tbreak; /* process next filter */\n\t\t\t\t}\n\t\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {\n\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\t\"ERROR truncated\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrno = -err->error;\n\t\t\t\t\t\tperror(\"RTNETLINK answers\");\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\terr = a->filter(&nladdr, h, a->arg1);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\nskip_it:\n\t\t\t\th = NLMSG_NEXT(h, msglen);\n\t\t\t}\n\t\t}\n\n\t\tif (found_done) {\n\t\t\tif (dump_intr)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Dump was interrupted and may be inconsistent.\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (msglen) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", msglen);\n\t\t\texit(1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_dump_filter_l(struct rtnl_handle *rth,\n\t\t       const struct rtnl_dump_filter_arg *arg)\n{\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov;\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar buf[16384];\n\tint dump_intr = 0;\n\n\tiov.iov_base = buf;\n\twhile (1) {\n\t\tint status;\n\t\tconst struct rtnl_dump_filter_arg *a;\n\t\tint found_done = 0;\n\t\tint msglen = 0;\n\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rth->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (a = arg; a->filter; a++) {\n\t\t\tstruct nlmsghdr *h = (struct nlmsghdr*)buf;\n\t\t\tmsglen = status;\n\n\t\t\twhile (NLMSG_OK(h, (unsigned) msglen)) {\n\t\t\t\tint err;\n\n\t\t\t\tif (nladdr.nl_pid != 0 ||\n\t\t\t\t    h->nlmsg_pid != rth->local.nl_pid ||\n\t\t\t\t    h->nlmsg_seq != rth->dump)\n\t\t\t\t\tgoto skip_it;\n\n\t\t\t\tif (h->nlmsg_flags & NLM_F_DUMP_INTR)\n\t\t\t\t\tdump_intr = 1;\n\n\t\t\t\tif (h->nlmsg_type == NLMSG_DONE) {\n\t\t\t\t\tfound_done = 1;\n\t\t\t\t\tbreak; /* process next filter */\n\t\t\t\t}\n\t\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {\n\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\t\"ERROR truncated\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrno = -err->error;\n\t\t\t\t\t\tperror(\"RTNETLINK answers\");\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\terr = a->filter(&nladdr, h, a->arg1);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\nskip_it:\n\t\t\t\th = NLMSG_NEXT(h, msglen);\n\t\t\t}\n\t\t}\n\n\t\tif (found_done) {\n\t\t\tif (dump_intr)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Dump was interrupted and may be inconsistent.\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (msglen) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", msglen);\n\t\t\texit(1);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_dump_filter(struct rtnl_handle *rth,\n\t\t     rtnl_filter_t filter,\n\t\t     void *arg1)\n{\n\tconst struct rtnl_dump_filter_arg a[2] = {\n\t\t{ .filter = filter, .arg1 = arg1, },\n\t\t{ .filter = NULL,   .arg1 = NULL, },\n\t};\n\n\treturn rtnl_dump_filter_l(rth, a);\n}"
  },
  {
    "function_name": "rtnl_dump_filter_l",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "202-294",
    "snippet": "int rtnl_dump_filter_l(struct rtnl_handle *rth,\n\t\t       const struct rtnl_dump_filter_arg *arg)\n{\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov;\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar buf[16384];\n\tint dump_intr = 0;\n\n\tiov.iov_base = buf;\n\twhile (1) {\n\t\tint status;\n\t\tconst struct rtnl_dump_filter_arg *a;\n\t\tint found_done = 0;\n\t\tint msglen = 0;\n\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rth->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (a = arg; a->filter; a++) {\n\t\t\tstruct nlmsghdr *h = (struct nlmsghdr*)buf;\n\t\t\tmsglen = status;\n\n\t\t\twhile (NLMSG_OK(h, (unsigned) msglen)) {\n\t\t\t\tint err;\n\n\t\t\t\tif (nladdr.nl_pid != 0 ||\n\t\t\t\t    h->nlmsg_pid != rth->local.nl_pid ||\n\t\t\t\t    h->nlmsg_seq != rth->dump)\n\t\t\t\t\tgoto skip_it;\n\n\t\t\t\tif (h->nlmsg_flags & NLM_F_DUMP_INTR)\n\t\t\t\t\tdump_intr = 1;\n\n\t\t\t\tif (h->nlmsg_type == NLMSG_DONE) {\n\t\t\t\t\tfound_done = 1;\n\t\t\t\t\tbreak; /* process next filter */\n\t\t\t\t}\n\t\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {\n\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\t\"ERROR truncated\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrno = -err->error;\n\t\t\t\t\t\tperror(\"RTNETLINK answers\");\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\terr = a->filter(&nladdr, h, a->arg1);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\nskip_it:\n\t\t\t\th = NLMSG_NEXT(h, msglen);\n\t\t\t}\n\t\t}\n\n\t\tif (found_done) {\n\t\t\tif (dump_intr)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Dump was interrupted and may be inconsistent.\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (msglen) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", msglen);\n\t\t\texit(1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"!!!Remnant of size %d\\n\"",
            "msglen"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Message truncated\\n\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Dump was interrupted and may be inconsistent.\\n\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_NEXT",
          "args": [
            "h",
            "msglen"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a->filter",
          "args": [
            "&nladdr",
            "h",
            "a->arg1"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"RTNETLINK answers\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR truncated\\n\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(struct nlmsgerr)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "h"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_OK",
          "args": [
            "h",
            "(unsigned) msglen"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"EOF on netlink\\n\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"netlink receive error %s (%d)\\n\"",
            "strerror(errno)",
            "errno"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recvmsg",
          "args": [
            "rth->fd",
            "&msg",
            "0"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_dump_filter_l(struct rtnl_handle *rth,\n\t\t       const struct rtnl_dump_filter_arg *arg)\n{\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov;\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar buf[16384];\n\tint dump_intr = 0;\n\n\tiov.iov_base = buf;\n\twhile (1) {\n\t\tint status;\n\t\tconst struct rtnl_dump_filter_arg *a;\n\t\tint found_done = 0;\n\t\tint msglen = 0;\n\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rth->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (a = arg; a->filter; a++) {\n\t\t\tstruct nlmsghdr *h = (struct nlmsghdr*)buf;\n\t\t\tmsglen = status;\n\n\t\t\twhile (NLMSG_OK(h, (unsigned) msglen)) {\n\t\t\t\tint err;\n\n\t\t\t\tif (nladdr.nl_pid != 0 ||\n\t\t\t\t    h->nlmsg_pid != rth->local.nl_pid ||\n\t\t\t\t    h->nlmsg_seq != rth->dump)\n\t\t\t\t\tgoto skip_it;\n\n\t\t\t\tif (h->nlmsg_flags & NLM_F_DUMP_INTR)\n\t\t\t\t\tdump_intr = 1;\n\n\t\t\t\tif (h->nlmsg_type == NLMSG_DONE) {\n\t\t\t\t\tfound_done = 1;\n\t\t\t\t\tbreak; /* process next filter */\n\t\t\t\t}\n\t\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {\n\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\t\"ERROR truncated\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrno = -err->error;\n\t\t\t\t\t\tperror(\"RTNETLINK answers\");\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\terr = a->filter(&nladdr, h, a->arg1);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\nskip_it:\n\t\t\t\th = NLMSG_NEXT(h, msglen);\n\t\t\t}\n\t\t}\n\n\t\tif (found_done) {\n\t\t\tif (dump_intr)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Dump was interrupted and may be inconsistent.\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (msglen) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", msglen);\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rtnl_dump_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "178-200",
    "snippet": "int rtnl_dump_request(struct rtnl_handle *rth, int type, void *req, int len)\n{\n\tstruct nlmsghdr nlh;\n\tstruct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };\n\tstruct iovec iov[2] = {\n\t\t{ .iov_base = &nlh, .iov_len = sizeof(nlh) },\n\t\t{ .iov_base = req, .iov_len = len }\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = \tsizeof(nladdr),\n\t\t.msg_iov = iov,\n\t\t.msg_iovlen = 2,\n\t};\n\n\tnlh.nlmsg_len = NLMSG_LENGTH(len);\n\tnlh.nlmsg_type = type;\n\tnlh.nlmsg_flags = NLM_F_DUMP|NLM_F_REQUEST;\n\tnlh.nlmsg_pid = 0;\n\tnlh.nlmsg_seq = rth->dump = ++rth->seq;\n\n\treturn sendmsg(rth->fd, &msg, 0);\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendmsg",
          "args": [
            "rth->fd",
            "&msg",
            "0"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "len"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_dump_request(struct rtnl_handle *rth, int type, void *req, int len)\n{\n\tstruct nlmsghdr nlh;\n\tstruct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };\n\tstruct iovec iov[2] = {\n\t\t{ .iov_base = &nlh, .iov_len = sizeof(nlh) },\n\t\t{ .iov_base = req, .iov_len = len }\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = \tsizeof(nladdr),\n\t\t.msg_iov = iov,\n\t\t.msg_iovlen = 2,\n\t};\n\n\tnlh.nlmsg_len = NLMSG_LENGTH(len);\n\tnlh.nlmsg_type = type;\n\tnlh.nlmsg_flags = NLM_F_DUMP|NLM_F_REQUEST;\n\tnlh.nlmsg_pid = 0;\n\tnlh.nlmsg_seq = rth->dump = ++rth->seq;\n\n\treturn sendmsg(rth->fd, &msg, 0);\n}"
  },
  {
    "function_name": "rtnl_send_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "145-176",
    "snippet": "int rtnl_send_check(struct rtnl_handle *rth, const void *buf, int len)\n{\n\tstruct nlmsghdr *h;\n\tint status;\n\tchar resp[1024];\n\n\tstatus = send(rth->fd, buf, len, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\t/* Check for immediate errors */\n\tstatus = recv(rth->fd, resp, sizeof(resp), MSG_DONTWAIT|MSG_PEEK);\n\tif (status < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\n\tfor (h = (struct nlmsghdr *)resp; NLMSG_OK(h, (unsigned) status);\n\t     h = NLMSG_NEXT(h, status)) {\n\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr)))\n\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\telse\n\t\t\t\terrno = -err->error;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR truncated\\n\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(struct nlmsgerr)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "h"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_NEXT",
          "args": [
            "h",
            "status"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_OK",
          "args": [
            "h",
            "(unsigned) status"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "rth->fd",
            "resp",
            "sizeof(resp)",
            "MSG_DONTWAIT|MSG_PEEK"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "rth->fd",
            "buf",
            "len",
            "0"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_send_check(struct rtnl_handle *rth, const void *buf, int len)\n{\n\tstruct nlmsghdr *h;\n\tint status;\n\tchar resp[1024];\n\n\tstatus = send(rth->fd, buf, len, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\t/* Check for immediate errors */\n\tstatus = recv(rth->fd, resp, sizeof(resp), MSG_DONTWAIT|MSG_PEEK);\n\tif (status < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\n\tfor (h = (struct nlmsghdr *)resp; NLMSG_OK(h, (unsigned) status);\n\t     h = NLMSG_NEXT(h, status)) {\n\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr)))\n\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\telse\n\t\t\t\terrno = -err->error;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rtnl_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "140-143",
    "snippet": "int rtnl_send(struct rtnl_handle *rth, const void *buf, int len)\n{\n\treturn send(rth->fd, buf, len, 0);\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send",
          "args": [
            "rth->fd",
            "buf",
            "len",
            "0"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_send(struct rtnl_handle *rth, const void *buf, int len)\n{\n\treturn send(rth->fd, buf, len, 0);\n}"
  },
  {
    "function_name": "rtnl_wilddump_req_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "114-138",
    "snippet": "int rtnl_wilddump_req_filter(struct rtnl_handle *rth, int family, int type,\n\t\t\t    __u32 filt_mask)\n{\n\tstruct {\n\t\tstruct nlmsghdr nlh;\n\t\tstruct ifinfomsg ifm;\n\t\t/* attribute has to be NLMSG aligned */\n\t\tstruct rtattr ext_req __attribute__ ((aligned(NLMSG_ALIGNTO)));\n\t\t__u32 ext_filter_mask;\n\t} req;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nlh.nlmsg_len = sizeof(req);\n\treq.nlh.nlmsg_type = type;\n\treq.nlh.nlmsg_flags = NLM_F_DUMP|NLM_F_REQUEST;\n\treq.nlh.nlmsg_pid = 0;\n\treq.nlh.nlmsg_seq = rth->dump = ++rth->seq;\n\treq.ifm.ifi_family = family;\n\n\treq.ext_req.rta_type = IFLA_EXT_MASK;\n\treq.ext_req.rta_len = RTA_LENGTH(sizeof(__u32));\n\treq.ext_filter_mask = filt_mask;\n\n\treturn send(rth->fd, (void*)&req, sizeof(req), 0);\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send",
          "args": [
            "rth->fd",
            "(void*)&req",
            "sizeof(req)",
            "0"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_LENGTH",
          "args": [
            "sizeof(__u32)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&req",
            "0",
            "sizeof(req)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aligned",
          "args": [
            "NLMSG_ALIGNTO"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_wilddump_req_filter(struct rtnl_handle *rth, int family, int type,\n\t\t\t    __u32 filt_mask)\n{\n\tstruct {\n\t\tstruct nlmsghdr nlh;\n\t\tstruct ifinfomsg ifm;\n\t\t/* attribute has to be NLMSG aligned */\n\t\tstruct rtattr ext_req __attribute__ ((aligned(NLMSG_ALIGNTO)));\n\t\t__u32 ext_filter_mask;\n\t} req;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nlh.nlmsg_len = sizeof(req);\n\treq.nlh.nlmsg_type = type;\n\treq.nlh.nlmsg_flags = NLM_F_DUMP|NLM_F_REQUEST;\n\treq.nlh.nlmsg_pid = 0;\n\treq.nlh.nlmsg_seq = rth->dump = ++rth->seq;\n\treq.ifm.ifi_family = family;\n\n\treq.ext_req.rta_type = IFLA_EXT_MASK;\n\treq.ext_req.rta_len = RTA_LENGTH(sizeof(__u32));\n\treq.ext_filter_mask = filt_mask;\n\n\treturn send(rth->fd, (void*)&req, sizeof(req), 0);\n}"
  },
  {
    "function_name": "rtnl_wilddump_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "109-112",
    "snippet": "int rtnl_wilddump_request(struct rtnl_handle *rth, int family, int type)\n{\n\treturn rtnl_wilddump_req_filter(rth, family, type, RTEXT_FILTER_VF);\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtnl_wilddump_req_filter",
          "args": [
            "rth",
            "family",
            "type",
            "RTEXT_FILTER_VF"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_wilddump_req_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "114-138",
          "snippet": "int rtnl_wilddump_req_filter(struct rtnl_handle *rth, int family, int type,\n\t\t\t    __u32 filt_mask)\n{\n\tstruct {\n\t\tstruct nlmsghdr nlh;\n\t\tstruct ifinfomsg ifm;\n\t\t/* attribute has to be NLMSG aligned */\n\t\tstruct rtattr ext_req __attribute__ ((aligned(NLMSG_ALIGNTO)));\n\t\t__u32 ext_filter_mask;\n\t} req;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nlh.nlmsg_len = sizeof(req);\n\treq.nlh.nlmsg_type = type;\n\treq.nlh.nlmsg_flags = NLM_F_DUMP|NLM_F_REQUEST;\n\treq.nlh.nlmsg_pid = 0;\n\treq.nlh.nlmsg_seq = rth->dump = ++rth->seq;\n\treq.ifm.ifi_family = family;\n\n\treq.ext_req.rta_type = IFLA_EXT_MASK;\n\treq.ext_req.rta_len = RTA_LENGTH(sizeof(__u32));\n\treq.ext_filter_mask = filt_mask;\n\n\treturn send(rth->fd, (void*)&req, sizeof(req), 0);\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_wilddump_req_filter(struct rtnl_handle *rth, int family, int type,\n\t\t\t    __u32 filt_mask)\n{\n\tstruct {\n\t\tstruct nlmsghdr nlh;\n\t\tstruct ifinfomsg ifm;\n\t\t/* attribute has to be NLMSG aligned */\n\t\tstruct rtattr ext_req __attribute__ ((aligned(NLMSG_ALIGNTO)));\n\t\t__u32 ext_filter_mask;\n\t} req;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nlh.nlmsg_len = sizeof(req);\n\treq.nlh.nlmsg_type = type;\n\treq.nlh.nlmsg_flags = NLM_F_DUMP|NLM_F_REQUEST;\n\treq.nlh.nlmsg_pid = 0;\n\treq.nlh.nlmsg_seq = rth->dump = ++rth->seq;\n\treq.ifm.ifi_family = family;\n\n\treq.ext_req.rta_type = IFLA_EXT_MASK;\n\treq.ext_req.rta_len = RTA_LENGTH(sizeof(__u32));\n\treq.ext_filter_mask = filt_mask;\n\n\treturn send(rth->fd, (void*)&req, sizeof(req), 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_wilddump_request(struct rtnl_handle *rth, int family, int type)\n{\n\treturn rtnl_wilddump_req_filter(rth, family, type, RTEXT_FILTER_VF);\n}"
  },
  {
    "function_name": "rtnl_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "103-106",
    "snippet": "int rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)\n{\n\treturn rtnl_open_byproto(rth, subscriptions, NETLINK_ROUTE);\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtnl_open_byproto",
          "args": [
            "rth",
            "subscriptions",
            "NETLINK_ROUTE"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_open_byproto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "54-101",
          "snippet": "int rtnl_open_byproto(struct rtnl_handle *rth, unsigned subscriptions,\n\t\t      int protocol)\n{\n\tsocklen_t addr_len;\n\tint sndbuf = 32768;\n\n\tmemset(rth, 0, sizeof(*rth));\n\n\trth->fd = socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, protocol);\n\tif (rth->fd < 0) {\n\t\tperror(\"Cannot open netlink socket\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(rth->fd,SOL_SOCKET,SO_SNDBUF,&sndbuf,sizeof(sndbuf)) < 0) {\n\t\tperror(\"SO_SNDBUF\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(rth->fd,SOL_SOCKET,SO_RCVBUF,&rcvbuf,sizeof(rcvbuf)) < 0) {\n\t\tperror(\"SO_RCVBUF\");\n\t\treturn -1;\n\t}\n\n\tmemset(&rth->local, 0, sizeof(rth->local));\n\trth->local.nl_family = AF_NETLINK;\n\trth->local.nl_groups = subscriptions;\n\n\tif (bind(rth->fd, (struct sockaddr*)&rth->local, sizeof(rth->local)) < 0) {\n\t\tperror(\"Cannot bind netlink socket\");\n\t\treturn -1;\n\t}\n\taddr_len = sizeof(rth->local);\n\tif (getsockname(rth->fd, (struct sockaddr*)&rth->local, &addr_len) < 0) {\n\t\tperror(\"Cannot getsockname\");\n\t\treturn -1;\n\t}\n\tif (addr_len != sizeof(rth->local)) {\n\t\tfprintf(stderr, \"Wrong address length %d\\n\", addr_len);\n\t\treturn -1;\n\t}\n\tif (rth->local.nl_family != AF_NETLINK) {\n\t\tfprintf(stderr, \"Wrong address family %d\\n\", rth->local.nl_family);\n\t\treturn -1;\n\t}\n\trth->seq = time(NULL);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int rcvbuf = 1024 * 1024;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rcvbuf = 1024 * 1024;\n\nint rtnl_open_byproto(struct rtnl_handle *rth, unsigned subscriptions,\n\t\t      int protocol)\n{\n\tsocklen_t addr_len;\n\tint sndbuf = 32768;\n\n\tmemset(rth, 0, sizeof(*rth));\n\n\trth->fd = socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, protocol);\n\tif (rth->fd < 0) {\n\t\tperror(\"Cannot open netlink socket\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(rth->fd,SOL_SOCKET,SO_SNDBUF,&sndbuf,sizeof(sndbuf)) < 0) {\n\t\tperror(\"SO_SNDBUF\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(rth->fd,SOL_SOCKET,SO_RCVBUF,&rcvbuf,sizeof(rcvbuf)) < 0) {\n\t\tperror(\"SO_RCVBUF\");\n\t\treturn -1;\n\t}\n\n\tmemset(&rth->local, 0, sizeof(rth->local));\n\trth->local.nl_family = AF_NETLINK;\n\trth->local.nl_groups = subscriptions;\n\n\tif (bind(rth->fd, (struct sockaddr*)&rth->local, sizeof(rth->local)) < 0) {\n\t\tperror(\"Cannot bind netlink socket\");\n\t\treturn -1;\n\t}\n\taddr_len = sizeof(rth->local);\n\tif (getsockname(rth->fd, (struct sockaddr*)&rth->local, &addr_len) < 0) {\n\t\tperror(\"Cannot getsockname\");\n\t\treturn -1;\n\t}\n\tif (addr_len != sizeof(rth->local)) {\n\t\tfprintf(stderr, \"Wrong address length %d\\n\", addr_len);\n\t\treturn -1;\n\t}\n\tif (rth->local.nl_family != AF_NETLINK) {\n\t\tfprintf(stderr, \"Wrong address family %d\\n\", rth->local.nl_family);\n\t\treturn -1;\n\t}\n\trth->seq = time(NULL);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)\n{\n\treturn rtnl_open_byproto(rth, subscriptions, NETLINK_ROUTE);\n}"
  },
  {
    "function_name": "rtnl_open_byproto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "54-101",
    "snippet": "int rtnl_open_byproto(struct rtnl_handle *rth, unsigned subscriptions,\n\t\t      int protocol)\n{\n\tsocklen_t addr_len;\n\tint sndbuf = 32768;\n\n\tmemset(rth, 0, sizeof(*rth));\n\n\trth->fd = socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, protocol);\n\tif (rth->fd < 0) {\n\t\tperror(\"Cannot open netlink socket\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(rth->fd,SOL_SOCKET,SO_SNDBUF,&sndbuf,sizeof(sndbuf)) < 0) {\n\t\tperror(\"SO_SNDBUF\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(rth->fd,SOL_SOCKET,SO_RCVBUF,&rcvbuf,sizeof(rcvbuf)) < 0) {\n\t\tperror(\"SO_RCVBUF\");\n\t\treturn -1;\n\t}\n\n\tmemset(&rth->local, 0, sizeof(rth->local));\n\trth->local.nl_family = AF_NETLINK;\n\trth->local.nl_groups = subscriptions;\n\n\tif (bind(rth->fd, (struct sockaddr*)&rth->local, sizeof(rth->local)) < 0) {\n\t\tperror(\"Cannot bind netlink socket\");\n\t\treturn -1;\n\t}\n\taddr_len = sizeof(rth->local);\n\tif (getsockname(rth->fd, (struct sockaddr*)&rth->local, &addr_len) < 0) {\n\t\tperror(\"Cannot getsockname\");\n\t\treturn -1;\n\t}\n\tif (addr_len != sizeof(rth->local)) {\n\t\tfprintf(stderr, \"Wrong address length %d\\n\", addr_len);\n\t\treturn -1;\n\t}\n\tif (rth->local.nl_family != AF_NETLINK) {\n\t\tfprintf(stderr, \"Wrong address family %d\\n\", rth->local.nl_family);\n\t\treturn -1;\n\t}\n\trth->seq = time(NULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int rcvbuf = 1024 * 1024;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "pid_get_start_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "92-125",
          "snippet": "unsigned long long pid_get_start_time(unsigned pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/stat\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\treturn 0;\n\t}\n\tfree(file);\n\n\tchar line[PIDS_BUFLEN];\n\tunsigned long long retval = 0;\n\tif (fgets(line, PIDS_BUFLEN - 1, fp)) {\n\t\tchar *ptr = line;\n\t\t// jump 21 fields\n\t\tint i;\n\t\tfor (i = 0; i < 21; i++) {\n\t\t\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0')\n\t\t\t\tptr++;\n\t\t\tif (*ptr == '\\0')\n\t\t\t\tgoto myexit;\n\t\t\tptr++;\n\t\t}\n\t\tif (1 != sscanf(ptr, \"%llu\", &retval))\n\t\t\tgoto myexit;\n\t}\n\nmyexit:\n\tfclose(fp);\n\treturn retval;\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [
            "#define PIDS_BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\n#define PIDS_BUFLEN 4096\n\nunsigned long long pid_get_start_time(unsigned pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/stat\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\treturn 0;\n\t}\n\tfree(file);\n\n\tchar line[PIDS_BUFLEN];\n\tunsigned long long retval = 0;\n\tif (fgets(line, PIDS_BUFLEN - 1, fp)) {\n\t\tchar *ptr = line;\n\t\t// jump 21 fields\n\t\tint i;\n\t\tfor (i = 0; i < 21; i++) {\n\t\t\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0')\n\t\t\t\tptr++;\n\t\t\tif (*ptr == '\\0')\n\t\t\t\tgoto myexit;\n\t\t\tptr++;\n\t\t}\n\t\tif (1 != sscanf(ptr, \"%llu\", &retval))\n\t\t\tgoto myexit;\n\t}\n\nmyexit:\n\tfclose(fp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Wrong address family %d\\n\"",
            "rth->local.nl_family"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Wrong address length %d\\n\"",
            "addr_len"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"Cannot getsockname\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "rth->fd",
            "(struct sockaddr*)&rth->local",
            "&addr_len"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"Cannot bind netlink socket\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "rth->fd",
            "(struct sockaddr*)&rth->local",
            "sizeof(rth->local)"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "bind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "548-556",
          "snippet": "int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {\n\tif (!orig_bind)\n\t\torig_bind = (orig_bind_t)dlsym(RTLD_NEXT, \"bind\");\n\n\tint rv = orig_bind(sockfd, addr, addrlen);\n\tprint_sockaddr(sockfd, \"bind\", addr, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_bind_t orig_bind = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_bind_t orig_bind = NULL;\n\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {\n\tif (!orig_bind)\n\t\torig_bind = (orig_bind_t)dlsym(RTLD_NEXT, \"bind\");\n\n\tint rv = orig_bind(sockfd, addr, addrlen);\n\tprint_sockaddr(sockfd, \"bind\", addr, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rth->local",
            "0",
            "sizeof(rth->local)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"SO_RCVBUF\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "rth->fd",
            "SOL_SOCKET",
            "SO_RCVBUF",
            "&rcvbuf",
            "sizeof(rcvbuf)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"SO_SNDBUF\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "rth->fd",
            "SOL_SOCKET",
            "SO_SNDBUF",
            "&sndbuf",
            "sizeof(sndbuf)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"Cannot open netlink socket\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_NETLINK",
            "SOCK_RAW | SOCK_CLOEXEC",
            "protocol"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rth",
            "0",
            "sizeof(*rth)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rcvbuf = 1024 * 1024;\n\nint rtnl_open_byproto(struct rtnl_handle *rth, unsigned subscriptions,\n\t\t      int protocol)\n{\n\tsocklen_t addr_len;\n\tint sndbuf = 32768;\n\n\tmemset(rth, 0, sizeof(*rth));\n\n\trth->fd = socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, protocol);\n\tif (rth->fd < 0) {\n\t\tperror(\"Cannot open netlink socket\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(rth->fd,SOL_SOCKET,SO_SNDBUF,&sndbuf,sizeof(sndbuf)) < 0) {\n\t\tperror(\"SO_SNDBUF\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(rth->fd,SOL_SOCKET,SO_RCVBUF,&rcvbuf,sizeof(rcvbuf)) < 0) {\n\t\tperror(\"SO_RCVBUF\");\n\t\treturn -1;\n\t}\n\n\tmemset(&rth->local, 0, sizeof(rth->local));\n\trth->local.nl_family = AF_NETLINK;\n\trth->local.nl_groups = subscriptions;\n\n\tif (bind(rth->fd, (struct sockaddr*)&rth->local, sizeof(rth->local)) < 0) {\n\t\tperror(\"Cannot bind netlink socket\");\n\t\treturn -1;\n\t}\n\taddr_len = sizeof(rth->local);\n\tif (getsockname(rth->fd, (struct sockaddr*)&rth->local, &addr_len) < 0) {\n\t\tperror(\"Cannot getsockname\");\n\t\treturn -1;\n\t}\n\tif (addr_len != sizeof(rth->local)) {\n\t\tfprintf(stderr, \"Wrong address length %d\\n\", addr_len);\n\t\treturn -1;\n\t}\n\tif (rth->local.nl_family != AF_NETLINK) {\n\t\tfprintf(stderr, \"Wrong address family %d\\n\", rth->local.nl_family);\n\t\treturn -1;\n\t}\n\trth->seq = time(NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "rtnl_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
    "lines": "46-52",
    "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
    "includes": [
      "#include \"../include/libnetlink.h\"",
      "#include <sys/uio.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <net/if_arp.h>",
      "#include <fcntl.h>",
      "#include <syslog.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "rth->fd"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
  }
]