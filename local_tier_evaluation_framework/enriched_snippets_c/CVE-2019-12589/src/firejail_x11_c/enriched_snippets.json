[
  {
    "function_name": "x11_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "1288-1321",
    "snippet": "void x11_block(void) {\n#ifdef HAVE_X11\n\t// check abstract socket presence and network namespace options\n\tif ((!arg_nonetwork && !cfg.bridge0.configured && !cfg.interface0.configured)\n\t&& x11_abstract_sockets_present()) {\n\t\tfprintf(stderr, \"ERROR: --x11=none specified, but abstract X11 socket still accessible.\\n\"\n\t\t\t\"Additional setup required. To block abstract X11 socket you can either:\\n\"\n\t\t\t\" * use network namespace in firejail (--net=none, --net=...)\\n\"\n\t\t\t\" * add \\\"-nolisten local\\\" to xserver options\\n\"\n\t\t\t\"   (eg. to your display manager config, or /etc/X11/xinit/xserverrc)\\n\");\n\t\texit(1);\n\t}\n\n\t// blacklist sockets\n\tprofile_check_line(\"blacklist /tmp/.X11-unix\", 0, NULL);\n\tprofile_add(strdup(\"blacklist /tmp/.X11-unix\"));\n\n\t// blacklist .Xauthority\n\tprofile_check_line(\"blacklist ${HOME}/.Xauthority\", 0, NULL);\n\tprofile_add(strdup(\"blacklist ${HOME}/.Xauthority\"));\n\tchar *xauthority = getenv(\"XAUTHORITY\");\n\tif (xauthority) {\n\t\tchar *line;\n\t\tif (asprintf(&line, \"blacklist %s\", xauthority) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tprofile_check_line(line, 0, NULL);\n\t\tprofile_add(line);\n\t}\n\n\t// clear environment\n\tenv_store(\"DISPLAY\", RMENV);\n\tenv_store(\"XAUTHORITY\", RMENV);\n#endif\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_store",
          "args": [
            "\"XAUTHORITY\"",
            "RMENV"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "env_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
          "lines": "167-206",
          "snippet": "void env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_add",
          "args": [
            "line"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "1364-1383",
          "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_check_line",
          "args": [
            "line",
            "0",
            "NULL"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "profile_check_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/profile.c",
          "lines": "243-1361",
          "snippet": "int profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\n\t// check and process conditional profile lines\n\tif (profile_check_conditional(ptr, lineno, fname) == 0)\n\t\treturn 0;\n\n\t// check ignore list\n\tif (is_in_ignore_list(ptr))\n\t\treturn 0;\n\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tprofile_add_ignore(ptr + 7);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\txephyr_screen = ptr + 14;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\t// mkdir\n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\t// process mkdir again while applying blacklists\n\t}\n\t// mkfile\n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\t// process mkfile again while applying blacklists\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse\n\t\t\twarning_feature_disabled(\"noroot\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tif (cfg.home_private_keep) {\n\t\t\t\tif ( asprintf(&cfg.home_private_keep, \"%s,%s\", cfg.home_private_keep, ptr + 13) < 0 )\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t} else\n\t\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\targ_private = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-home\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-cache\") == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_CACHE))\n\t\t\targ_private_cache = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"private-cache\");\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"keep-dev-shm\") == 0) {\n\t\targ_keep_dev_shm = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"noautopulse\") == 0) {\n\t\targ_noautopulse = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"notv\") == 0) {\n\t\targ_notv = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodvd\") == 0) {\n\t\targ_nodvd = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"novideo\") == 0) {\n\t\targ_novideo = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodbus\") == 0) {\n\t\targ_nodbus = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nou2f\") == 0) {\n\t        arg_nou2f = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n\t\targ_nonetwork  = 1;\n\t\tcfg.bridge0.configured = 0;\n\t\tcfg.bridge1.configured = 0;\n\t\tcfg.bridge2.configured = 0;\n\t\tcfg.bridge3.configured = 0;\n\t\tcfg.interface0.configured = 0;\n\t\tcfg.interface1.configured = 0;\n\t\tcfg.interface2.configured = 0;\n\t\tcfg.interface3.configured = 0;\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbr->dev = ptr + 4;\n\t\t\tbr->configured = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"netmask \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->masksandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the network mask twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this network mask for the last bridge defined\n\t\t\tif (atoip(ptr + 8, &br->masksandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid  network mask\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// if the bridge is not configured, use this mask as the bridge mask\n\t\t\tif (br->mask == 0)\n\t\t\t\tbr->mask = br->masksandbox;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: interface %s already has a network mask defined; \"\n\t\t\t\t\t\"please remove --netmask\\n\",\n\t\t\t\t\tbr->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IPv6 address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->ip6sandbox = strdup(ptr + 4);\n\t\t\tif (br->ip6sandbox == NULL)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\tif (cfg.protocol) {\n\t\t\t\tfwarning(\"two protocol lists are present, \\\"%s\\\" will be installed\\n\", cfg.protocol);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// store list\n\t\t\tcfg.protocol = strdup(ptr + 9);\n\t\t\tif (!cfg.protocol)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = seccomp_check_list(ptr + 8);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"seccomp.block-secondary\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp_block_secondary = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// memory deny write&execute\n\tif (strcmp(ptr, \"memory-deny-write-execute\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_memory_deny_write_execute = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\n\t// hosts-file\n\tif (strncmp(ptr, \"hosts-file \", 11) == 0) {\n\t\tcfg.hosts_file = fs_check_hosts_file(ptr + 11);\n\t\treturn 0;\n\t}\n\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\n\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IPv4 or IPv6 address\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tchar *dns = strdup(ptr + 4);\n\t\tif (!dns)\n\t\t\terrExit(\"strdup\");\n\n\t\tif (cfg.dns1 == NULL)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == NULL)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == NULL)\n\t\t\tcfg.dns3 = dns;\n\t\telse if (cfg.dns4 == NULL)\n\t\t\tcfg.dns4 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 4 DNS servers can be specified\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 5) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tif (checkcfg(CFG_CGROUP))\n\t\t\tset_cgroup(ptr + 7);\n\t\telse\n\t\t\twarning_feature_disabled(\"cgroup\");\n\t\treturn 0;\n\t}\n\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"machine-id\") == 0) {\n\t\targ_machineid = 1;\n\t\treturn 0;\n\t}\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t// don't overwrite /var/tmp\n\tif (strcmp(ptr, \"keep-var-tmp\") == 0) {\n\t\targ_keep_var_tmp = 1;\n\t\treturn 0;\n\t}\n\t// writable-run-user\n\tif (strcmp(ptr, \"writable-run-user\") == 0) {\n\t\targ_writable_run_user = 1;\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"writable-var-log\") == 0) {\n\t\targ_writable_var_log = 1;\n\t\treturn 0;\n\t}\n\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xvfb\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xvfb(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (cfg.etc_private_keep) {\n\t\t\tif ( asprintf(&cfg.etc_private_keep, \"%s,%s\", cfg.etc_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.etc_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_etc = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /opt list of files and directories\n\tif (strncmp(ptr, \"private-opt \", 12) == 0) {\n\t\tif (cfg.opt_private_keep) {\n\t\t\tif ( asprintf(&cfg.opt_private_keep, \"%s,%s\", cfg.opt_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.opt_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_opt = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /srv list of files and directories\n\tif (strncmp(ptr, \"private-srv \", 12) == 0) {\n\t\tif (cfg.srv_private_keep) {\n\t\t\tif ( asprintf(&cfg.srv_private_keep, \"%s,%s\", cfg.srv_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.srv_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_srv = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tif (cfg.bin_private_keep) {\n\t\t\tif ( asprintf(&cfg.bin_private_keep, \"%s,%s\", cfg.bin_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.bin_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_bin = 1;\n\t\treturn 0;\n\t}\n\n\t// private /lib list of files\n\tif (strncmp(ptr, \"private-lib\", 11) == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_LIB)) {\n\t\t\tif (ptr[11] == ' ') {\n\t\t\t\tif (cfg.lib_private_keep) {\n\t\t\t\t\tif (ptr[12] != '\\0' && asprintf(&cfg.lib_private_keep, \"%s,%s\", cfg.lib_private_keep, ptr + 12) < 0)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t} else {\n\t\t\t\t\tcfg.lib_private_keep = ptr + 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\targ_private_lib = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-lib\");\n\t\treturn 0;\n\t}\n\n\n#ifdef HAVE_OVERLAYFS\n\tif (strncmp(ptr, \"overlay-named \", 14) == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\t\t\targ_overlay_reuse = 1;\n\n\t\t\tchar *subdirname = ptr + 14;\n\t\t\tif (*subdirname == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay option\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check name\n\t\t\tinvalid_filename(subdirname, 0); // no globbing\n\t\t\tif (strstr(subdirname, \"..\") || strstr(subdirname, \"/\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay-tmpfs\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\n\t\t\tchar *subdirname;\n\t\t\tif (asprintf(&subdirname, \"%d\", getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\n\t\t\tfree(subdirname);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\t}\n#endif\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1, 0); // no globbing\n\t\t\tinvalid_filename(dname2, 0); // no globbing\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"bind\");\n\t\treturn 0;\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tcheck_unsigned(ptr + 14, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 14, \"%llu\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-cpu \", 11) == 0) {\n\t\t\tcheck_unsigned(ptr + 11, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 11, \"%llu\", &cfg.rlimit_cpu);\n\t\t\targ_rlimit_cpu = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tcheck_unsigned(ptr + 18, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 18, \"%llu\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-as \", 10) == 0) {\n\t\t\tcheck_unsigned(ptr + 10, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 10, \"%llu\", &cfg.rlimit_as);\n\t\t\targ_rlimit_as = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"timeout \", 8) == 0) {\n\t\tcfg.timeout = extract_timeout(ptr +8);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0) {\n\t\t\t// try to join by name only\n\t\t\tpid_t pid;\n\t\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t\t// find first non-option arg\n\t\t\t\tint i;\n\t\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t// set sandbox name and start normally\n\t\t\tcfg.name = ptr + 14;\n\t\t\tif (strlen(cfg.name) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"join\");\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"disable-mnt\") == 0) {\n\t\targ_disable_mnt = 1;\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse {\n\t\t\tstatic int whitelist_warning_printed = 0;\n\t\t\tif (!whitelist_warning_printed) {\n\t\t\t\twarning_feature_disabled(\"whitelist\");\n\t\t\t\twhitelist_warning_printed = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n#else\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"nowhitelist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr, 1); // globbing\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern char *xephyr_screen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nextern char *xephyr_screen;\n\nint profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\n\t// check and process conditional profile lines\n\tif (profile_check_conditional(ptr, lineno, fname) == 0)\n\t\treturn 0;\n\n\t// check ignore list\n\tif (is_in_ignore_list(ptr))\n\t\treturn 0;\n\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tprofile_add_ignore(ptr + 7);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\txephyr_screen = ptr + 14;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\t// mkdir\n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\t// process mkdir again while applying blacklists\n\t}\n\t// mkfile\n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\t// process mkfile again while applying blacklists\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse\n\t\t\twarning_feature_disabled(\"noroot\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tif (cfg.home_private_keep) {\n\t\t\t\tif ( asprintf(&cfg.home_private_keep, \"%s,%s\", cfg.home_private_keep, ptr + 13) < 0 )\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t} else\n\t\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\targ_private = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-home\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-cache\") == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_CACHE))\n\t\t\targ_private_cache = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"private-cache\");\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"keep-dev-shm\") == 0) {\n\t\targ_keep_dev_shm = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"noautopulse\") == 0) {\n\t\targ_noautopulse = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"notv\") == 0) {\n\t\targ_notv = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodvd\") == 0) {\n\t\targ_nodvd = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"novideo\") == 0) {\n\t\targ_novideo = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nodbus\") == 0) {\n\t\targ_nodbus = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nou2f\") == 0) {\n\t        arg_nou2f = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n\t\targ_nonetwork  = 1;\n\t\tcfg.bridge0.configured = 0;\n\t\tcfg.bridge1.configured = 0;\n\t\tcfg.bridge2.configured = 0;\n\t\tcfg.bridge3.configured = 0;\n\t\tcfg.interface0.configured = 0;\n\t\tcfg.interface1.configured = 0;\n\t\tcfg.interface2.configured = 0;\n\t\tcfg.interface3.configured = 0;\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbr->dev = ptr + 4;\n\t\t\tbr->configured = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"netmask \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->masksandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the network mask twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this network mask for the last bridge defined\n\t\t\tif (atoip(ptr + 8, &br->masksandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid  network mask\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// if the bridge is not configured, use this mask as the bridge mask\n\t\t\tif (br->mask == 0)\n\t\t\t\tbr->mask = br->masksandbox;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: interface %s already has a network mask defined; \"\n\t\t\t\t\t\"please remove --netmask\\n\",\n\t\t\t\t\tbr->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IPv6 address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->ip6sandbox = strdup(ptr + 4);\n\t\t\tif (br->ip6sandbox == NULL)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"networking\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\tif (cfg.protocol) {\n\t\t\t\tfwarning(\"two protocol lists are present, \\\"%s\\\" will be installed\\n\", cfg.protocol);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// store list\n\t\t\tcfg.protocol = strdup(ptr + 9);\n\t\t\tif (!cfg.protocol)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = seccomp_check_list(ptr + 8);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"seccomp.block-secondary\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp_block_secondary = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= seccomp_check_list(ptr + 13);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// memory deny write&execute\n\tif (strcmp(ptr, \"memory-deny-write-execute\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_memory_deny_write_execute = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"seccomp\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify caps list and exit if problems\n\t\tcaps_check_list(arg_caps_list, NULL);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\n\t// hosts-file\n\tif (strncmp(ptr, \"hosts-file \", 11) == 0) {\n\t\tcfg.hosts_file = fs_check_hosts_file(ptr + 11);\n\t\treturn 0;\n\t}\n\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\n\t\tif (check_ip46_address(ptr + 4) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IPv4 or IPv6 address\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tchar *dns = strdup(ptr + 4);\n\t\tif (!dns)\n\t\t\terrExit(\"strdup\");\n\n\t\tif (cfg.dns1 == NULL)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == NULL)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == NULL)\n\t\t\tcfg.dns3 = dns;\n\t\telse if (cfg.dns4 == NULL)\n\t\t\tcfg.dns4 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 4 DNS servers can be specified\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 5) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tif (checkcfg(CFG_CGROUP))\n\t\t\tset_cgroup(ptr + 7);\n\t\telse\n\t\t\twarning_feature_disabled(\"cgroup\");\n\t\treturn 0;\n\t}\n\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"machine-id\") == 0) {\n\t\targ_machineid = 1;\n\t\treturn 0;\n\t}\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t// don't overwrite /var/tmp\n\tif (strcmp(ptr, \"keep-var-tmp\") == 0) {\n\t\targ_keep_var_tmp = 1;\n\t\treturn 0;\n\t}\n\t// writable-run-user\n\tif (strcmp(ptr, \"writable-run-user\") == 0) {\n\t\targ_writable_run_user = 1;\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"writable-var-log\") == 0) {\n\t\targ_writable_var_log = 1;\n\t\treturn 0;\n\t}\n\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xvfb\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xvfb(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"x11\");\n#endif\n\t\treturn 0;\n\t}\n\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (cfg.etc_private_keep) {\n\t\t\tif ( asprintf(&cfg.etc_private_keep, \"%s,%s\", cfg.etc_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.etc_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_etc = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /opt list of files and directories\n\tif (strncmp(ptr, \"private-opt \", 12) == 0) {\n\t\tif (cfg.opt_private_keep) {\n\t\t\tif ( asprintf(&cfg.opt_private_keep, \"%s,%s\", cfg.opt_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.opt_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_opt = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /srv list of files and directories\n\tif (strncmp(ptr, \"private-srv \", 12) == 0) {\n\t\tif (cfg.srv_private_keep) {\n\t\t\tif ( asprintf(&cfg.srv_private_keep, \"%s,%s\", cfg.srv_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.srv_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_srv = 1;\n\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tif (cfg.bin_private_keep) {\n\t\t\tif ( asprintf(&cfg.bin_private_keep, \"%s,%s\", cfg.bin_private_keep, ptr + 12) < 0 )\n\t\t\t\terrExit(\"asprintf\");\n\t\t} else {\n\t\t\tcfg.bin_private_keep = ptr + 12;\n\t\t}\n\t\targ_private_bin = 1;\n\t\treturn 0;\n\t}\n\n\t// private /lib list of files\n\tif (strncmp(ptr, \"private-lib\", 11) == 0) {\n\t\tif (checkcfg(CFG_PRIVATE_LIB)) {\n\t\t\tif (ptr[11] == ' ') {\n\t\t\t\tif (cfg.lib_private_keep) {\n\t\t\t\t\tif (ptr[12] != '\\0' && asprintf(&cfg.lib_private_keep, \"%s,%s\", cfg.lib_private_keep, ptr + 12) < 0)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t} else {\n\t\t\t\t\tcfg.lib_private_keep = ptr + 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\targ_private_lib = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"private-lib\");\n\t\treturn 0;\n\t}\n\n\n#ifdef HAVE_OVERLAYFS\n\tif (strncmp(ptr, \"overlay-named \", 14) == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\t\t\targ_overlay_reuse = 1;\n\n\t\t\tchar *subdirname = ptr + 14;\n\t\t\tif (*subdirname == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay option\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check name\n\t\t\tinvalid_filename(subdirname, 0); // no globbing\n\t\t\tif (strstr(subdirname, \"..\") || strstr(subdirname, \"/\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid overlay name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay-tmpfs\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\n\t} else if (strcmp(ptr, \"overlay\") == 0) {\n\t\tif (checkcfg(CFG_OVERLAYFS)) {\n\t\t\tif (arg_overlay) {\n\t\t\t\tfprintf(stderr, \"Error: only one overlay command is allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.chrootdir) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay and --chroot options are mutually exclusive\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(\"/proc/sys/kernel/grsecurity\", &s) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: --overlay option is not available on Grsecurity systems\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\targ_overlay = 1;\n\t\t\targ_overlay_keep = 1;\n\n\t\t\tchar *subdirname;\n\t\t\tif (asprintf(&subdirname, \"%d\", getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tcfg.overlay_dir = fs_check_overlay_dir(subdirname, arg_overlay_reuse);\n\n\t\t\tfree(subdirname);\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"overlayfs\");\n\t\treturn 0;\n\t}\n#endif\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1, 0); // no globbing\n\t\t\tinvalid_filename(dname2, 0); // no globbing\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"bind\");\n\t\treturn 0;\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tcheck_unsigned(ptr + 14, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 14, \"%llu\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-cpu \", 11) == 0) {\n\t\t\tcheck_unsigned(ptr + 11, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 11, \"%llu\", &cfg.rlimit_cpu);\n\t\t\targ_rlimit_cpu = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tcheck_unsigned(ptr + 13, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 13, \"%llu\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tcheck_unsigned(ptr + 18, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 18, \"%llu\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-as \", 10) == 0) {\n\t\t\tcheck_unsigned(ptr + 10, \"Error: invalid rlimit in profile file: \");\n\t\t\tsscanf(ptr + 10, \"%llu\", &cfg.rlimit_as);\n\t\t\targ_rlimit_as = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"timeout \", 8) == 0) {\n\t\tcfg.timeout = extract_timeout(ptr +8);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\tif (checkcfg(CFG_JOIN) || getuid() == 0) {\n\t\t\t// try to join by name only\n\t\t\tpid_t pid;\n\t\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t\t// find first non-option arg\n\t\t\t\tint i;\n\t\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t// set sandbox name and start normally\n\t\t\tcfg.name = ptr + 14;\n\t\t\tif (strlen(cfg.name) == 0) {\n\t\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\twarning_feature_disabled(\"join\");\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"disable-mnt\") == 0) {\n\t\targ_disable_mnt = 1;\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse {\n\t\t\tstatic int whitelist_warning_printed = 0;\n\t\t\tif (!whitelist_warning_printed) {\n\t\t\t\twarning_feature_disabled(\"whitelist\");\n\t\t\t\twhitelist_warning_printed = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n#else\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"nowhitelist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr, 1); // globbing\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&line",
            "\"blacklist %s\"",
            "xauthority"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"blacklist ${HOME}/.Xauthority\""
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"blacklist /tmp/.X11-unix\""
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: --x11=none specified, but abstract X11 socket still accessible.\\n\"\n\t\t\t\"Additional setup required. To block abstract X11 socket you can either:\\n\"\n\t\t\t\" * use network namespace in firejail (--net=none, --net=...)\\n\"\n\t\t\t\" * add \\\"-nolisten local\\\" to xserver options\\n\"\n\t\t\t\"   (eg. to your display manager config, or /etc/X11/xinit/xserverrc)\\n\""
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_abstract_sockets_present",
          "args": [],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "x11_abstract_sockets_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "80-116",
          "snippet": "static int x11_abstract_sockets_present(void) {\n\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(\"/proc/net/unix\", \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tEUID_USER();\n\n\tchar *linebuf = 0;\n\tsize_t bufsz = 0;\n\tint found = 0;\n\terrno = 0;\n\n\tfor (;;) {\n\t\tif (getline(&linebuf, &bufsz, fp) == -1) {\n\t\t\tif (errno)\n\t\t\t\terrExit(\"getline\");\n\t\t\tbreak;\n\t\t}\n\t\t// The last space-separated field in 'linebuf' is the\n\t\t// pathname of the socket.  Abstract sockets' pathnames\n\t\t// all begin with '@/', normal ones begin with '/'.\n\t\tchar *p = strrchr(linebuf, ' ');\n\t\tif (!p) {\n\t\t\tfputs(\"error parsing /proc/net/unix\\n\", stderr);\n\t\t\texit(1);\n\t\t}\n\t\tif (strncmp(p+1, \"@/tmp/.X11-unix/\", 16) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(linebuf);\n\tfclose(fp);\n\treturn found;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int x11_abstract_sockets_present(void) {\n\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(\"/proc/net/unix\", \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tEUID_USER();\n\n\tchar *linebuf = 0;\n\tsize_t bufsz = 0;\n\tint found = 0;\n\terrno = 0;\n\n\tfor (;;) {\n\t\tif (getline(&linebuf, &bufsz, fp) == -1) {\n\t\t\tif (errno)\n\t\t\t\terrExit(\"getline\");\n\t\t\tbreak;\n\t\t}\n\t\t// The last space-separated field in 'linebuf' is the\n\t\t// pathname of the socket.  Abstract sockets' pathnames\n\t\t// all begin with '@/', normal ones begin with '/'.\n\t\tchar *p = strrchr(linebuf, ' ');\n\t\tif (!p) {\n\t\t\tfputs(\"error parsing /proc/net/unix\\n\", stderr);\n\t\t\texit(1);\n\t\t}\n\t\tif (strncmp(p+1, \"@/tmp/.X11-unix/\", 16) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(linebuf);\n\tfclose(fp);\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_block(void) {\n#ifdef HAVE_X11\n\t// check abstract socket presence and network namespace options\n\tif ((!arg_nonetwork && !cfg.bridge0.configured && !cfg.interface0.configured)\n\t&& x11_abstract_sockets_present()) {\n\t\tfprintf(stderr, \"ERROR: --x11=none specified, but abstract X11 socket still accessible.\\n\"\n\t\t\t\"Additional setup required. To block abstract X11 socket you can either:\\n\"\n\t\t\t\" * use network namespace in firejail (--net=none, --net=...)\\n\"\n\t\t\t\" * add \\\"-nolisten local\\\" to xserver options\\n\"\n\t\t\t\"   (eg. to your display manager config, or /etc/X11/xinit/xserverrc)\\n\");\n\t\texit(1);\n\t}\n\n\t// blacklist sockets\n\tprofile_check_line(\"blacklist /tmp/.X11-unix\", 0, NULL);\n\tprofile_add(strdup(\"blacklist /tmp/.X11-unix\"));\n\n\t// blacklist .Xauthority\n\tprofile_check_line(\"blacklist ${HOME}/.Xauthority\", 0, NULL);\n\tprofile_add(strdup(\"blacklist ${HOME}/.Xauthority\"));\n\tchar *xauthority = getenv(\"XAUTHORITY\");\n\tif (xauthority) {\n\t\tchar *line;\n\t\tif (asprintf(&line, \"blacklist %s\", xauthority) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tprofile_check_line(line, 0, NULL);\n\t\tprofile_add(line);\n\t}\n\n\t// clear environment\n\tenv_store(\"DISPLAY\", RMENV);\n\tenv_store(\"XAUTHORITY\", RMENV);\n#endif\n}"
  },
  {
    "function_name": "fs_x11",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "1224-1285",
    "snippet": "void fs_x11(void) {\n#ifdef HAVE_X11\n\tint display = x11_display();\n\tif (display <= 0)\n\t\treturn;\n\n\tchar *x11file;\n\tif (asprintf(&x11file, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat x11stat;\n\tif (stat(x11file, &x11stat) == -1 || !S_ISSOCK(x11stat.st_mode)) {\n\t\tfree(x11file);\n\t\treturn;\n\t}\n\n\tif (arg_debug || arg_debug_whitelists)\n\t\tfprintf(stderr, \"Masking all X11 sockets except %s\\n\", x11file);\n\n\t// Move the real /tmp/.X11-unix to a scratch location\n\t// so we can still access x11file after we mount a\n\t// tmpfs over /tmp/.X11-unix.\n\tint rv = mkdir(RUN_WHITELIST_X11_DIR, 0700);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (set_perms(RUN_WHITELIST_X11_DIR, 0, 0, 0700))\n\t\terrExit(\"set_perms\");\n\n\tif (mount(\"/tmp/.X11-unix\", RUN_WHITELIST_X11_DIR, 0, MS_BIND|MS_REC, 0) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// This directory must be mode 1777, or Xlib will barf.\n\tif (mount(\"tmpfs\", \"/tmp/.X11-unix\", \"tmpfs\",\n\t\tMS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,\n\t\t\"mode=1777,uid=0,gid=0\") < 0)\n\t\terrExit(\"mounting tmpfs on /tmp/.X11-unix\");\n\tfs_logger(\"tmpfs /tmp/.X11-unix\");\n\n\t// create an empty file which will have the desired socket bind-mounted over it\n\tint fd = open(x11file, O_RDWR|O_CREAT|O_EXCL, x11stat.st_mode & ~S_IFMT);\n\tif (fd < 0)\n\t\terrExit(x11file);\n\tif (fchown(fd, x11stat.st_uid, x11stat.st_gid))\n\t\terrExit(\"fchown\");\n\tclose(fd);\n\n\t// do the mount\n\tchar *wx11file;\n\tif (asprintf(&wx11file, \"%s/X%d\", RUN_WHITELIST_X11_DIR, display) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wx11file, x11file, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"whitelist\", x11file);\n\n\tfree(x11file);\n\tfree(wx11file);\n\n\t// block access to RUN_WHITELIST_X11_DIR\n\tif (mount(RUN_RO_DIR, RUN_WHITELIST_X11_DIR, 0, MS_BIND, 0) < 0)\n\t\terrExit(\"mount\");\n\tfs_logger2(\"blacklist\", RUN_WHITELIST_X11_DIR);\n#endif\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"blacklist\"",
            "RUN_WHITELIST_X11_DIR"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount\""
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_DIR",
            "RUN_WHITELIST_X11_DIR",
            "0",
            "MS_BIND",
            "0"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "wx11file"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "x11file"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "wx11file",
            "x11file",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wx11file",
            "\"%s/X%d\"",
            "RUN_WHITELIST_X11_DIR",
            "display"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fchown\""
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "fd",
            "x11stat.st_uid",
            "x11stat.st_gid"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "x11file"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "x11file",
            "O_RDWR|O_CREAT|O_EXCL",
            "x11stat.st_mode & ~S_IFMT"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "freopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "346-353",
          "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"tmpfs /tmp/.X11-unix\""
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /tmp/.X11-unix\""
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/tmp/.X11-unix\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME",
            "\"mode=1777,uid=0,gid=0\""
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/tmp/.X11-unix\"",
            "RUN_WHITELIST_X11_DIR",
            "0",
            "MS_BIND|MS_REC",
            "0"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"set_perms\""
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_perms",
          "args": [
            "RUN_WHITELIST_X11_DIR",
            "0",
            "0",
            "0700"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "set_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1047-1054",
          "snippet": "int set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint set_perms(const char *fname, uid_t uid, gid_t gid, mode_t mode) {\n\tassert(fname);\n\tif (chmod(fname, mode) == -1)\n\t\treturn 1;\n\tif (chown(fname, uid, gid) == -1)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "RUN_WHITELIST_X11_DIR",
            "0700"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "382-389",
          "snippet": "int mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdir_t orig_mkdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\tprintf(\"%u:%s:mkdir %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Masking all X11 sockets except %s\\n\"",
            "x11file"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "x11file"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "x11stat.st_mode"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "x11file",
            "&x11stat"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&x11file",
            "\"/tmp/.X11-unix/X%d\"",
            "display"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_display",
          "args": [],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "x11_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "39-75",
          "snippet": "int x11_display(void) {\n\tconst char *display_str = getenv(\"DISPLAY\");\n\tchar *endp;\n\tunsigned long display;\n\n\tif (!display_str) {\n\t\tif (arg_debug)\n\t\t\tfputs(\"DISPLAY is not set\\n\", stderr);\n\t\treturn -1;\n\t}\n\n\tif (display_str[0] != ':' || display_str[1] < '0' || display_str[1] > '9') {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"unsupported DISPLAY form '%s'\\n\", display_str);\n\t\treturn -1;\n\t}\n\n\terrno = 0;\n\tdisplay = strtoul(display_str+1, &endp, 10);\n\t// handling DISPLAY=:0 and also :0.0\n\tif (endp == display_str+1 || (*endp != '\\0' && *endp != '.')) {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"unsupported DISPLAY form '%s'\\n\", display_str);\n\t\treturn -1;\n\t}\n\tif (errno || display > (unsigned long)INT_MAX) {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"display number %s is outside the valid range\\n\",\n\t\t\t\tdisplay_str+1);\n\t\treturn -1;\n\t}\n\n\tif (arg_debug)\n\t\tfprintf(stderr, \"DISPLAY=%s parsed as %lu\\n\", display_str, display);\n\n\treturn (int)display;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint x11_display(void) {\n\tconst char *display_str = getenv(\"DISPLAY\");\n\tchar *endp;\n\tunsigned long display;\n\n\tif (!display_str) {\n\t\tif (arg_debug)\n\t\t\tfputs(\"DISPLAY is not set\\n\", stderr);\n\t\treturn -1;\n\t}\n\n\tif (display_str[0] != ':' || display_str[1] < '0' || display_str[1] > '9') {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"unsupported DISPLAY form '%s'\\n\", display_str);\n\t\treturn -1;\n\t}\n\n\terrno = 0;\n\tdisplay = strtoul(display_str+1, &endp, 10);\n\t// handling DISPLAY=:0 and also :0.0\n\tif (endp == display_str+1 || (*endp != '\\0' && *endp != '.')) {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"unsupported DISPLAY form '%s'\\n\", display_str);\n\t\treturn -1;\n\t}\n\tif (errno || display > (unsigned long)INT_MAX) {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"display number %s is outside the valid range\\n\",\n\t\t\t\tdisplay_str+1);\n\t\treturn -1;\n\t}\n\n\tif (arg_debug)\n\t\tfprintf(stderr, \"DISPLAY=%s parsed as %lu\\n\", display_str, display);\n\n\treturn (int)display;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_x11(void) {\n#ifdef HAVE_X11\n\tint display = x11_display();\n\tif (display <= 0)\n\t\treturn;\n\n\tchar *x11file;\n\tif (asprintf(&x11file, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat x11stat;\n\tif (stat(x11file, &x11stat) == -1 || !S_ISSOCK(x11stat.st_mode)) {\n\t\tfree(x11file);\n\t\treturn;\n\t}\n\n\tif (arg_debug || arg_debug_whitelists)\n\t\tfprintf(stderr, \"Masking all X11 sockets except %s\\n\", x11file);\n\n\t// Move the real /tmp/.X11-unix to a scratch location\n\t// so we can still access x11file after we mount a\n\t// tmpfs over /tmp/.X11-unix.\n\tint rv = mkdir(RUN_WHITELIST_X11_DIR, 0700);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (set_perms(RUN_WHITELIST_X11_DIR, 0, 0, 0700))\n\t\terrExit(\"set_perms\");\n\n\tif (mount(\"/tmp/.X11-unix\", RUN_WHITELIST_X11_DIR, 0, MS_BIND|MS_REC, 0) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// This directory must be mode 1777, or Xlib will barf.\n\tif (mount(\"tmpfs\", \"/tmp/.X11-unix\", \"tmpfs\",\n\t\tMS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,\n\t\t\"mode=1777,uid=0,gid=0\") < 0)\n\t\terrExit(\"mounting tmpfs on /tmp/.X11-unix\");\n\tfs_logger(\"tmpfs /tmp/.X11-unix\");\n\n\t// create an empty file which will have the desired socket bind-mounted over it\n\tint fd = open(x11file, O_RDWR|O_CREAT|O_EXCL, x11stat.st_mode & ~S_IFMT);\n\tif (fd < 0)\n\t\terrExit(x11file);\n\tif (fchown(fd, x11stat.st_uid, x11stat.st_gid))\n\t\terrExit(\"fchown\");\n\tclose(fd);\n\n\t// do the mount\n\tchar *wx11file;\n\tif (asprintf(&wx11file, \"%s/X%d\", RUN_WHITELIST_X11_DIR, display) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wx11file, x11file, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"whitelist\", x11file);\n\n\tfree(x11file);\n\tfree(wx11file);\n\n\t// block access to RUN_WHITELIST_X11_DIR\n\tif (mount(RUN_RO_DIR, RUN_WHITELIST_X11_DIR, 0, MS_BIND, 0) < 0)\n\t\terrExit(\"mount\");\n\tfs_logger2(\"blacklist\", RUN_WHITELIST_X11_DIR);\n#endif\n}"
  },
  {
    "function_name": "x11_xorg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "1079-1221",
    "snippet": "void x11_xorg(void) {\n#ifdef HAVE_X11\n\n\t// check xauth utility is present in the system\n\tstruct stat s;\n\tif (stat(\"/usr/bin/xauth\", &s) == -1) {\n\t\tfprintf(stderr, \"Error: xauth utility not found in /usr/bin. Please install it:\\n\"\n\t\t\t\"   Debian/Ubuntu/Mint: sudo apt-get install xauth\\n\");\n\t\texit(1);\n\t}\n\tif (s.st_uid != 0 && s.st_gid != 0) {\n\t\tfprintf(stderr, \"Error: invalid /usr/bin/xauth executable\\n\");\n\t\texit(1);\n\t}\n\n\t// get DISPLAY env\n\tchar *display = getenv(\"DISPLAY\");\n\tif (!display) {\n\t\tfputs(\"Error: --x11=xorg requires an 'outer' X11 server to use.\\n\", stderr);\n\t\texit(1);\n\t}\n\n\t// temporarily mount a tempfs on top of /tmp directory\n\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\terrExit(\"mounting /tmp\");\n\n\t// create the temporary .Xauthority file\n\tif (arg_debug)\n\t\tprintf(\"Generating a new .Xauthority file\\n\");\n\tchar tmpfname[] = \"/tmp/.tmpXauth-XXXXXX\";\n\tint fd = mkstemp(tmpfname);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Error: cannot create .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (fchown(fd, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tclose(fd);\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(1);\n\t\tclearenv();\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\texeclp(\"/usr/bin/xauth\", \"/usr/bin/xauth\", \"-v\", \"-f\", tmpfname,\n\t\t\t\"generate\", display, \"MIT-MAGIC-COOKIE-1\", \"untrusted\", NULL);\n\n\t\t_exit(127);\n\t}\n\n\t// wait for the xauth process to finish\n\tint status;\n\tif (waitpid(child, &status, 0) != child)\n\t\terrExit(\"waitpid\");\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t/* success */\n\t}\n\telse if (WIFEXITED(status)) {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: xauth: exit %d\\n\",\n\t\t\tWEXITSTATUS(status));\n\t\texit(1);\n\t}\n\telse if (WIFSIGNALED(status)) {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: xauth: %s\\n\",\n\t\t\tstrsignal(WTERMSIG(status)));\n\t\texit(1);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: \"\n\t\t\t\"xauth: un-decodable exit status %04x\\n\", status);\n\t\texit(1);\n\t}\n\n\t// move the temporary file in RUN_XAUTHORITY_SEC_FILE in order to have it deleted\n\t// automatically when the sandbox is closed (rename doesn't work)\n\t\t\t\t\t\t  // root needed\n\tif (copy_file(tmpfname, RUN_XAUTHORITY_SEC_FILE, getuid(), getgid(), 0600)) {\n\t\tfprintf(stderr, \"Error: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\t/* coverity[toctou] */\n\tunlink(tmpfname);\n\tumount(\"/tmp\");\n\n\t// remount RUN_XAUTHORITY_SEC_FILE noexec, nodev, nosuid\n\tfs_noexec(RUN_XAUTHORITY_SEC_FILE);\n\n\t// Ensure there is already a file in the usual location, so that bind-mount below will work.\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(dest, &s) == -1) {\n\t\ttouch_file_as_user(dest, 0600);\n\t\tif (stat(dest, &s) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s\\n\", dest);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// get a file descriptor for .Xauthority\n\tfd = safe_fd(dest, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\t// check if the actual mount destination is a user owned regular file\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != getuid()) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: .Xauthority is a symbolic link\\n\");\n\t\telse\n\t\t\tfprintf(stderr, \"Error: .Xauthority is not a user owned regular file\\n\");\n\t\texit(1);\n\t}\n\t// preserve a read-only mount\n\tstruct statvfs vfs;\n\tif (fstatvfs(fd, &vfs) == -1)\n\t\terrExit(\"fstatvfs\");\n\tif ((vfs.f_flag & MS_RDONLY) == MS_RDONLY)\n\t\tfs_rdonly(RUN_XAUTHORITY_SEC_FILE);\n\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(RUN_XAUTHORITY_SEC_FILE, proc, \"none\", MS_BIND, \"mode=0600\") == -1) {\n\t\tfprintf(stderr, \"Error: cannot mount the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tfree(proc);\n\tclose(fd);\n\t// check /proc/self/mountinfo to confirm the mount is ok\n\tMountData *mptr = get_last_mount();\n\tif (strcmp(mptr->dir, dest) != 0 || strcmp(mptr->fstype, \"tmpfs\") != 0)\n\t\terrLogExit(\"invalid .Xauthority mount\");\n\n\tASSERT_PERMS(dest, getuid(), getgid(), 0600);\n\tfree(dest);\n#endif\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dest"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "dest",
            "getuid()",
            "getgid()",
            "0600"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errLogExit",
          "args": [
            "\"invalid .Xauthority mount\""
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "errLogExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "40-57",
          "snippet": "void errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mptr->fstype",
            "\"tmpfs\""
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mptr->dir",
            "dest"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_mount",
          "args": [],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "get_last_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "131-152",
          "snippet": "MountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [
            "static char mbuf[MAX_BUF];",
            "static MountData mdata;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nstatic char mbuf[MAX_BUF];\nstatic MountData mdata;\n\nMountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "proc"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot mount the new .Xauthority file\\n\""
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_XAUTHORITY_SEC_FILE",
            "proc",
            "\"none\"",
            "MS_BIND",
            "\"mode=0600\""
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&proc",
            "\"/proc/self/fd/%d\"",
            "fd"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_rdonly",
          "args": [
            "RUN_XAUTHORITY_SEC_FILE"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "516-541",
          "snippet": "void fs_rdonly_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdonly(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdonly(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mount_warning = 0;",
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_rdonly_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_rdonly(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_rdonly(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstatvfs\""
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstatvfs",
          "args": [
            "fd",
            "&vfs"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: .Xauthority is not a user owned regular file\\n\""
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: .Xauthority is a symbolic link\\n\""
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "s.st_mode"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "s.st_mode"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&s"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"safe_fd\""
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_fd",
          "args": [
            "dest",
            "O_PATH|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "safe_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1143-1209",
          "snippet": "int safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define EMPTY_STRING (\"\")"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nint safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create %s\\n\"",
            "dest"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dest",
            "&s"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_file_as_user",
          "args": [
            "dest",
            "0600"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "touch_file_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "377-398",
          "snippet": "void touch_file_as_user(const char *fname, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tFILE *fp = fopen(fname, \"wx\");\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, -1, -1, mode);\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid touch_file_as_user(const char *fname, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tFILE *fp = fopen(fname, \"wx\");\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, -1, -1, mode);\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dest",
            "\"%s/.Xauthority\"",
            "cfg.homedir"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_noexec",
          "args": [
            "RUN_XAUTHORITY_SEC_FILE"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "fs_noexec_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "630-655",
          "snippet": "void fs_noexec_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_noexec(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_noexec(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mount_warning = 0;",
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int mount_warning = 0;\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_noexec_rec(const char *dir) {\n\tassert(dir);\n\t// get mount point of the directory\n\tint mountid = get_mount_id(dir);\n\tif (mountid == -1)\n\t\treturn;\n\tif (mountid == -2) {\n\t\t// falling back to a simple remount on old kernels\n\t\tif (!mount_warning) {\n\t\t\tfwarning(\"read-only, read-write and noexec options are not applied recursively\\n\");\n\t\t\tmount_warning = 1;\n\t\t}\n\t\tfs_noexec(dir);\n\t\treturn;\n\t}\n\t// build array with all mount points that need to get remounted\n\tchar **arr = build_mount_array(mountid, dir);\n\tassert(arr);\n\t// remount\n\tchar **tmp = arr;\n\twhile (*tmp) {\n\t\tfs_noexec(*tmp);\n\t\tfree(*tmp++);\n\t}\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "\"/tmp\""
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmpfname"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "359-366",
          "snippet": "int unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_unlink_t orig_unlink = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_unlink_t orig_unlink = NULL;\n\nint unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create the new .Xauthority file\\n\""
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_file",
          "args": [
            "tmpfname",
            "RUN_XAUTHORITY_SEC_FILE",
            "getuid()",
            "getgid()",
            "0600"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_from_user_to_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "337-374",
          "snippet": "void copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\treturn;\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tint src = open(srcname, O_RDONLY);\n\t\tif (src < 0) {\n\t\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\t} else {\n\t\t\tif (copy_file_by_fd(src, dst)) {\n\t\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n\t\t\t}\n\t\t\tclose(src);\n\t\t}\n\t\tclose(dst);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tif (fchown(dst, uid, gid) == -1)\n\t\terrExit(\"fchown\");\n\tif (fchmod(dst, mode) == -1)\n\t\terrExit(\"fchmod\");\n\tclose(dst);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_from_user_to_root(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\t// open destination\n\tint dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfwarning(\"cannot open destination file %s, file not copied\\n\", destname);\n\t\treturn;\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tint src = open(srcname, O_RDONLY);\n\t\tif (src < 0) {\n\t\t\tfwarning(\"cannot open source file %s, file not copied\\n\", srcname);\n\t\t} else {\n\t\t\tif (copy_file_by_fd(src, dst)) {\n\t\t\t\tfwarning(\"cannot copy %s\\n\", srcname);\n\t\t\t}\n\t\t\tclose(src);\n\t\t}\n\t\tclose(dst);\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tif (fchown(dst, uid, gid) == -1)\n\t\terrExit(\"fchown\");\n\tif (fchmod(dst, mode) == -1)\n\t\terrExit(\"fchmod\");\n\tclose(dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create untrusted X cookie: \"\n\t\t\t\"xauth: un-decodable exit status %04x\\n\"",
            "status"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create untrusted X cookie: xauth: %s\\n\"",
            "strsignal(WTERMSIG(status))"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsignal",
          "args": [
            "WTERMSIG(status)"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to create untrusted X cookie: xauth: exit %d\\n\"",
            "WEXITSTATUS(status)"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"waitpid\""
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&status",
            "0"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "127"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"/usr/bin/xauth\"",
            "\"/usr/bin/xauth\"",
            "\"-v\"",
            "\"-f\"",
            "tmpfname",
            "\"generate\"",
            "display",
            "\"MIT-MAGIC-COOKIE-1\"",
            "\"untrusted\"",
            "NULL"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gcov_flush",
          "args": [],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clearenv",
          "args": [],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "1"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "121-142",
          "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchown",
          "args": [
            "fd",
            "getuid()",
            "getgid()"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create .Xauthority file\\n\""
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmpfname"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Generating a new .Xauthority file\\n\""
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /tmp\""
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/tmp\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=1777,gid=0\""
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"Error: --x11=xorg requires an 'outer' X11 server to use.\\n\"",
            "stderr"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid /usr/bin/xauth executable\\n\""
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: xauth utility not found in /usr/bin. Please install it:\\n\"\n\t\t\t\"   Debian/Ubuntu/Mint: sudo apt-get install xauth\\n\""
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_xorg(void) {\n#ifdef HAVE_X11\n\n\t// check xauth utility is present in the system\n\tstruct stat s;\n\tif (stat(\"/usr/bin/xauth\", &s) == -1) {\n\t\tfprintf(stderr, \"Error: xauth utility not found in /usr/bin. Please install it:\\n\"\n\t\t\t\"   Debian/Ubuntu/Mint: sudo apt-get install xauth\\n\");\n\t\texit(1);\n\t}\n\tif (s.st_uid != 0 && s.st_gid != 0) {\n\t\tfprintf(stderr, \"Error: invalid /usr/bin/xauth executable\\n\");\n\t\texit(1);\n\t}\n\n\t// get DISPLAY env\n\tchar *display = getenv(\"DISPLAY\");\n\tif (!display) {\n\t\tfputs(\"Error: --x11=xorg requires an 'outer' X11 server to use.\\n\", stderr);\n\t\texit(1);\n\t}\n\n\t// temporarily mount a tempfs on top of /tmp directory\n\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\terrExit(\"mounting /tmp\");\n\n\t// create the temporary .Xauthority file\n\tif (arg_debug)\n\t\tprintf(\"Generating a new .Xauthority file\\n\");\n\tchar tmpfname[] = \"/tmp/.tmpXauth-XXXXXX\";\n\tint fd = mkstemp(tmpfname);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Error: cannot create .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (fchown(fd, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tclose(fd);\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(1);\n\t\tclearenv();\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\texeclp(\"/usr/bin/xauth\", \"/usr/bin/xauth\", \"-v\", \"-f\", tmpfname,\n\t\t\t\"generate\", display, \"MIT-MAGIC-COOKIE-1\", \"untrusted\", NULL);\n\n\t\t_exit(127);\n\t}\n\n\t// wait for the xauth process to finish\n\tint status;\n\tif (waitpid(child, &status, 0) != child)\n\t\terrExit(\"waitpid\");\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t/* success */\n\t}\n\telse if (WIFEXITED(status)) {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: xauth: exit %d\\n\",\n\t\t\tWEXITSTATUS(status));\n\t\texit(1);\n\t}\n\telse if (WIFSIGNALED(status)) {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: xauth: %s\\n\",\n\t\t\tstrsignal(WTERMSIG(status)));\n\t\texit(1);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: \"\n\t\t\t\"xauth: un-decodable exit status %04x\\n\", status);\n\t\texit(1);\n\t}\n\n\t// move the temporary file in RUN_XAUTHORITY_SEC_FILE in order to have it deleted\n\t// automatically when the sandbox is closed (rename doesn't work)\n\t\t\t\t\t\t  // root needed\n\tif (copy_file(tmpfname, RUN_XAUTHORITY_SEC_FILE, getuid(), getgid(), 0600)) {\n\t\tfprintf(stderr, \"Error: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\t/* coverity[toctou] */\n\tunlink(tmpfname);\n\tumount(\"/tmp\");\n\n\t// remount RUN_XAUTHORITY_SEC_FILE noexec, nodev, nosuid\n\tfs_noexec(RUN_XAUTHORITY_SEC_FILE);\n\n\t// Ensure there is already a file in the usual location, so that bind-mount below will work.\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(dest, &s) == -1) {\n\t\ttouch_file_as_user(dest, 0600);\n\t\tif (stat(dest, &s) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s\\n\", dest);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// get a file descriptor for .Xauthority\n\tfd = safe_fd(dest, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\t// check if the actual mount destination is a user owned regular file\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != getuid()) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: .Xauthority is a symbolic link\\n\");\n\t\telse\n\t\t\tfprintf(stderr, \"Error: .Xauthority is not a user owned regular file\\n\");\n\t\texit(1);\n\t}\n\t// preserve a read-only mount\n\tstruct statvfs vfs;\n\tif (fstatvfs(fd, &vfs) == -1)\n\t\terrExit(\"fstatvfs\");\n\tif ((vfs.f_flag & MS_RDONLY) == MS_RDONLY)\n\t\tfs_rdonly(RUN_XAUTHORITY_SEC_FILE);\n\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(RUN_XAUTHORITY_SEC_FILE, proc, \"none\", MS_BIND, \"mode=0600\") == -1) {\n\t\tfprintf(stderr, \"Error: cannot mount the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tfree(proc);\n\tclose(fd);\n\t// check /proc/self/mountinfo to confirm the mount is ok\n\tMountData *mptr = get_last_mount();\n\tif (strcmp(mptr->dir, dest) != 0 || strcmp(mptr->fstype, \"tmpfs\") != 0)\n\t\terrLogExit(\"invalid .Xauthority mount\");\n\n\tASSERT_PERMS(dest, getuid(), getgid(), 0600);\n\tfree(dest);\n#endif\n}"
  },
  {
    "function_name": "x11_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "1037-1057",
    "snippet": "void x11_start(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\n\t// check xpra\n\tif (program_in_path(\"xpra\"))\n\t\tx11_start_xpra(argc, argv);\n\telse if (program_in_path(\"Xephyr\"))\n\t\tx11_start_xephyr(argc, argv);\n\telse {\n\t\tfprintf(stderr, \"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\texit(0);\n\t}\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\""
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\""
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\""
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_start_xephyr",
          "args": [
            "argc",
            "argv"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start_xephyr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "414-619",
          "snippet": "void x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\n\t// default xephyr screen can be overwritten by a --xephyr-screen= command line option\n\tchar *newscreen = extract_setting(argc, argv, \"--xephyr-screen=\");\n\tif (newscreen)\n\t\txephyr_screen = newscreen;\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (!program_in_path(\"Xephyr\")) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[pos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[pos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\t\t\t\t\t\t  // no overrun\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\t{\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2);\t\t\t  // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"*** Starting xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t}\n\telse if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL);\t\t\t\t  // fulneral\n\n\texit(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\n\t// default xephyr screen can be overwritten by a --xephyr-screen= command line option\n\tchar *newscreen = extract_setting(argc, argv, \"--xephyr-screen=\");\n\tif (newscreen)\n\t\txephyr_screen = newscreen;\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (!program_in_path(\"Xephyr\")) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[pos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[pos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\t\t\t\t\t\t  // no overrun\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\t{\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2);\t\t\t  // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"*** Starting xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t}\n\telse if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL);\t\t\t\t  // fulneral\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "program_in_path",
          "args": [
            "\"Xephyr\""
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "program_in_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/paths.c",
          "lines": "100-151",
          "snippet": "int program_in_path(const char *program) {\n\tassert(program && *program);\n\tassert(strchr(program, '/') == 0);\n\tassert(strcmp(program, \".\") != 0);\n\tassert(strcmp(program, \"..\") != 0);\n\n\tif (!paths)\n\t\tinit_paths();\n\tassert(paths);\n\n\tsize_t proglen = strlen(program);\n\tchar *scratch = malloc(longest_path_elt + proglen + 2);\n\tif (!scratch)\n\t\terrExit(\"malloc\");\n\n\tint found = 0;\n\tsize_t dlen;\n\tchar **p;\n\tfor (p = paths; *p; p++) {\n\t\tchar *dir = *p;\n\t\tdlen = strlen(dir);\n\n\t\t// init_paths should ensure that this is true; as long\n\t\t// as it is true, 'scratch' has enough space for \"$p/$program\".\n\t\tassert(dlen <= longest_path_elt);\n\n\t\tmemcpy(scratch, dir, dlen);\n\t\tscratch[dlen++] = '/';\n\n\t\t// copy proglen+1 bytes to copy the nul terminator at\n\t\t// the end of 'program'.\n\t\tmemcpy(scratch + dlen, program, proglen+1);\n\n\t\tif (access(scratch, X_OK) == 0) {\n\t\t\t// must also verify that this is a regular file\n\t\t\t// ('x' permission means something different for directories).\n\t\t\t// exec follows symlinks, so use stat, not lstat.\n\t\t\tstruct stat st;\n\t\t\tif (stat(scratch, &st)) {\n\t\t\t\tperror(scratch);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (S_ISREG(st.st_mode)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(scratch);\n\treturn found;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char **paths = 0;",
            "static unsigned int longest_path_elt = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic char **paths = 0;\nstatic unsigned int longest_path_elt = 0;\n\nint program_in_path(const char *program) {\n\tassert(program && *program);\n\tassert(strchr(program, '/') == 0);\n\tassert(strcmp(program, \".\") != 0);\n\tassert(strcmp(program, \"..\") != 0);\n\n\tif (!paths)\n\t\tinit_paths();\n\tassert(paths);\n\n\tsize_t proglen = strlen(program);\n\tchar *scratch = malloc(longest_path_elt + proglen + 2);\n\tif (!scratch)\n\t\terrExit(\"malloc\");\n\n\tint found = 0;\n\tsize_t dlen;\n\tchar **p;\n\tfor (p = paths; *p; p++) {\n\t\tchar *dir = *p;\n\t\tdlen = strlen(dir);\n\n\t\t// init_paths should ensure that this is true; as long\n\t\t// as it is true, 'scratch' has enough space for \"$p/$program\".\n\t\tassert(dlen <= longest_path_elt);\n\n\t\tmemcpy(scratch, dir, dlen);\n\t\tscratch[dlen++] = '/';\n\n\t\t// copy proglen+1 bytes to copy the nul terminator at\n\t\t// the end of 'program'.\n\t\tmemcpy(scratch + dlen, program, proglen+1);\n\n\t\tif (access(scratch, X_OK) == 0) {\n\t\t\t// must also verify that this is a regular file\n\t\t\t// ('x' permission means something different for directories).\n\t\t\t// exec follows symlinks, so use stat, not lstat.\n\t\t\tstruct stat st;\n\t\t\tif (stat(scratch, &st)) {\n\t\t\t\tperror(scratch);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (S_ISREG(st.st_mode)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(scratch);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_start_xpra",
          "args": [
            "argc",
            "argv"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start_xpra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "1006-1034",
          "snippet": "void x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (!program_in_path(\"xpra\")) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (checkcfg(CFG_XPRA_ATTACH))\n\t\tx11_start_xpra_new(argc, argv, display_str);\n\telse\n\t\tx11_start_xpra_old(argc, argv, display, display_str);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (!program_in_path(\"xpra\")) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (checkcfg(CFG_XPRA_ATTACH))\n\t\tx11_start_xpra_new(argc, argv, display_str);\n\telse\n\t\tx11_start_xpra_old(argc, argv, display, display_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: X11 sandboxing is not available when running as root\\n\""
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\n\t// check xpra\n\tif (program_in_path(\"xpra\"))\n\t\tx11_start_xpra(argc, argv);\n\telse if (program_in_path(\"Xephyr\"))\n\t\tx11_start_xephyr(argc, argv);\n\telse {\n\t\tfprintf(stderr, \"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\texit(0);\n\t}\n}"
  },
  {
    "function_name": "x11_start_xpra",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "1006-1034",
    "snippet": "void x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (!program_in_path(\"xpra\")) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (checkcfg(CFG_XPRA_ATTACH))\n\t\tx11_start_xpra_new(argc, argv, display_str);\n\telse\n\t\tx11_start_xpra_old(argc, argv, display, display_str);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x11_start_xpra_old",
          "args": [
            "argc",
            "argv",
            "display",
            "display_str"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start_xpra_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "622-855",
          "snippet": "void x11_start_xpra_old(int argc, char **argv, int display, char *display_str) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t client = 0;\n\tpid_t server = 0;\n\n\t// build the start command\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"xpra\", \"start\", display_str, \"--no-daemon\",\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\n\tassert(xpra_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xpra_extra_params);\n\tif (*xpra_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xpra_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[pos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[pos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[pos++] = NULL;\n\n\t\t\t\t\t\t  // no overrun\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xpra server: \");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// add a small delay, on some systems it takes some time for the server to start\n\tsleep(5);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xpra\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\t// build attach command\n\tchar *attach_argv[] = { \"xpra\", \"--title=\\\"firejail x11 sandbox\\\"\", \"attach\", display_str, NULL };\n\n\t// run attach command\n\tclient = fork();\n\tif (client < 0)\n\t\terrExit(\"fork\");\n\tif (client == 0) {\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\tfmessage(\"\\n*** Attaching to xpra display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(attach_argv[0], attach_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tpos = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[pos] = argv[i];\n\t\tpos++;\n\t}\n\tfirejail_argv[pos] = NULL;\n\n\tassert((int) pos < (argc+2));\n\tassert(!firejail_argv[pos]);\n\n\t// start jail\n\tpid_t jail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\tif (firejail_argv[0])\t\t  // shut up llvm scan-build\n\t\t\texecvp(firejail_argv[0], firejail_argv);\n\t\tperror(\"execvp\");\n\t\texit(1);\n\t}\n\n\tfmessage(\"Xpra server pid %d, xpra client pid %d, jail %d\\n\", server, client, jail);\n\n\tsleep(1);\t\t\t\t  // adding a delay in order to let the server start\n\n\t// wait for jail or server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\n\t\tif (pid == jail) {\n\t\t\tchar *stop_argv[] = { \"xpra\", \"stop\", display_str, NULL };\n\t\t\tpid_t stop = fork();\n\t\t\tif (stop < 0)\n\t\t\t\terrExit(\"fork\");\n\t\t\tif (stop == 0) {\n\t\t\t\tif (arg_quiet && fd_null != -1) {\n\t\t\t\t\tdup2(fd_null,0);\n\t\t\t\t\tdup2(fd_null,1);\n\t\t\t\t\tdup2(fd_null,2);\n\t\t\t\t}\n\t\t\t\t// running without privileges - see drop_privs call above\n\t\t\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\t\t\texecvp(stop_argv[0], stop_argv);\n\t\t\t\tperror(\"execvp\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// wait for xpra server to stop, 10 seconds limit\n\t\t\twhile (++n < 10) {\n\t\t\t\tsleep(1);\n\t\t\t\tpid = waitpid(server, NULL, WNOHANG);\n\t\t\t\tif (pid == server)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (arg_debug) {\n\t\t\t\tif (n == 10)\n\t\t\t\t\tprintf(\"failed to stop xpra server gratefully\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"xpra server successfully stopped in %d secs\\n\", n);\n\t\t\t}\n\n\t\t\t// kill xpra server and xpra client\n\t\t\tkill(client, SIGTERM);\n\t\t\tkill(server, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t\telse if (pid == server) {\n\t\t\t// kill firejail process\n\t\t\tkill(jail, SIGTERM);\n\t\t\t// kill xpra client (should die with server, but...)\n\t\t\tkill(client, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xpra_old(int argc, char **argv, int display, char *display_str) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t client = 0;\n\tpid_t server = 0;\n\n\t// build the start command\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"xpra\", \"start\", display_str, \"--no-daemon\",\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\n\tassert(xpra_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xpra_extra_params);\n\tif (*xpra_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xpra_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[pos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[pos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[pos++] = NULL;\n\n\t\t\t\t\t\t  // no overrun\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xpra server: \");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// add a small delay, on some systems it takes some time for the server to start\n\tsleep(5);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xpra\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\t// build attach command\n\tchar *attach_argv[] = { \"xpra\", \"--title=\\\"firejail x11 sandbox\\\"\", \"attach\", display_str, NULL };\n\n\t// run attach command\n\tclient = fork();\n\tif (client < 0)\n\t\terrExit(\"fork\");\n\tif (client == 0) {\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\tfmessage(\"\\n*** Attaching to xpra display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(attach_argv[0], attach_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tpos = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[pos] = argv[i];\n\t\tpos++;\n\t}\n\tfirejail_argv[pos] = NULL;\n\n\tassert((int) pos < (argc+2));\n\tassert(!firejail_argv[pos]);\n\n\t// start jail\n\tpid_t jail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\tif (firejail_argv[0])\t\t  // shut up llvm scan-build\n\t\t\texecvp(firejail_argv[0], firejail_argv);\n\t\tperror(\"execvp\");\n\t\texit(1);\n\t}\n\n\tfmessage(\"Xpra server pid %d, xpra client pid %d, jail %d\\n\", server, client, jail);\n\n\tsleep(1);\t\t\t\t  // adding a delay in order to let the server start\n\n\t// wait for jail or server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\n\t\tif (pid == jail) {\n\t\t\tchar *stop_argv[] = { \"xpra\", \"stop\", display_str, NULL };\n\t\t\tpid_t stop = fork();\n\t\t\tif (stop < 0)\n\t\t\t\terrExit(\"fork\");\n\t\t\tif (stop == 0) {\n\t\t\t\tif (arg_quiet && fd_null != -1) {\n\t\t\t\t\tdup2(fd_null,0);\n\t\t\t\t\tdup2(fd_null,1);\n\t\t\t\t\tdup2(fd_null,2);\n\t\t\t\t}\n\t\t\t\t// running without privileges - see drop_privs call above\n\t\t\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\t\t\texecvp(stop_argv[0], stop_argv);\n\t\t\t\tperror(\"execvp\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// wait for xpra server to stop, 10 seconds limit\n\t\t\twhile (++n < 10) {\n\t\t\t\tsleep(1);\n\t\t\t\tpid = waitpid(server, NULL, WNOHANG);\n\t\t\t\tif (pid == server)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (arg_debug) {\n\t\t\t\tif (n == 10)\n\t\t\t\t\tprintf(\"failed to stop xpra server gratefully\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"xpra server successfully stopped in %d secs\\n\", n);\n\t\t\t}\n\n\t\t\t// kill xpra server and xpra client\n\t\t\tkill(client, SIGTERM);\n\t\t\tkill(server, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t\telse if (pid == server) {\n\t\t\t// kill firejail process\n\t\t\tkill(jail, SIGTERM);\n\t\t\t// kill xpra client (should die with server, but...)\n\t\t\tkill(client, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_start_xpra_new",
          "args": [
            "argc",
            "argv",
            "display_str"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start_xpra_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "858-1003",
          "snippet": "void x11_start_xpra_new(int argc, char **argv, char *display_str) {\n\tEUID_ASSERT();\n\tint i;\n\tpid_t server = 0;\n\n\t// build the start command\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"xpra\", \"start\", display_str, \"--daemon=no\", \"--attach=yes\", \"--exit-with-children=yes\"\n\t};\n\tunsigned spos = 0;\n\tunsigned fpos = 0;\n\twhile (server_argv[spos] != NULL) spos++;\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tsize_t total_length = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[fpos] = argv[i];\n\t\tfpos++;\n\t\ttotal_length += strlen(argv[i]);\n\t}\n\n\tchar *start_child_prefix = \"--start-child=\";\n\tchar *start_child;\n\tstart_child = malloc(total_length + strlen(start_child_prefix) + fpos + 2);\n\tif (start_child == NULL) {\n\t\tfprintf(stderr, \"Error: unable to allocate start_child to assemble command\\n\");\n\t\texit(1);\n\t}\n\n\tstrcpy(start_child,start_child_prefix);\n\tfor(i = 0; (unsigned) i < fpos; i++) {\n\t\tstrncat(start_child,firejail_argv[i],strlen(firejail_argv[i]));\n\t\tif((unsigned) i != fpos - 1)\n\t\t\tstrncat(start_child,\" \",strlen(\" \"));\n\t}\n\n\tserver_argv[spos++] = start_child;\n\n\tserver_argv[spos++] = NULL;\n\tfirejail_argv[fpos] = NULL;\n\n\tassert(xpra_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xpra_extra_params);\n\tif (*xpra_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xpra_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[spos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params)-1; i++) {\n\t\t\tif (spos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[spos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[spos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[spos++] = NULL;\n\n\tassert((int) fpos < (argc+2));\n\tassert(!firejail_argv[fpos]);\n\t\t\t\t\t\t  // no overrun\n\tassert(spos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[spos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xpra server: \");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// wait for server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\t\tif (pid == server) {\n\t\t\tfree(start_child);\n\t\t\texit(0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xpra_new(int argc, char **argv, char *display_str) {\n\tEUID_ASSERT();\n\tint i;\n\tpid_t server = 0;\n\n\t// build the start command\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"xpra\", \"start\", display_str, \"--daemon=no\", \"--attach=yes\", \"--exit-with-children=yes\"\n\t};\n\tunsigned spos = 0;\n\tunsigned fpos = 0;\n\twhile (server_argv[spos] != NULL) spos++;\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tsize_t total_length = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[fpos] = argv[i];\n\t\tfpos++;\n\t\ttotal_length += strlen(argv[i]);\n\t}\n\n\tchar *start_child_prefix = \"--start-child=\";\n\tchar *start_child;\n\tstart_child = malloc(total_length + strlen(start_child_prefix) + fpos + 2);\n\tif (start_child == NULL) {\n\t\tfprintf(stderr, \"Error: unable to allocate start_child to assemble command\\n\");\n\t\texit(1);\n\t}\n\n\tstrcpy(start_child,start_child_prefix);\n\tfor(i = 0; (unsigned) i < fpos; i++) {\n\t\tstrncat(start_child,firejail_argv[i],strlen(firejail_argv[i]));\n\t\tif((unsigned) i != fpos - 1)\n\t\t\tstrncat(start_child,\" \",strlen(\" \"));\n\t}\n\n\tserver_argv[spos++] = start_child;\n\n\tserver_argv[spos++] = NULL;\n\tfirejail_argv[fpos] = NULL;\n\n\tassert(xpra_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xpra_extra_params);\n\tif (*xpra_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xpra_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[spos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params)-1; i++) {\n\t\t\tif (spos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[spos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[spos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[spos++] = NULL;\n\n\tassert((int) fpos < (argc+2));\n\tassert(!firejail_argv[fpos]);\n\t\t\t\t\t\t  // no overrun\n\tassert(spos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[spos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xpra server: \");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// wait for server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\t\tif (pid == server) {\n\t\t\tfree(start_child);\n\t\t\texit(0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_XPRA_ATTACH"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/checkcfg.c",
          "lines": "35-213",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *xpra_extra_params = \"\";",
            "char *xvfb_screen = \"800x600x24\";",
            "char *xvfb_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *xpra_extra_params = \"\";\nchar *xvfb_screen = \"800x600x24\";\nchar *xvfb_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&display_str",
            "\":%d\"",
            "display"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "random_display_number",
          "args": [],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "random_display_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "122-196",
          "snippet": "static int random_display_number(void) {\n\tint display;\n\tint found = 0;\n\tint i;\n\n\tstruct sockaddr_un sa;\n\t// The -1 here is because we need space to inject a\n\t// leading nul byte.\n\tint sun_pathmax = (int)(sizeof sa.sun_path - 1);\n\tassert((size_t)sun_pathmax == sizeof sa.sun_path - 1);\n\tint sun_pathlen;\n\n\tint sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sockfd == -1)\n\t\terrExit(\"socket\");\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % (X11_DISPLAY_END - X11_DISPLAY_START) + X11_DISPLAY_START;\n\n\t\t// The display number might be claimed by a server listening\n\t\t// in _either_ the normal or the abstract namespace; they\n\t\t// don't necessarily do both.  The easiest way to check is\n\t\t// to try to connect, both ways.\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sun_family = AF_UNIX;\n\t\tsun_pathlen = snprintf(sa.sun_path, sun_pathmax,\n\t\t\t\"/tmp/.X11-unix/X%d\", display);\n\t\tif (sun_pathlen >= sun_pathmax) {\n\t\t\tfprintf(stderr, \"sun_path too small for display :%d\"\n\t\t\t\t\" (only %d bytes usable)\\n\", display, sun_pathmax);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + sun_pathlen + 1) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// Name not claimed in the normal namespace; now try it\n\t\t// in the abstract namespace.  Note that abstract-namespace\n\t\t// names are NOT nul-terminated; they extend to the length\n\t\t// specified as the third argument to 'connect'.\n\t\tmemmove(sa.sun_path + 1, sa.sun_path, sun_pathlen + 1);\n\t\tsa.sun_path[0] = '\\0';\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + 1 + sun_pathlen) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// This display number is unclaimed.  Of course, it could\n\t\t// be claimed before we get around to doing it...\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tclose(sockfd);\n\n\tif (!found) {\n\t\tfputs(\"Error: cannot find an unallocated X11 display number, \"\n\t\t\t\"exiting...\\n\", stderr);\n\t\texit(1);\n\t}\n\treturn display;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int random_display_number(void) {\n\tint display;\n\tint found = 0;\n\tint i;\n\n\tstruct sockaddr_un sa;\n\t// The -1 here is because we need space to inject a\n\t// leading nul byte.\n\tint sun_pathmax = (int)(sizeof sa.sun_path - 1);\n\tassert((size_t)sun_pathmax == sizeof sa.sun_path - 1);\n\tint sun_pathlen;\n\n\tint sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sockfd == -1)\n\t\terrExit(\"socket\");\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % (X11_DISPLAY_END - X11_DISPLAY_START) + X11_DISPLAY_START;\n\n\t\t// The display number might be claimed by a server listening\n\t\t// in _either_ the normal or the abstract namespace; they\n\t\t// don't necessarily do both.  The easiest way to check is\n\t\t// to try to connect, both ways.\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sun_family = AF_UNIX;\n\t\tsun_pathlen = snprintf(sa.sun_path, sun_pathmax,\n\t\t\t\"/tmp/.X11-unix/X%d\", display);\n\t\tif (sun_pathlen >= sun_pathmax) {\n\t\t\tfprintf(stderr, \"sun_path too small for display :%d\"\n\t\t\t\t\" (only %d bytes usable)\\n\", display, sun_pathmax);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + sun_pathlen + 1) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// Name not claimed in the normal namespace; now try it\n\t\t// in the abstract namespace.  Note that abstract-namespace\n\t\t// names are NOT nul-terminated; they extend to the length\n\t\t// specified as the third argument to 'connect'.\n\t\tmemmove(sa.sun_path + 1, sa.sun_path, sun_pathlen + 1);\n\t\tsa.sun_path[0] = '\\0';\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + 1 + sun_pathlen) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// This display number is unclaimed.  Of course, it could\n\t\t// be claimed before we get around to doing it...\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tclose(sockfd);\n\n\tif (!found) {\n\t\tfputs(\"Error: cannot find an unallocated X11 display number, \"\n\t\t\t\"exiting...\\n\", stderr);\n\t\texit(1);\n\t}\n\treturn display;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\""
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\""
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "program_in_path",
          "args": [
            "\"xpra\""
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "program_in_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/paths.c",
          "lines": "100-151",
          "snippet": "int program_in_path(const char *program) {\n\tassert(program && *program);\n\tassert(strchr(program, '/') == 0);\n\tassert(strcmp(program, \".\") != 0);\n\tassert(strcmp(program, \"..\") != 0);\n\n\tif (!paths)\n\t\tinit_paths();\n\tassert(paths);\n\n\tsize_t proglen = strlen(program);\n\tchar *scratch = malloc(longest_path_elt + proglen + 2);\n\tif (!scratch)\n\t\terrExit(\"malloc\");\n\n\tint found = 0;\n\tsize_t dlen;\n\tchar **p;\n\tfor (p = paths; *p; p++) {\n\t\tchar *dir = *p;\n\t\tdlen = strlen(dir);\n\n\t\t// init_paths should ensure that this is true; as long\n\t\t// as it is true, 'scratch' has enough space for \"$p/$program\".\n\t\tassert(dlen <= longest_path_elt);\n\n\t\tmemcpy(scratch, dir, dlen);\n\t\tscratch[dlen++] = '/';\n\n\t\t// copy proglen+1 bytes to copy the nul terminator at\n\t\t// the end of 'program'.\n\t\tmemcpy(scratch + dlen, program, proglen+1);\n\n\t\tif (access(scratch, X_OK) == 0) {\n\t\t\t// must also verify that this is a regular file\n\t\t\t// ('x' permission means something different for directories).\n\t\t\t// exec follows symlinks, so use stat, not lstat.\n\t\t\tstruct stat st;\n\t\t\tif (stat(scratch, &st)) {\n\t\t\t\tperror(scratch);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (S_ISREG(st.st_mode)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(scratch);\n\treturn found;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char **paths = 0;",
            "static unsigned int longest_path_elt = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic char **paths = 0;\nstatic unsigned int longest_path_elt = 0;\n\nint program_in_path(const char *program) {\n\tassert(program && *program);\n\tassert(strchr(program, '/') == 0);\n\tassert(strcmp(program, \".\") != 0);\n\tassert(strcmp(program, \"..\") != 0);\n\n\tif (!paths)\n\t\tinit_paths();\n\tassert(paths);\n\n\tsize_t proglen = strlen(program);\n\tchar *scratch = malloc(longest_path_elt + proglen + 2);\n\tif (!scratch)\n\t\terrExit(\"malloc\");\n\n\tint found = 0;\n\tsize_t dlen;\n\tchar **p;\n\tfor (p = paths; *p; p++) {\n\t\tchar *dir = *p;\n\t\tdlen = strlen(dir);\n\n\t\t// init_paths should ensure that this is true; as long\n\t\t// as it is true, 'scratch' has enough space for \"$p/$program\".\n\t\tassert(dlen <= longest_path_elt);\n\n\t\tmemcpy(scratch, dir, dlen);\n\t\tscratch[dlen++] = '/';\n\n\t\t// copy proglen+1 bytes to copy the nul terminator at\n\t\t// the end of 'program'.\n\t\tmemcpy(scratch + dlen, program, proglen+1);\n\n\t\tif (access(scratch, X_OK) == 0) {\n\t\t\t// must also verify that this is a regular file\n\t\t\t// ('x' permission means something different for directories).\n\t\t\t// exec follows symlinks, so use stat, not lstat.\n\t\t\tstruct stat st;\n\t\t\tif (stat(scratch, &st)) {\n\t\t\t\tperror(scratch);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (S_ISREG(st.st_mode)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(scratch);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "0"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "121-142",
          "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: X11 sandboxing is not available when running as root\\n\""
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"FIREJAIL_X11\"",
            "\"yes\"",
            "1"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (!program_in_path(\"xpra\")) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tif (checkcfg(CFG_XPRA_ATTACH))\n\t\tx11_start_xpra_new(argc, argv, display_str);\n\telse\n\t\tx11_start_xpra_old(argc, argv, display, display_str);\n}"
  },
  {
    "function_name": "x11_start_xpra_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "858-1003",
    "snippet": "void x11_start_xpra_new(int argc, char **argv, char *display_str) {\n\tEUID_ASSERT();\n\tint i;\n\tpid_t server = 0;\n\n\t// build the start command\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"xpra\", \"start\", display_str, \"--daemon=no\", \"--attach=yes\", \"--exit-with-children=yes\"\n\t};\n\tunsigned spos = 0;\n\tunsigned fpos = 0;\n\twhile (server_argv[spos] != NULL) spos++;\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tsize_t total_length = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[fpos] = argv[i];\n\t\tfpos++;\n\t\ttotal_length += strlen(argv[i]);\n\t}\n\n\tchar *start_child_prefix = \"--start-child=\";\n\tchar *start_child;\n\tstart_child = malloc(total_length + strlen(start_child_prefix) + fpos + 2);\n\tif (start_child == NULL) {\n\t\tfprintf(stderr, \"Error: unable to allocate start_child to assemble command\\n\");\n\t\texit(1);\n\t}\n\n\tstrcpy(start_child,start_child_prefix);\n\tfor(i = 0; (unsigned) i < fpos; i++) {\n\t\tstrncat(start_child,firejail_argv[i],strlen(firejail_argv[i]));\n\t\tif((unsigned) i != fpos - 1)\n\t\t\tstrncat(start_child,\" \",strlen(\" \"));\n\t}\n\n\tserver_argv[spos++] = start_child;\n\n\tserver_argv[spos++] = NULL;\n\tfirejail_argv[fpos] = NULL;\n\n\tassert(xpra_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xpra_extra_params);\n\tif (*xpra_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xpra_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[spos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params)-1; i++) {\n\t\t\tif (spos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[spos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[spos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[spos++] = NULL;\n\n\tassert((int) fpos < (argc+2));\n\tassert(!firejail_argv[fpos]);\n\t\t\t\t\t\t  // no overrun\n\tassert(spos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[spos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xpra server: \");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// wait for server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\t\tif (pid == server) {\n\t\t\tfree(start_child);\n\t\t\texit(0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "start_child"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "NULL"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "746-796",
          "snippet": "void wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nvoid wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "server_argv[0]",
            "server_argv"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "2"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "1"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "0"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Starting xpra...\\n\""
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"open\""
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDWR"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" ***\\n\\n\""
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" \\\"%s\\\"\"",
            "server_argv[i]"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n*** Starting xpra server: \""
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "server_argv[spos-1] == NULL"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "spos < (sizeof(server_argv)/sizeof(*server_argv))"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!firejail_argv[fpos]"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(int) fpos < (argc+2)"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: arg count limit exceeded while parsing xpra_extra_params\\n\""
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xpra_extra_params"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: unclosed quote found while parsing xpra_extra_params\\n\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: mixed quoting found while parsing xpra_extra_params\\n\""
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "xpra_extra_params"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "xpra_extra_params"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "start_child",
            "\" \"",
            "strlen(\" \")"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "start_child",
            "firejail_argv[i]",
            "strlen(firejail_argv[i])"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "start_child",
            "start_child_prefix"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: unable to allocate start_child to assemble command\\n\""
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "total_length + strlen(start_child_prefix) + fpos + 2"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--x11\"",
            "5"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xpra_new(int argc, char **argv, char *display_str) {\n\tEUID_ASSERT();\n\tint i;\n\tpid_t server = 0;\n\n\t// build the start command\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"xpra\", \"start\", display_str, \"--daemon=no\", \"--attach=yes\", \"--exit-with-children=yes\"\n\t};\n\tunsigned spos = 0;\n\tunsigned fpos = 0;\n\twhile (server_argv[spos] != NULL) spos++;\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tsize_t total_length = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[fpos] = argv[i];\n\t\tfpos++;\n\t\ttotal_length += strlen(argv[i]);\n\t}\n\n\tchar *start_child_prefix = \"--start-child=\";\n\tchar *start_child;\n\tstart_child = malloc(total_length + strlen(start_child_prefix) + fpos + 2);\n\tif (start_child == NULL) {\n\t\tfprintf(stderr, \"Error: unable to allocate start_child to assemble command\\n\");\n\t\texit(1);\n\t}\n\n\tstrcpy(start_child,start_child_prefix);\n\tfor(i = 0; (unsigned) i < fpos; i++) {\n\t\tstrncat(start_child,firejail_argv[i],strlen(firejail_argv[i]));\n\t\tif((unsigned) i != fpos - 1)\n\t\t\tstrncat(start_child,\" \",strlen(\" \"));\n\t}\n\n\tserver_argv[spos++] = start_child;\n\n\tserver_argv[spos++] = NULL;\n\tfirejail_argv[fpos] = NULL;\n\n\tassert(xpra_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xpra_extra_params);\n\tif (*xpra_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xpra_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[spos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params)-1; i++) {\n\t\t\tif (spos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[spos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[spos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[spos++] = NULL;\n\n\tassert((int) fpos < (argc+2));\n\tassert(!firejail_argv[fpos]);\n\t\t\t\t\t\t  // no overrun\n\tassert(spos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[spos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xpra server: \");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// wait for server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\t\tif (pid == server) {\n\t\t\tfree(start_child);\n\t\t\texit(0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "x11_start_xpra_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "622-855",
    "snippet": "void x11_start_xpra_old(int argc, char **argv, int display, char *display_str) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t client = 0;\n\tpid_t server = 0;\n\n\t// build the start command\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"xpra\", \"start\", display_str, \"--no-daemon\",\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\n\tassert(xpra_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xpra_extra_params);\n\tif (*xpra_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xpra_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[pos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[pos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[pos++] = NULL;\n\n\t\t\t\t\t\t  // no overrun\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xpra server: \");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// add a small delay, on some systems it takes some time for the server to start\n\tsleep(5);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xpra\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\t// build attach command\n\tchar *attach_argv[] = { \"xpra\", \"--title=\\\"firejail x11 sandbox\\\"\", \"attach\", display_str, NULL };\n\n\t// run attach command\n\tclient = fork();\n\tif (client < 0)\n\t\terrExit(\"fork\");\n\tif (client == 0) {\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\tfmessage(\"\\n*** Attaching to xpra display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(attach_argv[0], attach_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tpos = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[pos] = argv[i];\n\t\tpos++;\n\t}\n\tfirejail_argv[pos] = NULL;\n\n\tassert((int) pos < (argc+2));\n\tassert(!firejail_argv[pos]);\n\n\t// start jail\n\tpid_t jail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\tif (firejail_argv[0])\t\t  // shut up llvm scan-build\n\t\t\texecvp(firejail_argv[0], firejail_argv);\n\t\tperror(\"execvp\");\n\t\texit(1);\n\t}\n\n\tfmessage(\"Xpra server pid %d, xpra client pid %d, jail %d\\n\", server, client, jail);\n\n\tsleep(1);\t\t\t\t  // adding a delay in order to let the server start\n\n\t// wait for jail or server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\n\t\tif (pid == jail) {\n\t\t\tchar *stop_argv[] = { \"xpra\", \"stop\", display_str, NULL };\n\t\t\tpid_t stop = fork();\n\t\t\tif (stop < 0)\n\t\t\t\terrExit(\"fork\");\n\t\t\tif (stop == 0) {\n\t\t\t\tif (arg_quiet && fd_null != -1) {\n\t\t\t\t\tdup2(fd_null,0);\n\t\t\t\t\tdup2(fd_null,1);\n\t\t\t\t\tdup2(fd_null,2);\n\t\t\t\t}\n\t\t\t\t// running without privileges - see drop_privs call above\n\t\t\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\t\t\texecvp(stop_argv[0], stop_argv);\n\t\t\t\tperror(\"execvp\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// wait for xpra server to stop, 10 seconds limit\n\t\t\twhile (++n < 10) {\n\t\t\t\tsleep(1);\n\t\t\t\tpid = waitpid(server, NULL, WNOHANG);\n\t\t\t\tif (pid == server)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (arg_debug) {\n\t\t\t\tif (n == 10)\n\t\t\t\t\tprintf(\"failed to stop xpra server gratefully\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"xpra server successfully stopped in %d secs\\n\", n);\n\t\t\t}\n\n\t\t\t// kill xpra server and xpra client\n\t\t\tkill(client, SIGTERM);\n\t\t\tkill(server, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t\telse if (pid == server) {\n\t\t\t// kill firejail process\n\t\t\tkill(jail, SIGTERM);\n\t\t\t// kill xpra client (should die with server, but...)\n\t\t\tkill(client, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "client",
            "SIGTERM"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "jail",
            "SIGTERM"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "server",
            "SIGTERM"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "client",
            "SIGTERM"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xpra server successfully stopped in %d secs\\n\"",
            "n"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"failed to stop xpra server gratefully\\n\""
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "server",
            "NULL",
            "WNOHANG"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "firemon_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "90-121",
          "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios tlocal;",
            "static struct termios twait;",
            "static int terminal_set = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "stop_argv[0]",
            "stop_argv"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "2"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "1"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "0"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "NULL"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "746-796",
          "snippet": "void wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nvoid wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"Xpra server pid %d, xpra client pid %d, jail %d\\n\"",
            "server",
            "client",
            "jail"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "189-198",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "firejail_argv[0]",
            "firejail_argv"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!firejail_argv[pos]"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(int) pos < (argc+2)"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--x11\"",
            "5"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"DISPLAY\"",
            "display_str",
            "1"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "display_str"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "attach_argv[0]",
            "attach_argv"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "2"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "1"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "0"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: failed to start xpra\\n\""
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/tmp/.X11-unix/X%d\"",
            "display"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "server_argv[0]",
            "server_argv"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "2"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "1"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "0"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Starting xpra...\\n\""
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"open\""
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDWR"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" ***\\n\\n\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" \\\"%s\\\"\"",
            "server_argv[i]"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n*** Starting xpra server: \""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "server_argv[pos-1] == NULL"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pos < (sizeof(server_argv)/sizeof(*server_argv))"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: arg count limit exceeded while parsing xpra_extra_params\\n\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xpra_extra_params"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: unclosed quote found while parsing xpra_extra_params\\n\""
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: mixed quoting found while parsing xpra_extra_params\\n\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "xpra_extra_params"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "xpra_extra_params"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xpra_old(int argc, char **argv, int display, char *display_str) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t client = 0;\n\tpid_t server = 0;\n\n\t// build the start command\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"xpra\", \"start\", display_str, \"--no-daemon\",\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\n\tassert(xpra_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xpra_extra_params);\n\tif (*xpra_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xpra_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xpra_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xpra_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[pos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[pos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[pos++] = NULL;\n\n\t\t\t\t\t\t  // no overrun\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xpra server: \");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// add a small delay, on some systems it takes some time for the server to start\n\tsleep(5);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xpra\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\t// build attach command\n\tchar *attach_argv[] = { \"xpra\", \"--title=\\\"firejail x11 sandbox\\\"\", \"attach\", display_str, NULL };\n\n\t// run attach command\n\tclient = fork();\n\tif (client < 0)\n\t\terrExit(\"fork\");\n\tif (client == 0) {\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\tfmessage(\"\\n*** Attaching to xpra display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(attach_argv[0], attach_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tpos = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[pos] = argv[i];\n\t\tpos++;\n\t}\n\tfirejail_argv[pos] = NULL;\n\n\tassert((int) pos < (argc+2));\n\tassert(!firejail_argv[pos]);\n\n\t// start jail\n\tpid_t jail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\tif (firejail_argv[0])\t\t  // shut up llvm scan-build\n\t\t\texecvp(firejail_argv[0], firejail_argv);\n\t\tperror(\"execvp\");\n\t\texit(1);\n\t}\n\n\tfmessage(\"Xpra server pid %d, xpra client pid %d, jail %d\\n\", server, client, jail);\n\n\tsleep(1);\t\t\t\t  // adding a delay in order to let the server start\n\n\t// wait for jail or server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\n\t\tif (pid == jail) {\n\t\t\tchar *stop_argv[] = { \"xpra\", \"stop\", display_str, NULL };\n\t\t\tpid_t stop = fork();\n\t\t\tif (stop < 0)\n\t\t\t\terrExit(\"fork\");\n\t\t\tif (stop == 0) {\n\t\t\t\tif (arg_quiet && fd_null != -1) {\n\t\t\t\t\tdup2(fd_null,0);\n\t\t\t\t\tdup2(fd_null,1);\n\t\t\t\t\tdup2(fd_null,2);\n\t\t\t\t}\n\t\t\t\t// running without privileges - see drop_privs call above\n\t\t\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\t\t\texecvp(stop_argv[0], stop_argv);\n\t\t\t\tperror(\"execvp\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// wait for xpra server to stop, 10 seconds limit\n\t\t\twhile (++n < 10) {\n\t\t\t\tsleep(1);\n\t\t\t\tpid = waitpid(server, NULL, WNOHANG);\n\t\t\t\tif (pid == server)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (arg_debug) {\n\t\t\t\tif (n == 10)\n\t\t\t\t\tprintf(\"failed to stop xpra server gratefully\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"xpra server successfully stopped in %d secs\\n\", n);\n\t\t\t}\n\n\t\t\t// kill xpra server and xpra client\n\t\t\tkill(client, SIGTERM);\n\t\t\tkill(server, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t\telse if (pid == server) {\n\t\t\t// kill firejail process\n\t\t\tkill(jail, SIGTERM);\n\t\t\t// kill xpra client (should die with server, but...)\n\t\t\tkill(client, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "x11_start_xephyr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "414-619",
    "snippet": "void x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\n\t// default xephyr screen can be overwritten by a --xephyr-screen= command line option\n\tchar *newscreen = extract_setting(argc, argv, \"--xephyr-screen=\");\n\tif (newscreen)\n\t\txephyr_screen = newscreen;\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (!program_in_path(\"Xephyr\")) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[pos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[pos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\t\t\t\t\t\t  // no overrun\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\t{\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2);\t\t\t  // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"*** Starting xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t}\n\telse if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL);\t\t\t\t  // fulneral\n\n\texit(0);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "NULL"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "746-796",
          "snippet": "void wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nvoid wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "server",
            "SIGTERM"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "jail",
            "SIGTERM"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "temp"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "display_str"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "jail_argv[0]",
            "jail_argv"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n*** Attaching to Xephyr display %d ***\\n\\n\"",
            "display"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"DISPLAY\"",
            "display_str",
            "1"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "display_str"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: failed to start xephyr\\n\""
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "firemon_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "90-121",
          "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios tlocal;",
            "static struct termios twait;",
            "static int terminal_set = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/tmp/.X11-unix/X%d\"",
            "display"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xephyr server pid %d\\n\"",
            "server"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "server_argv[0]",
            "server_argv"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Starting xephyr...\\n\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" ***\\n\\n\""
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" \\\"%s\\\"\"",
            "jail_argv[i]"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"*** Starting xephyr client:\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "j < argc+2"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--x11\"",
            "5"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" ***\\n\\n\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" \\\"%s\\\"\"",
            "server_argv[i]"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n*** Starting xephyr server:\""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "server_argv[pos-1] == NULL"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pos < (sizeof(server_argv)/sizeof(*server_argv))"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\""
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xephyr_extra_params"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: unclosed quote found while parsing xephyr_extra_params\\n\""
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: mixed quoting found while parsing xephyr_extra_params\\n\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "xephyr_extra_params"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "xephyr_extra_params"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_XEPHYR_WINDOW_TITLE"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/checkcfg.c",
          "lines": "35-213",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *xpra_extra_params = \"\";",
            "char *xvfb_screen = \"800x600x24\";",
            "char *xvfb_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *xpra_extra_params = \"\";\nchar *xvfb_screen = \"800x600x24\";\nchar *xvfb_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "xephyr_screen"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&display_str",
            "\":%d\"",
            "display"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "random_display_number",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "random_display_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "122-196",
          "snippet": "static int random_display_number(void) {\n\tint display;\n\tint found = 0;\n\tint i;\n\n\tstruct sockaddr_un sa;\n\t// The -1 here is because we need space to inject a\n\t// leading nul byte.\n\tint sun_pathmax = (int)(sizeof sa.sun_path - 1);\n\tassert((size_t)sun_pathmax == sizeof sa.sun_path - 1);\n\tint sun_pathlen;\n\n\tint sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sockfd == -1)\n\t\terrExit(\"socket\");\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % (X11_DISPLAY_END - X11_DISPLAY_START) + X11_DISPLAY_START;\n\n\t\t// The display number might be claimed by a server listening\n\t\t// in _either_ the normal or the abstract namespace; they\n\t\t// don't necessarily do both.  The easiest way to check is\n\t\t// to try to connect, both ways.\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sun_family = AF_UNIX;\n\t\tsun_pathlen = snprintf(sa.sun_path, sun_pathmax,\n\t\t\t\"/tmp/.X11-unix/X%d\", display);\n\t\tif (sun_pathlen >= sun_pathmax) {\n\t\t\tfprintf(stderr, \"sun_path too small for display :%d\"\n\t\t\t\t\" (only %d bytes usable)\\n\", display, sun_pathmax);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + sun_pathlen + 1) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// Name not claimed in the normal namespace; now try it\n\t\t// in the abstract namespace.  Note that abstract-namespace\n\t\t// names are NOT nul-terminated; they extend to the length\n\t\t// specified as the third argument to 'connect'.\n\t\tmemmove(sa.sun_path + 1, sa.sun_path, sun_pathlen + 1);\n\t\tsa.sun_path[0] = '\\0';\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + 1 + sun_pathlen) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// This display number is unclaimed.  Of course, it could\n\t\t// be claimed before we get around to doing it...\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tclose(sockfd);\n\n\tif (!found) {\n\t\tfputs(\"Error: cannot find an unallocated X11 display number, \"\n\t\t\t\"exiting...\\n\", stderr);\n\t\texit(1);\n\t}\n\treturn display;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int random_display_number(void) {\n\tint display;\n\tint found = 0;\n\tint i;\n\n\tstruct sockaddr_un sa;\n\t// The -1 here is because we need space to inject a\n\t// leading nul byte.\n\tint sun_pathmax = (int)(sizeof sa.sun_path - 1);\n\tassert((size_t)sun_pathmax == sizeof sa.sun_path - 1);\n\tint sun_pathlen;\n\n\tint sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sockfd == -1)\n\t\terrExit(\"socket\");\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % (X11_DISPLAY_END - X11_DISPLAY_START) + X11_DISPLAY_START;\n\n\t\t// The display number might be claimed by a server listening\n\t\t// in _either_ the normal or the abstract namespace; they\n\t\t// don't necessarily do both.  The easiest way to check is\n\t\t// to try to connect, both ways.\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sun_family = AF_UNIX;\n\t\tsun_pathlen = snprintf(sa.sun_path, sun_pathmax,\n\t\t\t\"/tmp/.X11-unix/X%d\", display);\n\t\tif (sun_pathlen >= sun_pathmax) {\n\t\t\tfprintf(stderr, \"sun_path too small for display :%d\"\n\t\t\t\t\" (only %d bytes usable)\\n\", display, sun_pathmax);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + sun_pathlen + 1) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// Name not claimed in the normal namespace; now try it\n\t\t// in the abstract namespace.  Note that abstract-namespace\n\t\t// names are NOT nul-terminated; they extend to the length\n\t\t// specified as the third argument to 'connect'.\n\t\tmemmove(sa.sun_path + 1, sa.sun_path, sun_pathlen + 1);\n\t\tsa.sun_path[0] = '\\0';\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + 1 + sun_pathlen) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// This display number is unclaimed.  Of course, it could\n\t\t// be claimed before we get around to doing it...\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tclose(sockfd);\n\n\tif (!found) {\n\t\tfputs(\"Error: cannot find an unallocated X11 display number, \"\n\t\t\t\"exiting...\\n\", stderr);\n\t\texit(1);\n\t}\n\treturn display;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Arch: sudo pacman -S xorg-server-xephyr\\n\""
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "program_in_path",
          "args": [
            "\"Xephyr\""
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "program_in_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/paths.c",
          "lines": "100-151",
          "snippet": "int program_in_path(const char *program) {\n\tassert(program && *program);\n\tassert(strchr(program, '/') == 0);\n\tassert(strcmp(program, \".\") != 0);\n\tassert(strcmp(program, \"..\") != 0);\n\n\tif (!paths)\n\t\tinit_paths();\n\tassert(paths);\n\n\tsize_t proglen = strlen(program);\n\tchar *scratch = malloc(longest_path_elt + proglen + 2);\n\tif (!scratch)\n\t\terrExit(\"malloc\");\n\n\tint found = 0;\n\tsize_t dlen;\n\tchar **p;\n\tfor (p = paths; *p; p++) {\n\t\tchar *dir = *p;\n\t\tdlen = strlen(dir);\n\n\t\t// init_paths should ensure that this is true; as long\n\t\t// as it is true, 'scratch' has enough space for \"$p/$program\".\n\t\tassert(dlen <= longest_path_elt);\n\n\t\tmemcpy(scratch, dir, dlen);\n\t\tscratch[dlen++] = '/';\n\n\t\t// copy proglen+1 bytes to copy the nul terminator at\n\t\t// the end of 'program'.\n\t\tmemcpy(scratch + dlen, program, proglen+1);\n\n\t\tif (access(scratch, X_OK) == 0) {\n\t\t\t// must also verify that this is a regular file\n\t\t\t// ('x' permission means something different for directories).\n\t\t\t// exec follows symlinks, so use stat, not lstat.\n\t\t\tstruct stat st;\n\t\t\tif (stat(scratch, &st)) {\n\t\t\t\tperror(scratch);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (S_ISREG(st.st_mode)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(scratch);\n\treturn found;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char **paths = 0;",
            "static unsigned int longest_path_elt = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic char **paths = 0;\nstatic unsigned int longest_path_elt = 0;\n\nint program_in_path(const char *program) {\n\tassert(program && *program);\n\tassert(strchr(program, '/') == 0);\n\tassert(strcmp(program, \".\") != 0);\n\tassert(strcmp(program, \"..\") != 0);\n\n\tif (!paths)\n\t\tinit_paths();\n\tassert(paths);\n\n\tsize_t proglen = strlen(program);\n\tchar *scratch = malloc(longest_path_elt + proglen + 2);\n\tif (!scratch)\n\t\terrExit(\"malloc\");\n\n\tint found = 0;\n\tsize_t dlen;\n\tchar **p;\n\tfor (p = paths; *p; p++) {\n\t\tchar *dir = *p;\n\t\tdlen = strlen(dir);\n\n\t\t// init_paths should ensure that this is true; as long\n\t\t// as it is true, 'scratch' has enough space for \"$p/$program\".\n\t\tassert(dlen <= longest_path_elt);\n\n\t\tmemcpy(scratch, dir, dlen);\n\t\tscratch[dlen++] = '/';\n\n\t\t// copy proglen+1 bytes to copy the nul terminator at\n\t\t// the end of 'program'.\n\t\tmemcpy(scratch + dlen, program, proglen+1);\n\n\t\tif (access(scratch, X_OK) == 0) {\n\t\t\t// must also verify that this is a regular file\n\t\t\t// ('x' permission means something different for directories).\n\t\t\t// exec follows symlinks, so use stat, not lstat.\n\t\t\tstruct stat st;\n\t\t\tif (stat(scratch, &st)) {\n\t\t\t\tperror(scratch);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (S_ISREG(st.st_mode)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(scratch);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "0"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "121-142",
          "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: X11 sandboxing is not available when running as root\\n\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"FIREJAIL_X11\"",
            "\"yes\"",
            "1"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_setting",
          "args": [
            "argc",
            "argv",
            "\"--xephyr-screen=\""
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "extract_setting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "392-409",
          "snippet": "static char *extract_setting(int argc, char **argv, const char *argument) {\n\tint i;\n\tint len = strlen(argument);\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strncmp(argv[i], argument, len) == 0) {\n\t\t\treturn argv[i] + len;\n\t\t}\n\n\t\t// detect end of firejail params\n\t\tif (strcmp(argv[i], \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(argv[i], \"--\", 2) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic char *extract_setting(int argc, char **argv, const char *argument) {\n\tint i;\n\tint len = strlen(argument);\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strncmp(argv[i], argument, len) == 0) {\n\t\t\treturn argv[i] + len;\n\t\t}\n\n\t\t// detect end of firejail params\n\t\tif (strcmp(argv[i], \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(argv[i], \"--\", 2) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\n\t// default xephyr screen can be overwritten by a --xephyr-screen= command line option\n\tchar *newscreen = extract_setting(argc, argv, \"--xephyr-screen=\");\n\tif (newscreen)\n\t\txephyr_screen = newscreen;\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (!program_in_path(\"Xephyr\")) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) {\n\t\t\t\tserver_argv[pos++] = temp + i + 2;\n\t\t\t}\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') {\n\t\t\t\tserver_argv[pos++] = temp + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\t\t\t\t\t\t  // no overrun\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv)));\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\t{\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2);\t\t\t  // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"*** Starting xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t}\n\telse if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL);\t\t\t\t  // fulneral\n\n\texit(0);\n}"
  },
  {
    "function_name": "extract_setting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "392-409",
    "snippet": "static char *extract_setting(int argc, char **argv, const char *argument) {\n\tint i;\n\tint len = strlen(argument);\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strncmp(argv[i], argument, len) == 0) {\n\t\t\treturn argv[i] + len;\n\t\t}\n\n\t\t// detect end of firejail params\n\t\tif (strcmp(argv[i], \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(argv[i], \"--\", 2) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--\"",
            "2"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "argument",
            "len"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argument"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic char *extract_setting(int argc, char **argv, const char *argument) {\n\tint i;\n\tint len = strlen(argument);\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strncmp(argv[i], argument, len) == 0) {\n\t\t\treturn argv[i] + len;\n\t\t}\n\n\t\t// detect end of firejail params\n\t\tif (strcmp(argv[i], \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(argv[i], \"--\", 2) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "x11_start_xvfb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "200-389",
    "snippet": "void x11_start_xvfb(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// mever try to run X servers as root!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xvfb\n\tif (!program_in_path(\"Xvfb\")) {\n\t\tfprintf(stderr, \"\\nError: Xvfb program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xvfb\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xvfb\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xvfb_screen);\n\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"Xvfb\", display_str, \"-screen\", \"0\", xvfb_screen\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tassert(xvfb_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xvfb_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xvfb_extra_params);\n\tif (*xvfb_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xvfb_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xvfb_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xvfb_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xvfb_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xvfb_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) server_argv[pos++] = temp + i + 2;\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') server_argv[pos++] = temp + i + 1;\n\t\t}\n\t}\n\n\tserver_argv[pos++] = NULL;\n\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv))); // no overrun\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xvfb server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2);\t\t\t  // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Stating xvfb client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xvfb...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xvfb server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xvfb\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tfmessage(\"\\n*** Attaching to Xvfb display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t}\n\telse if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL);\t\t\t\t  // fulneral\n\n\texit(0);\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "NULL"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "746-796",
          "snippet": "void wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nvoid wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "server",
            "SIGTERM"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "jail",
            "SIGTERM"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "temp"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "display_str"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "jail_argv[0]",
            "jail_argv"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"\\n*** Attaching to Xvfb display %d ***\\n\\n\"",
            "display"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "189-198",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"DISPLAY\"",
            "display_str",
            "1"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "display_str"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: failed to start xvfb\\n\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "firemon_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "90-121",
          "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios tlocal;",
            "static struct termios twait;",
            "static int terminal_set = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/tmp/.X11-unix/X%d\"",
            "display"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xvfb server pid %d\\n\"",
            "server"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "server_argv[0]",
            "server_argv"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Starting xvfb...\\n\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" ***\\n\\n\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" \\\"%s\\\"\"",
            "jail_argv[i]"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n*** Stating xvfb client:\""
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "j < argc+2"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--x11\"",
            "5"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" ***\\n\\n\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" \\\"%s\\\"\"",
            "server_argv[i]"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n*** Starting xvfb server:\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "server_argv[pos-1] == NULL"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pos < (sizeof(server_argv)/sizeof(*server_argv))"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: arg count limit exceeded while parsing xvfb_extra_params\\n\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xvfb_extra_params"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: unclosed quote found while parsing xvfb_extra_params\\n\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: mixed quoting found while parsing xvfb_extra_params\\n\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "xvfb_extra_params"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "xvfb_extra_params"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "xvfb_screen"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&display_str",
            "\":%d\"",
            "display"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "random_display_number",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "random_display_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "122-196",
          "snippet": "static int random_display_number(void) {\n\tint display;\n\tint found = 0;\n\tint i;\n\n\tstruct sockaddr_un sa;\n\t// The -1 here is because we need space to inject a\n\t// leading nul byte.\n\tint sun_pathmax = (int)(sizeof sa.sun_path - 1);\n\tassert((size_t)sun_pathmax == sizeof sa.sun_path - 1);\n\tint sun_pathlen;\n\n\tint sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sockfd == -1)\n\t\terrExit(\"socket\");\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % (X11_DISPLAY_END - X11_DISPLAY_START) + X11_DISPLAY_START;\n\n\t\t// The display number might be claimed by a server listening\n\t\t// in _either_ the normal or the abstract namespace; they\n\t\t// don't necessarily do both.  The easiest way to check is\n\t\t// to try to connect, both ways.\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sun_family = AF_UNIX;\n\t\tsun_pathlen = snprintf(sa.sun_path, sun_pathmax,\n\t\t\t\"/tmp/.X11-unix/X%d\", display);\n\t\tif (sun_pathlen >= sun_pathmax) {\n\t\t\tfprintf(stderr, \"sun_path too small for display :%d\"\n\t\t\t\t\" (only %d bytes usable)\\n\", display, sun_pathmax);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + sun_pathlen + 1) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// Name not claimed in the normal namespace; now try it\n\t\t// in the abstract namespace.  Note that abstract-namespace\n\t\t// names are NOT nul-terminated; they extend to the length\n\t\t// specified as the third argument to 'connect'.\n\t\tmemmove(sa.sun_path + 1, sa.sun_path, sun_pathlen + 1);\n\t\tsa.sun_path[0] = '\\0';\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + 1 + sun_pathlen) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// This display number is unclaimed.  Of course, it could\n\t\t// be claimed before we get around to doing it...\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tclose(sockfd);\n\n\tif (!found) {\n\t\tfputs(\"Error: cannot find an unallocated X11 display number, \"\n\t\t\t\"exiting...\\n\", stderr);\n\t\texit(1);\n\t}\n\treturn display;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int random_display_number(void) {\n\tint display;\n\tint found = 0;\n\tint i;\n\n\tstruct sockaddr_un sa;\n\t// The -1 here is because we need space to inject a\n\t// leading nul byte.\n\tint sun_pathmax = (int)(sizeof sa.sun_path - 1);\n\tassert((size_t)sun_pathmax == sizeof sa.sun_path - 1);\n\tint sun_pathlen;\n\n\tint sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sockfd == -1)\n\t\terrExit(\"socket\");\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % (X11_DISPLAY_END - X11_DISPLAY_START) + X11_DISPLAY_START;\n\n\t\t// The display number might be claimed by a server listening\n\t\t// in _either_ the normal or the abstract namespace; they\n\t\t// don't necessarily do both.  The easiest way to check is\n\t\t// to try to connect, both ways.\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sun_family = AF_UNIX;\n\t\tsun_pathlen = snprintf(sa.sun_path, sun_pathmax,\n\t\t\t\"/tmp/.X11-unix/X%d\", display);\n\t\tif (sun_pathlen >= sun_pathmax) {\n\t\t\tfprintf(stderr, \"sun_path too small for display :%d\"\n\t\t\t\t\" (only %d bytes usable)\\n\", display, sun_pathmax);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + sun_pathlen + 1) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// Name not claimed in the normal namespace; now try it\n\t\t// in the abstract namespace.  Note that abstract-namespace\n\t\t// names are NOT nul-terminated; they extend to the length\n\t\t// specified as the third argument to 'connect'.\n\t\tmemmove(sa.sun_path + 1, sa.sun_path, sun_pathlen + 1);\n\t\tsa.sun_path[0] = '\\0';\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + 1 + sun_pathlen) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// This display number is unclaimed.  Of course, it could\n\t\t// be claimed before we get around to doing it...\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tclose(sockfd);\n\n\tif (!found) {\n\t\tfputs(\"Error: cannot find an unallocated X11 display number, \"\n\t\t\t\"exiting...\\n\", stderr);\n\t\texit(1);\n\t}\n\treturn display;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Arch: sudo pacman -S xorg-server-xvfb\\n\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Debian/Ubuntu/Mint: sudo apt-get install xvfb\\n\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nError: Xvfb program was not found in /usr/bin directory, please install it:\\n\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "program_in_path",
          "args": [
            "\"Xvfb\""
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "program_in_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/paths.c",
          "lines": "100-151",
          "snippet": "int program_in_path(const char *program) {\n\tassert(program && *program);\n\tassert(strchr(program, '/') == 0);\n\tassert(strcmp(program, \".\") != 0);\n\tassert(strcmp(program, \"..\") != 0);\n\n\tif (!paths)\n\t\tinit_paths();\n\tassert(paths);\n\n\tsize_t proglen = strlen(program);\n\tchar *scratch = malloc(longest_path_elt + proglen + 2);\n\tif (!scratch)\n\t\terrExit(\"malloc\");\n\n\tint found = 0;\n\tsize_t dlen;\n\tchar **p;\n\tfor (p = paths; *p; p++) {\n\t\tchar *dir = *p;\n\t\tdlen = strlen(dir);\n\n\t\t// init_paths should ensure that this is true; as long\n\t\t// as it is true, 'scratch' has enough space for \"$p/$program\".\n\t\tassert(dlen <= longest_path_elt);\n\n\t\tmemcpy(scratch, dir, dlen);\n\t\tscratch[dlen++] = '/';\n\n\t\t// copy proglen+1 bytes to copy the nul terminator at\n\t\t// the end of 'program'.\n\t\tmemcpy(scratch + dlen, program, proglen+1);\n\n\t\tif (access(scratch, X_OK) == 0) {\n\t\t\t// must also verify that this is a regular file\n\t\t\t// ('x' permission means something different for directories).\n\t\t\t// exec follows symlinks, so use stat, not lstat.\n\t\t\tstruct stat st;\n\t\t\tif (stat(scratch, &st)) {\n\t\t\t\tperror(scratch);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (S_ISREG(st.st_mode)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(scratch);\n\treturn found;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char **paths = 0;",
            "static unsigned int longest_path_elt = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic char **paths = 0;\nstatic unsigned int longest_path_elt = 0;\n\nint program_in_path(const char *program) {\n\tassert(program && *program);\n\tassert(strchr(program, '/') == 0);\n\tassert(strcmp(program, \".\") != 0);\n\tassert(strcmp(program, \"..\") != 0);\n\n\tif (!paths)\n\t\tinit_paths();\n\tassert(paths);\n\n\tsize_t proglen = strlen(program);\n\tchar *scratch = malloc(longest_path_elt + proglen + 2);\n\tif (!scratch)\n\t\terrExit(\"malloc\");\n\n\tint found = 0;\n\tsize_t dlen;\n\tchar **p;\n\tfor (p = paths; *p; p++) {\n\t\tchar *dir = *p;\n\t\tdlen = strlen(dir);\n\n\t\t// init_paths should ensure that this is true; as long\n\t\t// as it is true, 'scratch' has enough space for \"$p/$program\".\n\t\tassert(dlen <= longest_path_elt);\n\n\t\tmemcpy(scratch, dir, dlen);\n\t\tscratch[dlen++] = '/';\n\n\t\t// copy proglen+1 bytes to copy the nul terminator at\n\t\t// the end of 'program'.\n\t\tmemcpy(scratch + dlen, program, proglen+1);\n\n\t\tif (access(scratch, X_OK) == 0) {\n\t\t\t// must also verify that this is a regular file\n\t\t\t// ('x' permission means something different for directories).\n\t\t\t// exec follows symlinks, so use stat, not lstat.\n\t\t\tstruct stat st;\n\t\t\tif (stat(scratch, &st)) {\n\t\t\t\tperror(scratch);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (S_ISREG(st.st_mode)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(scratch);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "0"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "121-142",
          "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: X11 sandboxing is not available when running as root\\n\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"FIREJAIL_X11\"",
            "\"yes\"",
            "1"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xvfb(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// mever try to run X servers as root!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xvfb\n\tif (!program_in_path(\"Xvfb\")) {\n\t\tfprintf(stderr, \"\\nError: Xvfb program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xvfb\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xvfb\\n\");\n\t\texit(0);\n\t}\n\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xvfb_screen);\n\n\tchar *server_argv[256] = {\t\t  // rest initialized to NULL\n\t\t\"Xvfb\", display_str, \"-screen\", \"0\", xvfb_screen\n\t};\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tassert(xvfb_extra_params);\t\t  // should be \"\" if empty\n\n\t// parse xvfb_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xvfb_extra_params);\n\tif (*xvfb_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xvfb_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (dquote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\t\t\t  // replace closing quote by \\0\n\t\t\t\tif (squote) temp[i] = '\\0';\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xvfb_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xvfb_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tserver_argv[pos++] = temp;\n\t\tfor (i = 0; i < (int) strlen(xvfb_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xvfb_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) server_argv[pos++] = temp + i + 2;\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') server_argv[pos++] = temp + i + 1;\n\t\t}\n\t}\n\n\tserver_argv[pos++] = NULL;\n\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv))); // no overrun\n\tassert(server_argv[pos-1] == NULL);\t  // last element is null\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Starting xvfb server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strncmp(argv[i], \"--x11\", 5) == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2);\t\t\t  // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"\\n*** Stating xvfb client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tprintf(\" ***\\n\\n\");\n\t}\n\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xvfb...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xvfb server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xvfb\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\n\tassert(display_str);\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tfmessage(\"\\n*** Attaching to Xvfb display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t}\n\telse if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL);\t\t\t\t  // fulneral\n\n\texit(0);\n}"
  },
  {
    "function_name": "random_display_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "122-196",
    "snippet": "static int random_display_number(void) {\n\tint display;\n\tint found = 0;\n\tint i;\n\n\tstruct sockaddr_un sa;\n\t// The -1 here is because we need space to inject a\n\t// leading nul byte.\n\tint sun_pathmax = (int)(sizeof sa.sun_path - 1);\n\tassert((size_t)sun_pathmax == sizeof sa.sun_path - 1);\n\tint sun_pathlen;\n\n\tint sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sockfd == -1)\n\t\terrExit(\"socket\");\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % (X11_DISPLAY_END - X11_DISPLAY_START) + X11_DISPLAY_START;\n\n\t\t// The display number might be claimed by a server listening\n\t\t// in _either_ the normal or the abstract namespace; they\n\t\t// don't necessarily do both.  The easiest way to check is\n\t\t// to try to connect, both ways.\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sun_family = AF_UNIX;\n\t\tsun_pathlen = snprintf(sa.sun_path, sun_pathmax,\n\t\t\t\"/tmp/.X11-unix/X%d\", display);\n\t\tif (sun_pathlen >= sun_pathmax) {\n\t\t\tfprintf(stderr, \"sun_path too small for display :%d\"\n\t\t\t\t\" (only %d bytes usable)\\n\", display, sun_pathmax);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + sun_pathlen + 1) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// Name not claimed in the normal namespace; now try it\n\t\t// in the abstract namespace.  Note that abstract-namespace\n\t\t// names are NOT nul-terminated; they extend to the length\n\t\t// specified as the third argument to 'connect'.\n\t\tmemmove(sa.sun_path + 1, sa.sun_path, sun_pathlen + 1);\n\t\tsa.sun_path[0] = '\\0';\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + 1 + sun_pathlen) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// This display number is unclaimed.  Of course, it could\n\t\t// be claimed before we get around to doing it...\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tclose(sockfd);\n\n\tif (!found) {\n\t\tfputs(\"Error: cannot find an unallocated X11 display number, \"\n\t\t\t\"exiting...\\n\", stderr);\n\t\texit(1);\n\t}\n\treturn display;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"Error: cannot find an unallocated X11 display number, \"\n\t\t\t\"exiting...\\n\"",
            "stderr"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sockfd"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"connect\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "505-543",
          "snippet": "int socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_socket_t orig_socket = NULL;",
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_socket_t orig_socket = NULL;\nstatic char buf[1024];\n\nint socket(int domain, int type, int protocol) {\n\tif (!orig_socket)\n\t\torig_socket = (orig_socket_t)dlsym(RTLD_NEXT, \"socket\");\n\n\tint rv = orig_socket(domain, type, protocol);\n\tchar *ptr = buf;\n\tptr += sprintf(ptr, \"%u:%s:socket \", pid(), name());\n\tchar *str = translate(socket_domain, domain);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", domain);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tint t = type;\t// glibc uses higher bits for various other purposes\n#ifdef SOCK_CLOEXEC\n\tt &= ~SOCK_CLOEXEC;\n#endif\n#ifdef SOCK_NONBLOCK\n\tt &= ~SOCK_NONBLOCK;\n#endif\n\tstr = translate(socket_type, t);\n\tif (str == NULL)\n\t\tptr += sprintf(ptr, \"%d \", type);\n\telse\n\t\tptr += sprintf(ptr, \"%s \", str);\n\n\tif (domain == AF_LOCAL)\n\t\tsprintf(ptr, \"0\");\n\telse {\n\t\tstr = translate(socket_protocol, protocol);\n\t\tif (str == NULL)\n\t\t\tsprintf(ptr, \"%d\", protocol);\n\t\telse\n\t\t\tsprintf(ptr, \"%s\", str);\n\t}\n\n\tprintf(\"%s:%d\\n\", buf, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sockfd",
            "(struct sockaddr *)&sa",
            "offsetof(struct sockaddr_un, sun_path) + 1 + sun_pathlen"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "491-499",
          "snippet": "int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {\n\tif (!orig_connect)\n\t\torig_connect = (orig_connect_t)dlsym(RTLD_NEXT, \"connect\");\n\n \tint rv = orig_connect(sockfd, addr, addrlen);\n\tprint_sockaddr(sockfd, \"connect\", addr, rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_connect_t orig_connect = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_connect_t orig_connect = NULL;\n\nint connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {\n\tif (!orig_connect)\n\t\torig_connect = (orig_connect_t)dlsym(RTLD_NEXT, \"connect\");\n\n \tint rv = orig_connect(sockfd, addr, addrlen);\n\tprint_sockaddr(sockfd, \"connect\", addr, rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "sa.sun_path + 1",
            "sa.sun_path",
            "sun_pathlen + 1"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"connect\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sun_path too small for display :%d\"\n\t\t\t\t\" (only %d bytes usable)\\n\"",
            "display",
            "sun_pathmax"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sa.sun_path",
            "sun_pathmax",
            "\"/tmp/.X11-unix/X%d\"",
            "display"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sa",
            "0",
            "sizeof sa"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "random_display_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "122-196",
          "snippet": "static int random_display_number(void) {\n\tint display;\n\tint found = 0;\n\tint i;\n\n\tstruct sockaddr_un sa;\n\t// The -1 here is because we need space to inject a\n\t// leading nul byte.\n\tint sun_pathmax = (int)(sizeof sa.sun_path - 1);\n\tassert((size_t)sun_pathmax == sizeof sa.sun_path - 1);\n\tint sun_pathlen;\n\n\tint sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sockfd == -1)\n\t\terrExit(\"socket\");\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % (X11_DISPLAY_END - X11_DISPLAY_START) + X11_DISPLAY_START;\n\n\t\t// The display number might be claimed by a server listening\n\t\t// in _either_ the normal or the abstract namespace; they\n\t\t// don't necessarily do both.  The easiest way to check is\n\t\t// to try to connect, both ways.\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sun_family = AF_UNIX;\n\t\tsun_pathlen = snprintf(sa.sun_path, sun_pathmax,\n\t\t\t\"/tmp/.X11-unix/X%d\", display);\n\t\tif (sun_pathlen >= sun_pathmax) {\n\t\t\tfprintf(stderr, \"sun_path too small for display :%d\"\n\t\t\t\t\" (only %d bytes usable)\\n\", display, sun_pathmax);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + sun_pathlen + 1) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// Name not claimed in the normal namespace; now try it\n\t\t// in the abstract namespace.  Note that abstract-namespace\n\t\t// names are NOT nul-terminated; they extend to the length\n\t\t// specified as the third argument to 'connect'.\n\t\tmemmove(sa.sun_path + 1, sa.sun_path, sun_pathlen + 1);\n\t\tsa.sun_path[0] = '\\0';\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + 1 + sun_pathlen) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// This display number is unclaimed.  Of course, it could\n\t\t// be claimed before we get around to doing it...\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tclose(sockfd);\n\n\tif (!found) {\n\t\tfputs(\"Error: cannot find an unallocated X11 display number, \"\n\t\t\t\"exiting...\\n\", stderr);\n\t\texit(1);\n\t}\n\treturn display;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(size_t)sun_pathmax == sizeof sa.sun_path - 1"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int random_display_number(void) {\n\tint display;\n\tint found = 0;\n\tint i;\n\n\tstruct sockaddr_un sa;\n\t// The -1 here is because we need space to inject a\n\t// leading nul byte.\n\tint sun_pathmax = (int)(sizeof sa.sun_path - 1);\n\tassert((size_t)sun_pathmax == sizeof sa.sun_path - 1);\n\tint sun_pathlen;\n\n\tint sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sockfd == -1)\n\t\terrExit(\"socket\");\n\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % (X11_DISPLAY_END - X11_DISPLAY_START) + X11_DISPLAY_START;\n\n\t\t// The display number might be claimed by a server listening\n\t\t// in _either_ the normal or the abstract namespace; they\n\t\t// don't necessarily do both.  The easiest way to check is\n\t\t// to try to connect, both ways.\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sun_family = AF_UNIX;\n\t\tsun_pathlen = snprintf(sa.sun_path, sun_pathmax,\n\t\t\t\"/tmp/.X11-unix/X%d\", display);\n\t\tif (sun_pathlen >= sun_pathmax) {\n\t\t\tfprintf(stderr, \"sun_path too small for display :%d\"\n\t\t\t\t\" (only %d bytes usable)\\n\", display, sun_pathmax);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + sun_pathlen + 1) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// Name not claimed in the normal namespace; now try it\n\t\t// in the abstract namespace.  Note that abstract-namespace\n\t\t// names are NOT nul-terminated; they extend to the length\n\t\t// specified as the third argument to 'connect'.\n\t\tmemmove(sa.sun_path + 1, sa.sun_path, sun_pathlen + 1);\n\t\tsa.sun_path[0] = '\\0';\n\t\tif (connect(sockfd, (struct sockaddr *)&sa,\n\t\toffsetof(struct sockaddr_un, sun_path) + 1 + sun_pathlen) == 0) {\n\t\t\tclose(sockfd);\n\t\t\tsockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\t\tif (sockfd == -1)\n\t\t\t\terrExit(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\terrExit(\"connect\");\n\n\t\t// This display number is unclaimed.  Of course, it could\n\t\t// be claimed before we get around to doing it...\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tclose(sockfd);\n\n\tif (!found) {\n\t\tfputs(\"Error: cannot find an unallocated X11 display number, \"\n\t\t\t\"exiting...\\n\", stderr);\n\t\texit(1);\n\t}\n\treturn display;\n}"
  },
  {
    "function_name": "x11_abstract_sockets_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "80-116",
    "snippet": "static int x11_abstract_sockets_present(void) {\n\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(\"/proc/net/unix\", \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tEUID_USER();\n\n\tchar *linebuf = 0;\n\tsize_t bufsz = 0;\n\tint found = 0;\n\terrno = 0;\n\n\tfor (;;) {\n\t\tif (getline(&linebuf, &bufsz, fp) == -1) {\n\t\t\tif (errno)\n\t\t\t\terrExit(\"getline\");\n\t\t\tbreak;\n\t\t}\n\t\t// The last space-separated field in 'linebuf' is the\n\t\t// pathname of the socket.  Abstract sockets' pathnames\n\t\t// all begin with '@/', normal ones begin with '/'.\n\t\tchar *p = strrchr(linebuf, ' ');\n\t\tif (!p) {\n\t\t\tfputs(\"error parsing /proc/net/unix\\n\", stderr);\n\t\t\texit(1);\n\t\t}\n\t\tif (strncmp(p+1, \"@/tmp/.X11-unix/\", 16) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(linebuf);\n\tfclose(fp);\n\treturn found;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "linebuf"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p+1",
            "\"@/tmp/.X11-unix/\"",
            "16"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"error parsing /proc/net/unix\\n\"",
            "stderr"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "linebuf",
            "' '"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"getline\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&linebuf",
            "&bufsz",
            "fp"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fopen\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/net/unix\"",
            "\"r\""
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int x11_abstract_sockets_present(void) {\n\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(\"/proc/net/unix\", \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tEUID_USER();\n\n\tchar *linebuf = 0;\n\tsize_t bufsz = 0;\n\tint found = 0;\n\terrno = 0;\n\n\tfor (;;) {\n\t\tif (getline(&linebuf, &bufsz, fp) == -1) {\n\t\t\tif (errno)\n\t\t\t\terrExit(\"getline\");\n\t\t\tbreak;\n\t\t}\n\t\t// The last space-separated field in 'linebuf' is the\n\t\t// pathname of the socket.  Abstract sockets' pathnames\n\t\t// all begin with '@/', normal ones begin with '/'.\n\t\tchar *p = strrchr(linebuf, ' ');\n\t\tif (!p) {\n\t\t\tfputs(\"error parsing /proc/net/unix\\n\", stderr);\n\t\t\texit(1);\n\t\t}\n\t\tif (strncmp(p+1, \"@/tmp/.X11-unix/\", 16) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(linebuf);\n\tfclose(fp);\n\treturn found;\n}"
  },
  {
    "function_name": "x11_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
    "lines": "39-75",
    "snippet": "int x11_display(void) {\n\tconst char *display_str = getenv(\"DISPLAY\");\n\tchar *endp;\n\tunsigned long display;\n\n\tif (!display_str) {\n\t\tif (arg_debug)\n\t\t\tfputs(\"DISPLAY is not set\\n\", stderr);\n\t\treturn -1;\n\t}\n\n\tif (display_str[0] != ':' || display_str[1] < '0' || display_str[1] > '9') {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"unsupported DISPLAY form '%s'\\n\", display_str);\n\t\treturn -1;\n\t}\n\n\terrno = 0;\n\tdisplay = strtoul(display_str+1, &endp, 10);\n\t// handling DISPLAY=:0 and also :0.0\n\tif (endp == display_str+1 || (*endp != '\\0' && *endp != '.')) {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"unsupported DISPLAY form '%s'\\n\", display_str);\n\t\treturn -1;\n\t}\n\tif (errno || display > (unsigned long)INT_MAX) {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"display number %s is outside the valid range\\n\",\n\t\t\t\tdisplay_str+1);\n\t\treturn -1;\n\t}\n\n\tif (arg_debug)\n\t\tfprintf(stderr, \"DISPLAY=%s parsed as %lu\\n\", display_str, display);\n\n\treturn (int)display;\n}",
    "includes": [
      "#include <fcntl.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/statvfs.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"DISPLAY=%s parsed as %lu\\n\"",
            "display_str",
            "display"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"display number %s is outside the valid range\\n\"",
            "display_str+1"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unsupported DISPLAY form '%s'\\n\"",
            "display_str"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "display_str+1",
            "&endp",
            "10"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unsupported DISPLAY form '%s'\\n\"",
            "display_str"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"DISPLAY is not set\\n\"",
            "stderr"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint x11_display(void) {\n\tconst char *display_str = getenv(\"DISPLAY\");\n\tchar *endp;\n\tunsigned long display;\n\n\tif (!display_str) {\n\t\tif (arg_debug)\n\t\t\tfputs(\"DISPLAY is not set\\n\", stderr);\n\t\treturn -1;\n\t}\n\n\tif (display_str[0] != ':' || display_str[1] < '0' || display_str[1] > '9') {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"unsupported DISPLAY form '%s'\\n\", display_str);\n\t\treturn -1;\n\t}\n\n\terrno = 0;\n\tdisplay = strtoul(display_str+1, &endp, 10);\n\t// handling DISPLAY=:0 and also :0.0\n\tif (endp == display_str+1 || (*endp != '\\0' && *endp != '.')) {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"unsupported DISPLAY form '%s'\\n\", display_str);\n\t\treturn -1;\n\t}\n\tif (errno || display > (unsigned long)INT_MAX) {\n\t\tif (arg_debug)\n\t\t\tfprintf(stderr, \"display number %s is outside the valid range\\n\",\n\t\t\t\tdisplay_str+1);\n\t\treturn -1;\n\t}\n\n\tif (arg_debug)\n\t\tfprintf(stderr, \"DISPLAY=%s parsed as %lu\\n\", display_str, display);\n\n\treturn (int)display;\n}"
  }
]