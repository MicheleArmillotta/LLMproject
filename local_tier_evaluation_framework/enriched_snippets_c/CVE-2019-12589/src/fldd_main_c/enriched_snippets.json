[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
    "lines": "283-348",
    "snippet": "int main(int argc, char **argv) {\n#if 0\n{\n//system(\"cat /proc/self/status\");\nint i;\nfor (i = 0; i < argc; i++)\n        printf(\"*%s* \", argv[i]);\nprintf(\"\\n\");\n}\n#endif\n\tif (argc < 2) {\n\t\tfprintf(stderr, \"Error fldd: invalid arguments\\n\");\n\t\tusage();\n\t\texit(1);\n\t}\n\n\n\tif (strcmp(argv[1], \"-h\") == 0 || strcmp(argv[1], \"--help\") == 0 || strcmp(argv[1], \"-?\") == 0) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\n\t// check program access\n\tif (access(argv[1], R_OK)) {\n\t\tfprintf(stderr, \"Error fldd: cannot access %s\\n\", argv[1]);\n\t\texit(1);\n\t}\n\n\tchar *quiet = getenv(\"FIREJAIL_QUIET\");\n\tif (quiet && strcmp(quiet, \"yes\") == 0)\n\t\targ_quiet = 1;\n\n\tint fd = STDOUT_FILENO;\n\t// attempt to open the file\n\tif (argc == 3) {\n\t\tfd = open(argv[2], O_CREAT | O_TRUNC | O_WRONLY, 0644);\n\t\tif (fd == -1) {\n\t\t\tfprintf(stderr, \"Error fldd: invalid arguments\\n\");\n\t\t\tusage();\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// initialize local storage\n\tlib_paths_init();\n\n\t// process files\n\tstruct stat s;\n\tif (stat(argv[1], &s) == -1)\n\t\terrExit(\"stat\");\n\tif (S_ISDIR(s.st_mode))\n\t\twalk_directory(argv[1]);\n\telse {\n\t\tif (is_lib_64(argv[1]))\n\t\t\tparse_elf(argv[1]);\n\t\telse\n\t\t\tfprintf(stderr, \"Warning fldd: %s is not a 64bit program/library\\n\", argv[1]);\n\t}\n\n\n\t// print libraries and exit\n\tstorage_print(libs, fd);\n\tif (argc == 3)\n\t\tclose(fd);\n\treturn 0;\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <fcntl.h>",
      "#include \"../include/ldd_utils.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int arg_quiet = 0;",
      "static Storage *libs = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_print",
          "args": [
            "libs",
            "fd"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "storage_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "69-74",
          "snippet": "static void storage_print(Storage *ptr, int fd) {\n\twhile (ptr) {\n\t\tdprintf(fd, \"%s\\n\", ptr->name);\n\t\tptr = ptr->next;\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic void storage_print(Storage *ptr, int fd) {\n\twhile (ptr) {\n\t\tdprintf(fd, \"%s\\n\", ptr->name);\n\t\tptr = ptr->next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning fldd: %s is not a 64bit program/library\\n\"",
            "argv[1]"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_elf",
          "args": [
            "argv[1]"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "parse_elf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "85-203",
          "snippet": "static void parse_elf(const char *exe) {\n\tint f;\n\tf = open(exe, O_RDONLY);\n\tif (f < 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: cannot open %s, skipping...\\n\", exe);\n\t\treturn;\n\t}\n\n\tstruct stat s;\n\tchar *base = NULL, *end;\n\tif (fstat(f, &s) == -1)\n\t\tgoto error_close;\n\tbase = mmap(0, s.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, f, 0);\n\tif (base == MAP_FAILED)\n\t\tgoto error_close;\n\n\tend = base + s.st_size;\n\n\tElf_Ehdr *ebuf = (Elf_Ehdr *)base;\n\tif (strncmp((const char *)ebuf->e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: %s is not an ELF executable or library\\n\", exe);\n\t\tgoto close;\n\t}\n//unsigned char elfclass = ebuf->e_ident[EI_CLASS];\n//if (elfclass == ELFCLASS32)\n//printf(\"%s 32bit\\n\", exe);\n//else if (elfclass == ELFCLASS64)\n//printf(\"%s 64bit\\n\", exe);\n\n\n\tElf_Phdr *pbuf = (Elf_Phdr *)(base + sizeof(*ebuf));\n\twhile (ebuf->e_phnum-- > 0 && ptr_ok(pbuf, base, end, \"pbuf\")) {\n\t\tswitch (pbuf->p_type) {\n\t\tcase PT_INTERP:\n\t\t\t// dynamic loader ld-linux.so\n\t\t\tif (!ptr_ok(base + pbuf->p_offset, base, end, \"base + pbuf->p_offset\"))\n\t\t\t\tgoto close;\n\n\t\t\tstorage_add(&libs, base + pbuf->p_offset);\n\t\t\tbreak;\n\t\t}\n\t\tpbuf++;\n\t}\n\n\tElf_Shdr *sbuf = (Elf_Shdr *)(base + ebuf->e_shoff);\n\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\tgoto close;\n\n\t// Find strings section\n\tchar *strbase = NULL;\n\tint sections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n\t\tif (sbuf->sh_type == SHT_STRTAB) {\n\t\t\tstrbase = base + sbuf->sh_offset;\n\t\t\tif (!ptr_ok(strbase, base, end, \"strbase\"))\n\t\t\t\tgoto close;\n\t\t\tbreak;\n\t\t}\n\t\tsbuf++;\n\t}\n\tif (strbase == NULL)\n\t\tgoto error_close;\n\n\t// Find dynamic section\n\tsections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n// TODO: running fldd on large gui programs (fldd /usr/bin/transmission-qt)\n// crash on accessing memory location sbuf->sh_type if sbuf->sh_type in the previous section was 0 (SHT_NULL)\n// for now we just exit the while loop - this is probably incorrect\n// printf(\"sbuf %p #%s#, sections %d, type %u\\n\", sbuf, exe, sections, sbuf->sh_type);\n\t\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\t\tgoto close;\n\n\t\tif (sbuf->sh_type == SHT_NULL)\n\t\t\tbreak;\n\t\tif (sbuf->sh_type == SHT_DYNAMIC) {\n\t\t\tElf_Dyn *dbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tif (!ptr_ok(dbuf, base, end, \"dbuf\"))\n\t\t\t\tgoto close;\n\t\t\t// Find DT_RPATH/DT_RUNPATH tags first\n\t\t\tunsigned long size = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_RPATH || dbuf->d_tag ==  DT_RUNPATH) {\n\t\t\t\t\tconst char *searchpath = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(searchpath, base, end, \"searchpath\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tstorage_add(&lib_paths, searchpath);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t\t// Find DT_NEEDED tags\n\t\t\tdbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tsize = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_NEEDED) {\n\t\t\t\t\tconst char *lib = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(lib, base, end, \"lib\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tcopy_libs_for_lib(lib);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t}\n\t\tsbuf++;\n\t}\n\tgoto close;\n\n error_close:\n\tperror(\"copy libs\");\n close:\n\tif (base)\n\t\tmunmap(base, s.st_size);\n\n\tclose(f);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int arg_quiet = 0;",
            "static void copy_libs_for_lib(const char *lib);",
            "static Storage *libs = NULL;",
            "static Storage *lib_paths = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic int arg_quiet = 0;\nstatic void copy_libs_for_lib(const char *lib);\nstatic Storage *libs = NULL;\nstatic Storage *lib_paths = NULL;\n\nstatic void parse_elf(const char *exe) {\n\tint f;\n\tf = open(exe, O_RDONLY);\n\tif (f < 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: cannot open %s, skipping...\\n\", exe);\n\t\treturn;\n\t}\n\n\tstruct stat s;\n\tchar *base = NULL, *end;\n\tif (fstat(f, &s) == -1)\n\t\tgoto error_close;\n\tbase = mmap(0, s.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, f, 0);\n\tif (base == MAP_FAILED)\n\t\tgoto error_close;\n\n\tend = base + s.st_size;\n\n\tElf_Ehdr *ebuf = (Elf_Ehdr *)base;\n\tif (strncmp((const char *)ebuf->e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: %s is not an ELF executable or library\\n\", exe);\n\t\tgoto close;\n\t}\n//unsigned char elfclass = ebuf->e_ident[EI_CLASS];\n//if (elfclass == ELFCLASS32)\n//printf(\"%s 32bit\\n\", exe);\n//else if (elfclass == ELFCLASS64)\n//printf(\"%s 64bit\\n\", exe);\n\n\n\tElf_Phdr *pbuf = (Elf_Phdr *)(base + sizeof(*ebuf));\n\twhile (ebuf->e_phnum-- > 0 && ptr_ok(pbuf, base, end, \"pbuf\")) {\n\t\tswitch (pbuf->p_type) {\n\t\tcase PT_INTERP:\n\t\t\t// dynamic loader ld-linux.so\n\t\t\tif (!ptr_ok(base + pbuf->p_offset, base, end, \"base + pbuf->p_offset\"))\n\t\t\t\tgoto close;\n\n\t\t\tstorage_add(&libs, base + pbuf->p_offset);\n\t\t\tbreak;\n\t\t}\n\t\tpbuf++;\n\t}\n\n\tElf_Shdr *sbuf = (Elf_Shdr *)(base + ebuf->e_shoff);\n\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\tgoto close;\n\n\t// Find strings section\n\tchar *strbase = NULL;\n\tint sections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n\t\tif (sbuf->sh_type == SHT_STRTAB) {\n\t\t\tstrbase = base + sbuf->sh_offset;\n\t\t\tif (!ptr_ok(strbase, base, end, \"strbase\"))\n\t\t\t\tgoto close;\n\t\t\tbreak;\n\t\t}\n\t\tsbuf++;\n\t}\n\tif (strbase == NULL)\n\t\tgoto error_close;\n\n\t// Find dynamic section\n\tsections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n// TODO: running fldd on large gui programs (fldd /usr/bin/transmission-qt)\n// crash on accessing memory location sbuf->sh_type if sbuf->sh_type in the previous section was 0 (SHT_NULL)\n// for now we just exit the while loop - this is probably incorrect\n// printf(\"sbuf %p #%s#, sections %d, type %u\\n\", sbuf, exe, sections, sbuf->sh_type);\n\t\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\t\tgoto close;\n\n\t\tif (sbuf->sh_type == SHT_NULL)\n\t\t\tbreak;\n\t\tif (sbuf->sh_type == SHT_DYNAMIC) {\n\t\t\tElf_Dyn *dbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tif (!ptr_ok(dbuf, base, end, \"dbuf\"))\n\t\t\t\tgoto close;\n\t\t\t// Find DT_RPATH/DT_RUNPATH tags first\n\t\t\tunsigned long size = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_RPATH || dbuf->d_tag ==  DT_RUNPATH) {\n\t\t\t\t\tconst char *searchpath = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(searchpath, base, end, \"searchpath\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tstorage_add(&lib_paths, searchpath);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t\t// Find DT_NEEDED tags\n\t\t\tdbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tsize = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_NEEDED) {\n\t\t\t\t\tconst char *lib = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(lib, base, end, \"lib\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tcopy_libs_for_lib(lib);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t}\n\t\tsbuf++;\n\t}\n\tgoto close;\n\n error_close:\n\tperror(\"copy libs\");\n close:\n\tif (base)\n\t\tmunmap(base, s.st_size);\n\n\tclose(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_lib_64",
          "args": [
            "argv[1]"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "is_lib_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/ldd_utils.c",
          "lines": "41-62",
          "snippet": "int is_lib_64(const char *exe) {\n\tint retval = 0;\n\tint fd = open(exe, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tunsigned char buf[EI_NIDENT];\n\tssize_t len = 0;\n\twhile (len < EI_NIDENT) {\n\t\tssize_t sz = read(fd, buf, EI_NIDENT);\n\t\tif (sz <= 0)\n\t\t\tgoto doexit;\n\t\tlen += sz;\n\t}\n\n\tif (buf[EI_CLASS] == ELFCLASS64)\n\t\tretval = 1;\n\ndoexit:\n\tclose(fd);\n\treturn retval;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"../include/ldd_utils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"../include/ldd_utils.h\"\n\nint is_lib_64(const char *exe) {\n\tint retval = 0;\n\tint fd = open(exe, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tunsigned char buf[EI_NIDENT];\n\tssize_t len = 0;\n\twhile (len < EI_NIDENT) {\n\t\tssize_t sz = read(fd, buf, EI_NIDENT);\n\t\tif (sz <= 0)\n\t\t\tgoto doexit;\n\t\tlen += sz;\n\t}\n\n\tif (buf[EI_CLASS] == ELFCLASS64)\n\t\tretval = 1;\n\ndoexit:\n\tclose(fd);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_directory",
          "args": [
            "argv[1]"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "walk_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "235-273",
          "snippet": "static void walk_directory(const char *dirname) {\n\tassert(dirname);\n\n\tDIR *dir = opendir(dirname);\n\tif (dir) {\n\t\tstruct dirent *entry;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tif (strcmp(entry->d_name, \".\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// build full path\n\t\t\tchar *path;\n\t\t\tif (asprintf(&path, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t// check regular so library\n\t\t\tchar *ptr = strstr(entry->d_name, \".so\");\n\t\t\tif (ptr && is_lib_64(path)) {\n\t\t\t\tif (*(ptr + 3) == '\\0' || *(ptr + 3) == '.') {\n\t\t\t\t\tparse_elf(path);\n\t\t\t\t\tfree(path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check directory\n\t\t\t// entry->d_type field is supported  in glibc since version 2.19 (Feb 2014)\n\t\t\t// we'll use stat to check for directories\n\t\t\tstruct stat s;\n\t\t\tif (stat(path, &s) == -1)\n\t\t\t\terrExit(\"stat\");\n\t\t\tif (S_ISDIR(s.st_mode))\n\t\t\t\twalk_directory(path);\n\t\t}\n\t\tclosedir(dir);\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic void walk_directory(const char *dirname) {\n\tassert(dirname);\n\n\tDIR *dir = opendir(dirname);\n\tif (dir) {\n\t\tstruct dirent *entry;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tif (strcmp(entry->d_name, \".\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// build full path\n\t\t\tchar *path;\n\t\t\tif (asprintf(&path, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t// check regular so library\n\t\t\tchar *ptr = strstr(entry->d_name, \".so\");\n\t\t\tif (ptr && is_lib_64(path)) {\n\t\t\t\tif (*(ptr + 3) == '\\0' || *(ptr + 3) == '.') {\n\t\t\t\t\tparse_elf(path);\n\t\t\t\t\tfree(path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check directory\n\t\t\t// entry->d_type field is supported  in glibc since version 2.19 (Feb 2014)\n\t\t\t// we'll use stat to check for directories\n\t\t\tstruct stat s;\n\t\t\tif (stat(path, &s) == -1)\n\t\t\t\terrExit(\"stat\");\n\t\t\tif (S_ISDIR(s.st_mode))\n\t\t\t\twalk_directory(path);\n\t\t}\n\t\tclosedir(dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"stat\""
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "argv[1]",
            "&s"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lib_paths_init",
          "args": [],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "lib_paths_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "228-232",
          "snippet": "static void lib_paths_init(void) {\n\tint i;\n\tfor (i = 0; default_lib_paths[i]; i++)\n\t\tstorage_add(&lib_paths, default_lib_paths[i]);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Storage *lib_paths = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic Storage *lib_paths = NULL;\n\nstatic void lib_paths_init(void) {\n\tint i;\n\tfor (i = 0; default_lib_paths[i]; i++)\n\t\tstorage_add(&lib_paths, default_lib_paths[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "277-281",
          "snippet": "static void usage(void) {\n\tprintf(\"Usage: fldd program_or_directory [file]\\n\");\n\tprintf(\"Print a list of libraries used by program or store it in the file.\\n\");\n\tprintf(\"Print a list of libraries used by all .so files in a directory or store it in the file.\\n\");\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic void usage(void) {\n\tprintf(\"Usage: fldd program_or_directory [file]\\n\");\n\tprintf(\"Print a list of libraries used by program or store it in the file.\\n\");\n\tprintf(\"Print a list of libraries used by all .so files in a directory or store it in the file.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fldd: invalid arguments\\n\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "argv[2]",
            "O_CREAT | O_TRUNC | O_WRONLY",
            "0644"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "freopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "346-353",
          "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\tprintf(\"%u:%s:freopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "quiet",
            "\"yes\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_QUIET\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fldd: cannot access %s\\n\"",
            "argv[1]"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "argv[1]",
            "R_OK"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "478-485",
          "snippet": "int access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_access_t orig_access = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_access_t orig_access = NULL;\n\nint access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"-?\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"--help\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"-h\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fldd: invalid arguments\\n\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"*%s* \"",
            "argv[i]"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic int arg_quiet = 0;\nstatic Storage *libs = NULL;\n\nint main(int argc, char **argv) {\n#if 0\n{\n//system(\"cat /proc/self/status\");\nint i;\nfor (i = 0; i < argc; i++)\n        printf(\"*%s* \", argv[i]);\nprintf(\"\\n\");\n}\n#endif\n\tif (argc < 2) {\n\t\tfprintf(stderr, \"Error fldd: invalid arguments\\n\");\n\t\tusage();\n\t\texit(1);\n\t}\n\n\n\tif (strcmp(argv[1], \"-h\") == 0 || strcmp(argv[1], \"--help\") == 0 || strcmp(argv[1], \"-?\") == 0) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\n\t// check program access\n\tif (access(argv[1], R_OK)) {\n\t\tfprintf(stderr, \"Error fldd: cannot access %s\\n\", argv[1]);\n\t\texit(1);\n\t}\n\n\tchar *quiet = getenv(\"FIREJAIL_QUIET\");\n\tif (quiet && strcmp(quiet, \"yes\") == 0)\n\t\targ_quiet = 1;\n\n\tint fd = STDOUT_FILENO;\n\t// attempt to open the file\n\tif (argc == 3) {\n\t\tfd = open(argv[2], O_CREAT | O_TRUNC | O_WRONLY, 0644);\n\t\tif (fd == -1) {\n\t\t\tfprintf(stderr, \"Error fldd: invalid arguments\\n\");\n\t\t\tusage();\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// initialize local storage\n\tlib_paths_init();\n\n\t// process files\n\tstruct stat s;\n\tif (stat(argv[1], &s) == -1)\n\t\terrExit(\"stat\");\n\tif (S_ISDIR(s.st_mode))\n\t\twalk_directory(argv[1]);\n\telse {\n\t\tif (is_lib_64(argv[1]))\n\t\t\tparse_elf(argv[1]);\n\t\telse\n\t\t\tfprintf(stderr, \"Warning fldd: %s is not a 64bit program/library\\n\", argv[1]);\n\t}\n\n\n\t// print libraries and exit\n\tstorage_print(libs, fd);\n\tif (argc == 3)\n\t\tclose(fd);\n\treturn 0;\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
    "lines": "277-281",
    "snippet": "static void usage(void) {\n\tprintf(\"Usage: fldd program_or_directory [file]\\n\");\n\tprintf(\"Print a list of libraries used by program or store it in the file.\\n\");\n\tprintf(\"Print a list of libraries used by all .so files in a directory or store it in the file.\\n\");\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <fcntl.h>",
      "#include \"../include/ldd_utils.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Print a list of libraries used by all .so files in a directory or store it in the file.\\n\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Print a list of libraries used by program or store it in the file.\\n\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage: fldd program_or_directory [file]\\n\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic void usage(void) {\n\tprintf(\"Usage: fldd program_or_directory [file]\\n\");\n\tprintf(\"Print a list of libraries used by program or store it in the file.\\n\");\n\tprintf(\"Print a list of libraries used by all .so files in a directory or store it in the file.\\n\");\n}"
  },
  {
    "function_name": "walk_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
    "lines": "235-273",
    "snippet": "static void walk_directory(const char *dirname) {\n\tassert(dirname);\n\n\tDIR *dir = opendir(dirname);\n\tif (dir) {\n\t\tstruct dirent *entry;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tif (strcmp(entry->d_name, \".\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// build full path\n\t\t\tchar *path;\n\t\t\tif (asprintf(&path, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t// check regular so library\n\t\t\tchar *ptr = strstr(entry->d_name, \".so\");\n\t\t\tif (ptr && is_lib_64(path)) {\n\t\t\t\tif (*(ptr + 3) == '\\0' || *(ptr + 3) == '.') {\n\t\t\t\t\tparse_elf(path);\n\t\t\t\t\tfree(path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check directory\n\t\t\t// entry->d_type field is supported  in glibc since version 2.19 (Feb 2014)\n\t\t\t// we'll use stat to check for directories\n\t\t\tstruct stat s;\n\t\t\tif (stat(path, &s) == -1)\n\t\t\t\terrExit(\"stat\");\n\t\t\tif (S_ISDIR(s.st_mode))\n\t\t\t\twalk_directory(path);\n\t\t}\n\t\tclosedir(dir);\n\t}\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <fcntl.h>",
      "#include \"../include/ldd_utils.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_directory",
          "args": [
            "path"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "walk_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "235-273",
          "snippet": "static void walk_directory(const char *dirname) {\n\tassert(dirname);\n\n\tDIR *dir = opendir(dirname);\n\tif (dir) {\n\t\tstruct dirent *entry;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tif (strcmp(entry->d_name, \".\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// build full path\n\t\t\tchar *path;\n\t\t\tif (asprintf(&path, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t// check regular so library\n\t\t\tchar *ptr = strstr(entry->d_name, \".so\");\n\t\t\tif (ptr && is_lib_64(path)) {\n\t\t\t\tif (*(ptr + 3) == '\\0' || *(ptr + 3) == '.') {\n\t\t\t\t\tparse_elf(path);\n\t\t\t\t\tfree(path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check directory\n\t\t\t// entry->d_type field is supported  in glibc since version 2.19 (Feb 2014)\n\t\t\t// we'll use stat to check for directories\n\t\t\tstruct stat s;\n\t\t\tif (stat(path, &s) == -1)\n\t\t\t\terrExit(\"stat\");\n\t\t\tif (S_ISDIR(s.st_mode))\n\t\t\t\twalk_directory(path);\n\t\t}\n\t\tclosedir(dir);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"stat\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&s"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_elf",
          "args": [
            "path"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "parse_elf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "85-203",
          "snippet": "static void parse_elf(const char *exe) {\n\tint f;\n\tf = open(exe, O_RDONLY);\n\tif (f < 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: cannot open %s, skipping...\\n\", exe);\n\t\treturn;\n\t}\n\n\tstruct stat s;\n\tchar *base = NULL, *end;\n\tif (fstat(f, &s) == -1)\n\t\tgoto error_close;\n\tbase = mmap(0, s.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, f, 0);\n\tif (base == MAP_FAILED)\n\t\tgoto error_close;\n\n\tend = base + s.st_size;\n\n\tElf_Ehdr *ebuf = (Elf_Ehdr *)base;\n\tif (strncmp((const char *)ebuf->e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: %s is not an ELF executable or library\\n\", exe);\n\t\tgoto close;\n\t}\n//unsigned char elfclass = ebuf->e_ident[EI_CLASS];\n//if (elfclass == ELFCLASS32)\n//printf(\"%s 32bit\\n\", exe);\n//else if (elfclass == ELFCLASS64)\n//printf(\"%s 64bit\\n\", exe);\n\n\n\tElf_Phdr *pbuf = (Elf_Phdr *)(base + sizeof(*ebuf));\n\twhile (ebuf->e_phnum-- > 0 && ptr_ok(pbuf, base, end, \"pbuf\")) {\n\t\tswitch (pbuf->p_type) {\n\t\tcase PT_INTERP:\n\t\t\t// dynamic loader ld-linux.so\n\t\t\tif (!ptr_ok(base + pbuf->p_offset, base, end, \"base + pbuf->p_offset\"))\n\t\t\t\tgoto close;\n\n\t\t\tstorage_add(&libs, base + pbuf->p_offset);\n\t\t\tbreak;\n\t\t}\n\t\tpbuf++;\n\t}\n\n\tElf_Shdr *sbuf = (Elf_Shdr *)(base + ebuf->e_shoff);\n\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\tgoto close;\n\n\t// Find strings section\n\tchar *strbase = NULL;\n\tint sections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n\t\tif (sbuf->sh_type == SHT_STRTAB) {\n\t\t\tstrbase = base + sbuf->sh_offset;\n\t\t\tif (!ptr_ok(strbase, base, end, \"strbase\"))\n\t\t\t\tgoto close;\n\t\t\tbreak;\n\t\t}\n\t\tsbuf++;\n\t}\n\tif (strbase == NULL)\n\t\tgoto error_close;\n\n\t// Find dynamic section\n\tsections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n// TODO: running fldd on large gui programs (fldd /usr/bin/transmission-qt)\n// crash on accessing memory location sbuf->sh_type if sbuf->sh_type in the previous section was 0 (SHT_NULL)\n// for now we just exit the while loop - this is probably incorrect\n// printf(\"sbuf %p #%s#, sections %d, type %u\\n\", sbuf, exe, sections, sbuf->sh_type);\n\t\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\t\tgoto close;\n\n\t\tif (sbuf->sh_type == SHT_NULL)\n\t\t\tbreak;\n\t\tif (sbuf->sh_type == SHT_DYNAMIC) {\n\t\t\tElf_Dyn *dbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tif (!ptr_ok(dbuf, base, end, \"dbuf\"))\n\t\t\t\tgoto close;\n\t\t\t// Find DT_RPATH/DT_RUNPATH tags first\n\t\t\tunsigned long size = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_RPATH || dbuf->d_tag ==  DT_RUNPATH) {\n\t\t\t\t\tconst char *searchpath = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(searchpath, base, end, \"searchpath\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tstorage_add(&lib_paths, searchpath);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t\t// Find DT_NEEDED tags\n\t\t\tdbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tsize = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_NEEDED) {\n\t\t\t\t\tconst char *lib = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(lib, base, end, \"lib\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tcopy_libs_for_lib(lib);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t}\n\t\tsbuf++;\n\t}\n\tgoto close;\n\n error_close:\n\tperror(\"copy libs\");\n close:\n\tif (base)\n\t\tmunmap(base, s.st_size);\n\n\tclose(f);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int arg_quiet = 0;",
            "static void copy_libs_for_lib(const char *lib);",
            "static Storage *libs = NULL;",
            "static Storage *lib_paths = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic int arg_quiet = 0;\nstatic void copy_libs_for_lib(const char *lib);\nstatic Storage *libs = NULL;\nstatic Storage *lib_paths = NULL;\n\nstatic void parse_elf(const char *exe) {\n\tint f;\n\tf = open(exe, O_RDONLY);\n\tif (f < 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: cannot open %s, skipping...\\n\", exe);\n\t\treturn;\n\t}\n\n\tstruct stat s;\n\tchar *base = NULL, *end;\n\tif (fstat(f, &s) == -1)\n\t\tgoto error_close;\n\tbase = mmap(0, s.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, f, 0);\n\tif (base == MAP_FAILED)\n\t\tgoto error_close;\n\n\tend = base + s.st_size;\n\n\tElf_Ehdr *ebuf = (Elf_Ehdr *)base;\n\tif (strncmp((const char *)ebuf->e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: %s is not an ELF executable or library\\n\", exe);\n\t\tgoto close;\n\t}\n//unsigned char elfclass = ebuf->e_ident[EI_CLASS];\n//if (elfclass == ELFCLASS32)\n//printf(\"%s 32bit\\n\", exe);\n//else if (elfclass == ELFCLASS64)\n//printf(\"%s 64bit\\n\", exe);\n\n\n\tElf_Phdr *pbuf = (Elf_Phdr *)(base + sizeof(*ebuf));\n\twhile (ebuf->e_phnum-- > 0 && ptr_ok(pbuf, base, end, \"pbuf\")) {\n\t\tswitch (pbuf->p_type) {\n\t\tcase PT_INTERP:\n\t\t\t// dynamic loader ld-linux.so\n\t\t\tif (!ptr_ok(base + pbuf->p_offset, base, end, \"base + pbuf->p_offset\"))\n\t\t\t\tgoto close;\n\n\t\t\tstorage_add(&libs, base + pbuf->p_offset);\n\t\t\tbreak;\n\t\t}\n\t\tpbuf++;\n\t}\n\n\tElf_Shdr *sbuf = (Elf_Shdr *)(base + ebuf->e_shoff);\n\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\tgoto close;\n\n\t// Find strings section\n\tchar *strbase = NULL;\n\tint sections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n\t\tif (sbuf->sh_type == SHT_STRTAB) {\n\t\t\tstrbase = base + sbuf->sh_offset;\n\t\t\tif (!ptr_ok(strbase, base, end, \"strbase\"))\n\t\t\t\tgoto close;\n\t\t\tbreak;\n\t\t}\n\t\tsbuf++;\n\t}\n\tif (strbase == NULL)\n\t\tgoto error_close;\n\n\t// Find dynamic section\n\tsections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n// TODO: running fldd on large gui programs (fldd /usr/bin/transmission-qt)\n// crash on accessing memory location sbuf->sh_type if sbuf->sh_type in the previous section was 0 (SHT_NULL)\n// for now we just exit the while loop - this is probably incorrect\n// printf(\"sbuf %p #%s#, sections %d, type %u\\n\", sbuf, exe, sections, sbuf->sh_type);\n\t\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\t\tgoto close;\n\n\t\tif (sbuf->sh_type == SHT_NULL)\n\t\t\tbreak;\n\t\tif (sbuf->sh_type == SHT_DYNAMIC) {\n\t\t\tElf_Dyn *dbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tif (!ptr_ok(dbuf, base, end, \"dbuf\"))\n\t\t\t\tgoto close;\n\t\t\t// Find DT_RPATH/DT_RUNPATH tags first\n\t\t\tunsigned long size = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_RPATH || dbuf->d_tag ==  DT_RUNPATH) {\n\t\t\t\t\tconst char *searchpath = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(searchpath, base, end, \"searchpath\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tstorage_add(&lib_paths, searchpath);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t\t// Find DT_NEEDED tags\n\t\t\tdbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tsize = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_NEEDED) {\n\t\t\t\t\tconst char *lib = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(lib, base, end, \"lib\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tcopy_libs_for_lib(lib);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t}\n\t\tsbuf++;\n\t}\n\tgoto close;\n\n error_close:\n\tperror(\"copy libs\");\n close:\n\tif (base)\n\t\tmunmap(base, s.st_size);\n\n\tclose(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_lib_64",
          "args": [
            "path"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "is_lib_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/ldd_utils.c",
          "lines": "41-62",
          "snippet": "int is_lib_64(const char *exe) {\n\tint retval = 0;\n\tint fd = open(exe, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tunsigned char buf[EI_NIDENT];\n\tssize_t len = 0;\n\twhile (len < EI_NIDENT) {\n\t\tssize_t sz = read(fd, buf, EI_NIDENT);\n\t\tif (sz <= 0)\n\t\t\tgoto doexit;\n\t\tlen += sz;\n\t}\n\n\tif (buf[EI_CLASS] == ELFCLASS64)\n\t\tretval = 1;\n\ndoexit:\n\tclose(fd);\n\treturn retval;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"../include/ldd_utils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"../include/ldd_utils.h\"\n\nint is_lib_64(const char *exe) {\n\tint retval = 0;\n\tint fd = open(exe, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tunsigned char buf[EI_NIDENT];\n\tssize_t len = 0;\n\twhile (len < EI_NIDENT) {\n\t\tssize_t sz = read(fd, buf, EI_NIDENT);\n\t\tif (sz <= 0)\n\t\t\tgoto doexit;\n\t\tlen += sz;\n\t}\n\n\tif (buf[EI_CLASS] == ELFCLASS64)\n\t\tretval = 1;\n\ndoexit:\n\tclose(fd);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "entry->d_name",
            "\".so\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&path",
            "\"%s/%s\"",
            "dirname",
            "entry->d_name"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\"..\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->d_name",
            "\".\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "dirname"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "466-473",
          "snippet": "DIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_opendir_t orig_opendir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dirname"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic void walk_directory(const char *dirname) {\n\tassert(dirname);\n\n\tDIR *dir = opendir(dirname);\n\tif (dir) {\n\t\tstruct dirent *entry;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tif (strcmp(entry->d_name, \".\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(entry->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// build full path\n\t\t\tchar *path;\n\t\t\tif (asprintf(&path, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t// check regular so library\n\t\t\tchar *ptr = strstr(entry->d_name, \".so\");\n\t\t\tif (ptr && is_lib_64(path)) {\n\t\t\t\tif (*(ptr + 3) == '\\0' || *(ptr + 3) == '.') {\n\t\t\t\t\tparse_elf(path);\n\t\t\t\t\tfree(path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check directory\n\t\t\t// entry->d_type field is supported  in glibc since version 2.19 (Feb 2014)\n\t\t\t// we'll use stat to check for directories\n\t\t\tstruct stat s;\n\t\t\tif (stat(path, &s) == -1)\n\t\t\t\terrExit(\"stat\");\n\t\t\tif (S_ISDIR(s.st_mode))\n\t\t\t\twalk_directory(path);\n\t\t}\n\t\tclosedir(dir);\n\t}\n}"
  },
  {
    "function_name": "lib_paths_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
    "lines": "228-232",
    "snippet": "static void lib_paths_init(void) {\n\tint i;\n\tfor (i = 0; default_lib_paths[i]; i++)\n\t\tstorage_add(&lib_paths, default_lib_paths[i]);\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <fcntl.h>",
      "#include \"../include/ldd_utils.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Storage *lib_paths = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "storage_add",
          "args": [
            "&lib_paths",
            "default_lib_paths[i]"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "storage_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "54-66",
          "snippet": "static void storage_add(Storage **head, const char *name) {\n\tif (storage_find(*head, name))\n\t\treturn;\n\n\tStorage *s = malloc(sizeof(Storage));\n\tif (!s)\n\t\terrExit(\"malloc\");\n\ts->next = *head;\n\t*head = s;\n\ts->name = strdup(name);\n\tif (!s->name)\n\t\terrExit(\"strdup\");\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic void storage_add(Storage **head, const char *name) {\n\tif (storage_find(*head, name))\n\t\treturn;\n\n\tStorage *s = malloc(sizeof(Storage));\n\tif (!s)\n\t\terrExit(\"malloc\");\n\ts->next = *head;\n\t*head = s;\n\ts->name = strdup(name);\n\tif (!s->name)\n\t\terrExit(\"strdup\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic Storage *lib_paths = NULL;\n\nstatic void lib_paths_init(void) {\n\tint i;\n\tfor (i = 0; default_lib_paths[i]; i++)\n\t\tstorage_add(&lib_paths, default_lib_paths[i]);\n}"
  },
  {
    "function_name": "copy_libs_for_lib",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
    "lines": "205-226",
    "snippet": "static void copy_libs_for_lib(const char *lib) {\n\tStorage *lib_path;\n\tfor (lib_path = lib_paths; lib_path; lib_path = lib_path->next) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%s\", lib_path->name, lib) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (access(fname, R_OK) == 0 && is_lib_64(fname)) {\n\t\t\tif (!storage_find(libs, fname)) {\n\t\t\t\tstorage_add(&libs, fname);\n\t\t\t\t// libs may need other libs\n\t\t\t\tparse_elf(fname);\n\t\t\t}\n\t\t\tfree(fname);\n\t\t\treturn;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\t// log a  warning and continue\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fldd: cannot find %s, skipping...\\n\", lib);\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <fcntl.h>",
      "#include \"../include/ldd_utils.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int arg_quiet = 0;",
      "static void copy_libs_for_lib(const char *lib);",
      "static Storage *libs = NULL;",
      "static Storage *lib_paths = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning fldd: cannot find %s, skipping...\\n\"",
            "lib"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_elf",
          "args": [
            "fname"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "parse_elf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "85-203",
          "snippet": "static void parse_elf(const char *exe) {\n\tint f;\n\tf = open(exe, O_RDONLY);\n\tif (f < 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: cannot open %s, skipping...\\n\", exe);\n\t\treturn;\n\t}\n\n\tstruct stat s;\n\tchar *base = NULL, *end;\n\tif (fstat(f, &s) == -1)\n\t\tgoto error_close;\n\tbase = mmap(0, s.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, f, 0);\n\tif (base == MAP_FAILED)\n\t\tgoto error_close;\n\n\tend = base + s.st_size;\n\n\tElf_Ehdr *ebuf = (Elf_Ehdr *)base;\n\tif (strncmp((const char *)ebuf->e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: %s is not an ELF executable or library\\n\", exe);\n\t\tgoto close;\n\t}\n//unsigned char elfclass = ebuf->e_ident[EI_CLASS];\n//if (elfclass == ELFCLASS32)\n//printf(\"%s 32bit\\n\", exe);\n//else if (elfclass == ELFCLASS64)\n//printf(\"%s 64bit\\n\", exe);\n\n\n\tElf_Phdr *pbuf = (Elf_Phdr *)(base + sizeof(*ebuf));\n\twhile (ebuf->e_phnum-- > 0 && ptr_ok(pbuf, base, end, \"pbuf\")) {\n\t\tswitch (pbuf->p_type) {\n\t\tcase PT_INTERP:\n\t\t\t// dynamic loader ld-linux.so\n\t\t\tif (!ptr_ok(base + pbuf->p_offset, base, end, \"base + pbuf->p_offset\"))\n\t\t\t\tgoto close;\n\n\t\t\tstorage_add(&libs, base + pbuf->p_offset);\n\t\t\tbreak;\n\t\t}\n\t\tpbuf++;\n\t}\n\n\tElf_Shdr *sbuf = (Elf_Shdr *)(base + ebuf->e_shoff);\n\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\tgoto close;\n\n\t// Find strings section\n\tchar *strbase = NULL;\n\tint sections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n\t\tif (sbuf->sh_type == SHT_STRTAB) {\n\t\t\tstrbase = base + sbuf->sh_offset;\n\t\t\tif (!ptr_ok(strbase, base, end, \"strbase\"))\n\t\t\t\tgoto close;\n\t\t\tbreak;\n\t\t}\n\t\tsbuf++;\n\t}\n\tif (strbase == NULL)\n\t\tgoto error_close;\n\n\t// Find dynamic section\n\tsections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n// TODO: running fldd on large gui programs (fldd /usr/bin/transmission-qt)\n// crash on accessing memory location sbuf->sh_type if sbuf->sh_type in the previous section was 0 (SHT_NULL)\n// for now we just exit the while loop - this is probably incorrect\n// printf(\"sbuf %p #%s#, sections %d, type %u\\n\", sbuf, exe, sections, sbuf->sh_type);\n\t\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\t\tgoto close;\n\n\t\tif (sbuf->sh_type == SHT_NULL)\n\t\t\tbreak;\n\t\tif (sbuf->sh_type == SHT_DYNAMIC) {\n\t\t\tElf_Dyn *dbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tif (!ptr_ok(dbuf, base, end, \"dbuf\"))\n\t\t\t\tgoto close;\n\t\t\t// Find DT_RPATH/DT_RUNPATH tags first\n\t\t\tunsigned long size = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_RPATH || dbuf->d_tag ==  DT_RUNPATH) {\n\t\t\t\t\tconst char *searchpath = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(searchpath, base, end, \"searchpath\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tstorage_add(&lib_paths, searchpath);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t\t// Find DT_NEEDED tags\n\t\t\tdbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tsize = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_NEEDED) {\n\t\t\t\t\tconst char *lib = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(lib, base, end, \"lib\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tcopy_libs_for_lib(lib);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t}\n\t\tsbuf++;\n\t}\n\tgoto close;\n\n error_close:\n\tperror(\"copy libs\");\n close:\n\tif (base)\n\t\tmunmap(base, s.st_size);\n\n\tclose(f);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int arg_quiet = 0;",
            "static void copy_libs_for_lib(const char *lib);",
            "static Storage *libs = NULL;",
            "static Storage *lib_paths = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic int arg_quiet = 0;\nstatic void copy_libs_for_lib(const char *lib);\nstatic Storage *libs = NULL;\nstatic Storage *lib_paths = NULL;\n\nstatic void parse_elf(const char *exe) {\n\tint f;\n\tf = open(exe, O_RDONLY);\n\tif (f < 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: cannot open %s, skipping...\\n\", exe);\n\t\treturn;\n\t}\n\n\tstruct stat s;\n\tchar *base = NULL, *end;\n\tif (fstat(f, &s) == -1)\n\t\tgoto error_close;\n\tbase = mmap(0, s.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, f, 0);\n\tif (base == MAP_FAILED)\n\t\tgoto error_close;\n\n\tend = base + s.st_size;\n\n\tElf_Ehdr *ebuf = (Elf_Ehdr *)base;\n\tif (strncmp((const char *)ebuf->e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: %s is not an ELF executable or library\\n\", exe);\n\t\tgoto close;\n\t}\n//unsigned char elfclass = ebuf->e_ident[EI_CLASS];\n//if (elfclass == ELFCLASS32)\n//printf(\"%s 32bit\\n\", exe);\n//else if (elfclass == ELFCLASS64)\n//printf(\"%s 64bit\\n\", exe);\n\n\n\tElf_Phdr *pbuf = (Elf_Phdr *)(base + sizeof(*ebuf));\n\twhile (ebuf->e_phnum-- > 0 && ptr_ok(pbuf, base, end, \"pbuf\")) {\n\t\tswitch (pbuf->p_type) {\n\t\tcase PT_INTERP:\n\t\t\t// dynamic loader ld-linux.so\n\t\t\tif (!ptr_ok(base + pbuf->p_offset, base, end, \"base + pbuf->p_offset\"))\n\t\t\t\tgoto close;\n\n\t\t\tstorage_add(&libs, base + pbuf->p_offset);\n\t\t\tbreak;\n\t\t}\n\t\tpbuf++;\n\t}\n\n\tElf_Shdr *sbuf = (Elf_Shdr *)(base + ebuf->e_shoff);\n\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\tgoto close;\n\n\t// Find strings section\n\tchar *strbase = NULL;\n\tint sections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n\t\tif (sbuf->sh_type == SHT_STRTAB) {\n\t\t\tstrbase = base + sbuf->sh_offset;\n\t\t\tif (!ptr_ok(strbase, base, end, \"strbase\"))\n\t\t\t\tgoto close;\n\t\t\tbreak;\n\t\t}\n\t\tsbuf++;\n\t}\n\tif (strbase == NULL)\n\t\tgoto error_close;\n\n\t// Find dynamic section\n\tsections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n// TODO: running fldd on large gui programs (fldd /usr/bin/transmission-qt)\n// crash on accessing memory location sbuf->sh_type if sbuf->sh_type in the previous section was 0 (SHT_NULL)\n// for now we just exit the while loop - this is probably incorrect\n// printf(\"sbuf %p #%s#, sections %d, type %u\\n\", sbuf, exe, sections, sbuf->sh_type);\n\t\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\t\tgoto close;\n\n\t\tif (sbuf->sh_type == SHT_NULL)\n\t\t\tbreak;\n\t\tif (sbuf->sh_type == SHT_DYNAMIC) {\n\t\t\tElf_Dyn *dbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tif (!ptr_ok(dbuf, base, end, \"dbuf\"))\n\t\t\t\tgoto close;\n\t\t\t// Find DT_RPATH/DT_RUNPATH tags first\n\t\t\tunsigned long size = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_RPATH || dbuf->d_tag ==  DT_RUNPATH) {\n\t\t\t\t\tconst char *searchpath = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(searchpath, base, end, \"searchpath\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tstorage_add(&lib_paths, searchpath);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t\t// Find DT_NEEDED tags\n\t\t\tdbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tsize = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_NEEDED) {\n\t\t\t\t\tconst char *lib = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(lib, base, end, \"lib\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tcopy_libs_for_lib(lib);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t}\n\t\tsbuf++;\n\t}\n\tgoto close;\n\n error_close:\n\tperror(\"copy libs\");\n close:\n\tif (base)\n\t\tmunmap(base, s.st_size);\n\n\tclose(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_add",
          "args": [
            "&libs",
            "fname"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "storage_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "54-66",
          "snippet": "static void storage_add(Storage **head, const char *name) {\n\tif (storage_find(*head, name))\n\t\treturn;\n\n\tStorage *s = malloc(sizeof(Storage));\n\tif (!s)\n\t\terrExit(\"malloc\");\n\ts->next = *head;\n\t*head = s;\n\ts->name = strdup(name);\n\tif (!s->name)\n\t\terrExit(\"strdup\");\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic void storage_add(Storage **head, const char *name) {\n\tif (storage_find(*head, name))\n\t\treturn;\n\n\tStorage *s = malloc(sizeof(Storage));\n\tif (!s)\n\t\terrExit(\"malloc\");\n\ts->next = *head;\n\t*head = s;\n\ts->name = strdup(name);\n\tif (!s->name)\n\t\terrExit(\"strdup\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "libs",
            "fname"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "44-52",
          "snippet": "static int storage_find(Storage *ptr, const char *name) {\n\twhile (ptr) {\n\t\tif (strcmp(ptr->name, name) == 0)\n\t\t\treturn 1;\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic int storage_find(Storage *ptr, const char *name) {\n\twhile (ptr) {\n\t\tif (strcmp(ptr->name, name) == 0)\n\t\t\treturn 1;\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_lib_64",
          "args": [
            "fname"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "is_lib_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/ldd_utils.c",
          "lines": "41-62",
          "snippet": "int is_lib_64(const char *exe) {\n\tint retval = 0;\n\tint fd = open(exe, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tunsigned char buf[EI_NIDENT];\n\tssize_t len = 0;\n\twhile (len < EI_NIDENT) {\n\t\tssize_t sz = read(fd, buf, EI_NIDENT);\n\t\tif (sz <= 0)\n\t\t\tgoto doexit;\n\t\tlen += sz;\n\t}\n\n\tif (buf[EI_CLASS] == ELFCLASS64)\n\t\tretval = 1;\n\ndoexit:\n\tclose(fd);\n\treturn retval;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"../include/ldd_utils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"../include/ldd_utils.h\"\n\nint is_lib_64(const char *exe) {\n\tint retval = 0;\n\tint fd = open(exe, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tunsigned char buf[EI_NIDENT];\n\tssize_t len = 0;\n\twhile (len < EI_NIDENT) {\n\t\tssize_t sz = read(fd, buf, EI_NIDENT);\n\t\tif (sz <= 0)\n\t\t\tgoto doexit;\n\t\tlen += sz;\n\t}\n\n\tif (buf[EI_CLASS] == ELFCLASS64)\n\t\tretval = 1;\n\ndoexit:\n\tclose(fd);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "fname",
            "R_OK"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "478-485",
          "snippet": "int access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_access_t orig_access = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_access_t orig_access = NULL;\n\nint access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/%s\"",
            "lib_path->name",
            "lib"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic int arg_quiet = 0;\nstatic void copy_libs_for_lib(const char *lib);\nstatic Storage *libs = NULL;\nstatic Storage *lib_paths = NULL;\n\nstatic void copy_libs_for_lib(const char *lib) {\n\tStorage *lib_path;\n\tfor (lib_path = lib_paths; lib_path; lib_path = lib_path->next) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%s\", lib_path->name, lib) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (access(fname, R_OK) == 0 && is_lib_64(fname)) {\n\t\t\tif (!storage_find(libs, fname)) {\n\t\t\t\tstorage_add(&libs, fname);\n\t\t\t\t// libs may need other libs\n\t\t\t\tparse_elf(fname);\n\t\t\t}\n\t\t\tfree(fname);\n\t\t\treturn;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\t// log a  warning and continue\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fldd: cannot find %s, skipping...\\n\", lib);\n}"
  },
  {
    "function_name": "parse_elf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
    "lines": "85-203",
    "snippet": "static void parse_elf(const char *exe) {\n\tint f;\n\tf = open(exe, O_RDONLY);\n\tif (f < 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: cannot open %s, skipping...\\n\", exe);\n\t\treturn;\n\t}\n\n\tstruct stat s;\n\tchar *base = NULL, *end;\n\tif (fstat(f, &s) == -1)\n\t\tgoto error_close;\n\tbase = mmap(0, s.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, f, 0);\n\tif (base == MAP_FAILED)\n\t\tgoto error_close;\n\n\tend = base + s.st_size;\n\n\tElf_Ehdr *ebuf = (Elf_Ehdr *)base;\n\tif (strncmp((const char *)ebuf->e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: %s is not an ELF executable or library\\n\", exe);\n\t\tgoto close;\n\t}\n//unsigned char elfclass = ebuf->e_ident[EI_CLASS];\n//if (elfclass == ELFCLASS32)\n//printf(\"%s 32bit\\n\", exe);\n//else if (elfclass == ELFCLASS64)\n//printf(\"%s 64bit\\n\", exe);\n\n\n\tElf_Phdr *pbuf = (Elf_Phdr *)(base + sizeof(*ebuf));\n\twhile (ebuf->e_phnum-- > 0 && ptr_ok(pbuf, base, end, \"pbuf\")) {\n\t\tswitch (pbuf->p_type) {\n\t\tcase PT_INTERP:\n\t\t\t// dynamic loader ld-linux.so\n\t\t\tif (!ptr_ok(base + pbuf->p_offset, base, end, \"base + pbuf->p_offset\"))\n\t\t\t\tgoto close;\n\n\t\t\tstorage_add(&libs, base + pbuf->p_offset);\n\t\t\tbreak;\n\t\t}\n\t\tpbuf++;\n\t}\n\n\tElf_Shdr *sbuf = (Elf_Shdr *)(base + ebuf->e_shoff);\n\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\tgoto close;\n\n\t// Find strings section\n\tchar *strbase = NULL;\n\tint sections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n\t\tif (sbuf->sh_type == SHT_STRTAB) {\n\t\t\tstrbase = base + sbuf->sh_offset;\n\t\t\tif (!ptr_ok(strbase, base, end, \"strbase\"))\n\t\t\t\tgoto close;\n\t\t\tbreak;\n\t\t}\n\t\tsbuf++;\n\t}\n\tif (strbase == NULL)\n\t\tgoto error_close;\n\n\t// Find dynamic section\n\tsections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n// TODO: running fldd on large gui programs (fldd /usr/bin/transmission-qt)\n// crash on accessing memory location sbuf->sh_type if sbuf->sh_type in the previous section was 0 (SHT_NULL)\n// for now we just exit the while loop - this is probably incorrect\n// printf(\"sbuf %p #%s#, sections %d, type %u\\n\", sbuf, exe, sections, sbuf->sh_type);\n\t\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\t\tgoto close;\n\n\t\tif (sbuf->sh_type == SHT_NULL)\n\t\t\tbreak;\n\t\tif (sbuf->sh_type == SHT_DYNAMIC) {\n\t\t\tElf_Dyn *dbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tif (!ptr_ok(dbuf, base, end, \"dbuf\"))\n\t\t\t\tgoto close;\n\t\t\t// Find DT_RPATH/DT_RUNPATH tags first\n\t\t\tunsigned long size = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_RPATH || dbuf->d_tag ==  DT_RUNPATH) {\n\t\t\t\t\tconst char *searchpath = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(searchpath, base, end, \"searchpath\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tstorage_add(&lib_paths, searchpath);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t\t// Find DT_NEEDED tags\n\t\t\tdbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tsize = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_NEEDED) {\n\t\t\t\t\tconst char *lib = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(lib, base, end, \"lib\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tcopy_libs_for_lib(lib);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t}\n\t\tsbuf++;\n\t}\n\tgoto close;\n\n error_close:\n\tperror(\"copy libs\");\n close:\n\tif (base)\n\t\tmunmap(base, s.st_size);\n\n\tclose(f);\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <fcntl.h>",
      "#include \"../include/ldd_utils.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int arg_quiet = 0;",
      "static void copy_libs_for_lib(const char *lib);",
      "static Storage *libs = NULL;",
      "static Storage *lib_paths = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "f"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "base",
            "s.st_size"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"copy libs\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_libs_for_lib",
          "args": [
            "lib"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "copy_libs_for_lib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "205-226",
          "snippet": "static void copy_libs_for_lib(const char *lib) {\n\tStorage *lib_path;\n\tfor (lib_path = lib_paths; lib_path; lib_path = lib_path->next) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%s\", lib_path->name, lib) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (access(fname, R_OK) == 0 && is_lib_64(fname)) {\n\t\t\tif (!storage_find(libs, fname)) {\n\t\t\t\tstorage_add(&libs, fname);\n\t\t\t\t// libs may need other libs\n\t\t\t\tparse_elf(fname);\n\t\t\t}\n\t\t\tfree(fname);\n\t\t\treturn;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\t// log a  warning and continue\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fldd: cannot find %s, skipping...\\n\", lib);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int arg_quiet = 0;",
            "static void copy_libs_for_lib(const char *lib);",
            "static Storage *libs = NULL;",
            "static Storage *lib_paths = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic int arg_quiet = 0;\nstatic void copy_libs_for_lib(const char *lib);\nstatic Storage *libs = NULL;\nstatic Storage *lib_paths = NULL;\n\nstatic void copy_libs_for_lib(const char *lib) {\n\tStorage *lib_path;\n\tfor (lib_path = lib_paths; lib_path; lib_path = lib_path->next) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%s\", lib_path->name, lib) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (access(fname, R_OK) == 0 && is_lib_64(fname)) {\n\t\t\tif (!storage_find(libs, fname)) {\n\t\t\t\tstorage_add(&libs, fname);\n\t\t\t\t// libs may need other libs\n\t\t\t\tparse_elf(fname);\n\t\t\t}\n\t\t\tfree(fname);\n\t\t\treturn;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\t// log a  warning and continue\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fldd: cannot find %s, skipping...\\n\", lib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_ok",
          "args": [
            "lib",
            "base",
            "end",
            "\"lib\""
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "ptr_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "76-82",
          "snippet": "static bool ptr_ok(const void *ptr, const void *base, const void *end, const char *name) {\n\tbool r;\n\t(void) name;\n\n\tr = (ptr >= base && ptr < end);\n\treturn r;\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic bool ptr_ok(const void *ptr, const void *base, const void *end, const char *name) {\n\tbool r;\n\t(void) name;\n\n\tr = (ptr >= base && ptr < end);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_add",
          "args": [
            "&lib_paths",
            "searchpath"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "storage_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "54-66",
          "snippet": "static void storage_add(Storage **head, const char *name) {\n\tif (storage_find(*head, name))\n\t\treturn;\n\n\tStorage *s = malloc(sizeof(Storage));\n\tif (!s)\n\t\terrExit(\"malloc\");\n\ts->next = *head;\n\t*head = s;\n\ts->name = strdup(name);\n\tif (!s->name)\n\t\terrExit(\"strdup\");\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic void storage_add(Storage **head, const char *name) {\n\tif (storage_find(*head, name))\n\t\treturn;\n\n\tStorage *s = malloc(sizeof(Storage));\n\tif (!s)\n\t\terrExit(\"malloc\");\n\ts->next = *head;\n\t*head = s;\n\ts->name = strdup(name);\n\tif (!s->name)\n\t\terrExit(\"strdup\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning fldd: %s is not an ELF executable or library\\n\"",
            "exe"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "(const char *)ebuf->e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "0",
            "s.st_size",
            "PROT_READ | PROT_WRITE",
            "MAP_PRIVATE",
            "f",
            "0"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "f",
            "&s"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning fldd: cannot open %s, skipping...\\n\"",
            "exe"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "exe",
            "O_RDONLY"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic int arg_quiet = 0;\nstatic void copy_libs_for_lib(const char *lib);\nstatic Storage *libs = NULL;\nstatic Storage *lib_paths = NULL;\n\nstatic void parse_elf(const char *exe) {\n\tint f;\n\tf = open(exe, O_RDONLY);\n\tif (f < 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: cannot open %s, skipping...\\n\", exe);\n\t\treturn;\n\t}\n\n\tstruct stat s;\n\tchar *base = NULL, *end;\n\tif (fstat(f, &s) == -1)\n\t\tgoto error_close;\n\tbase = mmap(0, s.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, f, 0);\n\tif (base == MAP_FAILED)\n\t\tgoto error_close;\n\n\tend = base + s.st_size;\n\n\tElf_Ehdr *ebuf = (Elf_Ehdr *)base;\n\tif (strncmp((const char *)ebuf->e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fldd: %s is not an ELF executable or library\\n\", exe);\n\t\tgoto close;\n\t}\n//unsigned char elfclass = ebuf->e_ident[EI_CLASS];\n//if (elfclass == ELFCLASS32)\n//printf(\"%s 32bit\\n\", exe);\n//else if (elfclass == ELFCLASS64)\n//printf(\"%s 64bit\\n\", exe);\n\n\n\tElf_Phdr *pbuf = (Elf_Phdr *)(base + sizeof(*ebuf));\n\twhile (ebuf->e_phnum-- > 0 && ptr_ok(pbuf, base, end, \"pbuf\")) {\n\t\tswitch (pbuf->p_type) {\n\t\tcase PT_INTERP:\n\t\t\t// dynamic loader ld-linux.so\n\t\t\tif (!ptr_ok(base + pbuf->p_offset, base, end, \"base + pbuf->p_offset\"))\n\t\t\t\tgoto close;\n\n\t\t\tstorage_add(&libs, base + pbuf->p_offset);\n\t\t\tbreak;\n\t\t}\n\t\tpbuf++;\n\t}\n\n\tElf_Shdr *sbuf = (Elf_Shdr *)(base + ebuf->e_shoff);\n\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\tgoto close;\n\n\t// Find strings section\n\tchar *strbase = NULL;\n\tint sections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n\t\tif (sbuf->sh_type == SHT_STRTAB) {\n\t\t\tstrbase = base + sbuf->sh_offset;\n\t\t\tif (!ptr_ok(strbase, base, end, \"strbase\"))\n\t\t\t\tgoto close;\n\t\t\tbreak;\n\t\t}\n\t\tsbuf++;\n\t}\n\tif (strbase == NULL)\n\t\tgoto error_close;\n\n\t// Find dynamic section\n\tsections = ebuf->e_shnum;\n\twhile (sections-- > 0 && ptr_ok(sbuf, base, end, \"sbuf\")) {\n// TODO: running fldd on large gui programs (fldd /usr/bin/transmission-qt)\n// crash on accessing memory location sbuf->sh_type if sbuf->sh_type in the previous section was 0 (SHT_NULL)\n// for now we just exit the while loop - this is probably incorrect\n// printf(\"sbuf %p #%s#, sections %d, type %u\\n\", sbuf, exe, sections, sbuf->sh_type);\n\t\tif (!ptr_ok(sbuf, base, end, \"sbuf\"))\n\t\t\tgoto close;\n\n\t\tif (sbuf->sh_type == SHT_NULL)\n\t\t\tbreak;\n\t\tif (sbuf->sh_type == SHT_DYNAMIC) {\n\t\t\tElf_Dyn *dbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tif (!ptr_ok(dbuf, base, end, \"dbuf\"))\n\t\t\t\tgoto close;\n\t\t\t// Find DT_RPATH/DT_RUNPATH tags first\n\t\t\tunsigned long size = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_RPATH || dbuf->d_tag ==  DT_RUNPATH) {\n\t\t\t\t\tconst char *searchpath = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(searchpath, base, end, \"searchpath\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tstorage_add(&lib_paths, searchpath);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t\t// Find DT_NEEDED tags\n\t\t\tdbuf = (Elf_Dyn *)(base + sbuf->sh_offset);\n\t\t\tsize = sbuf->sh_size;\n\t\t\twhile (size >= sizeof(*dbuf) && ptr_ok(dbuf, base, end, \"dbuf\")) {\n\t\t\t\tif (dbuf->d_tag == DT_NEEDED) {\n\t\t\t\t\tconst char *lib = strbase + dbuf->d_un.d_ptr;\n\t\t\t\t\tif (!ptr_ok(lib, base, end, \"lib\"))\n\t\t\t\t\t\tgoto close;\n\t\t\t\t\tcopy_libs_for_lib(lib);\n\t\t\t\t}\n\t\t\t\tsize -= sizeof(*dbuf);\n\t\t\t\tdbuf++;\n\t\t\t}\n\t\t}\n\t\tsbuf++;\n\t}\n\tgoto close;\n\n error_close:\n\tperror(\"copy libs\");\n close:\n\tif (base)\n\t\tmunmap(base, s.st_size);\n\n\tclose(f);\n}"
  },
  {
    "function_name": "ptr_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
    "lines": "76-82",
    "snippet": "static bool ptr_ok(const void *ptr, const void *base, const void *end, const char *name) {\n\tbool r;\n\t(void) name;\n\n\tr = (ptr >= base && ptr < end);\n\treturn r;\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <fcntl.h>",
      "#include \"../include/ldd_utils.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic bool ptr_ok(const void *ptr, const void *base, const void *end, const char *name) {\n\tbool r;\n\t(void) name;\n\n\tr = (ptr >= base && ptr < end);\n\treturn r;\n}"
  },
  {
    "function_name": "storage_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
    "lines": "69-74",
    "snippet": "static void storage_print(Storage *ptr, int fd) {\n\twhile (ptr) {\n\t\tdprintf(fd, \"%s\\n\", ptr->name);\n\t\tptr = ptr->next;\n\t}\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <fcntl.h>",
      "#include \"../include/ldd_utils.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "fd",
            "\"%s\\n\"",
            "ptr->name"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic void storage_print(Storage *ptr, int fd) {\n\twhile (ptr) {\n\t\tdprintf(fd, \"%s\\n\", ptr->name);\n\t\tptr = ptr->next;\n\t}\n}"
  },
  {
    "function_name": "storage_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
    "lines": "54-66",
    "snippet": "static void storage_add(Storage **head, const char *name) {\n\tif (storage_find(*head, name))\n\t\treturn;\n\n\tStorage *s = malloc(sizeof(Storage));\n\tif (!s)\n\t\terrExit(\"malloc\");\n\ts->next = *head;\n\t*head = s;\n\ts->name = strdup(name);\n\tif (!s->name)\n\t\terrExit(\"strdup\");\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <fcntl.h>",
      "#include \"../include/ldd_utils.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(Storage)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "*head",
            "name"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
          "lines": "44-52",
          "snippet": "static int storage_find(Storage *ptr, const char *name) {\n\twhile (ptr) {\n\t\tif (strcmp(ptr->name, name) == 0)\n\t\t\treturn 1;\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <fcntl.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic int storage_find(Storage *ptr, const char *name) {\n\twhile (ptr) {\n\t\tif (strcmp(ptr->name, name) == 0)\n\t\t\treturn 1;\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic void storage_add(Storage **head, const char *name) {\n\tif (storage_find(*head, name))\n\t\treturn;\n\n\tStorage *s = malloc(sizeof(Storage));\n\tif (!s)\n\t\terrExit(\"malloc\");\n\ts->next = *head;\n\t*head = s;\n\ts->name = strdup(name);\n\tif (!s->name)\n\t\terrExit(\"strdup\");\n}"
  },
  {
    "function_name": "storage_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fldd/main.c",
    "lines": "44-52",
    "snippet": "static int storage_find(Storage *ptr, const char *name) {\n\twhile (ptr) {\n\t\tif (strcmp(ptr->name, name) == 0)\n\t\t\treturn 1;\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <fcntl.h>",
      "#include \"../include/ldd_utils.h\"",
      "#include \"../include/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr->name",
            "name"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include \"../include/ldd_utils.h\"\n#include \"../include/common.h\"\n\nstatic int storage_find(Storage *ptr, const char *name) {\n\twhile (ptr) {\n\t\tif (strcmp(ptr->name, name) == 0)\n\t\t\treturn 1;\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}"
  }
]