[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/main.c",
    "lines": "52-150",
    "snippet": "int main(int argc, char **argv) {\n#if 0\n{\n//system(\"cat /proc/self/status\");\nint i;\nfor (i = 0; i < argc; i++)\n\tprintf(\"*%s* \", argv[i]);\nprintf(\"\\n\");\n}\n#endif\n\tif (argc < 2) {\n\t\tusage();\n\t\treturn 1;\n\t}\n\n\tchar *quiet = getenv(\"FIREJAIL_QUIET\");\n\tif (quiet && strcmp(quiet, \"yes\") == 0)\n\t\targ_quiet = 1;\n\n\tif (strcmp(argv[1], \"-h\") == 0 || strcmp(argv[1], \"--help\") == 0 || strcmp(argv[1], \"-?\") ==0) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\telse if (argc == 3 && strcmp(argv[1], \"ifup\") == 0) {\n\t\tnet_if_up(argv[2]);\n\t}\n\telse if (argc == 2 && strcmp(argv[1], \"printif\") == 0) {\n\t\tnet_ifprint(0);\n\t}\n\telse if (argc == 3 && strcmp(argv[1], \"printif\") == 0 && strcmp(argv[2], \"scan\") == 0) {\n\t\tnet_ifprint(1);\n\t}\n\telse if (argc == 7 && strcmp(argv[1], \"create\") == 0 && strcmp(argv[2], \"veth\") == 0) {\n\t\t// create veth pair and move one end in the the namespace\n\t\tnet_create_veth(argv[3], argv[4], atoi(argv[6]));\n\t\t// connect the ohter veth end to the bridge ...\n\t\tnet_bridge_add_interface(argv[5], argv[3]);\n\t\t// ... and bring it  up\n\t\tnet_if_up(argv[3]);\n\t}\n\telse if (argc == 6 && strcmp(argv[1], \"create\") == 0 && strcmp(argv[2], \"macvlan\") == 0) {\n\t\t// use ipvlan for wireless devices\n\t\t// ipvlan driver was introduced in Linux kernel 3.19\n\n\t\t// check kernel version\n\t\tstruct utsname u;\n\t\tint rv = uname(&u);\n\t\tif (rv != 0)\n\t\t\terrExit(\"uname\");\n\t\tint major;\n\t\tint minor;\n\t\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\t\tfprintf(stderr, \"Error fnet: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (major <= 3 && minor < 18)\n\t\t\tnet_create_macvlan(argv[3], argv[4], atoi(argv[5]));\n\t\telse {\n\t\t\tstruct stat s;\n\t\t\tchar *fname;\n\t\t\tif (asprintf(&fname, \"/sys/class/net/%s/wireless\", argv[4]) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (stat(fname, &s) == 0) // wireless\n\t\t\t\tnet_create_ipvlan(argv[3], argv[4], atoi(argv[5]));\n\t\t\telse // regular ethernet\n\t\t\t\tnet_create_macvlan(argv[3], argv[4], atoi(argv[5]));\n\t\t}\n\t}\n\telse if (argc == 7 && strcmp(argv[1], \"config\") == 0 && strcmp(argv[2], \"interface\") == 0) {\n\t\tchar *dev = argv[3];\n\t\tuint32_t ip = (uint32_t)  atoll(argv[4]);\n\t\tuint32_t mask = (uint32_t)  atoll(argv[5]);\n\t\tint mtu = atoi(argv[6]);\n\t\t// configure interface\n\t\tnet_if_ip(dev, ip, mask, mtu);\n\t\t// ... and bring it  up\n\t\tnet_if_up(dev);\n\t}\n\telse if (argc == 5 && strcmp(argv[1], \"config\") == 0 && strcmp(argv[2], \"mac\") == 0) {\n\t\tunsigned char mac[6];\n\t\tif (atomac(argv[4], mac)) {\n\t\t\tfprintf(stderr, \"Error fnet: invalid mac address %s\\n\", argv[4]);\n\t\t}\n\t\tnet_if_mac(argv[3], mac);\n\t}\n\telse if (argc == 4 && strcmp(argv[1], \"moveif\") == 0) {\n\t\tnet_move_interface(argv[2], atoi(argv[3]));\n\t}\n\telse if (argc == 5 && strcmp(argv[1], \"config\") == 0 && strcmp(argv[2], \"ipv6\") == 0) {\n\t\tnet_if_ip6(argv[3], argv[4]);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error fnet: invalid arguments\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int arg_quiet = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fnet: invalid arguments\\n\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_if_ip6",
          "args": [
            "argv[3]",
            "argv[4]"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_ip6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "312-372",
          "snippet": "void net_if_ip6(const char *ifname, const char *addr6) {\n\tcheck_if_name(ifname);\n\tif (strchr(addr6, ':') == NULL) {\n\t\tfprintf(stderr, \"Error fnet: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// extract prefix\n\tunsigned long prefix;\n\tchar *ptr;\n\tif ((ptr = strchr(addr6, '/'))) {\n\t\tprefix = atol(ptr + 1);\n\t\tif (prefix > 128) {\n\t\t\tfprintf(stderr, \"Error fnet: invalid prefix for IPv6 address %s\\n\", addr6);\n\t\t\texit(1);\n\t\t}\n\t\t*ptr = '\\0';\t// mark the end of the address\n\t}\n\telse\n\t\tprefix = 128;\n\n\t// extract address\n\tstruct sockaddr_in6 sin6;\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n\tint rv = inet_pton(AF_INET6, addr6, sin6.sin6_addr.s6_addr);\n\tif (rv <= 0) {\n\t\tfprintf(stderr, \"Error fnet: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// open socket\n\tint sock = socket(PF_INET6, SOCK_DGRAM, IPPROTO_IP);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error fnet: IPv6 is not supported on this system\\n\");\n\t\texit(1);\n\t}\n\n\t// find interface index\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\tif (ioctl(sock, SIOGIFINDEX, &ifr) < 0) {\n\t\tperror(\"ioctl SIOGIFINDEX\");\n\t\texit(1);\n\t}\n\n\t// configure address\n\tstruct ifreq6 ifr6;\n\tmemset(&ifr6, 0, sizeof(ifr6));\n\tifr6.ifr6_prefixlen = prefix;\n\tifr6.ifr6_ifindex = ifr.ifr_ifindex;\n\tmemcpy((char *) &ifr6.ifr6_addr, (char *) &sin6.sin6_addr, sizeof(struct in6_addr));\n\tif (ioctl(sock, SIOCSIFADDR, &ifr6) < 0) {\n\t\tperror(\"ioctl SIOCSIFADDR\");\n\t\texit(1);\n\t}\n\n\tclose(sock);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_if_ip6(const char *ifname, const char *addr6) {\n\tcheck_if_name(ifname);\n\tif (strchr(addr6, ':') == NULL) {\n\t\tfprintf(stderr, \"Error fnet: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// extract prefix\n\tunsigned long prefix;\n\tchar *ptr;\n\tif ((ptr = strchr(addr6, '/'))) {\n\t\tprefix = atol(ptr + 1);\n\t\tif (prefix > 128) {\n\t\t\tfprintf(stderr, \"Error fnet: invalid prefix for IPv6 address %s\\n\", addr6);\n\t\t\texit(1);\n\t\t}\n\t\t*ptr = '\\0';\t// mark the end of the address\n\t}\n\telse\n\t\tprefix = 128;\n\n\t// extract address\n\tstruct sockaddr_in6 sin6;\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n\tint rv = inet_pton(AF_INET6, addr6, sin6.sin6_addr.s6_addr);\n\tif (rv <= 0) {\n\t\tfprintf(stderr, \"Error fnet: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// open socket\n\tint sock = socket(PF_INET6, SOCK_DGRAM, IPPROTO_IP);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error fnet: IPv6 is not supported on this system\\n\");\n\t\texit(1);\n\t}\n\n\t// find interface index\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\tif (ioctl(sock, SIOGIFINDEX, &ifr) < 0) {\n\t\tperror(\"ioctl SIOGIFINDEX\");\n\t\texit(1);\n\t}\n\n\t// configure address\n\tstruct ifreq6 ifr6;\n\tmemset(&ifr6, 0, sizeof(ifr6));\n\tifr6.ifr6_prefixlen = prefix;\n\tifr6.ifr6_ifindex = ifr.ifr_ifindex;\n\tmemcpy((char *) &ifr6.ifr6_addr, (char *) &sin6.sin6_addr, sizeof(struct in6_addr));\n\tif (ioctl(sock, SIOCSIFADDR, &ifr6) < 0) {\n\t\tperror(\"ioctl SIOCSIFADDR\");\n\t\texit(1);\n\t}\n\n\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"ipv6\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"config\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_move_interface",
          "args": [
            "argv[2]",
            "atoi(argv[3])"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "net_move_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/veth.c",
          "lines": "250-284",
          "snippet": "int net_move_interface(const char *dev, unsigned pid) {\n\tstruct iplink_req req;\n\tassert(dev);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find ifindex\n\tint ifindex = if_nametoindex(dev);\n\tif (ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find interface %s\\n\", dev);\n\t\texit(1);\n\t}\n\treq.i.ifi_index = ifindex;\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}",
          "includes": [
            "#include <net/if.h>",
            "#include <linux/veth.h>",
            "#include \"../include/libnetlink.h\"",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rtnl_handle rth = { .fd = -1 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"fnet.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_move_interface(const char *dev, unsigned pid) {\n\tstruct iplink_req req;\n\tassert(dev);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find ifindex\n\tint ifindex = if_nametoindex(dev);\n\tif (ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find interface %s\\n\", dev);\n\t\texit(1);\n\t}\n\treq.i.ifi_index = ifindex;\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[3]"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"moveif\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_if_mac",
          "args": [
            "argv[3]",
            "mac"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_mac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "286-303",
          "snippet": "int net_if_mac(const char *ifname, const unsigned char mac[6]) {\n\tcheck_if_name(ifname);\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\tmemcpy(ifr.ifr_hwaddr.sa_data, mac, 6);\n\n\tif (ioctl(sock, SIOCSIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nint net_if_mac(const char *ifname, const unsigned char mac[6]) {\n\tcheck_if_name(ifname);\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\tmemcpy(ifr.ifr_hwaddr.sa_data, mac, 6);\n\n\tif (ioctl(sock, SIOCSIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fnet: invalid mac address %s\\n\"",
            "argv[4]"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomac",
          "args": [
            "argv[4]",
            "mac"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "atomac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "84-99",
          "snippet": "static inline int atomac(char *str, unsigned char macAddr[6]) {\n\tunsigned mac[6];\n\n\tif (sscanf(str, \"%2x:%2x:%2x:%2x:%2x:%2x\", &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]) != 6)\n\t\treturn 1;\n\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (mac[i] > 0xff)\n\t\t\treturn 1;\n\n\t\tmacAddr[i] = (unsigned char) mac[i];\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline int atomac(char *str, unsigned char macAddr[6]) {\n\tunsigned mac[6];\n\n\tif (sscanf(str, \"%2x:%2x:%2x:%2x:%2x:%2x\", &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]) != 6)\n\t\treturn 1;\n\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (mac[i] > 0xff)\n\t\t\treturn 1;\n\n\t\tmacAddr[i] = (unsigned char) mac[i];\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"mac\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"config\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_if_up",
          "args": [
            "dev"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "83-125",
          "snippet": "void net_if_up(const char *ifname) {\n\tcheck_if_name(ifname);\n\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_if_up(const char *ifname) {\n\tcheck_if_name(ifname);\n\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_if_ip",
          "args": [
            "dev",
            "ip",
            "mask",
            "mtu"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "253-284",
          "snippet": "void net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu) {\n\tcheck_if_name(ifname);\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr = htonl(ip);\n\tif (ioctl( sock, SIOCSIFADDR, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\tif (ip != 0) {\n\t\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr =  htonl(mask);\n\t\tif (ioctl( sock, SIOCSIFNETMASK, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t}\n\n\t// configure mtu\n\tif (mtu > 0) {\n\t\tifr.ifr_mtu = mtu;\n\t\tif (ioctl( sock, SIOCSIFMTU, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t}\n\n\tclose(sock);\n\tusleep(10000);\t\t\t\t  // sleep 10ms\n\treturn;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu) {\n\tcheck_if_name(ifname);\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr = htonl(ip);\n\tif (ioctl( sock, SIOCSIFADDR, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\tif (ip != 0) {\n\t\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr =  htonl(mask);\n\t\tif (ioctl( sock, SIOCSIFNETMASK, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t}\n\n\t// configure mtu\n\tif (mtu > 0) {\n\t\tifr.ifr_mtu = mtu;\n\t\tif (ioctl( sock, SIOCSIFMTU, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t}\n\n\tclose(sock);\n\tusleep(10000);\t\t\t\t  // sleep 10ms\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[6]"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoll",
          "args": [
            "argv[5]"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoll",
          "args": [
            "argv[4]"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"interface\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"config\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_create_macvlan",
          "args": [
            "argv[3]",
            "argv[4]",
            "atoi(argv[5])"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "net_create_macvlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/veth.c",
          "lines": "127-184",
          "snippet": "int net_create_macvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"macvlan\", strlen(\"macvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = MACVLAN_MODE_BRIDGE;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 4);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}",
          "includes": [
            "#include <net/if.h>",
            "#include <linux/veth.h>",
            "#include \"../include/libnetlink.h\"",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rtnl_handle rth = { .fd = -1 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"fnet.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_create_macvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"macvlan\", strlen(\"macvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = MACVLAN_MODE_BRIDGE;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 4);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[5]"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_create_ipvlan",
          "args": [
            "argv[3]",
            "argv[4]",
            "atoi(argv[5])"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "net_create_ipvlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/veth.c",
          "lines": "186-246",
          "snippet": "int net_create_ipvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"ipvlan\", strlen(\"ipvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = IPVLAN_MODE_L2;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 2);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n//\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}",
          "includes": [
            "#include <net/if.h>",
            "#include <linux/veth.h>",
            "#include \"../include/libnetlink.h\"",
            "#include \"fnet.h\""
          ],
          "macros_used": [
            "#define IPVLAN_MODE_L2 0"
          ],
          "globals_used": [
            "static struct rtnl_handle rth = { .fd = -1 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"fnet.h\"\n\n#define IPVLAN_MODE_L2 0\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_create_ipvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"ipvlan\", strlen(\"ipvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = IPVLAN_MODE_L2;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 2);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n//\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[5]"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/sys/class/net/%s/wireless\"",
            "argv[4]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[5]"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fnet: cannot extract Linux kernel version: %s\\n\"",
            "u.version"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "u.release",
            "\"%d.%d\"",
            "&major",
            "&minor"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"uname\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uname",
          "args": [
            "&u"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"macvlan\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"create\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_bridge_add_interface",
          "args": [
            "argv[5]",
            "argv[3]"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "net_bridge_add_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "40-79",
          "snippet": "void net_bridge_add_interface(const char *bridge, const char *dev) {\n\tcheck_if_name(bridge);\n\tcheck_if_name(dev);\n\n\t// somehow adding the interface to the bridge resets MTU on bridge device!!!\n\t// workaround: restore MTU on the bridge device\n\t// todo: put a real fix in\n\tint mtu1 = net_get_mtu(bridge);\n\n\tstruct ifreq ifr;\n\tint err;\n\tint ifindex = if_nametoindex(dev);\n\n\tif (ifindex <= 0)\n\t\terrExit(\"if_nametoindex\");\n\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ - 1);\n#ifdef SIOCBRADDIF\n\tifr.ifr_ifindex = ifindex;\n\terr = ioctl(sock, SIOCBRADDIF, &ifr);\n\tif (err < 0)\n#endif\n\t{\n\t\tunsigned long args[4] = { BRCTL_ADD_IF, ifindex, 0, 0 };\n\n\t\tifr.ifr_data = (char *) args;\n\t\terr = ioctl(sock, SIOCDEVPRIVATE, &ifr);\n\t}\n\t(void) err;\n\tclose(sock);\n\n\tint mtu2 = net_get_mtu(bridge);\n\tif (mtu1 != mtu2)\n\t\tnet_set_mtu(bridge, mtu1);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_bridge_add_interface(const char *bridge, const char *dev) {\n\tcheck_if_name(bridge);\n\tcheck_if_name(dev);\n\n\t// somehow adding the interface to the bridge resets MTU on bridge device!!!\n\t// workaround: restore MTU on the bridge device\n\t// todo: put a real fix in\n\tint mtu1 = net_get_mtu(bridge);\n\n\tstruct ifreq ifr;\n\tint err;\n\tint ifindex = if_nametoindex(dev);\n\n\tif (ifindex <= 0)\n\t\terrExit(\"if_nametoindex\");\n\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ - 1);\n#ifdef SIOCBRADDIF\n\tifr.ifr_ifindex = ifindex;\n\terr = ioctl(sock, SIOCBRADDIF, &ifr);\n\tif (err < 0)\n#endif\n\t{\n\t\tunsigned long args[4] = { BRCTL_ADD_IF, ifindex, 0, 0 };\n\n\t\tifr.ifr_data = (char *) args;\n\t\terr = ioctl(sock, SIOCDEVPRIVATE, &ifr);\n\t}\n\t(void) err;\n\tclose(sock);\n\n\tint mtu2 = net_get_mtu(bridge);\n\tif (mtu1 != mtu2)\n\t\tnet_set_mtu(bridge, mtu1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_create_veth",
          "args": [
            "argv[3]",
            "argv[4]",
            "atoi(argv[6])"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "net_create_veth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/veth.c",
          "lines": "69-124",
          "snippet": "int net_create_veth(const char *dev, const char *nsdev, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\n\tassert(dev);\n\tassert(nsdev);\n\tassert(pid);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\tif (dev) {\n\t\tlen = strlen(dev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t}\n\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"veth\", strlen(\"veth\"));\n\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\n\tstruct rtattr * peerdata = NLMSG_TAIL(&req.n);\n\taddattr_l (&req.n, sizeof(req), VETH_INFO_PEER, NULL, 0);\n\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\t// place the link in the child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\tif (nsdev) {\n\t\tint len = strlen(nsdev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, nsdev, len);\n\t}\n\tpeerdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)peerdata;\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}",
          "includes": [
            "#include <net/if.h>",
            "#include <linux/veth.h>",
            "#include \"../include/libnetlink.h\"",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rtnl_handle rth = { .fd = -1 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"fnet.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_create_veth(const char *dev, const char *nsdev, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\n\tassert(dev);\n\tassert(nsdev);\n\tassert(pid);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\tif (dev) {\n\t\tlen = strlen(dev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t}\n\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"veth\", strlen(\"veth\"));\n\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\n\tstruct rtattr * peerdata = NLMSG_TAIL(&req.n);\n\taddattr_l (&req.n, sizeof(req), VETH_INFO_PEER, NULL, 0);\n\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\t// place the link in the child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\tif (nsdev) {\n\t\tint len = strlen(nsdev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, nsdev, len);\n\t}\n\tpeerdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)peerdata;\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[6]"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"veth\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"create\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_ifprint",
          "args": [
            "1"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "net_ifprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/interface.c",
          "lines": "167-229",
          "snippet": "void net_ifprint(int scan) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\tfmessage(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\"Interface\", \"MAC\", \"IP\", \"Mask\", \"Status\");\n\t// walk through the linked list\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\t// interface status\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t// ip address and mask\n\t\t\tchar ipstr[30];\n\t\t\tsprintf(ipstr, \"%d.%d.%d.%d\", PRINT_IP(ip));\n\t\t\tchar maskstr[30];\n\t\t\tsprintf(maskstr, \"%d.%d.%d.%d\", PRINT_IP(mask));\n\n\t\t\t// mac address\n\t\t\tunsigned char mac[6];\n\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\tchar macstr[30];\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\n\t\t\t\tmacstr[0] = '\\0';\n\t\t\telse\n\t\t\t\tsprintf(macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\", PRINT_MAC(mac));\n\n\t\t\t// print\n\t\t\tfmessage(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\t\tifa->ifa_name, macstr, ipstr, maskstr, status);\n\n\t\t\t// network scanning\n\t\t\tif (!scan)\t\t\t\t// scanning disabled\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\t// no loopbabck scanning\n\t\t\t\tcontinue;\n\t\t\tif (mask2bits(mask) < 16)\t\t// not scanning large networks\n\t\t\t\tcontinue;\n\t\t\tif (!ip)\t\t\t\t\t// if not configured\n\t\t\t\tcontinue;\n\t\t\t// only if the interface is up and running\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tarp_scan(ifa->ifa_name, ip, mask);\n\t\t}\n\t}\n\tfreeifaddrs(ifaddr);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"fnet.h\"\n\nvoid net_ifprint(int scan) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\tfmessage(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\"Interface\", \"MAC\", \"IP\", \"Mask\", \"Status\");\n\t// walk through the linked list\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\t// interface status\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t// ip address and mask\n\t\t\tchar ipstr[30];\n\t\t\tsprintf(ipstr, \"%d.%d.%d.%d\", PRINT_IP(ip));\n\t\t\tchar maskstr[30];\n\t\t\tsprintf(maskstr, \"%d.%d.%d.%d\", PRINT_IP(mask));\n\n\t\t\t// mac address\n\t\t\tunsigned char mac[6];\n\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\tchar macstr[30];\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\n\t\t\t\tmacstr[0] = '\\0';\n\t\t\telse\n\t\t\t\tsprintf(macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\", PRINT_MAC(mac));\n\n\t\t\t// print\n\t\t\tfmessage(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\t\tifa->ifa_name, macstr, ipstr, maskstr, status);\n\n\t\t\t// network scanning\n\t\t\tif (!scan)\t\t\t\t// scanning disabled\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\t// no loopbabck scanning\n\t\t\t\tcontinue;\n\t\t\tif (mask2bits(mask) < 16)\t\t// not scanning large networks\n\t\t\t\tcontinue;\n\t\t\tif (!ip)\t\t\t\t\t// if not configured\n\t\t\t\tcontinue;\n\t\t\t// only if the interface is up and running\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tarp_scan(ifa->ifa_name, ip, mask);\n\t\t}\n\t}\n\tfreeifaddrs(ifaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[2]",
            "\"scan\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"printif\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"printif\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"ifup\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/main.c",
          "lines": "39-50",
          "snippet": "static void usage(void) {\n\tprintf(\"Usage:\\n\");\n\tprintf(\"\\tfnet create veth dev1 dev2 bridge child\\n\");\n\tprintf(\"\\tfnet create macvlan dev parent child\\n\");\n\tprintf(\"\\tfnet moveif dev proc\\n\");\n\tprintf(\"\\tfnet printif\\n\");\n\tprintf(\"\\tfnet printif scan\\n\");\n\tprintf(\"\\tfnet config interface dev ip mask mtu\\n\");\n\tprintf(\"\\tfnet config mac addr\\n\");\n\tprintf(\"\\tfnet config ipv6 dev ip\\n\");\n\tprintf(\"\\tfnet ifup dev\\n\");\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"fnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"fnet.h\"\n\nstatic void usage(void) {\n\tprintf(\"Usage:\\n\");\n\tprintf(\"\\tfnet create veth dev1 dev2 bridge child\\n\");\n\tprintf(\"\\tfnet create macvlan dev parent child\\n\");\n\tprintf(\"\\tfnet moveif dev proc\\n\");\n\tprintf(\"\\tfnet printif\\n\");\n\tprintf(\"\\tfnet printif scan\\n\");\n\tprintf(\"\\tfnet config interface dev ip mask mtu\\n\");\n\tprintf(\"\\tfnet config mac addr\\n\");\n\tprintf(\"\\tfnet config ipv6 dev ip\\n\");\n\tprintf(\"\\tfnet ifup dev\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"-?\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"--help\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"-h\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "quiet",
            "\"yes\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_QUIET\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"*%s* \"",
            "argv[i]"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"fnet.h\"\n\nint arg_quiet = 0;\n\nint main(int argc, char **argv) {\n#if 0\n{\n//system(\"cat /proc/self/status\");\nint i;\nfor (i = 0; i < argc; i++)\n\tprintf(\"*%s* \", argv[i]);\nprintf(\"\\n\");\n}\n#endif\n\tif (argc < 2) {\n\t\tusage();\n\t\treturn 1;\n\t}\n\n\tchar *quiet = getenv(\"FIREJAIL_QUIET\");\n\tif (quiet && strcmp(quiet, \"yes\") == 0)\n\t\targ_quiet = 1;\n\n\tif (strcmp(argv[1], \"-h\") == 0 || strcmp(argv[1], \"--help\") == 0 || strcmp(argv[1], \"-?\") ==0) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\telse if (argc == 3 && strcmp(argv[1], \"ifup\") == 0) {\n\t\tnet_if_up(argv[2]);\n\t}\n\telse if (argc == 2 && strcmp(argv[1], \"printif\") == 0) {\n\t\tnet_ifprint(0);\n\t}\n\telse if (argc == 3 && strcmp(argv[1], \"printif\") == 0 && strcmp(argv[2], \"scan\") == 0) {\n\t\tnet_ifprint(1);\n\t}\n\telse if (argc == 7 && strcmp(argv[1], \"create\") == 0 && strcmp(argv[2], \"veth\") == 0) {\n\t\t// create veth pair and move one end in the the namespace\n\t\tnet_create_veth(argv[3], argv[4], atoi(argv[6]));\n\t\t// connect the ohter veth end to the bridge ...\n\t\tnet_bridge_add_interface(argv[5], argv[3]);\n\t\t// ... and bring it  up\n\t\tnet_if_up(argv[3]);\n\t}\n\telse if (argc == 6 && strcmp(argv[1], \"create\") == 0 && strcmp(argv[2], \"macvlan\") == 0) {\n\t\t// use ipvlan for wireless devices\n\t\t// ipvlan driver was introduced in Linux kernel 3.19\n\n\t\t// check kernel version\n\t\tstruct utsname u;\n\t\tint rv = uname(&u);\n\t\tif (rv != 0)\n\t\t\terrExit(\"uname\");\n\t\tint major;\n\t\tint minor;\n\t\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\t\tfprintf(stderr, \"Error fnet: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (major <= 3 && minor < 18)\n\t\t\tnet_create_macvlan(argv[3], argv[4], atoi(argv[5]));\n\t\telse {\n\t\t\tstruct stat s;\n\t\t\tchar *fname;\n\t\t\tif (asprintf(&fname, \"/sys/class/net/%s/wireless\", argv[4]) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (stat(fname, &s) == 0) // wireless\n\t\t\t\tnet_create_ipvlan(argv[3], argv[4], atoi(argv[5]));\n\t\t\telse // regular ethernet\n\t\t\t\tnet_create_macvlan(argv[3], argv[4], atoi(argv[5]));\n\t\t}\n\t}\n\telse if (argc == 7 && strcmp(argv[1], \"config\") == 0 && strcmp(argv[2], \"interface\") == 0) {\n\t\tchar *dev = argv[3];\n\t\tuint32_t ip = (uint32_t)  atoll(argv[4]);\n\t\tuint32_t mask = (uint32_t)  atoll(argv[5]);\n\t\tint mtu = atoi(argv[6]);\n\t\t// configure interface\n\t\tnet_if_ip(dev, ip, mask, mtu);\n\t\t// ... and bring it  up\n\t\tnet_if_up(dev);\n\t}\n\telse if (argc == 5 && strcmp(argv[1], \"config\") == 0 && strcmp(argv[2], \"mac\") == 0) {\n\t\tunsigned char mac[6];\n\t\tif (atomac(argv[4], mac)) {\n\t\t\tfprintf(stderr, \"Error fnet: invalid mac address %s\\n\", argv[4]);\n\t\t}\n\t\tnet_if_mac(argv[3], mac);\n\t}\n\telse if (argc == 4 && strcmp(argv[1], \"moveif\") == 0) {\n\t\tnet_move_interface(argv[2], atoi(argv[3]));\n\t}\n\telse if (argc == 5 && strcmp(argv[1], \"config\") == 0 && strcmp(argv[2], \"ipv6\") == 0) {\n\t\tnet_if_ip6(argv[3], argv[4]);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error fnet: invalid arguments\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/main.c",
    "lines": "39-50",
    "snippet": "static void usage(void) {\n\tprintf(\"Usage:\\n\");\n\tprintf(\"\\tfnet create veth dev1 dev2 bridge child\\n\");\n\tprintf(\"\\tfnet create macvlan dev parent child\\n\");\n\tprintf(\"\\tfnet moveif dev proc\\n\");\n\tprintf(\"\\tfnet printif\\n\");\n\tprintf(\"\\tfnet printif scan\\n\");\n\tprintf(\"\\tfnet config interface dev ip mask mtu\\n\");\n\tprintf(\"\\tfnet config mac addr\\n\");\n\tprintf(\"\\tfnet config ipv6 dev ip\\n\");\n\tprintf(\"\\tfnet ifup dev\\n\");\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfnet ifup dev\\n\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfnet config ipv6 dev ip\\n\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfnet config mac addr\\n\""
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfnet config interface dev ip mask mtu\\n\""
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfnet printif scan\\n\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfnet printif\\n\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfnet moveif dev proc\\n\""
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfnet create macvlan dev parent child\\n\""
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tfnet create veth dev1 dev2 bridge child\\n\""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage:\\n\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"fnet.h\"\n\nstatic void usage(void) {\n\tprintf(\"Usage:\\n\");\n\tprintf(\"\\tfnet create veth dev1 dev2 bridge child\\n\");\n\tprintf(\"\\tfnet create macvlan dev parent child\\n\");\n\tprintf(\"\\tfnet moveif dev proc\\n\");\n\tprintf(\"\\tfnet printif\\n\");\n\tprintf(\"\\tfnet printif scan\\n\");\n\tprintf(\"\\tfnet config interface dev ip mask mtu\\n\");\n\tprintf(\"\\tfnet config mac addr\\n\");\n\tprintf(\"\\tfnet config ipv6 dev ip\\n\");\n\tprintf(\"\\tfnet ifup dev\\n\");\n}"
  },
  {
    "function_name": "fmessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/main.c",
    "lines": "27-36",
    "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/firejail/util.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int arg_quiet = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfprintf",
          "args": [
            "stderr",
            "fmt",
            "args"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"fnet.h\"\n\nint arg_quiet = 0;\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/firejail/util.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
  }
]