[
  {
    "function_name": "fchdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "684-708",
    "snippet": "int fchdir(int fd) {\n#ifdef DEBUG\n\tprintf(\"%s %d\\n\", __FUNCTION__, fd);\n#endif\n\tif (!orig_fchdir)\n\t\torig_fchdir = (orig_fchdir_t)dlsym(RTLD_NEXT, \"fchdir\");\n\n\tfree(cwd);\n\tchar *pathname=malloc(PATH_MAX);\n\tif (pathname) {\n\t\tif (snprintf(pathname,PATH_MAX,\"/proc/self/fd/%d\", fd)>0) {\n\t\t\tcwd = realpath(pathname, NULL);\n\t\t} else {\n\t\t\tcwd = NULL;\n\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t}\n\t\tfree(pathname);\n\t} else {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tcwd = NULL;\n\t}\n\n\tint rv = orig_fchdir(fd);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char* cwd = NULL;",
      "static orig_fchdir_t orig_fchdir = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_fchdir",
          "args": [
            "fd"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot allocate memory\\n\""
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pathname"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: snprintf failed\\n\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "pathname",
            "NULL"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pathname",
            "PATH_MAX",
            "\"/proc/self/fd/%d\"",
            "fd"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "PATH_MAX"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cwd"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"fchdir\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %d\\n\"",
            "__FUNCTION__",
            "fd"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char* cwd = NULL;\nstatic orig_fchdir_t orig_fchdir = NULL;\n\nint fchdir(int fd) {\n#ifdef DEBUG\n\tprintf(\"%s %d\\n\", __FUNCTION__, fd);\n#endif\n\tif (!orig_fchdir)\n\t\torig_fchdir = (orig_fchdir_t)dlsym(RTLD_NEXT, \"fchdir\");\n\n\tfree(cwd);\n\tchar *pathname=malloc(PATH_MAX);\n\tif (pathname) {\n\t\tif (snprintf(pathname,PATH_MAX,\"/proc/self/fd/%d\", fd)>0) {\n\t\t\tcwd = realpath(pathname, NULL);\n\t\t} else {\n\t\t\tcwd = NULL;\n\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t}\n\t\tfree(pathname);\n\t} else {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tcwd = NULL;\n\t}\n\n\tint rv = orig_fchdir(fd);\n\treturn rv;\n}"
  },
  {
    "function_name": "chdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "662-679",
    "snippet": "int chdir(const char *pathname) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_chdir)\n\t\torig_chdir = (orig_chdir_t)dlsym(RTLD_NEXT, \"chdir\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\n\tfree(cwd);\n\tcwd = strdup(pathname);\n\n\tint rv = orig_chdir(pathname);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char* cwd = NULL;",
      "static int blacklist_loaded = 0;",
      "static orig_chdir_t orig_chdir = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_chdir",
          "args": [
            "pathname"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "pathname"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cwd"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"chdir\""
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char* cwd = NULL;\nstatic int blacklist_loaded = 0;\nstatic orig_chdir_t orig_chdir = NULL;\n\nint chdir(const char *pathname) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_chdir)\n\t\torig_chdir = (orig_chdir_t)dlsym(RTLD_NEXT, \"chdir\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\n\tfree(cwd);\n\tcwd = strdup(pathname);\n\n\tint rv = orig_chdir(pathname);\n\treturn rv;\n}"
  },
  {
    "function_name": "opendir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "644-657",
    "snippet": "DIR *opendir(const char *pathname) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tDIR *rv = orig_opendir(pathname);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_opendir_t orig_opendir = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_opendir",
          "args": [
            "pathname"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"opendir\""
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tDIR *rv = orig_opendir(pathname);\n\treturn rv;\n}"
  },
  {
    "function_name": "access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "626-639",
    "snippet": "int access(const char *pathname, int mode) {\n#ifdef DEBUG\n\tprintf(\"%s, %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_access(pathname, mode);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_access_t orig_access = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_access",
          "args": [
            "pathname",
            "mode"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"access\""
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s, %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_access_t orig_access = NULL;\n\nint access(const char *pathname, int mode) {\n#ifdef DEBUG\n\tprintf(\"%s, %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_access(pathname, mode);\n\treturn rv;\n}"
  },
  {
    "function_name": "lstat64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "607-620",
    "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_lstat64(pathname, buf);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_lstat64",
          "args": [
            "pathname",
            "buf"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"lstat64\""
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_lstat64(pathname, buf);\n\treturn rv;\n}"
  },
  {
    "function_name": "lstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "589-602",
    "snippet": "int lstat(const char *pathname, struct stat *buf) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_lstat)\n\t\torig_lstat = (orig_lstat_t)dlsym(RTLD_NEXT, \"lstat\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_lstat(pathname, buf);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_lstat_t orig_lstat = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_lstat",
          "args": [
            "pathname",
            "buf"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"lstat\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_lstat_t orig_lstat = NULL;\n\nint lstat(const char *pathname, struct stat *buf) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_lstat)\n\t\torig_lstat = (orig_lstat_t)dlsym(RTLD_NEXT, \"lstat\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_lstat(pathname, buf);\n\treturn rv;\n}"
  },
  {
    "function_name": "stat64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "571-584",
    "snippet": "int stat64(const char *pathname, struct stat64 *buf) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_stat64)\n\t\torig_stat64 = (orig_stat64_t)dlsym(RTLD_NEXT, \"stat64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_stat64(pathname, buf);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_stat64",
          "args": [
            "pathname",
            "buf"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"stat64\""
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\n\nint stat64(const char *pathname, struct stat64 *buf) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_stat64)\n\t\torig_stat64 = (orig_stat64_t)dlsym(RTLD_NEXT, \"stat64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_stat64(pathname, buf);\n\treturn rv;\n}"
  },
  {
    "function_name": "stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "553-566",
    "snippet": "int stat(const char *pathname, struct stat *buf) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_stat)\n\t\torig_stat = (orig_stat_t)dlsym(RTLD_NEXT, \"stat\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_stat(pathname, buf);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_stat_t orig_stat = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_stat",
          "args": [
            "pathname",
            "buf"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"stat\""
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_stat_t orig_stat = NULL;\n\nint stat(const char *pathname, struct stat *buf) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_stat)\n\t\torig_stat = (orig_stat_t)dlsym(RTLD_NEXT, \"stat\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_stat(pathname, buf);\n\treturn rv;\n}"
  },
  {
    "function_name": "rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "535-548",
    "snippet": "int rmdir(const char *pathname) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_rmdir)\n\t\torig_rmdir = (orig_rmdir_t)dlsym(RTLD_NEXT, \"rmdir\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_rmdir(pathname);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_rmdir_t orig_rmdir = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_rmdir",
          "args": [
            "pathname"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"rmdir\""
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_rmdir_t orig_rmdir = NULL;\n\nint rmdir(const char *pathname) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_rmdir)\n\t\torig_rmdir = (orig_rmdir_t)dlsym(RTLD_NEXT, \"rmdir\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_rmdir(pathname);\n\treturn rv;\n}"
  },
  {
    "function_name": "mkdirat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "518-531",
    "snippet": "int mkdirat(int dirfd, const char *pathname, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_mkdirat)\n\t\torig_mkdirat = (orig_mkdirat_t)dlsym(RTLD_NEXT, \"mkdirat\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_mkdirat(dirfd, pathname, mode);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_mkdirat_t orig_mkdirat = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_mkdirat",
          "args": [
            "dirfd",
            "pathname",
            "mode"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"mkdirat\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_mkdirat_t orig_mkdirat = NULL;\n\nint mkdirat(int dirfd, const char *pathname, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_mkdirat)\n\t\torig_mkdirat = (orig_mkdirat_t)dlsym(RTLD_NEXT, \"mkdirat\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_mkdirat(dirfd, pathname, mode);\n\treturn rv;\n}"
  },
  {
    "function_name": "mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "501-514",
    "snippet": "int mkdir(const char *pathname, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_mkdir(pathname, mode);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_mkdir_t orig_mkdir = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_mkdir",
          "args": [
            "pathname",
            "mode"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"mkdir\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_mkdir_t orig_mkdir = NULL;\n\nint mkdir(const char *pathname, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_mkdir(pathname, mode);\n\treturn rv;\n}"
  },
  {
    "function_name": "unlinkat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "483-496",
    "snippet": "int unlinkat(int dirfd, const char *pathname, int flags) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_unlinkat)\n\t\torig_unlinkat = (orig_unlinkat_t)dlsym(RTLD_NEXT, \"unlinkat\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_unlinkat(dirfd, pathname, flags);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_unlinkat_t orig_unlinkat = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_unlinkat",
          "args": [
            "dirfd",
            "pathname",
            "flags"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"unlinkat\""
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_unlinkat_t orig_unlinkat = NULL;\n\nint unlinkat(int dirfd, const char *pathname, int flags) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_unlinkat)\n\t\torig_unlinkat = (orig_unlinkat_t)dlsym(RTLD_NEXT, \"unlinkat\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_unlinkat(dirfd, pathname, flags);\n\treturn rv;\n}"
  },
  {
    "function_name": "unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "466-479",
    "snippet": "int unlink(const char *pathname) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_unlink(pathname);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_unlink_t orig_unlink = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_unlink",
          "args": [
            "pathname"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"unlink\""
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_unlink_t orig_unlink = NULL;\n\nint unlink(const char *pathname) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_unlink(pathname);\n\treturn rv;\n}"
  },
  {
    "function_name": "freopen64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "447-460",
    "snippet": "FILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_freopen64",
          "args": [
            "pathname",
            "mode",
            "stream"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"freopen64\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\n\nFILE *freopen64(const char *pathname, const char *mode, FILE *stream) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_freopen64)\n\t\torig_freopen64 = (orig_freopen64_t)dlsym(RTLD_NEXT, \"freopen64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tFILE *rv = orig_freopen64(pathname, mode, stream);\n\treturn rv;\n}"
  },
  {
    "function_name": "freopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "429-442",
    "snippet": "FILE *freopen(const char *pathname, const char *mode, FILE *stream) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_freopen)\n\t\torig_freopen = (orig_freopen_t)dlsym(RTLD_NEXT, \"freopen\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tFILE *rv = orig_freopen(pathname, mode, stream);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_freopen_t orig_freopen = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_freopen",
          "args": [
            "pathname",
            "mode",
            "stream"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"freopen\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_freopen_t orig_freopen = NULL;\n\nFILE *freopen(const char *pathname, const char *mode, FILE *stream) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_freopen)\n\t\torig_freopen = (orig_freopen_t)dlsym(RTLD_NEXT, \"freopen\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tFILE *rv = orig_freopen(pathname, mode, stream);\n\treturn rv;\n}"
  },
  {
    "function_name": "fopen64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "409-422",
    "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tFILE *rv = orig_fopen64(pathname, mode);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static orig_fopen64_t orig_fopen64 = NULL;",
      "static int blacklist_loaded = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_fopen64",
          "args": [
            "pathname",
            "mode"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"fopen64\""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\nstatic int blacklist_loaded = 0;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tFILE *rv = orig_fopen64(pathname, mode);\n\treturn rv;\n}"
  },
  {
    "function_name": "fopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "393-406",
    "snippet": "FILE *fopen(const char *pathname, const char *mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tFILE *rv = orig_fopen(pathname, mode);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static orig_fopen_t orig_fopen = NULL;",
      "static int blacklist_loaded = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_fopen",
          "args": [
            "pathname",
            "mode"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"fopen\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic int blacklist_loaded = 0;\n\nFILE *fopen(const char *pathname, const char *mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tFILE *rv = orig_fopen(pathname, mode);\n\treturn rv;\n}"
  },
  {
    "function_name": "openat64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "376-389",
    "snippet": "int openat64(int dirfd, const char *pathname, int flags, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_openat64)\n\t\torig_openat64 = (orig_openat64_t)dlsym(RTLD_NEXT, \"openat64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_openat64(dirfd, pathname, flags, mode);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_openat64_t orig_openat64 = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_openat64",
          "args": [
            "dirfd",
            "pathname",
            "flags",
            "mode"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"openat64\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_openat64_t orig_openat64 = NULL;\n\nint openat64(int dirfd, const char *pathname, int flags, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_openat64)\n\t\torig_openat64 = (orig_openat64_t)dlsym(RTLD_NEXT, \"openat64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_openat64(dirfd, pathname, flags, mode);\n\treturn rv;\n}"
  },
  {
    "function_name": "openat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "359-372",
    "snippet": "int openat(int dirfd, const char *pathname, int flags, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_openat)\n\t\torig_openat = (orig_openat_t)dlsym(RTLD_NEXT, \"openat\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_openat(dirfd, pathname, flags, mode);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_openat_t orig_openat = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_openat",
          "args": [
            "dirfd",
            "pathname",
            "flags",
            "mode"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"openat\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_openat_t orig_openat = NULL;\n\nint openat(int dirfd, const char *pathname, int flags, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_openat)\n\t\torig_openat = (orig_openat_t)dlsym(RTLD_NEXT, \"openat\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_openat(dirfd, pathname, flags, mode);\n\treturn rv;\n}"
  },
  {
    "function_name": "open64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "339-352",
    "snippet": "int open64(const char *pathname, int flags, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_open64)\n\t\torig_open64 = (orig_open64_t)dlsym(RTLD_NEXT, \"open64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_open64(pathname, flags, mode);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_open64_t orig_open64 = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_open64",
          "args": [
            "pathname",
            "flags",
            "mode"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"open64\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_open64_t orig_open64 = NULL;\n\nint open64(const char *pathname, int flags, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_open64)\n\t\torig_open64 = (orig_open64_t)dlsym(RTLD_NEXT, \"open64\");\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_open64(pathname, flags, mode);\n\treturn rv;\n}"
  },
  {
    "function_name": "open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "317-331",
    "snippet": "int open(const char *pathname, int flags, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_open)\n\t\torig_open = (orig_open_t)dlsym(RTLD_NEXT, \"open\");\n\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_open(pathname, flags, mode);\n\treturn rv;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blacklist_loaded = 0;",
      "static orig_open_t orig_open = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orig_open",
          "args": [
            "pathname",
            "flags",
            "mode"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendlog",
          "args": [
            "name()",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "sendlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "236-255",
          "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
        }
      },
      {
        "call_info": {
          "callee": "name",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "274-308",
          "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXNAME 16"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "static char myname[MAXNAME];",
            "static int nameinit = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_find",
          "args": [
            "pathname"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "storage_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "99-160",
          "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];",
            "static char* cwd = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_blacklist",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "load_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "171-233",
          "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAXBUF 4096",
            "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
            "#define HMASK 0x0ff"
          ],
          "globals_used": [
            "static orig_fopen_t orig_fopen = NULL;",
            "ListElem *storage[HMASK + 1];",
            "static int blacklist_loaded = 0;",
            "static char *sandbox_pid_str = NULL;",
            "static char *sandbox_name_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"open\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s %s\\n\"",
            "__FUNCTION__",
            "pathname"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int blacklist_loaded = 0;\nstatic orig_open_t orig_open = NULL;\n\nint open(const char *pathname, int flags, mode_t mode) {\n#ifdef DEBUG\n\tprintf(\"%s %s\\n\", __FUNCTION__, pathname);\n#endif\n\tif (!orig_open)\n\t\torig_open = (orig_open_t)dlsym(RTLD_NEXT, \"open\");\n\n\tif (!blacklist_loaded)\n\t\tload_blacklist();\n\n\tif (storage_find(pathname))\n\t\tsendlog(name(), __FUNCTION__, pathname);\n\tint rv = orig_open(pathname, flags, mode);\n\treturn rv;\n}"
  },
  {
    "function_name": "name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "274-308",
    "snippet": "static char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define MAXNAME 16"
    ],
    "globals_used": [
      "static orig_fopen_t orig_fopen = NULL;",
      "static char myname[MAXNAME];",
      "static int nameinit = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "myname",
            "'\\n'"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "myname",
            "MAXNAME",
            "fp"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orig_fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"fopen\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%u/comm\"",
            "p"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "262-266",
          "snippet": "static inline pid_t pid(void) {\n\tif (!mypid)\n\t\tmypid = getpid();\n\treturn mypid;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static pid_t mypid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic pid_t mypid = 0;\n\nstatic inline pid_t pid(void) {\n\tif (!mypid)\n\t\tmypid = getpid();\n\treturn mypid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "myname",
            "0",
            "MAXNAME"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXNAME 16\n\nstatic orig_fopen_t orig_fopen = NULL;\nstatic char myname[MAXNAME];\nstatic int nameinit = 0;\n\nstatic char *name(void) {\n\tif (!nameinit) {\n\n\t\t// initialize the name of the process based on /proc/PID/comm\n\t\tmemset(myname, 0, MAXNAME);\n\n\t\tpid_t p = pid();\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%u/comm\", p) == -1)\n\t\t\treturn \"unknown\";\n\n\t\t// read file\n\t\tif (!orig_fopen)\n\t\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\t\tFILE *fp  = orig_fopen(fname, \"r\");\n\t\tif (!fp)\n\t\t\treturn \"unknown\";\n\t\tif (fgets(myname, MAXNAME, fp) == NULL) {\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\treturn \"unknown\";\n\t\t}\n\n\t\t// clean '\\n'\n\t\tchar *ptr = strchr(myname, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tnameinit = 1;\n\t}\n\n\treturn myname;\n}"
  },
  {
    "function_name": "pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "262-266",
    "snippet": "static inline pid_t pid(void) {\n\tif (!mypid)\n\t\tmypid = getpid();\n\treturn mypid;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static pid_t mypid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic pid_t mypid = 0;\n\nstatic inline pid_t pid(void) {\n\tif (!mypid)\n\t\tmypid = getpid();\n\treturn mypid;\n}"
  },
  {
    "function_name": "sendlog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "236-255",
    "snippet": "static void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *sandbox_pid_str = NULL;",
      "static char *sandbox_name_str = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "closelog",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_INFO",
            "\"blacklist violation - exe %s, syscall %s, path %s\"",
            "name",
            "call",
            "path"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_INFO",
            "\"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\"",
            "sandbox_pid_str",
            "name",
            "call",
            "path"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_INFO",
            "\"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\"",
            "sandbox_pid_str",
            "sandbox_name_str",
            "name",
            "call",
            "path"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "\"firejail\"",
            "LOG_CONS | LOG_PID | LOG_NDELAY",
            "LOG_LOCAL1"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"null pointer passed to sendlog\\n\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void sendlog(const char *name, const char *call, const char *path) {\n\tif (!name || !call || !path) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to sendlog\\n\");\n#endif\n\t\treturn;\n\t}\n\n\topenlog (\"firejail\", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);\n\tif (sandbox_pid_str && sandbox_name_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, name %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, sandbox_name_str, name, call, path);\n\telse if (sandbox_pid_str)\n\t\tsyslog (LOG_INFO, \"blacklist violation - sandbox %s, exe %s, syscall %s, path %s\",\n\t\t\tsandbox_pid_str, name, call, path);\n\telse\n\t\tsyslog (LOG_INFO, \"blacklist violation - exe %s, syscall %s, path %s\",\n\t\t\tname, call, path);\n\tcloselog ();\n}"
  },
  {
    "function_name": "load_blacklist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "171-233",
    "snippet": "static void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define MAXBUF 4096",
      "#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"",
      "#define HMASK 0x0ff"
    ],
    "globals_used": [
      "static orig_fopen_t orig_fopen = NULL;",
      "ListElem *storage[HMASK + 1];",
      "static int blacklist_loaded = 0;",
      "static char *sandbox_pid_str = NULL;",
      "static char *sandbox_name_str = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%02d \"",
            "cnt"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Monitoring %d blacklists\\n\"",
            "cnt"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage_add",
          "args": [
            "buf + 10"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "storage_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "66-94",
          "snippet": "static void storage_add(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_add\\n\");\n#endif\n\t\treturn;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"add %s\\n\", str);\n#endif\n\n\tListElem *ptr = malloc(sizeof(ListElem));\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\treturn;\n\t}\n\tptr->path = strdup(str);\n\tif (!ptr->path) {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tfree(ptr);\n\t\treturn;\n\t}\n\n\t// insert it into the hash table\n\tuint32_t h = hash(ptr->path);\n\tptr->next = storage[h];\n\tstorage[h] = ptr;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ListElem *storage[HMASK + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\n\nstatic void storage_add(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_add\\n\");\n#endif\n\t\treturn;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"add %s\\n\", str);\n#endif\n\n\tListElem *ptr = malloc(sizeof(ListElem));\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\treturn;\n\t}\n\tptr->path = strdup(str);\n\tif (!ptr->path) {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tfree(ptr);\n\t\treturn;\n\t}\n\n\t// insert it into the hash table\n\tuint32_t h = hash(ptr->path);\n\tptr->next = storage[h];\n\tstorage[h] = ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"blacklist \"",
            "10"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buf + 14"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"sandbox name: \"",
            "14"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buf + 13"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"sandbox pid: \"",
            "13"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fp"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orig_fopen",
          "args": [
            "RUN_FSLOGGER_FILE",
            "\"r\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlsym",
          "args": [
            "RTLD_NEXT",
            "\"fopen\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAXBUF 4096\n#define RUN_FSLOGGER_FILE\t\t\"/run/firejail/mnt/fslogger\"\n#define HMASK 0x0ff\n\nstatic orig_fopen_t orig_fopen = NULL;\nListElem *storage[HMASK + 1];\nstatic int blacklist_loaded = 0;\nstatic char *sandbox_pid_str = NULL;\nstatic char *sandbox_name_str = NULL;\n\nstatic void load_blacklist(void) {\n\tif (blacklist_loaded)\n\t\treturn;\n\n\t// open filesystem log\n\tif (!orig_fopen)\n\t\torig_fopen = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen\");\n\tFILE *fp = orig_fopen(RUN_FSLOGGER_FILE, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\t// extract blacklists\n\tchar buf[MAXBUF];\n#ifdef DEBUG\n\tint cnt = 0;\n#endif\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"sandbox pid: \", 13) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_pid_str == NULL)\n\t\t\t\tsandbox_pid_str = strdup(buf + 13);\n\t\t}\n\t\telse if (strncmp(buf, \"sandbox name: \", 14) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (sandbox_name_str == NULL)\n\t\t\t\tsandbox_name_str = strdup(buf + 14);\n\t\t}\n\t\telse if (strncmp(buf, \"blacklist \", 10) == 0) {\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tstorage_add(buf + 10);\n#ifdef DEBUG\n\t\t\tcnt++;\n#endif\n\t\t}\n\t}\n\tfclose(fp);\n\tblacklist_loaded = 1;\n#ifdef DEBUG\n\tprintf(\"Monitoring %d blacklists\\n\", cnt);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i <= HMASK; i++) {\n\t\t\tint cnt = 0;\n\t\t\tListElem *ptr = storage[i];\n\t\t\twhile (ptr) {\n\t\t\t\tcnt++;\n\t\t\t\tptr = ptr->next;\n\t\t\t}\n\n\t\t\tif ((i % 16) == 0)\n\t\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%02d \", cnt);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n#endif\n}"
  },
  {
    "function_name": "storage_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "99-160",
    "snippet": "static char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ListElem *storage[HMASK + 1];",
      "static char* cwd = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"storage not found\\n\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "(char *) tofind"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"storage found\\n\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "(char *) tofind"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tofind",
            "ptr->path"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "tofind"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "56-64",
          "snippet": "static inline uint32_t hash(const char *str) {\n\tuint32_t hash = 5381;\n\tint c;\n\n\twhile ((c = *str++) != '\\0')\n\t\thash = ((hash << 5) + hash) + c; // hash * 33 + c; another variant would be hash * 33 ^ c\n\n\treturn hash & HMASK;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define HMASK 0x0ff"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define HMASK 0x0ff\n\nstatic inline uint32_t hash(const char *str) {\n\tuint32_t hash = 5381;\n\tint c;\n\n\twhile ((c = *str++) != '\\0')\n\t\thash = ((hash << 5) + hash) + c; // hash * 33 + c; another variant would be hash * 33 ^ c\n\n\treturn hash & HMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"realpath failed\\n\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "str",
            "NULL"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fullpath"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "fullpath",
            "NULL"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fullpath"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: snprintf failed\\n\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fullpath",
            "PATH_MAX",
            "\"%s/%s\"",
            "cwd",
            "str"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot allocate memory\\n\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "PATH_MAX"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"//\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"/./\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"..\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"storage find %s\\n\"",
            "str"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"null pointer passed to storage_find\\n\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\nstatic char* cwd = NULL;\n\nstatic char *storage_find(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_find\\n\");\n#endif\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"storage find %s\\n\", str);\n#endif\n\n\tconst char *tofind = str;\n\tint allocated = 0;\n\n\tif (strstr(str, \"..\") || strstr(str, \"/./\") || strstr(str, \"//\") || str[0] != '/') {\n\t\tif (cwd != NULL && str[0] != '/') {\n\t\t\tchar *fullpath=malloc(PATH_MAX);\n\t\t\tif (!fullpath) {\n\t\t\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (snprintf(fullpath, PATH_MAX, \"%s/%s\", cwd, str)<3) {\n\t\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t\t\tfree(fullpath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttofind = realpath(fullpath, NULL);\n\t\t\tfree(fullpath);\n\t\t} else {\n\t\t\ttofind = realpath(str, NULL);\n\t\t}\n\t\tif (!tofind) {\n#ifdef DEBUG\n\t\t\tprintf(\"realpath failed\\n\");\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t\tallocated = 1;\n\t}\n\n\tuint32_t h = hash(tofind);\n\tListElem *ptr = storage[h];\n\twhile (ptr) {\n\t\tif (strcmp(tofind, ptr->path) == 0) {\n\t\t\tif (allocated)\n\t\t\t\tfree((char *) tofind);\n#ifdef DEBUG\n\t\t\tprintf(\"storage found\\n\");\n#endif\n\t\t\treturn ptr->path;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\tif (allocated)\n\t\tfree((char *) tofind);\n#ifdef DEBUG\n\tprintf(\"storage not found\\n\");\n#endif\n\treturn NULL;\n}"
  },
  {
    "function_name": "storage_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "66-94",
    "snippet": "static void storage_add(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_add\\n\");\n#endif\n\t\treturn;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"add %s\\n\", str);\n#endif\n\n\tListElem *ptr = malloc(sizeof(ListElem));\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\treturn;\n\t}\n\tptr->path = strdup(str);\n\tif (!ptr->path) {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tfree(ptr);\n\t\treturn;\n\t}\n\n\t// insert it into the hash table\n\tuint32_t h = hash(ptr->path);\n\tptr->next = storage[h];\n\tstorage[h] = ptr;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ListElem *storage[HMASK + 1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "ptr->path"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "56-64",
          "snippet": "static inline uint32_t hash(const char *str) {\n\tuint32_t hash = 5381;\n\tint c;\n\n\twhile ((c = *str++) != '\\0')\n\t\thash = ((hash << 5) + hash) + c; // hash * 33 + c; another variant would be hash * 33 ^ c\n\n\treturn hash & HMASK;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define HMASK 0x0ff"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define HMASK 0x0ff\n\nstatic inline uint32_t hash(const char *str) {\n\tuint32_t hash = 5381;\n\tint c;\n\n\twhile ((c = *str++) != '\\0')\n\t\thash = ((hash << 5) + hash) + c; // hash * 33 + c; another variant would be hash * 33 ^ c\n\n\treturn hash & HMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot allocate memory\\n\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot allocate memory\\n\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(ListElem)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"add %s\\n\"",
            "str"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"null pointer passed to storage_add\\n\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nListElem *storage[HMASK + 1];\n\nstatic void storage_add(const char *str) {\n\tif (!str) {\n#ifdef DEBUG\n\t\tprintf(\"null pointer passed to storage_add\\n\");\n#endif\n\t\treturn;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"add %s\\n\", str);\n#endif\n\n\tListElem *ptr = malloc(sizeof(ListElem));\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\treturn;\n\t}\n\tptr->path = strdup(str);\n\tif (!ptr->path) {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tfree(ptr);\n\t\treturn;\n\t}\n\n\t// insert it into the hash table\n\tuint32_t h = hash(ptr->path);\n\tptr->next = storage[h];\n\tstorage[h] = ptr;\n}"
  },
  {
    "function_name": "hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
    "lines": "56-64",
    "snippet": "static inline uint32_t hash(const char *str) {\n\tuint32_t hash = 5381;\n\tint c;\n\n\twhile ((c = *str++) != '\\0')\n\t\thash = ((hash << 5) + hash) + c; // hash * 33 + c; another variant would be hash * 33 ^ c\n\n\treturn hash & HMASK;\n}",
    "includes": [
      "#include <limits.h>",
      "#include <dirent.h>",
      "#include <syslog.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <dlfcn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define HMASK 0x0ff"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define HMASK 0x0ff\n\nstatic inline uint32_t hash(const char *str) {\n\tuint32_t hash = 5381;\n\tint c;\n\n\twhile ((c = *str++) != '\\0')\n\t\thash = ((hash << 5) + hash) + c; // hash * 33 + c; another variant would be hash * 33 ^ c\n\n\treturn hash & HMASK;\n}"
  }
]