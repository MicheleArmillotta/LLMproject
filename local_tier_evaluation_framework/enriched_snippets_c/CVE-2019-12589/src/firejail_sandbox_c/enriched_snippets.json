[
  {
    "function_name": "sandbox",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "582-1215",
    "snippet": "int sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\"Initializing child process\\n\");\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n\n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\"PID namespace installed\\n\");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\"sethostname\");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t// ... and mount a tmpfs on top of /run/firejail/mnt directory\n\tpreproc_mount_mnt_dir();\n\t// bind-mount firejail binaries and helper programs\n\tif (mount(LIBDIR \"/firejail\", RUN_FIREJAIL_LIB_DIR, \"none\", MS_BIND, NULL) < 0)\n\t\terrExit(\"mounting \" RUN_FIREJAIL_LIB_DIR);\n\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\"sandbox name:\", cfg.name);\n\tfs_logger2int(\"sandbox pid:\", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\"sandbox filesystem: chroot\");\n\telse if (arg_overlay)\n\t\tfs_logger(\"sandbox filesystem: overlay\");\n\telse\n\t\tfs_logger(\"sandbox filesystem: local\");\n\tfs_logger(\"install mount namespace\");\n\n\t//****************************\n\t// netfilter\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\"lo\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled, only loopback interface available\\n\");\n\t}\n\telse if (arg_netns) {\n\t\tnetns(arg_netns);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace '%s' activated\\n\", arg_netns);\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\"lo\");\n\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\n\n\t\t// moving an interface in a namespace using --interface will reset the interface configuration;\n\t\t// we need to put the configuration back\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_config_interface(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t}\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_config_interface(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t}\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_config_interface(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t}\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_config_interface(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t}\n\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfwarning(\"cannot configure default route\\n\");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled\\n\");\n\t}\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tfmessage(\"\\n\");\n\t\t\tif (any_bridge_configured() || any_interface_configured()) {\n\t\t\t\tif (arg_scan)\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3, PATH_FNET, \"printif\", \"scan\");\n\t\t\t\telse\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET, \"printif\");\n\n\t\t\t}\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tfmessage(\"Default gateway configuration failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tfmessage(\"Default gateway %d.%d.%d.%d\\n\", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns1);\n\t\t\tif (cfg.dns2 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns2);\n\t\t\tif (cfg.dns3 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns3);\n\t\t\tif (cfg.dns4 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns4);\n\t\t\tfmessage(\"\\n\");\n\t\t}\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tenv_ibus_load();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// fs pre-processing:\n\t//  - build seccomp filters\n\t//  - create an empty /etc/ld.so.preload\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Build protocol filter: %s\\n\", cfg.protocol);\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\tPATH_FSECCOMP, \"protocol\", \"build\", cfg.protocol, RUN_SECCOMP_PROTOCOL);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\tif (arg_seccomp && (cfg.seccomp_list || cfg.seccomp_list_drop || cfg.seccomp_list_keep))\n\t\targ_seccomp_postexec = 1;\n#endif\n\n\t// need ld.so.preload if tracing or seccomp with any non-default lists\n\tbool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec;\n\t// for --appimage, --chroot and --overlay* we force NO_NEW_PRIVS\n\t// and drop all capabilities\n\tif (getuid() != 0 && (arg_appimage || cfg.chrootdir || arg_overlay)) {\n\t\tenforce_filters();\n\t\tneed_preload = arg_trace || arg_tracelog;\n\t}\n\n\t// trace pre-install\n\tif (need_preload)\n\t\tfs_trace_preload();\n\n\t// store hosts file\n\tif (cfg.hosts_file)\n\t\tfs_store_hosts_file();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_CHROOT\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (need_preload)\n\t\t\tfs_trace_preload();\n\t}\n\telse\n#endif\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\n\t\tfs_overlayfs();\n\telse\n#endif\n\t\tfs_basic_fs();\n\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private=directory feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private=directory feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private-home= feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private-home= feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev)\n\t\tfs_private_dev();\n\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-etc feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-etc feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/etc\", RUN_ETC_DIR, cfg.etc_private_keep);\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (need_preload)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\n\tif (arg_private_opt) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-opt feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-opt feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/opt\", RUN_OPT_DIR, cfg.opt_private_keep);\n\t\t}\n\t}\n\n\tif (arg_private_srv) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-srv feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-srv feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/srv\", RUN_SRV_DIR, cfg.srv_private_keep);\n\t\t}\n\t}\n\n\t// private-bin is disabled for appimages\n\tif (arg_private_bin && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-bin feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-bin feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \"%s,xauth\", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\n\t// private-lib is disabled for appimages\n\tif (arg_private_lib && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-lib feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-lib feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_lib();\n\t\t}\n\t}\n\n\tif (arg_private_cache) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-cache feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-cache feature is disabled in overlay\\n\");\n\t\telse\n\t\t\tfs_private_cache();\n\t}\n\n\tif (arg_private_tmp) {\n\t\t// private-tmp is implemented as a whitelist\n\t\tEUID_USER();\n\t\tfs_private_tmp();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// Session D-BUS\n\t//****************************\n\tif (arg_nodbus)\n\t\tdbus_session_disable();\n\n\n\t//****************************\n\t// hosts and hostname\n\t//****************************\n\tif (cfg.hostname)\n\t\tfs_hostname(cfg.hostname);\n\n\tif (cfg.hosts_file)\n\t\tfs_mount_hosts_file();\n\n\t//****************************\n\t// /etc overrides from the network namespace\n\t//****************************\n\tif (arg_netns)\n\t\tnetns_mounts(arg_netns);\n\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directory\n\t//****************************\n\tfs_proc_sys_dev_boot();\n\n\t//****************************\n\t// handle /mnt and /media\n\t//****************************\n\tif (checkcfg(CFG_DISABLE_MNT))\n\t\tfs_mnt(1);\n\telse if (arg_disable_mnt)\n\t\tfs_mnt(0);\n\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ...\n\tfs_whitelist();\n\n\t// ... followed by blacklist commands\n\tfs_blacklist(); // mkdir and mkfile are processed all over again\n\n\t//****************************\n\t// nosound/no3d/notv/novideo and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse if (!arg_noautopulse)\n\t\tpulseaudio_init();\n\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\n\tif (arg_notv)\n\t\tfs_dev_disable_tv();\n\n\tif (arg_nodvd)\n\t\tfs_dev_disable_dvd();\n\n\tif (arg_nou2f)\n\t        fs_dev_disable_u2f();\n\n\tif (arg_novideo)\n\t\tfs_dev_disable_video();\n\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (need_preload)\n\t\tfs_trace();\n\n\t//****************************\n\t// set dns\n\t//****************************\n\tfs_resolvconf();\n\n\t//****************************\n\t// fs post-processing\n\t//****************************\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tEUID_USER();\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\n\tif (!cwd) {\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t}\n\tif (arg_debug) {\n\t\tchar *cpath = get_current_dir_name();\n\t\tif (cpath) {\n\t\t\tprintf(\"Current directory: %s\\n\", cpath);\n\t\t\tfree(cpath);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\n\t// save original umask\n\tsave_umask();\n\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// save state of nonewprivs\n\tsave_nonewprivs();\n\n\t// set capabilities\n\tset_caps();\n\n\t// save cpu affinity mask to CPU_CFG file\n\tsave_cpu();\n\n\t// save cgroup in CGROUP_CFG file\n\tsave_cgroup();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n#ifdef SYS_socket\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install protocol filter: %s\\n\", cfg.protocol);\n\t\tseccomp_load(RUN_SECCOMP_PROTOCOL);\t// install filter\n\t\tprotocol_filter_save();\t// save filter in RUN_PROTOCOL_CFG\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_PROTOCOL);\n\t\t(void) rv;\n\t}\n#endif\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse\n\t\t\tseccomp_filter_drop();\n\n\t}\n\telse { // clean seccomp files under /run/firejail/mnt\n\t\tint rv = unlink(RUN_SECCOMP_CFG);\n\t\trv |= unlink(RUN_SECCOMP_32);\n\t\t(void) rv;\n\t}\n\n\tif (arg_memory_deny_write_execute) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install memory write&execute filter\\n\");\n\t\tseccomp_load(RUN_SECCOMP_MDWX);\t// install filter\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_MDWX);\n\t\t(void) rv;\n\t}\n#endif\n\n\t//****************************************\n\t// communicate progress of sandbox set up\n\t// to --join\n\t//****************************************\n\n\tFILE *rj = create_ready_for_join_file();\n\n\t//****************************************\n\t// create a new user namespace\n\t//     - too early to drop privileges\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfwarning(\"cannot create a new user namespace, going forward without it...\\n\");\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n\n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"noroot user namespace installed\\n\");\n\t\tset_caps();\n\t}\n\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif (prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {\n\t\t\tfwarning(\"cannot set NO_NEW_PRIVS, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\t\tif (force_nonewprivs) {\n\t\t\t\tfprintf(stderr, \"Error: NO_NEW_PRIVS required for this sandbox, exiting ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (arg_debug)\n\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t}\n\n\t//****************************************\n\t// drop privileges\n\t//****************************************\n\tdrop_privs(arg_nogroups);\n\n\t// kill the sandbox in case the parent died\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t//****************************************\n\t// set cpu affinity\n\t//****************************************\n\n\tif (cfg.cpus)\n\t\tset_cpu_affinity();\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\"fork\");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (checkcfg(CFG_APPARMOR) && arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\"firejail-default\")) {\n\t\t\t\tfwarning(\"Cannot confine the application using AppArmor.\\n\"\n\t\t\t\t\t\"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\"\n\t\t\t\t\t\"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\");\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\"AppArmor enabled\\n\");\n\t\t}\n#endif\n\t\t// set nice and rlimits\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\t\tset_rlimits();\n\n\t\tstart_application(0, rj);\n\t}\n\n\tfclose(rj);\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define CLONE_NEWUSER\t0x10000000"
    ],
    "globals_used": [
      "static int force_nonewprivs = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_stdin",
          "args": [],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "flush_stdin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "959-969",
          "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_application",
          "args": [
            "app_pid"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_application",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "252-357",
          "snippet": "static int monitor_application(pid_t app_pid) {\n\tEUID_ASSERT();\n\tmonitored_pid = app_pid;\n\n\t// block signals and install handler\n\tsigset_t oldmask, newmask;\n\tsigemptyset(&oldmask);\n\tsigemptyset(&newmask);\n\tsigaddset(&newmask, SIGTERM);\n\tsigaddset(&newmask, SIGINT);\n\tsigprocmask(SIG_BLOCK, &newmask, &oldmask);\n\tinstall_handler();\n\n\t// handle --timeout\n\tint options = 0;;\n\tunsigned timeout = 0;\n\tif (cfg.timeout) {\n\t\toptions = WNOHANG;\n\t\ttimeout = cfg.timeout;\n\t}\n\n\tint status = 0;\n\twhile (monitored_pid) {\n\t\tusleep(20000);\n\t\tchar *msg;\n\t\tif (asprintf(&msg, \"monitoring pid %d\\n\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tlogmsg(msg);\n\t\tif (arg_debug)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tfree(msg);\n\n\t\tpid_t rv;\n\t\tdo {\n\t\t\t// handle signals asynchronously\n\t\t\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\t\t\trv = waitpid(-1, &status, options);\n\n\t\t\t// block signals again\n\t\t\tsigprocmask(SIG_BLOCK, &newmask, NULL);\n\n\t\t\tif (rv == -1) { // we can get here if we have processes joining the sandbox (ECHILD)\n\t\t\t\tsleep(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// handle --timeout\n\t\t\tif (options) {\n\t\t\t\tif (--timeout == 0)  {\n\t\t\t\t\tkill(-1, SIGTERM);\n\t\t\t\t\tsleep(1);\n\t\t\t\t\tflush_stdin();\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsleep(1);\n\t\t\t}\n\t\t}\n\t\twhile(rv != monitored_pid);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Sandbox monitor: waitpid %d retval %d status %d\\n\", monitored_pid, rv, status);\n\n\t\tDIR *dir;\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t// sleep 2 seconds and try again\n\t\t\tsleep(2);\n\t\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent *entry;\n\t\tmonitored_pid = 0;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tunsigned pid;\n\t\t\tif (sscanf(entry->d_name, \"%u\", &pid) != 1)\n\t\t\t\tcontinue;\n\t\t\tif (pid == 1)\n\t\t\t\tcontinue;\n\n\t\t\t// todo: make this generic\n\t\t\t// Dillo browser leaves a dpid process running, we need to shut it down\n\t\t\tint found = 0;\n\t\t\tif (strcmp(cfg.command_name, \"dillo\") == 0) {\n\t\t\t\tchar *pidname = pid_proc_comm(pid);\n\t\t\t\tif (pidname && strcmp(pidname, \"dpid\") == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tfree(pidname);\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\n\t\t\tmonitored_pid = pid;\n\t\t\tbreak;\n\t\t}\n\t\tclosedir(dir);\n\n\t\tif (monitored_pid != 0 && arg_debug)\n\t\t\tprintf(\"Sandbox monitor: monitoring %d\\n\", monitored_pid);\n\t}\n\n\t// return the latest exit status.\n\treturn status;\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int monitored_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int monitored_pid = 0;\n\nstatic int monitor_application(pid_t app_pid) {\n\tEUID_ASSERT();\n\tmonitored_pid = app_pid;\n\n\t// block signals and install handler\n\tsigset_t oldmask, newmask;\n\tsigemptyset(&oldmask);\n\tsigemptyset(&newmask);\n\tsigaddset(&newmask, SIGTERM);\n\tsigaddset(&newmask, SIGINT);\n\tsigprocmask(SIG_BLOCK, &newmask, &oldmask);\n\tinstall_handler();\n\n\t// handle --timeout\n\tint options = 0;;\n\tunsigned timeout = 0;\n\tif (cfg.timeout) {\n\t\toptions = WNOHANG;\n\t\ttimeout = cfg.timeout;\n\t}\n\n\tint status = 0;\n\twhile (monitored_pid) {\n\t\tusleep(20000);\n\t\tchar *msg;\n\t\tif (asprintf(&msg, \"monitoring pid %d\\n\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tlogmsg(msg);\n\t\tif (arg_debug)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tfree(msg);\n\n\t\tpid_t rv;\n\t\tdo {\n\t\t\t// handle signals asynchronously\n\t\t\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\t\t\trv = waitpid(-1, &status, options);\n\n\t\t\t// block signals again\n\t\t\tsigprocmask(SIG_BLOCK, &newmask, NULL);\n\n\t\t\tif (rv == -1) { // we can get here if we have processes joining the sandbox (ECHILD)\n\t\t\t\tsleep(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// handle --timeout\n\t\t\tif (options) {\n\t\t\t\tif (--timeout == 0)  {\n\t\t\t\t\tkill(-1, SIGTERM);\n\t\t\t\t\tsleep(1);\n\t\t\t\t\tflush_stdin();\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsleep(1);\n\t\t\t}\n\t\t}\n\t\twhile(rv != monitored_pid);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Sandbox monitor: waitpid %d retval %d status %d\\n\", monitored_pid, rv, status);\n\n\t\tDIR *dir;\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t// sleep 2 seconds and try again\n\t\t\tsleep(2);\n\t\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent *entry;\n\t\tmonitored_pid = 0;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tunsigned pid;\n\t\t\tif (sscanf(entry->d_name, \"%u\", &pid) != 1)\n\t\t\t\tcontinue;\n\t\t\tif (pid == 1)\n\t\t\t\tcontinue;\n\n\t\t\t// todo: make this generic\n\t\t\t// Dillo browser leaves a dpid process running, we need to shut it down\n\t\t\tint found = 0;\n\t\t\tif (strcmp(cfg.command_name, \"dillo\") == 0) {\n\t\t\t\tchar *pidname = pid_proc_comm(pid);\n\t\t\t\tif (pidname && strcmp(pidname, \"dpid\") == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tfree(pidname);\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\n\t\t\tmonitored_pid = pid;\n\t\t\tbreak;\n\t\t}\n\t\tclosedir(dir);\n\n\t\tif (monitored_pid != 0 && arg_debug)\n\t\t\tprintf(\"Sandbox monitor: monitoring %d\\n\", monitored_pid);\n\t}\n\n\t// return the latest exit status.\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "rj"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_application",
          "args": [
            "0",
            "rj"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "start_application",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "432-566",
          "snippet": "void start_application(int no_sandbox, FILE *fp) {\n\t// set environment\n\tif (no_sandbox == 0) {\n\t\tenv_defaults();\n\t\tenv_apply();\n\t}\n\t// restore original umask\n\tumask(orig_umask);\n\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tint rv = ok_to_run(cfg.original_argv[cfg.original_program_index]);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\tif (rv)\n\t\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: no suitable %s executable found\\n\", cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid start_application(int no_sandbox, FILE *fp) {\n\t// set environment\n\tif (no_sandbox == 0) {\n\t\tenv_defaults();\n\t\tenv_apply();\n\t}\n\t// restore original umask\n\tumask(orig_umask);\n\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tint rv = ok_to_run(cfg.original_argv[cfg.original_program_index]);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\tif (rv)\n\t\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: no suitable %s executable found\\n\", cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_rlimits",
          "args": [],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "set_rlimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/rlimit.c",
          "lines": "24-129",
          "snippet": "void set_rlimits(void) {\n\tEUID_ASSERT();\n\t// resource limits\n\tstruct rlimit rl;\n\tif (arg_rlimit_cpu) {\n\t\tif (getrlimit(RLIMIT_CPU, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_cpu > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_cpu = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_cpu;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_cpu;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_CPU, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: max cpu time %llu\\n\", cfg.rlimit_cpu);\n\t}\n\n\tif (arg_rlimit_nofile) {\n\t\tif (getrlimit(RLIMIT_NOFILE, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_nofile > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_nofile = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_nofile;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_nofile;\n#ifdef HAVE_GCOV\t// gcov-instrumented programs might crash at this point\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_NOFILE, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: number of open file descriptors %llu\\n\", cfg.rlimit_nofile);\n\t}\n\n\tif (arg_rlimit_nproc) {\n\t\tif (getrlimit(RLIMIT_NPROC, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_nproc > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_nproc = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_nproc;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_nproc;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_NPROC, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: number of processes %llu\\n\", cfg.rlimit_nproc);\n\t}\n\n\tif (arg_rlimit_fsize) {\n\t\tif (getrlimit(RLIMIT_FSIZE, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_fsize > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_fsize = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_fsize;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_fsize;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_FSIZE, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum file size %llu\\n\", cfg.rlimit_fsize);\n\t}\n\n\tif (arg_rlimit_sigpending) {\n\t\tif (getrlimit(RLIMIT_SIGPENDING, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_sigpending > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_sigpending = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_sigpending;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_sigpending;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_SIGPENDING, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum number of signals pending %llu\\n\", cfg.rlimit_sigpending);\n\t}\n\n\tif (arg_rlimit_as) {\n\t\tif (getrlimit(RLIMIT_AS, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_as > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_as = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_as;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_as;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_AS, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum virtual memory %llu\\n\", cfg.rlimit_as);\n\t}\n}",
          "includes": [
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/resource.h>\n#include <sys/time.h>\n#include \"firejail.h\"\n\nvoid set_rlimits(void) {\n\tEUID_ASSERT();\n\t// resource limits\n\tstruct rlimit rl;\n\tif (arg_rlimit_cpu) {\n\t\tif (getrlimit(RLIMIT_CPU, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_cpu > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_cpu = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_cpu;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_cpu;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_CPU, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: max cpu time %llu\\n\", cfg.rlimit_cpu);\n\t}\n\n\tif (arg_rlimit_nofile) {\n\t\tif (getrlimit(RLIMIT_NOFILE, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_nofile > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_nofile = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_nofile;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_nofile;\n#ifdef HAVE_GCOV\t// gcov-instrumented programs might crash at this point\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_NOFILE, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: number of open file descriptors %llu\\n\", cfg.rlimit_nofile);\n\t}\n\n\tif (arg_rlimit_nproc) {\n\t\tif (getrlimit(RLIMIT_NPROC, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_nproc > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_nproc = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_nproc;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_nproc;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_NPROC, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: number of processes %llu\\n\", cfg.rlimit_nproc);\n\t}\n\n\tif (arg_rlimit_fsize) {\n\t\tif (getrlimit(RLIMIT_FSIZE, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_fsize > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_fsize = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_fsize;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_fsize;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_FSIZE, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum file size %llu\\n\", cfg.rlimit_fsize);\n\t}\n\n\tif (arg_rlimit_sigpending) {\n\t\tif (getrlimit(RLIMIT_SIGPENDING, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_sigpending > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_sigpending = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_sigpending;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_sigpending;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_SIGPENDING, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum number of signals pending %llu\\n\", cfg.rlimit_sigpending);\n\t}\n\n\tif (arg_rlimit_as) {\n\t\tif (getrlimit(RLIMIT_AS, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_as > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_as = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_as;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_as;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_AS, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum virtual memory %llu\\n\", cfg.rlimit_as);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nice",
          "args": [
            "cfg.nice"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "set_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "254-260",
          "snippet": "void set_nice(int inc) {\n\terrno = 0;\n\tint rv = nice(inc);\n\t(void) rv;\n\tif (errno)\n\t\tfwarning(\"cannot set nice value\\n\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid set_nice(int inc) {\n\terrno = 0;\n\tint rv = nice(inc);\n\t(void) rv;\n\tif (errno)\n\t\tfwarning(\"cannot set nice value\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"AppArmor enabled\\n\""
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwarning",
          "args": [
            "\"Cannot confine the application using AppArmor.\\n\"\n\t\t\t\t\t\"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\"\n\t\t\t\t\t\"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\""
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "fwarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "178-187",
          "snippet": "void fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_change_onexec",
          "args": [
            "\"firejail-default\""
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_APPARMOR"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/checkcfg.c",
          "lines": "35-213",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *xpra_extra_params = \"\";",
            "char *xvfb_screen = \"800x600x24\";",
            "char *xvfb_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *xpra_extra_params = \"\";\nchar *xvfb_screen = \"800x600x24\";\nchar *xvfb_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_affinity",
          "args": [],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_affinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cpu.c",
          "lines": "106-132",
          "snippet": "void set_cpu_affinity(void) {\n\t// set cpu affinity\n\tcpu_set_t mask;\n\tCPU_ZERO(&mask);\n\n\tint i;\n\tuint32_t m = 1;\n\tfor (i = 0; i < 32; i++, m <<= 1) {\n\t\tif (cfg.cpus & m)\n\t\t\tCPU_SET(i, &mask);\n\t}\n\n\tif (sched_setaffinity(0, sizeof(mask), &mask) == -1)\n\t\tfwarning(\"cannot set cpu affinity\\n\");\n\n        \t// verify cpu affinity\n\tcpu_set_t mask2;\n\tCPU_ZERO(&mask2);\n\tif (sched_getaffinity(0, sizeof(mask2), &mask2) == -1)\n\t\tfwarning(\"cannot verify cpu affinity\\n\");\n        \telse if (arg_debug) {\n\t        \tif (CPU_EQUAL(&mask, &mask2))\n        \t\t\tprintf(\"CPU affinity set\\n\");\n\t\telse\n        \t\t\tprintf(\"CPU affinity not set\\n\");\n        \t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <sched.h>\n#include \"firejail.h\"\n\nvoid set_cpu_affinity(void) {\n\t// set cpu affinity\n\tcpu_set_t mask;\n\tCPU_ZERO(&mask);\n\n\tint i;\n\tuint32_t m = 1;\n\tfor (i = 0; i < 32; i++, m <<= 1) {\n\t\tif (cfg.cpus & m)\n\t\t\tCPU_SET(i, &mask);\n\t}\n\n\tif (sched_setaffinity(0, sizeof(mask), &mask) == -1)\n\t\tfwarning(\"cannot set cpu affinity\\n\");\n\n        \t// verify cpu affinity\n\tcpu_set_t mask2;\n\tCPU_ZERO(&mask2);\n\tif (sched_getaffinity(0, sizeof(mask2), &mask2) == -1)\n\t\tfwarning(\"cannot verify cpu affinity\\n\");\n        \telse if (arg_debug) {\n\t        \tif (CPU_EQUAL(&mask, &mask2))\n        \t\t\tprintf(\"CPU affinity set\\n\");\n\t\telse\n        \t\t\tprintf(\"CPU affinity not set\\n\");\n        \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_PDEATHSIG",
            "SIGKILL",
            "0",
            "0",
            "0"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "arg_nogroups"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "121-142",
          "snippet": "void drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"NO_NEW_PRIVS set\\n\""
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: NO_NEW_PRIVS required for this sandbox, exiting ...\\n\""
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_GET_NO_NEW_PRIVS",
            "0",
            "0",
            "0",
            "0"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_NO_NEW_PRIVS",
            "1",
            "0",
            "0",
            "0"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_caps",
          "args": [],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "set_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "112-126",
          "snippet": "static void set_caps(void) {\n\tif (arg_caps_drop_all)\n\t\tcaps_drop_all();\n\telse if (arg_caps_drop)\n\t\tcaps_drop_list(arg_caps_list);\n\telse if (arg_caps_keep)\n\t\tcaps_keep_list(arg_caps_list);\n\telse if (arg_caps_default_filter)\n\t\tcaps_default_filter();\n\n\t// drop discretionary access control capabilities for root sandboxes\n\t// if caps.keep, the user has to set it manually in the list\n\tif (!arg_caps_keep)\n\t\tcaps_drop_dac_override();\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void set_caps(void) {\n\tif (arg_caps_drop_all)\n\t\tcaps_drop_all();\n\telse if (arg_caps_drop)\n\t\tcaps_drop_list(arg_caps_list);\n\telse if (arg_caps_keep)\n\t\tcaps_keep_list(arg_caps_list);\n\telse if (arg_caps_default_filter)\n\t\tcaps_default_filter();\n\n\t// drop discretionary access control capabilities for root sandboxes\n\t// if caps.keep, the user has to set it manually in the list\n\tif (!arg_caps_keep)\n\t\tcaps_drop_dac_override();\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"noroot user namespace installed\\n\""
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "parent_to_child_fds[0]"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_other",
          "args": [
            "parent_to_child_fds[0]"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "746-796",
          "snippet": "void wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nvoid wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_other",
          "args": [
            "child_to_parent_fds[1]"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "notify_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "798-807",
          "snippet": "void notify_other(int fd) {\n\tFILE* stream;\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tstream = fdopen(newfd, \"w\");\n\tfprintf(stream, \"arg_noroot=%d\\n\", arg_noroot);\n\tfflush(stream);\n\tfclose(stream);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid notify_other(int fd) {\n\tFILE* stream;\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tstream = fdopen(newfd, \"w\");\n\tfprintf(stream, \"arg_noroot=%d\\n\", arg_noroot);\n\tfflush(stream);\n\tfclose(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWUSER"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_nogroups",
          "args": [],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "save_nogroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "128-142",
          "snippet": "static void save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_ready_for_join_file",
          "args": [],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "create_ready_for_join_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "173-183",
          "snippet": "static FILE *create_ready_for_join_file(void) {\n\tFILE *fp = fopen(RUN_READY_FOR_JOIN, \"wxe\");\n\tif (fp) {\n\t\tASSERT_PERMS_STREAM(fp, 0, 0, 0644);\n\t\treturn fp;\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_READY_FOR_JOIN);\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic FILE *create_ready_for_join_file(void) {\n\tFILE *fp = fopen(RUN_READY_FOR_JOIN, \"wxe\");\n\tif (fp) {\n\t\tASSERT_PERMS_STREAM(fp, 0, 0, 0644);\n\t\treturn fp;\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_READY_FOR_JOIN);\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "RUN_SECCOMP_MDWX"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "359-366",
          "snippet": "int unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_unlink_t orig_unlink = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_unlink_t orig_unlink = NULL;\n\nint unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_load",
          "args": [
            "RUN_SECCOMP_MDWX"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/seccomp.c",
          "lines": "121-171",
          "snippet": "int seccomp_load(const char *fname) {\n\tassert(fname);\n\n\t// open filter file\n\tint fd = open(fname, O_RDONLY);\n\tif (fd == -1)\n\t\tgoto errexit;\n\n\t// calculate the number of entries\n\tint size = lseek(fd, 0, SEEK_END);\n\tif (size == -1)\n\t\tgoto errexit;\n\tunsigned short entries = (unsigned short) size / (unsigned short) sizeof(struct sock_filter);\n\tif (arg_debug)\n\t\tprintf(\"configuring %d seccomp entries in %s\\n\", entries, fname);\n\n\t// read filter\n\tstruct sock_filter *filter = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (filter == MAP_FAILED)\n\t\tgoto errexit;\n\n\t// close file\n\tclose(fd);\n\n\tFilterList *fl = malloc(sizeof(FilterList));\n\tif (!fl) {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\texit(1);\n\t}\n\tfl->next = filter_list_head;\n\tfl->prog.len = entries;\n\tfl->prog.filter = filter;\n\tfl->fname = strdup(fname);\n\tif (fl->fname == NULL)\n\t\terrExit(\"strdup\");\n\tfilter_list_head = fl;\n\n\tif (arg_debug && access(PATH_FSEC_PRINT, X_OK) == 0) {\n\t\tsbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2,\n\t\t\tPATH_FSEC_PRINT, fname);\n\t}\n\n\t// save the file name in seccomp list\n\tif (!load_file_list_flag)\n\t\tseccomp_save_file_list(fname);\n\n\treturn 0;\nerrexit:\n\tfprintf(stderr, \"Error: cannot read %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"firejail.h\"\n\nint seccomp_load(const char *fname) {\n\tassert(fname);\n\n\t// open filter file\n\tint fd = open(fname, O_RDONLY);\n\tif (fd == -1)\n\t\tgoto errexit;\n\n\t// calculate the number of entries\n\tint size = lseek(fd, 0, SEEK_END);\n\tif (size == -1)\n\t\tgoto errexit;\n\tunsigned short entries = (unsigned short) size / (unsigned short) sizeof(struct sock_filter);\n\tif (arg_debug)\n\t\tprintf(\"configuring %d seccomp entries in %s\\n\", entries, fname);\n\n\t// read filter\n\tstruct sock_filter *filter = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (filter == MAP_FAILED)\n\t\tgoto errexit;\n\n\t// close file\n\tclose(fd);\n\n\tFilterList *fl = malloc(sizeof(FilterList));\n\tif (!fl) {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\texit(1);\n\t}\n\tfl->next = filter_list_head;\n\tfl->prog.len = entries;\n\tfl->prog.filter = filter;\n\tfl->fname = strdup(fname);\n\tif (fl->fname == NULL)\n\t\terrExit(\"strdup\");\n\tfilter_list_head = fl;\n\n\tif (arg_debug && access(PATH_FSEC_PRINT, X_OK) == 0) {\n\t\tsbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2,\n\t\t\tPATH_FSEC_PRINT, fname);\n\t}\n\n\t// save the file name in seccomp list\n\tif (!load_file_list_flag)\n\t\tseccomp_save_file_list(fname);\n\n\treturn 0;\nerrexit:\n\tfprintf(stderr, \"Error: cannot read %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Install memory write&execute filter\\n\""
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_filter_drop",
          "args": [],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_filter_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/seccomp.c",
          "lines": "193-286",
          "snippet": "int seccomp_filter_drop(void) {\n\t// if we have multiple seccomp commands, only one of them is executed\n\t// in the following order:\n\t//\t- seccomp.drop list\n\t//\t- seccomp list\n\t//\t- seccomp\n\tif (cfg.seccomp_list_drop == NULL) {\n\t\t// default seccomp\n\t\tif (cfg.seccomp_list == NULL) {\n\t\t\tif (arg_seccomp_block_secondary)\n\t\t\t\tseccomp_filter_block_secondary();\n\t\t\telse {\n#if defined(__x86_64__)\n#if defined(__LP64__)\n\t\t\t\tseccomp_filter_32();\n#endif\n#endif\n\t\t\t}\n\t\t}\n\t\t// default seccomp filter with additional drop list\n\t\telse { // cfg.seccomp_list != NULL\n\t\t\tif (arg_seccomp_block_secondary)\n\t\t\t\tseccomp_filter_block_secondary();\n\t\t\telse {\n#if defined(__x86_64__)\n#if defined(__LP64__)\n\t\t\t\tseccomp_filter_32();\n#endif\n#endif\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Build default+drop seccomp filter\\n\");\n\n\t\t\t// build the seccomp filter as a regular user\n\t\t\tint rv;\n\t\t\tif (arg_allow_debuggers)\n\t\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 7,\n\t\t\t\t\t      PATH_FSECCOMP, \"default\", \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list, \"allow-debuggers\");\n\t\t\telse\n\t\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 6,\n\t\t\t\t\t      PATH_FSECCOMP, \"default\", \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list);\n\t\t\tif (rv)\n\t\t\t\texit(rv);\n\n\t\t\t// optimize the new filter\n\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2, PATH_FSEC_OPTIMIZE, RUN_SECCOMP_CFG);\n\t\t\tif (rv)\n\t\t\t\texit(rv);\n\t\t}\n\t}\n\n\t// drop list without defaults - secondary filters are not installed\n\t// except when secondary architectures are explicitly blocked\n\telse { // cfg.seccomp_list_drop != NULL\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tseccomp_filter_block_secondary();\n\t\tif (arg_debug)\n\t\t\tprintf(\"Build drop seccomp filter\\n\");\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv;\n\t\tif (arg_allow_debuggers)\n\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 6,\n\t\t\t\t      PATH_FSECCOMP, \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list_drop,  \"allow-debuggers\");\n\t\telse\n\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\t\tPATH_FSECCOMP, \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list_drop);\n\n\t\tif (rv)\n\t\t\texit(rv);\n\n\t\t// optimize the drop filter\n\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2, PATH_FSEC_OPTIMIZE, RUN_SECCOMP_CFG);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\n\t// load the filter\n\tif (seccomp_load(RUN_SECCOMP_CFG) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"seccomp filter configured\\n\");\n\t}\n\n\tif (arg_debug && access(PATH_FSEC_PRINT, X_OK) == 0) {\n\t\tstruct stat st;\n\t\tif (stat(RUN_SECCOMP_POSTEXEC, &st) != -1 && st.st_size != 0) {\n\t\t\tprintf(\"configuring postexec seccomp filter in %s\\n\", RUN_SECCOMP_POSTEXEC);\n\t\t\tsbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2,\n\t\t\t\t  PATH_FSEC_PRINT, RUN_SECCOMP_POSTEXEC);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"firejail.h\"\n\nint seccomp_filter_drop(void) {\n\t// if we have multiple seccomp commands, only one of them is executed\n\t// in the following order:\n\t//\t- seccomp.drop list\n\t//\t- seccomp list\n\t//\t- seccomp\n\tif (cfg.seccomp_list_drop == NULL) {\n\t\t// default seccomp\n\t\tif (cfg.seccomp_list == NULL) {\n\t\t\tif (arg_seccomp_block_secondary)\n\t\t\t\tseccomp_filter_block_secondary();\n\t\t\telse {\n#if defined(__x86_64__)\n#if defined(__LP64__)\n\t\t\t\tseccomp_filter_32();\n#endif\n#endif\n\t\t\t}\n\t\t}\n\t\t// default seccomp filter with additional drop list\n\t\telse { // cfg.seccomp_list != NULL\n\t\t\tif (arg_seccomp_block_secondary)\n\t\t\t\tseccomp_filter_block_secondary();\n\t\t\telse {\n#if defined(__x86_64__)\n#if defined(__LP64__)\n\t\t\t\tseccomp_filter_32();\n#endif\n#endif\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Build default+drop seccomp filter\\n\");\n\n\t\t\t// build the seccomp filter as a regular user\n\t\t\tint rv;\n\t\t\tif (arg_allow_debuggers)\n\t\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 7,\n\t\t\t\t\t      PATH_FSECCOMP, \"default\", \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list, \"allow-debuggers\");\n\t\t\telse\n\t\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 6,\n\t\t\t\t\t      PATH_FSECCOMP, \"default\", \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list);\n\t\t\tif (rv)\n\t\t\t\texit(rv);\n\n\t\t\t// optimize the new filter\n\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2, PATH_FSEC_OPTIMIZE, RUN_SECCOMP_CFG);\n\t\t\tif (rv)\n\t\t\t\texit(rv);\n\t\t}\n\t}\n\n\t// drop list without defaults - secondary filters are not installed\n\t// except when secondary architectures are explicitly blocked\n\telse { // cfg.seccomp_list_drop != NULL\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tseccomp_filter_block_secondary();\n\t\tif (arg_debug)\n\t\t\tprintf(\"Build drop seccomp filter\\n\");\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv;\n\t\tif (arg_allow_debuggers)\n\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 6,\n\t\t\t\t      PATH_FSECCOMP, \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list_drop,  \"allow-debuggers\");\n\t\telse\n\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\t\tPATH_FSECCOMP, \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list_drop);\n\n\t\tif (rv)\n\t\t\texit(rv);\n\n\t\t// optimize the drop filter\n\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2, PATH_FSEC_OPTIMIZE, RUN_SECCOMP_CFG);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\n\t// load the filter\n\tif (seccomp_load(RUN_SECCOMP_CFG) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"seccomp filter configured\\n\");\n\t}\n\n\tif (arg_debug && access(PATH_FSEC_PRINT, X_OK) == 0) {\n\t\tstruct stat st;\n\t\tif (stat(RUN_SECCOMP_POSTEXEC, &st) != -1 && st.st_size != 0) {\n\t\t\tprintf(\"configuring postexec seccomp filter in %s\\n\", RUN_SECCOMP_POSTEXEC);\n\t\t\tsbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2,\n\t\t\t\t  PATH_FSEC_PRINT, RUN_SECCOMP_POSTEXEC);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_filter_keep",
          "args": [],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_filter_keep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/seccomp.c",
          "lines": "289-326",
          "snippet": "int seccomp_filter_keep(void) {\n\t// secondary filters are not installed except when secondary\n\t// architectures are explicitly blocked\n\tif (arg_seccomp_block_secondary)\n\t\tseccomp_filter_block_secondary();\n\n\tif (arg_debug)\n\t\tprintf(\"Build keep seccomp filter\\n\");\n\n\t// build the seccomp filter as a regular user\n\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t PATH_FSECCOMP, \"keep\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list_keep);\n\n\tif (rv) {\n\t\tfprintf(stderr, \"Error: cannot configure seccomp filter\\n\");\n\t\texit(rv);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"seccomp filter configured\\n\");\n\n\t// load the filter\n\tif (seccomp_load(RUN_SECCOMP_CFG) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"seccomp filter configured\\n\");\n\t}\n\n\tif (arg_debug && access(PATH_FSEC_PRINT, X_OK) == 0) {\n\t\tstruct stat st;\n\t\tif (stat(RUN_SECCOMP_POSTEXEC, &st) != -1 && st.st_size != 0) {\n\t\t\tprintf(\"configuring postexec seccomp filter in %s\\n\", RUN_SECCOMP_POSTEXEC);\n\t\t\tsbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2,\n\t\t\t\t  PATH_FSEC_PRINT, RUN_SECCOMP_POSTEXEC);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"firejail.h\"\n\nint seccomp_filter_keep(void) {\n\t// secondary filters are not installed except when secondary\n\t// architectures are explicitly blocked\n\tif (arg_seccomp_block_secondary)\n\t\tseccomp_filter_block_secondary();\n\n\tif (arg_debug)\n\t\tprintf(\"Build keep seccomp filter\\n\");\n\n\t// build the seccomp filter as a regular user\n\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t PATH_FSECCOMP, \"keep\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list_keep);\n\n\tif (rv) {\n\t\tfprintf(stderr, \"Error: cannot configure seccomp filter\\n\");\n\t\texit(rv);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"seccomp filter configured\\n\");\n\n\t// load the filter\n\tif (seccomp_load(RUN_SECCOMP_CFG) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"seccomp filter configured\\n\");\n\t}\n\n\tif (arg_debug && access(PATH_FSEC_PRINT, X_OK) == 0) {\n\t\tstruct stat st;\n\t\tif (stat(RUN_SECCOMP_POSTEXEC, &st) != -1 && st.st_size != 0) {\n\t\t\tprintf(\"configuring postexec seccomp filter in %s\\n\", RUN_SECCOMP_POSTEXEC);\n\t\t\tsbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2,\n\t\t\t\t  PATH_FSEC_PRINT, RUN_SECCOMP_POSTEXEC);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "protocol_filter_save",
          "args": [],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "protocol_filter_save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/protocol.c",
          "lines": "25-33",
          "snippet": "void protocol_filter_save(void) {\n\t// save protocol filter configuration in PROTOCOL_CFG\n\tFILE *fp = fopen(RUN_PROTOCOL_CFG, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\\n\", cfg.protocol);\n\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\tfclose(fp);\n}",
          "includes": [
            "#include \"../include/seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_filter_save(void) {\n\t// save protocol filter configuration in PROTOCOL_CFG\n\tFILE *fp = fopen(RUN_PROTOCOL_CFG, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\\n\", cfg.protocol);\n\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Install protocol filter: %s\\n\"",
            "cfg.protocol"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_cgroup",
          "args": [],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "save_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cgroup.c",
          "lines": "25-45",
          "snippet": "void save_cgroup(void) {\n\tif (cfg.cgroup == NULL)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_CGROUP_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"%s\", cfg.cgroup);\n\t\tfflush(0);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tif (fclose(fp))\n\t\t\tgoto errout;\n\t}\n\telse\n\t\tgoto errout;\n\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: cannot save cgroup\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nvoid save_cgroup(void) {\n\tif (cfg.cgroup == NULL)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_CGROUP_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"%s\", cfg.cgroup);\n\t\tfflush(0);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tif (fclose(fp))\n\t\t\tgoto errout;\n\t}\n\telse\n\t\tgoto errout;\n\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: cannot save cgroup\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_cpu",
          "args": [],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "save_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/cpu.c",
          "lines": "74-88",
          "snippet": "void save_cpu(void) {\n\tif (cfg.cpus == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_CPU_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"%x\\n\", cfg.cpus);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save cpu affinity mask\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <sched.h>\n#include \"firejail.h\"\n\nvoid save_cpu(void) {\n\tif (cfg.cpus == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_CPU_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"%x\\n\", cfg.cpus);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save cpu affinity mask\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_nonewprivs",
          "args": [],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "save_nonewprivs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "144-158",
          "snippet": "static void save_nonewprivs(void) {\n\tif (arg_nonewprivs == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_NONEWPRIVS_CFG, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nonewprivs state\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void save_nonewprivs(void) {\n\tif (arg_nonewprivs == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_NONEWPRIVS_CFG, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nonewprivs state\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_umask",
          "args": [],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "save_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "160-171",
          "snippet": "static void save_umask(void) {\n\tFILE *fp = fopen(RUN_UMASK_FILE, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"%o\\n\", orig_umask);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save umask\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void save_umask(void) {\n\tFILE *fp = fopen(RUN_UMASK_FILE, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"%o\\n\", orig_umask);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save umask\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_xorg",
          "args": [],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "x11_xorg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "1079-1221",
          "snippet": "void x11_xorg(void) {\n#ifdef HAVE_X11\n\n\t// check xauth utility is present in the system\n\tstruct stat s;\n\tif (stat(\"/usr/bin/xauth\", &s) == -1) {\n\t\tfprintf(stderr, \"Error: xauth utility not found in /usr/bin. Please install it:\\n\"\n\t\t\t\"   Debian/Ubuntu/Mint: sudo apt-get install xauth\\n\");\n\t\texit(1);\n\t}\n\tif (s.st_uid != 0 && s.st_gid != 0) {\n\t\tfprintf(stderr, \"Error: invalid /usr/bin/xauth executable\\n\");\n\t\texit(1);\n\t}\n\n\t// get DISPLAY env\n\tchar *display = getenv(\"DISPLAY\");\n\tif (!display) {\n\t\tfputs(\"Error: --x11=xorg requires an 'outer' X11 server to use.\\n\", stderr);\n\t\texit(1);\n\t}\n\n\t// temporarily mount a tempfs on top of /tmp directory\n\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\terrExit(\"mounting /tmp\");\n\n\t// create the temporary .Xauthority file\n\tif (arg_debug)\n\t\tprintf(\"Generating a new .Xauthority file\\n\");\n\tchar tmpfname[] = \"/tmp/.tmpXauth-XXXXXX\";\n\tint fd = mkstemp(tmpfname);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Error: cannot create .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (fchown(fd, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tclose(fd);\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(1);\n\t\tclearenv();\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\texeclp(\"/usr/bin/xauth\", \"/usr/bin/xauth\", \"-v\", \"-f\", tmpfname,\n\t\t\t\"generate\", display, \"MIT-MAGIC-COOKIE-1\", \"untrusted\", NULL);\n\n\t\t_exit(127);\n\t}\n\n\t// wait for the xauth process to finish\n\tint status;\n\tif (waitpid(child, &status, 0) != child)\n\t\terrExit(\"waitpid\");\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t/* success */\n\t}\n\telse if (WIFEXITED(status)) {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: xauth: exit %d\\n\",\n\t\t\tWEXITSTATUS(status));\n\t\texit(1);\n\t}\n\telse if (WIFSIGNALED(status)) {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: xauth: %s\\n\",\n\t\t\tstrsignal(WTERMSIG(status)));\n\t\texit(1);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: \"\n\t\t\t\"xauth: un-decodable exit status %04x\\n\", status);\n\t\texit(1);\n\t}\n\n\t// move the temporary file in RUN_XAUTHORITY_SEC_FILE in order to have it deleted\n\t// automatically when the sandbox is closed (rename doesn't work)\n\t\t\t\t\t\t  // root needed\n\tif (copy_file(tmpfname, RUN_XAUTHORITY_SEC_FILE, getuid(), getgid(), 0600)) {\n\t\tfprintf(stderr, \"Error: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\t/* coverity[toctou] */\n\tunlink(tmpfname);\n\tumount(\"/tmp\");\n\n\t// remount RUN_XAUTHORITY_SEC_FILE noexec, nodev, nosuid\n\tfs_noexec(RUN_XAUTHORITY_SEC_FILE);\n\n\t// Ensure there is already a file in the usual location, so that bind-mount below will work.\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(dest, &s) == -1) {\n\t\ttouch_file_as_user(dest, 0600);\n\t\tif (stat(dest, &s) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s\\n\", dest);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// get a file descriptor for .Xauthority\n\tfd = safe_fd(dest, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\t// check if the actual mount destination is a user owned regular file\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != getuid()) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: .Xauthority is a symbolic link\\n\");\n\t\telse\n\t\t\tfprintf(stderr, \"Error: .Xauthority is not a user owned regular file\\n\");\n\t\texit(1);\n\t}\n\t// preserve a read-only mount\n\tstruct statvfs vfs;\n\tif (fstatvfs(fd, &vfs) == -1)\n\t\terrExit(\"fstatvfs\");\n\tif ((vfs.f_flag & MS_RDONLY) == MS_RDONLY)\n\t\tfs_rdonly(RUN_XAUTHORITY_SEC_FILE);\n\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(RUN_XAUTHORITY_SEC_FILE, proc, \"none\", MS_BIND, \"mode=0600\") == -1) {\n\t\tfprintf(stderr, \"Error: cannot mount the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tfree(proc);\n\tclose(fd);\n\t// check /proc/self/mountinfo to confirm the mount is ok\n\tMountData *mptr = get_last_mount();\n\tif (strcmp(mptr->dir, dest) != 0 || strcmp(mptr->fstype, \"tmpfs\") != 0)\n\t\terrLogExit(\"invalid .Xauthority mount\");\n\n\tASSERT_PERMS(dest, getuid(), getgid(), 0600);\n\tfree(dest);\n#endif\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_xorg(void) {\n#ifdef HAVE_X11\n\n\t// check xauth utility is present in the system\n\tstruct stat s;\n\tif (stat(\"/usr/bin/xauth\", &s) == -1) {\n\t\tfprintf(stderr, \"Error: xauth utility not found in /usr/bin. Please install it:\\n\"\n\t\t\t\"   Debian/Ubuntu/Mint: sudo apt-get install xauth\\n\");\n\t\texit(1);\n\t}\n\tif (s.st_uid != 0 && s.st_gid != 0) {\n\t\tfprintf(stderr, \"Error: invalid /usr/bin/xauth executable\\n\");\n\t\texit(1);\n\t}\n\n\t// get DISPLAY env\n\tchar *display = getenv(\"DISPLAY\");\n\tif (!display) {\n\t\tfputs(\"Error: --x11=xorg requires an 'outer' X11 server to use.\\n\", stderr);\n\t\texit(1);\n\t}\n\n\t// temporarily mount a tempfs on top of /tmp directory\n\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\terrExit(\"mounting /tmp\");\n\n\t// create the temporary .Xauthority file\n\tif (arg_debug)\n\t\tprintf(\"Generating a new .Xauthority file\\n\");\n\tchar tmpfname[] = \"/tmp/.tmpXauth-XXXXXX\";\n\tint fd = mkstemp(tmpfname);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Error: cannot create .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (fchown(fd, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tclose(fd);\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(1);\n\t\tclearenv();\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\texeclp(\"/usr/bin/xauth\", \"/usr/bin/xauth\", \"-v\", \"-f\", tmpfname,\n\t\t\t\"generate\", display, \"MIT-MAGIC-COOKIE-1\", \"untrusted\", NULL);\n\n\t\t_exit(127);\n\t}\n\n\t// wait for the xauth process to finish\n\tint status;\n\tif (waitpid(child, &status, 0) != child)\n\t\terrExit(\"waitpid\");\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t/* success */\n\t}\n\telse if (WIFEXITED(status)) {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: xauth: exit %d\\n\",\n\t\t\tWEXITSTATUS(status));\n\t\texit(1);\n\t}\n\telse if (WIFSIGNALED(status)) {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: xauth: %s\\n\",\n\t\t\tstrsignal(WTERMSIG(status)));\n\t\texit(1);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: \"\n\t\t\t\"xauth: un-decodable exit status %04x\\n\", status);\n\t\texit(1);\n\t}\n\n\t// move the temporary file in RUN_XAUTHORITY_SEC_FILE in order to have it deleted\n\t// automatically when the sandbox is closed (rename doesn't work)\n\t\t\t\t\t\t  // root needed\n\tif (copy_file(tmpfname, RUN_XAUTHORITY_SEC_FILE, getuid(), getgid(), 0600)) {\n\t\tfprintf(stderr, \"Error: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\t/* coverity[toctou] */\n\tunlink(tmpfname);\n\tumount(\"/tmp\");\n\n\t// remount RUN_XAUTHORITY_SEC_FILE noexec, nodev, nosuid\n\tfs_noexec(RUN_XAUTHORITY_SEC_FILE);\n\n\t// Ensure there is already a file in the usual location, so that bind-mount below will work.\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(dest, &s) == -1) {\n\t\ttouch_file_as_user(dest, 0600);\n\t\tif (stat(dest, &s) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s\\n\", dest);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// get a file descriptor for .Xauthority\n\tfd = safe_fd(dest, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\t// check if the actual mount destination is a user owned regular file\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != getuid()) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: .Xauthority is a symbolic link\\n\");\n\t\telse\n\t\t\tfprintf(stderr, \"Error: .Xauthority is not a user owned regular file\\n\");\n\t\texit(1);\n\t}\n\t// preserve a read-only mount\n\tstruct statvfs vfs;\n\tif (fstatvfs(fd, &vfs) == -1)\n\t\terrExit(\"fstatvfs\");\n\tif ((vfs.f_flag & MS_RDONLY) == MS_RDONLY)\n\t\tfs_rdonly(RUN_XAUTHORITY_SEC_FILE);\n\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(RUN_XAUTHORITY_SEC_FILE, proc, \"none\", MS_BIND, \"mode=0600\") == -1) {\n\t\tfprintf(stderr, \"Error: cannot mount the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tfree(proc);\n\tclose(fd);\n\t// check /proc/self/mountinfo to confirm the mount is ok\n\tMountData *mptr = get_last_mount();\n\tif (strcmp(mptr->dir, dest) != 0 || strcmp(mptr->fstype, \"tmpfs\") != 0)\n\t\terrLogExit(\"invalid .Xauthority mount\");\n\n\tASSERT_PERMS(dest, getuid(), getgid(), 0600);\n\tfree(dest);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_x11",
          "args": [],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "fs_x11",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/x11.c",
          "lines": "1224-1285",
          "snippet": "void fs_x11(void) {\n#ifdef HAVE_X11\n\tint display = x11_display();\n\tif (display <= 0)\n\t\treturn;\n\n\tchar *x11file;\n\tif (asprintf(&x11file, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat x11stat;\n\tif (stat(x11file, &x11stat) == -1 || !S_ISSOCK(x11stat.st_mode)) {\n\t\tfree(x11file);\n\t\treturn;\n\t}\n\n\tif (arg_debug || arg_debug_whitelists)\n\t\tfprintf(stderr, \"Masking all X11 sockets except %s\\n\", x11file);\n\n\t// Move the real /tmp/.X11-unix to a scratch location\n\t// so we can still access x11file after we mount a\n\t// tmpfs over /tmp/.X11-unix.\n\tint rv = mkdir(RUN_WHITELIST_X11_DIR, 0700);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (set_perms(RUN_WHITELIST_X11_DIR, 0, 0, 0700))\n\t\terrExit(\"set_perms\");\n\n\tif (mount(\"/tmp/.X11-unix\", RUN_WHITELIST_X11_DIR, 0, MS_BIND|MS_REC, 0) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// This directory must be mode 1777, or Xlib will barf.\n\tif (mount(\"tmpfs\", \"/tmp/.X11-unix\", \"tmpfs\",\n\t\tMS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,\n\t\t\"mode=1777,uid=0,gid=0\") < 0)\n\t\terrExit(\"mounting tmpfs on /tmp/.X11-unix\");\n\tfs_logger(\"tmpfs /tmp/.X11-unix\");\n\n\t// create an empty file which will have the desired socket bind-mounted over it\n\tint fd = open(x11file, O_RDWR|O_CREAT|O_EXCL, x11stat.st_mode & ~S_IFMT);\n\tif (fd < 0)\n\t\terrExit(x11file);\n\tif (fchown(fd, x11stat.st_uid, x11stat.st_gid))\n\t\terrExit(\"fchown\");\n\tclose(fd);\n\n\t// do the mount\n\tchar *wx11file;\n\tif (asprintf(&wx11file, \"%s/X%d\", RUN_WHITELIST_X11_DIR, display) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wx11file, x11file, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"whitelist\", x11file);\n\n\tfree(x11file);\n\tfree(wx11file);\n\n\t// block access to RUN_WHITELIST_X11_DIR\n\tif (mount(RUN_RO_DIR, RUN_WHITELIST_X11_DIR, 0, MS_BIND, 0) < 0)\n\t\terrExit(\"mount\");\n\tfs_logger2(\"blacklist\", RUN_WHITELIST_X11_DIR);\n#endif\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_x11(void) {\n#ifdef HAVE_X11\n\tint display = x11_display();\n\tif (display <= 0)\n\t\treturn;\n\n\tchar *x11file;\n\tif (asprintf(&x11file, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat x11stat;\n\tif (stat(x11file, &x11stat) == -1 || !S_ISSOCK(x11stat.st_mode)) {\n\t\tfree(x11file);\n\t\treturn;\n\t}\n\n\tif (arg_debug || arg_debug_whitelists)\n\t\tfprintf(stderr, \"Masking all X11 sockets except %s\\n\", x11file);\n\n\t// Move the real /tmp/.X11-unix to a scratch location\n\t// so we can still access x11file after we mount a\n\t// tmpfs over /tmp/.X11-unix.\n\tint rv = mkdir(RUN_WHITELIST_X11_DIR, 0700);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (set_perms(RUN_WHITELIST_X11_DIR, 0, 0, 0700))\n\t\terrExit(\"set_perms\");\n\n\tif (mount(\"/tmp/.X11-unix\", RUN_WHITELIST_X11_DIR, 0, MS_BIND|MS_REC, 0) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// This directory must be mode 1777, or Xlib will barf.\n\tif (mount(\"tmpfs\", \"/tmp/.X11-unix\", \"tmpfs\",\n\t\tMS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,\n\t\t\"mode=1777,uid=0,gid=0\") < 0)\n\t\terrExit(\"mounting tmpfs on /tmp/.X11-unix\");\n\tfs_logger(\"tmpfs /tmp/.X11-unix\");\n\n\t// create an empty file which will have the desired socket bind-mounted over it\n\tint fd = open(x11file, O_RDWR|O_CREAT|O_EXCL, x11stat.st_mode & ~S_IFMT);\n\tif (fd < 0)\n\t\terrExit(x11file);\n\tif (fchown(fd, x11stat.st_uid, x11stat.st_gid))\n\t\terrExit(\"fchown\");\n\tclose(fd);\n\n\t// do the mount\n\tchar *wx11file;\n\tif (asprintf(&wx11file, \"%s/X%d\", RUN_WHITELIST_X11_DIR, display) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wx11file, x11file, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"whitelist\", x11file);\n\n\tfree(x11file);\n\tfree(wx11file);\n\n\t// block access to RUN_WHITELIST_X11_DIR\n\tif (mount(RUN_RO_DIR, RUN_WHITELIST_X11_DIR, 0, MS_BIND, 0) < 0)\n\t\terrExit(\"mount\");\n\tfs_logger2(\"blacklist\", RUN_WHITELIST_X11_DIR);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cpath"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Current directory: %s\\n\"",
            "cpath"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_dir_name",
          "args": [],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "cfg.homedir"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "fchdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtracelog/libtracelog.c",
          "lines": "684-708",
          "snippet": "int fchdir(int fd) {\n#ifdef DEBUG\n\tprintf(\"%s %d\\n\", __FUNCTION__, fd);\n#endif\n\tif (!orig_fchdir)\n\t\torig_fchdir = (orig_fchdir_t)dlsym(RTLD_NEXT, \"fchdir\");\n\n\tfree(cwd);\n\tchar *pathname=malloc(PATH_MAX);\n\tif (pathname) {\n\t\tif (snprintf(pathname,PATH_MAX,\"/proc/self/fd/%d\", fd)>0) {\n\t\t\tcwd = realpath(pathname, NULL);\n\t\t} else {\n\t\t\tcwd = NULL;\n\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t}\n\t\tfree(pathname);\n\t} else {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tcwd = NULL;\n\t}\n\n\tint rv = orig_fchdir(fd);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char* cwd = NULL;",
            "static orig_fchdir_t orig_fchdir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char* cwd = NULL;\nstatic orig_fchdir_t orig_fchdir = NULL;\n\nint fchdir(int fd) {\n#ifdef DEBUG\n\tprintf(\"%s %d\\n\", __FUNCTION__, fd);\n#endif\n\tif (!orig_fchdir)\n\t\torig_fchdir = (orig_fchdir_t)dlsym(RTLD_NEXT, \"fchdir\");\n\n\tfree(cwd);\n\tchar *pathname=malloc(PATH_MAX);\n\tif (pathname) {\n\t\tif (snprintf(pathname,PATH_MAX,\"/proc/self/fd/%d\", fd)>0) {\n\t\t\tcwd = realpath(pathname, NULL);\n\t\t} else {\n\t\t\tcwd = NULL;\n\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t}\n\t\tfree(pathname);\n\t} else {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tcwd = NULL;\n\t}\n\n\tint rv = orig_fchdir(fd);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cfg.homedir",
            "&s"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger_change_owner",
          "args": [],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "115-118",
          "snippet": "void fs_logger_change_owner(void) {\n\tif (chown(RUN_FSLOGGER_FILE, 0, 0) == -1)\n\t\terrExit(\"chown\");\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger_change_owner(void) {\n\tif (chown(RUN_FSLOGGER_FILE, 0, 0) == -1)\n\t\terrExit(\"chown\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger_print",
          "args": [],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "91-113",
          "snippet": "void fs_logger_print(void) {\n\tif (!head)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_FSLOGGER_FILE, \"a\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\tSET_PERMS_STREAM_NOERR(fp, getuid(), getgid(), 0644);\n\n\tFsMsg *ptr = head;\n\twhile (ptr) {\n\t\tfprintf(fp, \"%s\\n\", ptr->msg);\n\t\tFsMsg *next = ptr->next;\n\t\t// remove message\n\t\tfree(ptr->msg);\n\t\tfree(ptr);\n\t\tptr = next;\n\t}\n\thead = NULL;\n\tfclose(fp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FsMsg *head = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic FsMsg *head = NULL;\n\nvoid fs_logger_print(void) {\n\tif (!head)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_FSLOGGER_FILE, \"a\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\tSET_PERMS_STREAM_NOERR(fp, getuid(), getgid(), 0644);\n\n\tFsMsg *ptr = head;\n\twhile (ptr) {\n\t\tfprintf(fp, \"%s\\n\", ptr->msg);\n\t\tFsMsg *next = ptr->next;\n\t\t// remove message\n\t\tfree(ptr->msg);\n\t\tfree(ptr);\n\t\tptr = next;\n\t}\n\thead = NULL;\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_resolvconf",
          "args": [],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "fs_resolvconf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_hostname.c",
          "lines": "91-187",
          "snippet": "void fs_resolvconf(void) {\n\tif (cfg.dns1 == NULL)\n\t\treturn;\n\n\tif (arg_debug)\n\t\tprintf(\"mirroring /etc directory\\n\");\n\tif (mkdir(RUN_DNS_ETC, 0755))\n\t\terrExit(\"mkdir\");\n\tfs_logger(\"tmpfs /etc\");\n\n\tDIR *dir = opendir(\"/etc\");\n\tif (!dir)\n\t\terrExit(\"opendir\");\n\n\tstruct stat s;\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// for resolv.conf we create a brand new file\n\t\tif (strcmp(entry->d_name, \"resolv.conf\") == 0)\n\t\t\tcontinue;\n//\t\tprintf(\"linking %s\\n\", entry->d_name);\n\n\t\tchar *src;\n\t\tif (asprintf(&src, \"/etc/%s\", entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(src, &s) != 0) {\n\t\t\tfree(src);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *dest;\n\t\tif (asprintf(&dest, \"%s/%s\", RUN_DNS_ETC, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tint symlink_done = 0;\n\t\tif (is_link(src)) {\n\t\t\tchar *rp =realpath(src, NULL);\n\t\t\tif (rp == NULL) {\n\t\t\t\tfree(src);\n\t\t\t\tfree(dest);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (symlink(rp, dest))\n\t\t\t\terrExit(\"symlink\");\n\t\t\telse\n\t\t\t\tsymlink_done = 1;\n\t\t}\n\t\telse if (S_ISDIR(s.st_mode))\n\t\t\tcreate_empty_dir_as_root(dest, s.st_mode);\n\t\telse\n\t\t\tcreate_empty_file_as_root(dest, s.st_mode);\n\n\t\t// bind-mount src on top of dest\n\t\tif (!symlink_done) {\n\t\t\tif (mount(src, dest, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind mirroring /etc\");\n\t\t}\n\t\tfs_logger2(\"clone\", src);\n\n\t\tfree(src);\n\t\tfree(dest);\n\t}\n\tclosedir(dir);\n\n\t// mount bind our private etc directory on top of /etc\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of /etc\\n\", RUN_DNS_ETC);\n\tif (mount(RUN_DNS_ETC, \"/etc\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind mirroring /etc\");\n\tfs_logger(\"mount /etc\");\n\n\tif (arg_debug)\n\t\tprintf(\"Creating a new /etc/resolv.conf file\\n\");\n\tFILE *fp = fopen(\"/etc/resolv.conf\", \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot create /etc/resolv.conf file\\n\");\n\t\texit(1);\n\t}\n\n\tif (cfg.dns1)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns1);\n\tif (cfg.dns2)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns2);\n\tif (cfg.dns3)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns3);\n\tif (cfg.dns4)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns4);\n\n\t// mode and owner\n\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\n\tfclose(fp);\n\n\tfs_logger(\"create /etc/resolv.conf\");\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_resolvconf(void) {\n\tif (cfg.dns1 == NULL)\n\t\treturn;\n\n\tif (arg_debug)\n\t\tprintf(\"mirroring /etc directory\\n\");\n\tif (mkdir(RUN_DNS_ETC, 0755))\n\t\terrExit(\"mkdir\");\n\tfs_logger(\"tmpfs /etc\");\n\n\tDIR *dir = opendir(\"/etc\");\n\tif (!dir)\n\t\terrExit(\"opendir\");\n\n\tstruct stat s;\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// for resolv.conf we create a brand new file\n\t\tif (strcmp(entry->d_name, \"resolv.conf\") == 0)\n\t\t\tcontinue;\n//\t\tprintf(\"linking %s\\n\", entry->d_name);\n\n\t\tchar *src;\n\t\tif (asprintf(&src, \"/etc/%s\", entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(src, &s) != 0) {\n\t\t\tfree(src);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *dest;\n\t\tif (asprintf(&dest, \"%s/%s\", RUN_DNS_ETC, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tint symlink_done = 0;\n\t\tif (is_link(src)) {\n\t\t\tchar *rp =realpath(src, NULL);\n\t\t\tif (rp == NULL) {\n\t\t\t\tfree(src);\n\t\t\t\tfree(dest);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (symlink(rp, dest))\n\t\t\t\terrExit(\"symlink\");\n\t\t\telse\n\t\t\t\tsymlink_done = 1;\n\t\t}\n\t\telse if (S_ISDIR(s.st_mode))\n\t\t\tcreate_empty_dir_as_root(dest, s.st_mode);\n\t\telse\n\t\t\tcreate_empty_file_as_root(dest, s.st_mode);\n\n\t\t// bind-mount src on top of dest\n\t\tif (!symlink_done) {\n\t\t\tif (mount(src, dest, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind mirroring /etc\");\n\t\t}\n\t\tfs_logger2(\"clone\", src);\n\n\t\tfree(src);\n\t\tfree(dest);\n\t}\n\tclosedir(dir);\n\n\t// mount bind our private etc directory on top of /etc\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of /etc\\n\", RUN_DNS_ETC);\n\tif (mount(RUN_DNS_ETC, \"/etc\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind mirroring /etc\");\n\tfs_logger(\"mount /etc\");\n\n\tif (arg_debug)\n\t\tprintf(\"Creating a new /etc/resolv.conf file\\n\");\n\tFILE *fp = fopen(\"/etc/resolv.conf\", \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot create /etc/resolv.conf file\\n\");\n\t\texit(1);\n\t}\n\n\tif (cfg.dns1)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns1);\n\tif (cfg.dns2)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns2);\n\tif (cfg.dns3)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns3);\n\tif (cfg.dns4)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns4);\n\n\t// mode and owner\n\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\n\tfclose(fp);\n\n\tfs_logger(\"create /etc/resolv.conf\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_trace",
          "args": [],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "fs_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_trace.c",
          "lines": "46-77",
          "snippet": "void fs_trace(void) {\n\t// create the new ld.so.preload file and mount-bind it\n\tif (arg_debug)\n\t\tprintf(\"Create the new ld.so.preload file\\n\");\n\n\tFILE *fp = fopen(RUN_LDPRELOAD_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tconst char *prefix = RUN_FIREJAIL_LIB_DIR;\n\n\tif (arg_trace) {\n\t\tfprintf(fp, \"%s/libtrace.so\\n\", prefix);\n\t}\n\telse if (arg_tracelog) {\n\t\tfprintf(fp, \"%s/libtracelog.so\\n\", prefix);\n\t\tfmessage(\"Blacklist violations are logged to syslog\\n\");\n\t}\n\tif (arg_seccomp_postexec) {\n\t\tfprintf(fp, \"%s/libpostexecseccomp.so\\n\", prefix);\n\t\tfmessage(\"Post-exec seccomp protector enabled\\n\");\n\t}\n\n\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\tfclose(fp);\n\n\t// mount the new preload file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new ld.so.preload file\\n\");\n\tif (mount(RUN_LDPRELOAD_FILE, \"/etc/ld.so.preload\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind ld.so.preload\");\n\tfs_logger(\"create /etc/ld.so.preload\");\n}",
          "includes": [
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_trace(void) {\n\t// create the new ld.so.preload file and mount-bind it\n\tif (arg_debug)\n\t\tprintf(\"Create the new ld.so.preload file\\n\");\n\n\tFILE *fp = fopen(RUN_LDPRELOAD_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tconst char *prefix = RUN_FIREJAIL_LIB_DIR;\n\n\tif (arg_trace) {\n\t\tfprintf(fp, \"%s/libtrace.so\\n\", prefix);\n\t}\n\telse if (arg_tracelog) {\n\t\tfprintf(fp, \"%s/libtracelog.so\\n\", prefix);\n\t\tfmessage(\"Blacklist violations are logged to syslog\\n\");\n\t}\n\tif (arg_seccomp_postexec) {\n\t\tfprintf(fp, \"%s/libpostexecseccomp.so\\n\", prefix);\n\t\tfmessage(\"Post-exec seccomp protector enabled\\n\");\n\t}\n\n\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\tfclose(fp);\n\n\t// mount the new preload file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new ld.so.preload file\\n\");\n\tif (mount(RUN_LDPRELOAD_FILE, \"/etc/ld.so.preload\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind ld.so.preload\");\n\tfs_logger(\"create /etc/ld.so.preload\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_dev_disable_video",
          "args": [],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "fs_dev_disable_video",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_dev.c",
          "lines": "343-350",
          "snippet": "void fs_dev_disable_video(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_VIDEO)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/sysmacros.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/sysmacros.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};\n\nvoid fs_dev_disable_video(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_VIDEO)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_dev_disable_u2f",
          "args": [],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "fs_dev_disable_u2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_dev.c",
          "lines": "379-386",
          "snippet": "void fs_dev_disable_u2f(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_U2F)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/sysmacros.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/sysmacros.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};\n\nvoid fs_dev_disable_u2f(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_U2F)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_dev_disable_dvd",
          "args": [],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "fs_dev_disable_dvd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_dev.c",
          "lines": "370-377",
          "snippet": "void fs_dev_disable_dvd(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_DVD)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/sysmacros.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/sysmacros.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};\n\nvoid fs_dev_disable_dvd(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_DVD)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_dev_disable_tv",
          "args": [],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "fs_dev_disable_tv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_dev.c",
          "lines": "361-368",
          "snippet": "void fs_dev_disable_tv(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_TV)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/sysmacros.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/sysmacros.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};\n\nvoid fs_dev_disable_tv(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_TV)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_dev_disable_3d",
          "args": [],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "fs_dev_disable_3d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_dev.c",
          "lines": "352-359",
          "snippet": "void fs_dev_disable_3d(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_3D)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/sysmacros.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/sysmacros.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};\n\nvoid fs_dev_disable_3d(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_3D)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pulseaudio_init",
          "args": [],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "pulseaudio_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/pulseaudio.c",
          "lines": "73-184",
          "snippet": "void pulseaudio_init(void) {\n\tstruct stat s;\n\n\t// do we have pulseaudio in the system?\n\tif (stat(\"/etc/pulse/client.conf\", &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"/etc/pulse/client.conf not found\\n\");\n\t\treturn;\n\t}\n\n\t// create the new user pulseaudio directory\n\tif (mkdir(RUN_PULSE_DIR, 0700) == -1)\n\t\terrExit(\"mkdir\");\n\t// mount it nosuid, noexec, nodev\n\tfs_noexec(RUN_PULSE_DIR);\n\n\t// create the new client.conf file\n\tchar *pulsecfg = NULL;\n\tif (asprintf(&pulsecfg, \"%s/client.conf\", RUN_PULSE_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (copy_file(\"/etc/pulse/client.conf\", pulsecfg, -1, -1, 0644)) // root needed\n\t\terrExit(\"copy_file\");\n\tFILE *fp = fopen(pulsecfg, \"a\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\", \"\\nenable-shm = no\\n\");\n\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\tfclose(fp);\n\t// hand over the directory to the user\n\tif (set_perms(RUN_PULSE_DIR, getuid(), getgid(), 0700))\n\t\terrExit(\"set_perms\");\n\n\t// create ~/.config/pulse directory if not present\n\tchar *homeusercfg;\n\tif (asprintf(&homeusercfg, \"%s/.config\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(homeusercfg, &s) == -1) {\n\t\tif (create_empty_dir_as_user(homeusercfg, 0700))\n\t\t\tfs_logger2(\"create\", homeusercfg);\n\t}\n\telse if (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", homeusercfg);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", homeusercfg);\n\t\texit(1);\n\t}\n\tfree(homeusercfg);\n\n\tif (asprintf(&homeusercfg, \"%s/.config/pulse\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(homeusercfg, &s) == -1) {\n\t\tif (create_empty_dir_as_user(homeusercfg, 0700))\n\t\t\tfs_logger2(\"create\", homeusercfg);\n\t}\n\telse if (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", homeusercfg);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", homeusercfg);\n\t\texit(1);\n\t}\n\n\t// if we have ~/.config/pulse mount the new directory, else set environment variable.\n\tif (stat(homeusercfg, &s) == 0) {\n\t\t// get a file descriptor for ~/.config/pulse, fails if there is any symlink\n\t\tint fd = safe_fd(homeusercfg, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\terrExit(\"safe_fd\");\n\t\t// confirm the actual mount destination is owned by the user\n\t\tif (fstat(fd, &s) == -1)\n\t\t\terrExit(\"fstat\");\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", homeusercfg);\n\t\t\texit(1);\n\t\t}\n\t\t// preserve a read-only mount\n\t\tstruct statvfs vfs;\n\t\tif (fstatvfs(fd, &vfs) == -1)\n\t\t\terrExit(\"fstatvfs\");\n\t\tif ((vfs.f_flag & MS_RDONLY) == MS_RDONLY)\n\t\t\tfs_rdonly(RUN_PULSE_DIR);\n\t\t// mount via the link in /proc/self/fd\n\t\tchar *proc;\n\t\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(RUN_PULSE_DIR, proc, \"none\", MS_BIND, NULL) < 0)\n\t\t\terrExit(\"mount pulseaudio\");\n\t\tfs_logger2(\"tmpfs\", homeusercfg);\n\t\tfree(proc);\n\t\tclose(fd);\n\t\t// check /proc/self/mountinfo to confirm the mount is ok\n\t\tMountData *mptr = get_last_mount();\n\t\tif (strcmp(mptr->dir, homeusercfg) != 0 || strcmp(mptr->fstype, \"tmpfs\") != 0)\n\t\t\terrLogExit(\"invalid pulseaudio mount\");\n\n\t\tchar *p;\n\t\tif (asprintf(&p, \"%s/client.conf\", homeusercfg) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tfs_logger2(\"create\", p);\n\t\tfree(p);\n\t}\n\n\telse {\n\t\t// set environment\n\t\tif (setenv(\"PULSE_CLIENTCONFIG\", pulsecfg, 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\n\tfree(pulsecfg);\n\tfree(homeusercfg);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <dirent.h>",
            "#include <sys/mount.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid pulseaudio_init(void) {\n\tstruct stat s;\n\n\t// do we have pulseaudio in the system?\n\tif (stat(\"/etc/pulse/client.conf\", &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"/etc/pulse/client.conf not found\\n\");\n\t\treturn;\n\t}\n\n\t// create the new user pulseaudio directory\n\tif (mkdir(RUN_PULSE_DIR, 0700) == -1)\n\t\terrExit(\"mkdir\");\n\t// mount it nosuid, noexec, nodev\n\tfs_noexec(RUN_PULSE_DIR);\n\n\t// create the new client.conf file\n\tchar *pulsecfg = NULL;\n\tif (asprintf(&pulsecfg, \"%s/client.conf\", RUN_PULSE_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (copy_file(\"/etc/pulse/client.conf\", pulsecfg, -1, -1, 0644)) // root needed\n\t\terrExit(\"copy_file\");\n\tFILE *fp = fopen(pulsecfg, \"a\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\", \"\\nenable-shm = no\\n\");\n\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\tfclose(fp);\n\t// hand over the directory to the user\n\tif (set_perms(RUN_PULSE_DIR, getuid(), getgid(), 0700))\n\t\terrExit(\"set_perms\");\n\n\t// create ~/.config/pulse directory if not present\n\tchar *homeusercfg;\n\tif (asprintf(&homeusercfg, \"%s/.config\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(homeusercfg, &s) == -1) {\n\t\tif (create_empty_dir_as_user(homeusercfg, 0700))\n\t\t\tfs_logger2(\"create\", homeusercfg);\n\t}\n\telse if (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", homeusercfg);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", homeusercfg);\n\t\texit(1);\n\t}\n\tfree(homeusercfg);\n\n\tif (asprintf(&homeusercfg, \"%s/.config/pulse\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(homeusercfg, &s) == -1) {\n\t\tif (create_empty_dir_as_user(homeusercfg, 0700))\n\t\t\tfs_logger2(\"create\", homeusercfg);\n\t}\n\telse if (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", homeusercfg);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", homeusercfg);\n\t\texit(1);\n\t}\n\n\t// if we have ~/.config/pulse mount the new directory, else set environment variable.\n\tif (stat(homeusercfg, &s) == 0) {\n\t\t// get a file descriptor for ~/.config/pulse, fails if there is any symlink\n\t\tint fd = safe_fd(homeusercfg, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\terrExit(\"safe_fd\");\n\t\t// confirm the actual mount destination is owned by the user\n\t\tif (fstat(fd, &s) == -1)\n\t\t\terrExit(\"fstat\");\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", homeusercfg);\n\t\t\texit(1);\n\t\t}\n\t\t// preserve a read-only mount\n\t\tstruct statvfs vfs;\n\t\tif (fstatvfs(fd, &vfs) == -1)\n\t\t\terrExit(\"fstatvfs\");\n\t\tif ((vfs.f_flag & MS_RDONLY) == MS_RDONLY)\n\t\t\tfs_rdonly(RUN_PULSE_DIR);\n\t\t// mount via the link in /proc/self/fd\n\t\tchar *proc;\n\t\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(RUN_PULSE_DIR, proc, \"none\", MS_BIND, NULL) < 0)\n\t\t\terrExit(\"mount pulseaudio\");\n\t\tfs_logger2(\"tmpfs\", homeusercfg);\n\t\tfree(proc);\n\t\tclose(fd);\n\t\t// check /proc/self/mountinfo to confirm the mount is ok\n\t\tMountData *mptr = get_last_mount();\n\t\tif (strcmp(mptr->dir, homeusercfg) != 0 || strcmp(mptr->fstype, \"tmpfs\") != 0)\n\t\t\terrLogExit(\"invalid pulseaudio mount\");\n\n\t\tchar *p;\n\t\tif (asprintf(&p, \"%s/client.conf\", homeusercfg) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tfs_logger2(\"create\", p);\n\t\tfree(p);\n\t}\n\n\telse {\n\t\t// set environment\n\t\tif (setenv(\"PULSE_CLIENTCONFIG\", pulsecfg, 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\n\tfree(pulsecfg);\n\tfree(homeusercfg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_dev_disable_sound",
          "args": [],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "fs_dev_disable_sound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_dev.c",
          "lines": "317-341",
          "snippet": "void fs_dev_disable_sound(void) {\n\tunsigned i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_SOUND)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n\n\t// disable all jack sockets in /dev/shm\n\tglob_t globbuf;\n\tint globerr = glob(\"/dev/shm/jack*\", GLOB_NOSORT, NULL, &globbuf);\n\tif (globerr)\n\t\treturn;\n\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\tif (is_link(path)) {\n\t\t\tfwarning(\"skipping nosound for %s because it is a symbolic link\\n\", path);\n\t\t\tcontinue;\n\t\t}\n\t\tdisable_file_or_dir(path);\n\t}\n\tglobfree(&globbuf);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/sysmacros.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/sysmacros.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};\n\nvoid fs_dev_disable_sound(void) {\n\tunsigned i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_SOUND)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n\n\t// disable all jack sockets in /dev/shm\n\tglob_t globbuf;\n\tint globerr = glob(\"/dev/shm/jack*\", GLOB_NOSORT, NULL, &globbuf);\n\tif (globerr)\n\t\treturn;\n\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\tif (is_link(path)) {\n\t\t\tfwarning(\"skipping nosound for %s because it is a symbolic link\\n\", path);\n\t\t\tcontinue;\n\t\t}\n\t\tdisable_file_or_dir(path);\n\t}\n\tglobfree(&globbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pulseaudio_disable",
          "args": [],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "pulseaudio_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/pulseaudio.c",
          "lines": "30-69",
          "snippet": "void pulseaudio_disable(void) {\n\tif (arg_debug)\n\t\tprintf(\"disable pulseaudio\\n\");\n\t// blacklist user config directory\n\tdisable_file_path(cfg.homedir, \".config/pulse\");\n\n\n\t// blacklist pulseaudio socket in XDG_RUNTIME_DIR\n\tchar *name = getenv(\"XDG_RUNTIME_DIR\");\n\tif (name)\n\t\tdisable_file_path(name, \"pulse/native\");\n\n\t// try the default location anyway\n\tchar *path;\n\tif (asprintf(&path, \"/run/user/%d\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\tdisable_file_path(path, \"pulse/native\");\n\tfree(path);\n\n\n\n\t// blacklist any pulse* file in /tmp directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tdisable_file_path(\"/tmp\", entry->d_name);\n\t\t}\n\t}\n\n\tclosedir(dir);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <dirent.h>",
            "#include <sys/mount.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid pulseaudio_disable(void) {\n\tif (arg_debug)\n\t\tprintf(\"disable pulseaudio\\n\");\n\t// blacklist user config directory\n\tdisable_file_path(cfg.homedir, \".config/pulse\");\n\n\n\t// blacklist pulseaudio socket in XDG_RUNTIME_DIR\n\tchar *name = getenv(\"XDG_RUNTIME_DIR\");\n\tif (name)\n\t\tdisable_file_path(name, \"pulse/native\");\n\n\t// try the default location anyway\n\tchar *path;\n\tif (asprintf(&path, \"/run/user/%d\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\tdisable_file_path(path, \"pulse/native\");\n\tfree(path);\n\n\n\n\t// blacklist any pulse* file in /tmp directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tdisable_file_path(\"/tmp\", entry->d_name);\n\t\t}\n\t}\n\n\tclosedir(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_blacklist",
          "args": [],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "fs_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "246-434",
          "snippet": "void fs_blacklist(void) {\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\n\tsize_t noblacklist_c = 0;\n\tsize_t noblacklist_m = 32;\n\tchar **noblacklist = calloc(noblacklist_m, sizeof(*noblacklist));\n\n\tif (noblacklist == NULL)\n\t\terrExit(\"failed allocating memory for noblacklist entries\");\n\n\twhile (entry) {\n\t\tOPERATION op = OPERATION_MAX;\n\t\tchar *ptr;\n\n\t\t// whitelist commands handled by fs_whitelist()\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0 ||\n\t\t    strncmp(entry->data, \"nowhitelist \", 12) == 0 ||\n\t\t   *entry->data == '\\0') {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process bind command\n\t\tif (strncmp(entry->data, \"bind \", 5) == 0)  {\n\t\t\tstruct stat s;\n\t\t\tchar *dname1 = entry->data + 5;\n\t\t\tchar *dname2 = split_comma(dname1);\n\t\t\tif (dname2 == NULL ||\n\t\t\t    stat(dname1, &s) == -1 ||\n\t\t\t    stat(dname2, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: invalid bind command, directory missing\\n\");\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// mount --bind olddir newdir\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", dname1, dname2);\n\t\t\t// preserve dname2 mode and ownership\n\t\t\tif (mount(dname1, dname2, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (set_perms(dname2,  s.st_uid, s.st_gid,s.st_mode))\n\t\t\t\terrExit(\"set_perms\");\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Process noblacklist command\n\t\tif (strncmp(entry->data, \"noblacklist \", 12) == 0) {\n\t\t\tchar **enames;\n\t\t\tint i;\n\n\t\t\tif (strncmp(entry->data + 12, \"${PATH}\", 7) == 0) {\n\t\t\t\t// expand ${PATH} macro\n\t\t\t\tchar **paths = build_paths();\n\t\t\t\tunsigned int npaths = count_paths();\n\t\t\t\tenames = calloc(npaths, sizeof(char *));\n\t\t\t\tif (!enames)\n\t\t\t\t\terrExit(\"calloc\");\n\n\t\t\t\tfor (i = 0; paths[i]; i++) {\n\t\t\t\t\tif (asprintf(&enames[i], \"%s%s\", paths[i],\n\t\t\t\t\t\tentry->data + 19) == -1)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t}\n\t\t\t\tassert(enames[npaths-1] == 0);\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// expand ${HOME} macro if found or pass as is\n\t\t\t\tenames = calloc(2, sizeof(char *));\n\t\t\t\tif (!enames)\n\t\t\t\t\terrExit(\"calloc\");\n\t\t\t\tenames[0] = expand_macros(entry->data + 12);\n\t\t\t\tassert(enames[1] == 0);\n\t\t\t}\n\n\t\t\tfor (i = 0; enames[i]; i++) {\n\t\t\t\tif (noblacklist_c >= noblacklist_m) {\n\t\t\t\t\tnoblacklist_m *= 2;\n\t\t\t\t\tnoblacklist = realloc(noblacklist, sizeof(*noblacklist) * noblacklist_m);\n\t\t\t\t\tif (noblacklist == NULL)\n\t\t\t\t\t\terrExit(\"failed increasing memory for noblacklist entries\");\n\t\t\t\t}\n\t\t\t\tnoblacklist[noblacklist_c++] = enames[i];\n\t\t\t}\n\n\t\t\tfree(enames);\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process blacklist command\n\t\tif (strncmp(entry->data, \"blacklist \", 10) == 0)  {\n\t\t\tptr = entry->data + 10;\n\t\t\top = BLACKLIST_FILE;\n\t\t}\n\t\telse if (strncmp(entry->data, \"blacklist-nolog \", 16) == 0)  {\n\t\t\tptr = entry->data + 16;\n\t\t\top = BLACKLIST_NOLOG;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-only \", 10) == 0) {\n\t\t\tptr = entry->data + 10;\n\t\t\top = MOUNT_READONLY;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-write \", 11) == 0) {\n\t\t\tptr = entry->data + 11;\n\t\t\top = MOUNT_RDWR;\n\t\t}\n\t\telse if (strncmp(entry->data, \"noexec \", 7) == 0) {\n\t\t\tptr = entry->data + 7;\n\t\t\top = MOUNT_NOEXEC;\n\t\t}\n\t\telse if (strncmp(entry->data, \"tmpfs \", 6) == 0) {\n\t\t\tptr = entry->data + 6;\n\t\t\top = MOUNT_TMPFS;\n\t\t}\n\t\telse if (strncmp(entry->data, \"mkdir \", 6) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkdir(entry->data + 6);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (strncmp(entry->data, \"mkfile \", 7) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkfile(entry->data + 7);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid profile line %s\\n\", entry->data);\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replace home macro in blacklist array\n\t\tchar *new_name = expand_macros(ptr);\n\t\tptr = new_name;\n\n\t\t// expand path macro - look for the file in /usr/local/bin,  /usr/local/sbin, /bin, /usr/bin, /sbin and  /usr/sbin directories\n\t\tif (ptr) {\n\t\t\tif (strncmp(ptr, \"${PATH}\", 7) == 0) {\n\t\t\t\tchar *fname = ptr + 7;\n\t\t\t\tsize_t fname_len = strlen(fname);\n\t\t\t\tchar **paths = build_paths(); //{\"/usr/local/bin\", \"/usr/local/sbin\", \"/bin\", \"/usr/bin/\", \"/sbin\", \"/usr/sbin\", NULL};\n\t\t\t\tint i = 0;\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tchar *path = paths[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tchar newname[strlen(path) + fname_len + 1];\n\t\t\t\t\tsprintf(newname, \"%s%s\", path, fname);\n\t\t\t\t\tglobbing(op, newname, (const char**)noblacklist, noblacklist_c);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tglobbing(op, ptr, (const char**)noblacklist, noblacklist_c);\n\t\t}\n\n\t\tif (new_name)\n\t\t\tfree(new_name);\n\t\tentry = entry->next;\n\t}\n\n\tsize_t i;\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\t// noblacklist checking\n\tfor (i = 0; i < nbcheck_size; i++)\n\t\tif (!arg_quiet && !nbcheck[i])\n\t\t\tprintf(\"TESTING warning: noblacklist %s not matched by a proper blacklist command in disable*.inc\\n\",\n\t\t\t\t noblacklist[i]);\n\n\t// free memory\n\tif (nbcheck) {\n\t\tfree(nbcheck);\n\t\tnbcheck = NULL;\n\t\tnbcheck_size = 0;\n\t}\n#endif\n\tfor (i = 0; i < noblacklist_c; i++)\n\t\tfree(noblacklist[i]);\n\tfree(noblacklist);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_blacklist(void) {\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\n\tsize_t noblacklist_c = 0;\n\tsize_t noblacklist_m = 32;\n\tchar **noblacklist = calloc(noblacklist_m, sizeof(*noblacklist));\n\n\tif (noblacklist == NULL)\n\t\terrExit(\"failed allocating memory for noblacklist entries\");\n\n\twhile (entry) {\n\t\tOPERATION op = OPERATION_MAX;\n\t\tchar *ptr;\n\n\t\t// whitelist commands handled by fs_whitelist()\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0 ||\n\t\t    strncmp(entry->data, \"nowhitelist \", 12) == 0 ||\n\t\t   *entry->data == '\\0') {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process bind command\n\t\tif (strncmp(entry->data, \"bind \", 5) == 0)  {\n\t\t\tstruct stat s;\n\t\t\tchar *dname1 = entry->data + 5;\n\t\t\tchar *dname2 = split_comma(dname1);\n\t\t\tif (dname2 == NULL ||\n\t\t\t    stat(dname1, &s) == -1 ||\n\t\t\t    stat(dname2, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: invalid bind command, directory missing\\n\");\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// mount --bind olddir newdir\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", dname1, dname2);\n\t\t\t// preserve dname2 mode and ownership\n\t\t\tif (mount(dname1, dname2, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (set_perms(dname2,  s.st_uid, s.st_gid,s.st_mode))\n\t\t\t\terrExit(\"set_perms\");\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Process noblacklist command\n\t\tif (strncmp(entry->data, \"noblacklist \", 12) == 0) {\n\t\t\tchar **enames;\n\t\t\tint i;\n\n\t\t\tif (strncmp(entry->data + 12, \"${PATH}\", 7) == 0) {\n\t\t\t\t// expand ${PATH} macro\n\t\t\t\tchar **paths = build_paths();\n\t\t\t\tunsigned int npaths = count_paths();\n\t\t\t\tenames = calloc(npaths, sizeof(char *));\n\t\t\t\tif (!enames)\n\t\t\t\t\terrExit(\"calloc\");\n\n\t\t\t\tfor (i = 0; paths[i]; i++) {\n\t\t\t\t\tif (asprintf(&enames[i], \"%s%s\", paths[i],\n\t\t\t\t\t\tentry->data + 19) == -1)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t}\n\t\t\t\tassert(enames[npaths-1] == 0);\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// expand ${HOME} macro if found or pass as is\n\t\t\t\tenames = calloc(2, sizeof(char *));\n\t\t\t\tif (!enames)\n\t\t\t\t\terrExit(\"calloc\");\n\t\t\t\tenames[0] = expand_macros(entry->data + 12);\n\t\t\t\tassert(enames[1] == 0);\n\t\t\t}\n\n\t\t\tfor (i = 0; enames[i]; i++) {\n\t\t\t\tif (noblacklist_c >= noblacklist_m) {\n\t\t\t\t\tnoblacklist_m *= 2;\n\t\t\t\t\tnoblacklist = realloc(noblacklist, sizeof(*noblacklist) * noblacklist_m);\n\t\t\t\t\tif (noblacklist == NULL)\n\t\t\t\t\t\terrExit(\"failed increasing memory for noblacklist entries\");\n\t\t\t\t}\n\t\t\t\tnoblacklist[noblacklist_c++] = enames[i];\n\t\t\t}\n\n\t\t\tfree(enames);\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process blacklist command\n\t\tif (strncmp(entry->data, \"blacklist \", 10) == 0)  {\n\t\t\tptr = entry->data + 10;\n\t\t\top = BLACKLIST_FILE;\n\t\t}\n\t\telse if (strncmp(entry->data, \"blacklist-nolog \", 16) == 0)  {\n\t\t\tptr = entry->data + 16;\n\t\t\top = BLACKLIST_NOLOG;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-only \", 10) == 0) {\n\t\t\tptr = entry->data + 10;\n\t\t\top = MOUNT_READONLY;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-write \", 11) == 0) {\n\t\t\tptr = entry->data + 11;\n\t\t\top = MOUNT_RDWR;\n\t\t}\n\t\telse if (strncmp(entry->data, \"noexec \", 7) == 0) {\n\t\t\tptr = entry->data + 7;\n\t\t\top = MOUNT_NOEXEC;\n\t\t}\n\t\telse if (strncmp(entry->data, \"tmpfs \", 6) == 0) {\n\t\t\tptr = entry->data + 6;\n\t\t\top = MOUNT_TMPFS;\n\t\t}\n\t\telse if (strncmp(entry->data, \"mkdir \", 6) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkdir(entry->data + 6);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (strncmp(entry->data, \"mkfile \", 7) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkfile(entry->data + 7);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid profile line %s\\n\", entry->data);\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replace home macro in blacklist array\n\t\tchar *new_name = expand_macros(ptr);\n\t\tptr = new_name;\n\n\t\t// expand path macro - look for the file in /usr/local/bin,  /usr/local/sbin, /bin, /usr/bin, /sbin and  /usr/sbin directories\n\t\tif (ptr) {\n\t\t\tif (strncmp(ptr, \"${PATH}\", 7) == 0) {\n\t\t\t\tchar *fname = ptr + 7;\n\t\t\t\tsize_t fname_len = strlen(fname);\n\t\t\t\tchar **paths = build_paths(); //{\"/usr/local/bin\", \"/usr/local/sbin\", \"/bin\", \"/usr/bin/\", \"/sbin\", \"/usr/sbin\", NULL};\n\t\t\t\tint i = 0;\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tchar *path = paths[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tchar newname[strlen(path) + fname_len + 1];\n\t\t\t\t\tsprintf(newname, \"%s%s\", path, fname);\n\t\t\t\t\tglobbing(op, newname, (const char**)noblacklist, noblacklist_c);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tglobbing(op, ptr, (const char**)noblacklist, noblacklist_c);\n\t\t}\n\n\t\tif (new_name)\n\t\t\tfree(new_name);\n\t\tentry = entry->next;\n\t}\n\n\tsize_t i;\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\t// noblacklist checking\n\tfor (i = 0; i < nbcheck_size; i++)\n\t\tif (!arg_quiet && !nbcheck[i])\n\t\t\tprintf(\"TESTING warning: noblacklist %s not matched by a proper blacklist command in disable*.inc\\n\",\n\t\t\t\t noblacklist[i]);\n\n\t// free memory\n\tif (nbcheck) {\n\t\tfree(nbcheck);\n\t\tnbcheck = NULL;\n\t\tnbcheck_size = 0;\n\t}\n#endif\n\tfor (i = 0; i < noblacklist_c; i++)\n\t\tfree(noblacklist[i]);\n\tfree(noblacklist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_whitelist",
          "args": [],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "fs_whitelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_whitelist.c",
          "lines": "331-1070",
          "snippet": "void fs_whitelist(void) {\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\n\tif (asprintf(&runuser, \"/run/user/%u\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\trunuser_len = strlen(runuser);\n\thomedir_len = strlen(cfg.homedir);\n\n\tchar *new_name = NULL;\n\tint home_dir = 0;\t// /home/user directory flag\n\tint tmp_dir = 0;\t// /tmp directory flag\n\tint media_dir = 0;\t// /media directory flag\n\tint mnt_dir = 0;\t// /mnt directory flag\n\tint var_dir = 0;\t\t// /var directory flag\n\tint dev_dir = 0;\t\t// /dev directory flag\n\tint opt_dir = 0;\t\t// /opt directory flag\n\tint srv_dir = 0;                // /srv directory flag\n\tint etc_dir = 0;                // /etc directory flag\n\tint share_dir = 0;                // /usr/share directory flag\n\tint module_dir = 0;                // /sys/module directory flag\n\tint run_dir = 0;                // /run/user/$uid directory flag\n\n\tsize_t nowhitelist_c = 0;\n\tsize_t nowhitelist_m = 32;\n\tchar **nowhitelist = calloc(nowhitelist_m, sizeof(*nowhitelist));\n\tif (nowhitelist == NULL)\n\t\terrExit(\"failed allocating memory for nowhitelist entries\");\n\n\t// verify whitelist files, extract symbolic links, etc.\n\tEUID_USER();\n\tstruct stat s;\n\twhile (entry) {\n\t\tint nowhitelist_flag = 0;\n\n\t\t// handle only whitelist and nowhitelist commands\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0)\n\t\t\tnowhitelist_flag = 0;\n\t\telse if (strncmp(entry->data, \"nowhitelist \", 12) == 0)\n\t\t\tnowhitelist_flag = 1;\n\t\telse {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\tchar *dataptr = (nowhitelist_flag)? entry->data + 12: entry->data + 10;\n\n\t\t// replace ~/ or ${HOME} into /home/username or resolve macro\n\t\tnew_name = expand_macros(dataptr);\n\t\tassert(new_name);\n\n\t\t// mount empty home directory if resolving the macro was not successful\n\t\tif (is_macro(new_name) && macro_id(new_name) > -1) {\n\t\t\t// no warning if home does not exist (e.g. in a chroot)\n\t\t\tif (stat(cfg.homedir, &s) == 0 && !nowhitelist_flag && !arg_private) {\n\t\t\t\thome_dir = 1;\n\t\t\t\tif (!arg_quiet) {\n\t\t\t\t\tfprintf(stderr, \"***\\n\");\n\t\t\t\t\tfprintf(stderr, \"*** Warning: cannot whitelist %s directory\\n\", new_name);\n\t\t\t\t\tfprintf(stderr, \"*** Any file saved in this directory will be lost when the sandbox is closed.\\n\");\n\t\t\t\t\tfprintf(stderr, \"***\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// remove trailing slashes and single dots\n\t\tif (!nowhitelist_flag)\n\t\t\ttrim_trailing_slash_or_dot(new_name);\n\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tfprintf(stderr, \"Debug %d: new_name #%s#, %s\\n\", __LINE__, new_name, (nowhitelist_flag)? \"nowhitelist\": \"whitelist\");\n\n\t\t// valid path referenced to filesystem root\n\t\tif (*new_name != '/') {\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tfprintf(stderr, \"Debug %d: \\n\", __LINE__);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\t// extract the absolute path of the file\n\t\t// realpath function will fail with ENOENT if the file is not found or with EACCES if user has no permission\n\t\t// special processing for /dev/fd, /dev/stdin, /dev/stdout and /dev/stderr\n\t\tchar *fname;\n\t\tif (strcmp(new_name, \"/dev/fd\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd\");\n\t\telse if (strcmp(new_name, \"/dev/stdin\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/0\");\n\t\telse if (strcmp(new_name, \"/dev/stdout\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/1\");\n\t\telse if (strcmp(new_name, \"/dev/stderr\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/2\");\n\t\telse\n\t\t\tfname = realpath(new_name, NULL);\n\n\t\tif (!fname) {\n\t\t\t// file not found, blank the entry in the list and continue\n\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\tprintf(\"Removed whitelist/nowhitelist path: %s\\n\", entry->data);\n\t\t\t\tprintf(\"\\texpanded: %s\\n\", new_name);\n\t\t\t\tprintf(\"\\treal path: (null)\\n\");\n\t\t\t\tprintf(\"\\t\");fflush(0);\n\t\t\t\tperror(\"realpath\");\n\t\t\t}\n\n\t\t\t// if 1 the file was not found; mount an empty directory\n\t\t\tif (!nowhitelist_flag) {\n\t\t\t\tif (strncmp(new_name, cfg.homedir, homedir_len) == 0 && new_name[homedir_len] == '/') {\n\t\t\t\t\tif(!arg_private)\n\t\t\t\t\t\thome_dir = 1;\n\t\t\t\t}\n\t\t\t\telse if (strncmp(new_name, \"/tmp/\", 5) == 0)\n\t\t\t\t\ttmp_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/media/\", 7) == 0)\n\t\t\t\t\tmedia_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/mnt/\", 5) == 0)\n\t\t\t\t\tmnt_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/var/\", 5) == 0)\n\t\t\t\t\tvar_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/dev/\", 5) == 0)\n\t\t\t\t\tdev_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/opt/\", 5) == 0)\n\t\t\t\t\topt_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/srv/\", 5) == 0)\n\t\t\t\t\tsrv_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/etc/\", 5) == 0)\n\t\t\t\t\tetc_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/usr/share/\", 11) == 0)\n\t\t\t\t\tshare_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/sys/module/\", 12) == 0)\n\t\t\t\t\tmodule_dir = 1;\n\t\t\t\telse if (strncmp(new_name, runuser, runuser_len) == 0 && new_name[runuser_len] == '/')\n\t\t\t\t\trun_dir = 1;\n\t\t\t}\n\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (arg_debug_whitelists)\n\t\t\tprintf(\"real path %s\\n\", fname);\n\n\t\tif (nowhitelist_flag) {\n\t\t\t// store the path in nowhitelist array\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Storing nowhitelist %s\\n\", fname);\n\n\t\t\tif (nowhitelist_c >= nowhitelist_m) {\n\t\t\t\tnowhitelist_m *= 2;\n\t\t\t\tnowhitelist = realloc(nowhitelist, sizeof(*nowhitelist) * nowhitelist_m);\n\t\t\t\tif (nowhitelist == NULL)\n\t\t\t\t\terrExit(\"failed increasing memory for nowhitelist entries\");\n\t\t\t}\n\t\t\tnowhitelist[nowhitelist_c++] = fname;\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// check for supported directories\n\t\tif (strncmp(new_name, cfg.homedir, homedir_len) == 0 && new_name[homedir_len] == '/') {\n\t\t\t// whitelisting home directory is disabled if --private option is present\n\t\t\tif (arg_private) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"\\\"%s\\\" disabled by --private\\n\", entry->data);\n\n\t\t\t\tentry->data = EMPTY_STRING;\n\t\t\t\tentry = entry->next;\n\t\t\t\tfree(fname);\n\t\t\t\tfree(new_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tentry->home_dir = 1;\n\t\t\thome_dir = 1;\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tfprintf(stderr, \"Debug %d: fname #%s#, cfg.homedir #%s#\\n\",\n\t\t\t\t\t__LINE__, fname, cfg.homedir);\n\n\t\t\t// both path and absolute path are in user home,\n\t\t\t// if not check if the symlink destination is owned by the user\n\t\t\tif (strncmp(fname, cfg.homedir, homedir_len) != 0 || fname[homedir_len] != '/') {\n\t\t\t\tif (checkcfg(CFG_FOLLOW_SYMLINK_AS_USER)) {\n\t\t\t\t\tif (stat(fname, &s) == 0 && s.st_uid != getuid()) {\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\tgoto errexit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/tmp/\", 5) == 0) {\n\t\t\tentry->tmp_dir = 1;\n\t\t\ttmp_dir = 1;\n\n\t\t\t// both path and absolute path are under /tmp\n\t\t\tif (strncmp(fname, \"/tmp/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/media/\", 7) == 0) {\n\t\t\tentry->media_dir = 1;\n\t\t\tmedia_dir = 1;\n\t\t\t// both path and absolute path are under /media\n\t\t\tif (strncmp(fname, \"/media/\", 7) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/mnt/\", 5) == 0) {\n\t\t\tentry->mnt_dir = 1;\n\t\t\tmnt_dir = 1;\n\t\t\t// both path and absolute path are under /mnt\n\t\t\tif (strncmp(fname, \"/mnt/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/var/\", 5) == 0) {\n\t\t\tentry->var_dir = 1;\n\t\t\tvar_dir = 1;\n\t\t\t// both path and absolute path are under /var\n\t\t\t// exceptions: /var/tmp, /var/run and /var/lock\n\t\t\tif (strcmp(new_name, \"/var/run\")== 0 && strcmp(fname, \"/run\") == 0);\n\t\t\telse if (strcmp(new_name, \"/var/lock\")== 0 && strcmp(fname, \"/run/lock\") == 0);\n\t\t\telse if (strcmp(new_name, \"/var/tmp\")== 0 && strcmp(fname, \"/tmp\") == 0);\n\t\t\telse {\n\t\t\t\t// both path and absolute path are under /var\n\t\t\t\tif (strncmp(fname, \"/var/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/dev/\", 5) == 0) {\n\t\t\tentry->dev_dir = 1;\n\t\t\tdev_dir = 1;\n\t\t\t// special handling for /dev/shm\n\t\t\t// on some platforms (Debian wheezy, Ubuntu 14.04), it is a symlink to /run/shm\n\t\t\tif (strcmp(new_name, \"/dev/shm\") == 0 && strcmp(fname, \"/run/shm\") == 0);\n\t\t\t// special handling for /dev/log, which can be a symlink to /run/systemd/journal/dev-log\n\t\t\telse if (strcmp(new_name, \"/dev/log\") == 0 && strcmp(fname, \"/run/systemd/journal/dev-log\") == 0);\n\t\t\t// special processing for /proc/self/fd files\n\t\t\telse if (strcmp(new_name, \"/dev/fd\") == 0 && strcmp(fname, \"/proc/self/fd\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stdin\") == 0 && strcmp(fname, \"/proc/self/fd/0\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stdout\") == 0 && strcmp(fname, \"/proc/self/fd/1\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stderr\") == 0 && strcmp(fname, \"/proc/self/fd/2\") == 0);\n\t\t\telse {\n\t\t\t\t// both path and absolute path are under /dev\n\t\t\t\tif (strncmp(fname, \"/dev/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/opt/\", 5) == 0) {\n\t\t\tentry->opt_dir = 1;\n\t\t\topt_dir = 1;\n\t\t\t// both path and absolute path are under /dev\n\t\t\tif (strncmp(fname, \"/opt/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/srv/\", 5) == 0) {\n\t\t\tentry->srv_dir = 1;\n\t\t\tsrv_dir = 1;\n\t\t\t// both path and absolute path are under /srv\n\t\t\tif (strncmp(fname, \"/srv/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/etc/\", 5) == 0) {\n\t\t\tentry->etc_dir = 1;\n\t\t\tetc_dir = 1;\n\t\t\t// special handling for some of the symlinks\n\t\t\tif (strcmp(new_name, \"/etc/localtime\") == 0);\n\t\t\telse if (strcmp(new_name, \"/etc/mtab\") == 0);\n\t\t\telse if (strcmp(new_name, \"/etc/os-release\") == 0);\n\t\t\t// both path and absolute path are under /etc\n\t\t\telse {\n\t\t\t\tif (strncmp(fname, \"/etc/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/usr/share/\", 11) == 0) {\n\t\t\tentry->share_dir = 1;\n\t\t\tshare_dir = 1;\n\t\t\t// both path and absolute path are under /etc\n\t\t\tif (strncmp(fname, \"/usr/share/\", 11) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/sys/module/\", 12) == 0) {\n\t\t\tentry->module_dir = 1;\n\t\t\tmodule_dir = 1;\n\t\t\t// both path and absolute path are under /sys/module\n\t\t\tif (strncmp(fname, \"/sys/module/\", 12) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, runuser, runuser_len) == 0 && new_name[runuser_len] == '/') {\n\t\t\tentry->run_dir = 1;\n\t\t\trun_dir = 1;\n\t\t\t// both path and absolute path are under /run/user/$uid\n\t\t\tif (strncmp(fname, runuser, runuser_len) != 0 || fname[runuser_len] != '/') {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfree(fname);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\t// check if the path is in nowhitelist array\n\t\tif (nowhitelist_flag == 0) {\n\t\t\tsize_t i;\n\t\t\tint found = 0;\n\t\t\tfor (i = 0; i < nowhitelist_c; i++) {\n\t\t\t\tif (nowhitelist[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (strcmp(nowhitelist[i], fname) == 0) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"Skip nowhitelisted path %s\\n\", fname);\n\t\t\t\tentry->data = EMPTY_STRING;\n\t\t\t\tentry = entry->next;\n\t\t\t\tfree(fname);\n\t\t\t\tfree(new_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// mark symbolic links\n\t\tif (is_link(new_name))\n\t\t\tentry->link = new_name;\n\t\telse {\n\t\t\tfree(new_name);\n\t\t\tentry->link = NULL;\n\t\t}\n\n\t\t// change file name in entry->data\n\t\tif (strcmp(fname, entry->data + 10) != 0) {\n\t\t\tchar *newdata;\n\t\t\tif (asprintf(&newdata, \"whitelist %s\", fname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tentry->data = newdata;\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Replaced whitelist path: %s\\n\", entry->data);\n\t\t}\n\t\tfree(fname);\n\t\tentry = entry->next;\n\t}\n\n\t// release nowhitelist memory\n\tassert(nowhitelist);\n\tfree(nowhitelist);\n\n\tEUID_ROOT();\n\t// /home/user mountpoint\n\tif (home_dir) {\n\t\t// check if /home/user directory exists\n\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t// keep a copy of real home dir in RUN_WHITELIST_HOME_USER_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_HOME_USER_DIR, 0755, getuid(), getgid());\n\t\t\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_USER_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount a tmpfs and initialize /home/user, overrides --allusers\n\t\t\tfs_private();\n\t\t}\n\t\telse\n\t\t\thome_dir = 0;\n\t}\n\n\t// /tmp mountpoint\n\tif (tmp_dir) {\n\t\t// keep a copy of real /tmp directory in RUN_WHITELIST_TMP_DIR\n\t\tmkdir_attr(RUN_WHITELIST_TMP_DIR, 1777, 0, 0);\n\t\tif (mount(\"/tmp\", RUN_WHITELIST_TMP_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /tmp\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /tmp directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /tmp\");\n\t\tfs_logger(\"tmpfs /tmp\");\n\t}\n\n\t// /media mountpoint\n\tif (media_dir) {\n\t\t// some distros don't have a /media directory\n\t\tif (stat(\"/media\", &s) == 0) {\n\t\t\t// keep a copy of real /media directory in RUN_WHITELIST_MEDIA_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MEDIA_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/media\", RUN_WHITELIST_MEDIA_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /media\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /media directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/media\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /media\");\n\t\t\tfs_logger(\"tmpfs /media\");\n\t\t}\n\t\telse\n\t\t\tmedia_dir = 0;\n\t}\n\n\t// /mnt mountpoint\n\tif (mnt_dir) {\n\t\t// check if /mnt directory exists\n\t\tif (stat(\"/mnt\", &s) == 0) {\n\t\t\t// keep a copy of real /mnt directory in RUN_WHITELIST_MNT_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MNT_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/mnt\", RUN_WHITELIST_MNT_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /mnt\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /mnt directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /mnt\");\n\t\t\tfs_logger(\"tmpfs /mnt\");\n\t\t}\n\t\telse\n\t\t\tmnt_dir = 0;\n\t}\n\n\n\t// /var mountpoint\n\tif (var_dir) {\n\t\t// keep a copy of real /var directory in RUN_WHITELIST_VAR_DIR\n\t\tmkdir_attr(RUN_WHITELIST_VAR_DIR, 0755, 0, 0);\n\t\tif (mount(\"/var\", RUN_WHITELIST_VAR_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /var\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /var directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/var\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /var\");\n\t\tfs_logger(\"tmpfs /var\");\n\t}\n\n\t// /dev mountpoint\n\tif (dev_dir) {\n\t\t// keep a copy of real /dev directory in RUN_WHITELIST_DEV_DIR\n\t\tmkdir_attr(RUN_WHITELIST_DEV_DIR, 0755, 0, 0);\n\t\tif (mount(\"/dev\", RUN_WHITELIST_DEV_DIR, NULL, MS_BIND|MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /dev\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /dev directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /dev\");\n\t\tfs_logger(\"tmpfs /dev\");\n\t}\n\n\t// /opt mountpoint\n\tif (opt_dir) {\n\t\t// check if /opt directory exists\n\t\tif (stat(\"/opt\", &s) == 0) {\n\t\t\t// keep a copy of real /opt directory in RUN_WHITELIST_OPT_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_OPT_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/opt\", RUN_WHITELIST_OPT_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /opt\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /opt directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/opt\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /opt\");\n\t\t\tfs_logger(\"tmpfs /opt\");\n\t\t}\n\t\telse\n\t\t\topt_dir = 0;\n\t}\n\n\t// /srv mountpoint\n\tif (srv_dir) {\n\t\t// check if /srv directory exists\n\t\tif (stat(\"/srv\", &s) == 0) {\n\t\t\t// keep a copy of real /srv directory in RUN_WHITELIST_SRV_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_SRV_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/srv\", RUN_WHITELIST_SRV_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /srv directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/srv\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /srv\");\n\t\t\tfs_logger(\"tmpfs /srv\");\n\t\t}\n\t\telse\n\t\t\tsrv_dir = 0;\n\t}\n\n\t// /etc mountpoint\n\tif (etc_dir) {\n\t\t// check if /etc directory exists\n\t\tif (stat(\"/etc\", &s) == 0) {\n\t\t\t// keep a copy of real /etc directory in RUN_WHITELIST_ETC_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_ETC_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/etc\", RUN_WHITELIST_ETC_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /etc directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/etc\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /etc\");\n\t\t\tfs_logger(\"tmpfs /etc\");\n\t\t}\n\t\telse\n\t\t\tetc_dir = 0;\n\t}\n\n\t// /usr/share mountpoint\n\tif (share_dir) {\n\t\t// check if /usr/share directory exists\n\t\tif (stat(\"/usr/share\", &s) == 0) {\n\t\t\t// keep a copy of real /usr/share directory in RUN_WHITELIST_ETC_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_SHARE_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/usr/share\", RUN_WHITELIST_SHARE_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /usr/share directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/usr/share\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /usr/share\");\n\t\t\tfs_logger(\"tmpfs /usr/share\");\n\t\t}\n\t\telse\n\t\t\tshare_dir = 0;\n\t}\n\n\t// /sys/module mountpoint\n\tif (module_dir) {\n\t\t// check if /sys/module directory exists\n\t\tif (stat(\"/sys/module\", &s) == 0) {\n\t\t\t// keep a copy of real /sys/module directory in RUN_WHITELIST_MODULE_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MODULE_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/sys/module\", RUN_WHITELIST_MODULE_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /sys/module\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /sys/module directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/sys/module\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /sys/module\");\n\t\t\tfs_logger(\"tmpfs /sys/module\");\n\t\t}\n\t\telse\n\t\t\tmodule_dir = 0;\n\t}\n\n\t// /run/user mountpoint\n\tif (run_dir) {\n\t\t// check if /run/user/$uid directory exists\n\t\tif (stat(runuser, &s) == 0) {\n\t\t\t// keep a copy of real /run/user/$uid directory in RUN_WHITELIST_RUN_USER_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_RUN_USER_DIR, 0700, getuid(), getgid());\n\t\t\tif (mount(runuser, RUN_WHITELIST_RUN_USER_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /run/user/$uid\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", runuser);\n\t\t\tchar *options;\n\t\t\tif (asprintf(&options, \"mode=700,uid=%u,gid=%u\", getuid(), getgid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (mount(\"tmpfs\", runuser, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME, options) < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /run/user/<uid>\");\n\t\t\tfree(options);\n\t\t\tfs_logger2(\"tmpfs\", runuser);\n\t\t}\n\t\telse\n\t\t\trun_dir = 0;\n\t}\n\n\n\t// go through profile rules again, and interpret whitelist commands\n\tentry = cfg.profile;\n\twhile (entry) {\n\t\t// handle only whitelist commands\n\t\tif (strncmp(entry->data, \"whitelist \", 10)) {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n//printf(\"here %d#%s#\\n\", __LINE__, entry->data);\n\t\t// whitelist the real file\n\t\twhitelist_path(entry);\n\n\t\t// create the link if any\n\t\tif (entry->link) {\n\t\t\t// if the link is already there, do not bother\n\t\t\tif (lstat(entry->link, &s) != 0) {\n\t\t\t\t// create the path if necessary\n\t\t\t\tint fd = mkpath(entry->link, 0755);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\t\tprintf(\"Debug %d: cannot create symbolic link %s\\n\", __LINE__, entry->link);\n\t\t\t\t\tfree(entry->link);\n\t\t\t\t\tentry->link = NULL;\n\t\t\t\t\tentry = entry->next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// get file name of symlink\n\t\t\t\tconst char *file = gnu_basename(entry->link);\n\t\t\t\t// create the link\n\t\t\t\tint rv = symlinkat(entry->data + 10, fd, file);\n\t\t\t\tif (rv) {\n\t\t\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\t\t\tperror(\"symlink\");\n\t\t\t\t\t\tprintf(\"Debug %d: cannot create symbolic link %s\\n\", __LINE__, entry->link);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"Created symbolic link %s -> %s\\n\", entry->link, entry->data + 10);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tfree(entry->link);\n\t\t\tentry->link = NULL;\n\t\t}\n\n\t\tentry = entry->next;\n\t}\n\n\t// mask the real home directory, currently mounted on RUN_WHITELIST_HOME_DIR\n\tif (home_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_USER_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_USER_DIR);\n\t}\n\n\t// mask the real /tmp directory, currently mounted on RUN_WHITELIST_TMP_DIR\n\tif (tmp_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_TMP_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_TMP_DIR);\n\t}\n\n\t// mask the real /var directory, currently mounted on RUN_WHITELIST_VAR_DIR\n\tif (var_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_VAR_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_VAR_DIR);\n\t}\n\n\t// mask the real /opt directory, currently mounted on RUN_WHITELIST_OPT_DIR\n\tif (opt_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_OPT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_OPT_DIR);\n\t}\n\n\t// mask the real /dev directory, currently mounted on RUN_WHITELIST_DEV_DIR\n\tif (dev_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_DEV_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_DEV_DIR);\n\t}\n\n\t// mask the real /media directory, currently mounted on RUN_WHITELIST_MEDIA_DIR\n\tif (media_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MEDIA_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MEDIA_DIR);\n\t}\n\n\t// mask the real /mnt directory, currently mounted on RUN_WHITELIST_MNT_DIR\n\tif (mnt_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MNT_DIR);\n\t}\n\n\t// mask the real /srv directory, currently mounted on RUN_WHITELIST_SRV_DIR\n\tif (srv_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_SRV_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_SRV_DIR);\n\t}\n\n\t// mask the real /etc directory, currently mounted on RUN_WHITELIST_ETC_DIR\n\tif (etc_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_ETC_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_ETC_DIR);\n\t}\n\n\t// mask the real /usr/share directory, currently mounted on RUN_WHITELIST_SHARE_DIR\n\tif (share_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_SHARE_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_SHARE_DIR);\n\t}\n\n\t// mask the real /sys/module directory, currently mounted on RUN_WHITELIST_MODULE_DIR\n\tif (module_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MODULE_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MODULE_DIR);\n\t}\n\n\t// mask the real /run/user/$uid directory, currently mounted on RUN_WHITELIST_MODULE_DIR\n\tif (run_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_RUN_USER_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_RUN_USER_DIR);\n\t}\n\n\tfree(runuser);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid whitelist path %s\\n\", new_name);\n\texit(1);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define EMPTY_STRING (\"\")"
          ],
          "globals_used": [
            "static size_t homedir_len;",
            "static size_t runuser_len;",
            "static char *runuser;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nstatic size_t homedir_len;\nstatic size_t runuser_len;\nstatic char *runuser;\n\nvoid fs_whitelist(void) {\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\n\tif (asprintf(&runuser, \"/run/user/%u\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\trunuser_len = strlen(runuser);\n\thomedir_len = strlen(cfg.homedir);\n\n\tchar *new_name = NULL;\n\tint home_dir = 0;\t// /home/user directory flag\n\tint tmp_dir = 0;\t// /tmp directory flag\n\tint media_dir = 0;\t// /media directory flag\n\tint mnt_dir = 0;\t// /mnt directory flag\n\tint var_dir = 0;\t\t// /var directory flag\n\tint dev_dir = 0;\t\t// /dev directory flag\n\tint opt_dir = 0;\t\t// /opt directory flag\n\tint srv_dir = 0;                // /srv directory flag\n\tint etc_dir = 0;                // /etc directory flag\n\tint share_dir = 0;                // /usr/share directory flag\n\tint module_dir = 0;                // /sys/module directory flag\n\tint run_dir = 0;                // /run/user/$uid directory flag\n\n\tsize_t nowhitelist_c = 0;\n\tsize_t nowhitelist_m = 32;\n\tchar **nowhitelist = calloc(nowhitelist_m, sizeof(*nowhitelist));\n\tif (nowhitelist == NULL)\n\t\terrExit(\"failed allocating memory for nowhitelist entries\");\n\n\t// verify whitelist files, extract symbolic links, etc.\n\tEUID_USER();\n\tstruct stat s;\n\twhile (entry) {\n\t\tint nowhitelist_flag = 0;\n\n\t\t// handle only whitelist and nowhitelist commands\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0)\n\t\t\tnowhitelist_flag = 0;\n\t\telse if (strncmp(entry->data, \"nowhitelist \", 12) == 0)\n\t\t\tnowhitelist_flag = 1;\n\t\telse {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\tchar *dataptr = (nowhitelist_flag)? entry->data + 12: entry->data + 10;\n\n\t\t// replace ~/ or ${HOME} into /home/username or resolve macro\n\t\tnew_name = expand_macros(dataptr);\n\t\tassert(new_name);\n\n\t\t// mount empty home directory if resolving the macro was not successful\n\t\tif (is_macro(new_name) && macro_id(new_name) > -1) {\n\t\t\t// no warning if home does not exist (e.g. in a chroot)\n\t\t\tif (stat(cfg.homedir, &s) == 0 && !nowhitelist_flag && !arg_private) {\n\t\t\t\thome_dir = 1;\n\t\t\t\tif (!arg_quiet) {\n\t\t\t\t\tfprintf(stderr, \"***\\n\");\n\t\t\t\t\tfprintf(stderr, \"*** Warning: cannot whitelist %s directory\\n\", new_name);\n\t\t\t\t\tfprintf(stderr, \"*** Any file saved in this directory will be lost when the sandbox is closed.\\n\");\n\t\t\t\t\tfprintf(stderr, \"***\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// remove trailing slashes and single dots\n\t\tif (!nowhitelist_flag)\n\t\t\ttrim_trailing_slash_or_dot(new_name);\n\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tfprintf(stderr, \"Debug %d: new_name #%s#, %s\\n\", __LINE__, new_name, (nowhitelist_flag)? \"nowhitelist\": \"whitelist\");\n\n\t\t// valid path referenced to filesystem root\n\t\tif (*new_name != '/') {\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tfprintf(stderr, \"Debug %d: \\n\", __LINE__);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\t// extract the absolute path of the file\n\t\t// realpath function will fail with ENOENT if the file is not found or with EACCES if user has no permission\n\t\t// special processing for /dev/fd, /dev/stdin, /dev/stdout and /dev/stderr\n\t\tchar *fname;\n\t\tif (strcmp(new_name, \"/dev/fd\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd\");\n\t\telse if (strcmp(new_name, \"/dev/stdin\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/0\");\n\t\telse if (strcmp(new_name, \"/dev/stdout\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/1\");\n\t\telse if (strcmp(new_name, \"/dev/stderr\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/2\");\n\t\telse\n\t\t\tfname = realpath(new_name, NULL);\n\n\t\tif (!fname) {\n\t\t\t// file not found, blank the entry in the list and continue\n\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\tprintf(\"Removed whitelist/nowhitelist path: %s\\n\", entry->data);\n\t\t\t\tprintf(\"\\texpanded: %s\\n\", new_name);\n\t\t\t\tprintf(\"\\treal path: (null)\\n\");\n\t\t\t\tprintf(\"\\t\");fflush(0);\n\t\t\t\tperror(\"realpath\");\n\t\t\t}\n\n\t\t\t// if 1 the file was not found; mount an empty directory\n\t\t\tif (!nowhitelist_flag) {\n\t\t\t\tif (strncmp(new_name, cfg.homedir, homedir_len) == 0 && new_name[homedir_len] == '/') {\n\t\t\t\t\tif(!arg_private)\n\t\t\t\t\t\thome_dir = 1;\n\t\t\t\t}\n\t\t\t\telse if (strncmp(new_name, \"/tmp/\", 5) == 0)\n\t\t\t\t\ttmp_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/media/\", 7) == 0)\n\t\t\t\t\tmedia_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/mnt/\", 5) == 0)\n\t\t\t\t\tmnt_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/var/\", 5) == 0)\n\t\t\t\t\tvar_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/dev/\", 5) == 0)\n\t\t\t\t\tdev_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/opt/\", 5) == 0)\n\t\t\t\t\topt_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/srv/\", 5) == 0)\n\t\t\t\t\tsrv_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/etc/\", 5) == 0)\n\t\t\t\t\tetc_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/usr/share/\", 11) == 0)\n\t\t\t\t\tshare_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/sys/module/\", 12) == 0)\n\t\t\t\t\tmodule_dir = 1;\n\t\t\t\telse if (strncmp(new_name, runuser, runuser_len) == 0 && new_name[runuser_len] == '/')\n\t\t\t\t\trun_dir = 1;\n\t\t\t}\n\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (arg_debug_whitelists)\n\t\t\tprintf(\"real path %s\\n\", fname);\n\n\t\tif (nowhitelist_flag) {\n\t\t\t// store the path in nowhitelist array\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Storing nowhitelist %s\\n\", fname);\n\n\t\t\tif (nowhitelist_c >= nowhitelist_m) {\n\t\t\t\tnowhitelist_m *= 2;\n\t\t\t\tnowhitelist = realloc(nowhitelist, sizeof(*nowhitelist) * nowhitelist_m);\n\t\t\t\tif (nowhitelist == NULL)\n\t\t\t\t\terrExit(\"failed increasing memory for nowhitelist entries\");\n\t\t\t}\n\t\t\tnowhitelist[nowhitelist_c++] = fname;\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// check for supported directories\n\t\tif (strncmp(new_name, cfg.homedir, homedir_len) == 0 && new_name[homedir_len] == '/') {\n\t\t\t// whitelisting home directory is disabled if --private option is present\n\t\t\tif (arg_private) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"\\\"%s\\\" disabled by --private\\n\", entry->data);\n\n\t\t\t\tentry->data = EMPTY_STRING;\n\t\t\t\tentry = entry->next;\n\t\t\t\tfree(fname);\n\t\t\t\tfree(new_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tentry->home_dir = 1;\n\t\t\thome_dir = 1;\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tfprintf(stderr, \"Debug %d: fname #%s#, cfg.homedir #%s#\\n\",\n\t\t\t\t\t__LINE__, fname, cfg.homedir);\n\n\t\t\t// both path and absolute path are in user home,\n\t\t\t// if not check if the symlink destination is owned by the user\n\t\t\tif (strncmp(fname, cfg.homedir, homedir_len) != 0 || fname[homedir_len] != '/') {\n\t\t\t\tif (checkcfg(CFG_FOLLOW_SYMLINK_AS_USER)) {\n\t\t\t\t\tif (stat(fname, &s) == 0 && s.st_uid != getuid()) {\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\tgoto errexit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/tmp/\", 5) == 0) {\n\t\t\tentry->tmp_dir = 1;\n\t\t\ttmp_dir = 1;\n\n\t\t\t// both path and absolute path are under /tmp\n\t\t\tif (strncmp(fname, \"/tmp/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/media/\", 7) == 0) {\n\t\t\tentry->media_dir = 1;\n\t\t\tmedia_dir = 1;\n\t\t\t// both path and absolute path are under /media\n\t\t\tif (strncmp(fname, \"/media/\", 7) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/mnt/\", 5) == 0) {\n\t\t\tentry->mnt_dir = 1;\n\t\t\tmnt_dir = 1;\n\t\t\t// both path and absolute path are under /mnt\n\t\t\tif (strncmp(fname, \"/mnt/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/var/\", 5) == 0) {\n\t\t\tentry->var_dir = 1;\n\t\t\tvar_dir = 1;\n\t\t\t// both path and absolute path are under /var\n\t\t\t// exceptions: /var/tmp, /var/run and /var/lock\n\t\t\tif (strcmp(new_name, \"/var/run\")== 0 && strcmp(fname, \"/run\") == 0);\n\t\t\telse if (strcmp(new_name, \"/var/lock\")== 0 && strcmp(fname, \"/run/lock\") == 0);\n\t\t\telse if (strcmp(new_name, \"/var/tmp\")== 0 && strcmp(fname, \"/tmp\") == 0);\n\t\t\telse {\n\t\t\t\t// both path and absolute path are under /var\n\t\t\t\tif (strncmp(fname, \"/var/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/dev/\", 5) == 0) {\n\t\t\tentry->dev_dir = 1;\n\t\t\tdev_dir = 1;\n\t\t\t// special handling for /dev/shm\n\t\t\t// on some platforms (Debian wheezy, Ubuntu 14.04), it is a symlink to /run/shm\n\t\t\tif (strcmp(new_name, \"/dev/shm\") == 0 && strcmp(fname, \"/run/shm\") == 0);\n\t\t\t// special handling for /dev/log, which can be a symlink to /run/systemd/journal/dev-log\n\t\t\telse if (strcmp(new_name, \"/dev/log\") == 0 && strcmp(fname, \"/run/systemd/journal/dev-log\") == 0);\n\t\t\t// special processing for /proc/self/fd files\n\t\t\telse if (strcmp(new_name, \"/dev/fd\") == 0 && strcmp(fname, \"/proc/self/fd\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stdin\") == 0 && strcmp(fname, \"/proc/self/fd/0\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stdout\") == 0 && strcmp(fname, \"/proc/self/fd/1\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stderr\") == 0 && strcmp(fname, \"/proc/self/fd/2\") == 0);\n\t\t\telse {\n\t\t\t\t// both path and absolute path are under /dev\n\t\t\t\tif (strncmp(fname, \"/dev/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/opt/\", 5) == 0) {\n\t\t\tentry->opt_dir = 1;\n\t\t\topt_dir = 1;\n\t\t\t// both path and absolute path are under /dev\n\t\t\tif (strncmp(fname, \"/opt/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/srv/\", 5) == 0) {\n\t\t\tentry->srv_dir = 1;\n\t\t\tsrv_dir = 1;\n\t\t\t// both path and absolute path are under /srv\n\t\t\tif (strncmp(fname, \"/srv/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/etc/\", 5) == 0) {\n\t\t\tentry->etc_dir = 1;\n\t\t\tetc_dir = 1;\n\t\t\t// special handling for some of the symlinks\n\t\t\tif (strcmp(new_name, \"/etc/localtime\") == 0);\n\t\t\telse if (strcmp(new_name, \"/etc/mtab\") == 0);\n\t\t\telse if (strcmp(new_name, \"/etc/os-release\") == 0);\n\t\t\t// both path and absolute path are under /etc\n\t\t\telse {\n\t\t\t\tif (strncmp(fname, \"/etc/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/usr/share/\", 11) == 0) {\n\t\t\tentry->share_dir = 1;\n\t\t\tshare_dir = 1;\n\t\t\t// both path and absolute path are under /etc\n\t\t\tif (strncmp(fname, \"/usr/share/\", 11) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/sys/module/\", 12) == 0) {\n\t\t\tentry->module_dir = 1;\n\t\t\tmodule_dir = 1;\n\t\t\t// both path and absolute path are under /sys/module\n\t\t\tif (strncmp(fname, \"/sys/module/\", 12) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, runuser, runuser_len) == 0 && new_name[runuser_len] == '/') {\n\t\t\tentry->run_dir = 1;\n\t\t\trun_dir = 1;\n\t\t\t// both path and absolute path are under /run/user/$uid\n\t\t\tif (strncmp(fname, runuser, runuser_len) != 0 || fname[runuser_len] != '/') {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfree(fname);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\t// check if the path is in nowhitelist array\n\t\tif (nowhitelist_flag == 0) {\n\t\t\tsize_t i;\n\t\t\tint found = 0;\n\t\t\tfor (i = 0; i < nowhitelist_c; i++) {\n\t\t\t\tif (nowhitelist[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (strcmp(nowhitelist[i], fname) == 0) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"Skip nowhitelisted path %s\\n\", fname);\n\t\t\t\tentry->data = EMPTY_STRING;\n\t\t\t\tentry = entry->next;\n\t\t\t\tfree(fname);\n\t\t\t\tfree(new_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// mark symbolic links\n\t\tif (is_link(new_name))\n\t\t\tentry->link = new_name;\n\t\telse {\n\t\t\tfree(new_name);\n\t\t\tentry->link = NULL;\n\t\t}\n\n\t\t// change file name in entry->data\n\t\tif (strcmp(fname, entry->data + 10) != 0) {\n\t\t\tchar *newdata;\n\t\t\tif (asprintf(&newdata, \"whitelist %s\", fname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tentry->data = newdata;\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Replaced whitelist path: %s\\n\", entry->data);\n\t\t}\n\t\tfree(fname);\n\t\tentry = entry->next;\n\t}\n\n\t// release nowhitelist memory\n\tassert(nowhitelist);\n\tfree(nowhitelist);\n\n\tEUID_ROOT();\n\t// /home/user mountpoint\n\tif (home_dir) {\n\t\t// check if /home/user directory exists\n\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t// keep a copy of real home dir in RUN_WHITELIST_HOME_USER_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_HOME_USER_DIR, 0755, getuid(), getgid());\n\t\t\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_USER_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount a tmpfs and initialize /home/user, overrides --allusers\n\t\t\tfs_private();\n\t\t}\n\t\telse\n\t\t\thome_dir = 0;\n\t}\n\n\t// /tmp mountpoint\n\tif (tmp_dir) {\n\t\t// keep a copy of real /tmp directory in RUN_WHITELIST_TMP_DIR\n\t\tmkdir_attr(RUN_WHITELIST_TMP_DIR, 1777, 0, 0);\n\t\tif (mount(\"/tmp\", RUN_WHITELIST_TMP_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /tmp\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /tmp directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /tmp\");\n\t\tfs_logger(\"tmpfs /tmp\");\n\t}\n\n\t// /media mountpoint\n\tif (media_dir) {\n\t\t// some distros don't have a /media directory\n\t\tif (stat(\"/media\", &s) == 0) {\n\t\t\t// keep a copy of real /media directory in RUN_WHITELIST_MEDIA_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MEDIA_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/media\", RUN_WHITELIST_MEDIA_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /media\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /media directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/media\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /media\");\n\t\t\tfs_logger(\"tmpfs /media\");\n\t\t}\n\t\telse\n\t\t\tmedia_dir = 0;\n\t}\n\n\t// /mnt mountpoint\n\tif (mnt_dir) {\n\t\t// check if /mnt directory exists\n\t\tif (stat(\"/mnt\", &s) == 0) {\n\t\t\t// keep a copy of real /mnt directory in RUN_WHITELIST_MNT_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MNT_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/mnt\", RUN_WHITELIST_MNT_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /mnt\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /mnt directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /mnt\");\n\t\t\tfs_logger(\"tmpfs /mnt\");\n\t\t}\n\t\telse\n\t\t\tmnt_dir = 0;\n\t}\n\n\n\t// /var mountpoint\n\tif (var_dir) {\n\t\t// keep a copy of real /var directory in RUN_WHITELIST_VAR_DIR\n\t\tmkdir_attr(RUN_WHITELIST_VAR_DIR, 0755, 0, 0);\n\t\tif (mount(\"/var\", RUN_WHITELIST_VAR_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /var\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /var directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/var\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /var\");\n\t\tfs_logger(\"tmpfs /var\");\n\t}\n\n\t// /dev mountpoint\n\tif (dev_dir) {\n\t\t// keep a copy of real /dev directory in RUN_WHITELIST_DEV_DIR\n\t\tmkdir_attr(RUN_WHITELIST_DEV_DIR, 0755, 0, 0);\n\t\tif (mount(\"/dev\", RUN_WHITELIST_DEV_DIR, NULL, MS_BIND|MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /dev\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /dev directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /dev\");\n\t\tfs_logger(\"tmpfs /dev\");\n\t}\n\n\t// /opt mountpoint\n\tif (opt_dir) {\n\t\t// check if /opt directory exists\n\t\tif (stat(\"/opt\", &s) == 0) {\n\t\t\t// keep a copy of real /opt directory in RUN_WHITELIST_OPT_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_OPT_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/opt\", RUN_WHITELIST_OPT_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /opt\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /opt directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/opt\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /opt\");\n\t\t\tfs_logger(\"tmpfs /opt\");\n\t\t}\n\t\telse\n\t\t\topt_dir = 0;\n\t}\n\n\t// /srv mountpoint\n\tif (srv_dir) {\n\t\t// check if /srv directory exists\n\t\tif (stat(\"/srv\", &s) == 0) {\n\t\t\t// keep a copy of real /srv directory in RUN_WHITELIST_SRV_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_SRV_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/srv\", RUN_WHITELIST_SRV_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /srv directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/srv\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /srv\");\n\t\t\tfs_logger(\"tmpfs /srv\");\n\t\t}\n\t\telse\n\t\t\tsrv_dir = 0;\n\t}\n\n\t// /etc mountpoint\n\tif (etc_dir) {\n\t\t// check if /etc directory exists\n\t\tif (stat(\"/etc\", &s) == 0) {\n\t\t\t// keep a copy of real /etc directory in RUN_WHITELIST_ETC_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_ETC_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/etc\", RUN_WHITELIST_ETC_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /etc directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/etc\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /etc\");\n\t\t\tfs_logger(\"tmpfs /etc\");\n\t\t}\n\t\telse\n\t\t\tetc_dir = 0;\n\t}\n\n\t// /usr/share mountpoint\n\tif (share_dir) {\n\t\t// check if /usr/share directory exists\n\t\tif (stat(\"/usr/share\", &s) == 0) {\n\t\t\t// keep a copy of real /usr/share directory in RUN_WHITELIST_ETC_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_SHARE_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/usr/share\", RUN_WHITELIST_SHARE_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /usr/share directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/usr/share\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /usr/share\");\n\t\t\tfs_logger(\"tmpfs /usr/share\");\n\t\t}\n\t\telse\n\t\t\tshare_dir = 0;\n\t}\n\n\t// /sys/module mountpoint\n\tif (module_dir) {\n\t\t// check if /sys/module directory exists\n\t\tif (stat(\"/sys/module\", &s) == 0) {\n\t\t\t// keep a copy of real /sys/module directory in RUN_WHITELIST_MODULE_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MODULE_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/sys/module\", RUN_WHITELIST_MODULE_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /sys/module\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /sys/module directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/sys/module\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /sys/module\");\n\t\t\tfs_logger(\"tmpfs /sys/module\");\n\t\t}\n\t\telse\n\t\t\tmodule_dir = 0;\n\t}\n\n\t// /run/user mountpoint\n\tif (run_dir) {\n\t\t// check if /run/user/$uid directory exists\n\t\tif (stat(runuser, &s) == 0) {\n\t\t\t// keep a copy of real /run/user/$uid directory in RUN_WHITELIST_RUN_USER_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_RUN_USER_DIR, 0700, getuid(), getgid());\n\t\t\tif (mount(runuser, RUN_WHITELIST_RUN_USER_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /run/user/$uid\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", runuser);\n\t\t\tchar *options;\n\t\t\tif (asprintf(&options, \"mode=700,uid=%u,gid=%u\", getuid(), getgid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (mount(\"tmpfs\", runuser, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME, options) < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /run/user/<uid>\");\n\t\t\tfree(options);\n\t\t\tfs_logger2(\"tmpfs\", runuser);\n\t\t}\n\t\telse\n\t\t\trun_dir = 0;\n\t}\n\n\n\t// go through profile rules again, and interpret whitelist commands\n\tentry = cfg.profile;\n\twhile (entry) {\n\t\t// handle only whitelist commands\n\t\tif (strncmp(entry->data, \"whitelist \", 10)) {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n//printf(\"here %d#%s#\\n\", __LINE__, entry->data);\n\t\t// whitelist the real file\n\t\twhitelist_path(entry);\n\n\t\t// create the link if any\n\t\tif (entry->link) {\n\t\t\t// if the link is already there, do not bother\n\t\t\tif (lstat(entry->link, &s) != 0) {\n\t\t\t\t// create the path if necessary\n\t\t\t\tint fd = mkpath(entry->link, 0755);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\t\tprintf(\"Debug %d: cannot create symbolic link %s\\n\", __LINE__, entry->link);\n\t\t\t\t\tfree(entry->link);\n\t\t\t\t\tentry->link = NULL;\n\t\t\t\t\tentry = entry->next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// get file name of symlink\n\t\t\t\tconst char *file = gnu_basename(entry->link);\n\t\t\t\t// create the link\n\t\t\t\tint rv = symlinkat(entry->data + 10, fd, file);\n\t\t\t\tif (rv) {\n\t\t\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\t\t\tperror(\"symlink\");\n\t\t\t\t\t\tprintf(\"Debug %d: cannot create symbolic link %s\\n\", __LINE__, entry->link);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"Created symbolic link %s -> %s\\n\", entry->link, entry->data + 10);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tfree(entry->link);\n\t\t\tentry->link = NULL;\n\t\t}\n\n\t\tentry = entry->next;\n\t}\n\n\t// mask the real home directory, currently mounted on RUN_WHITELIST_HOME_DIR\n\tif (home_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_USER_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_USER_DIR);\n\t}\n\n\t// mask the real /tmp directory, currently mounted on RUN_WHITELIST_TMP_DIR\n\tif (tmp_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_TMP_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_TMP_DIR);\n\t}\n\n\t// mask the real /var directory, currently mounted on RUN_WHITELIST_VAR_DIR\n\tif (var_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_VAR_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_VAR_DIR);\n\t}\n\n\t// mask the real /opt directory, currently mounted on RUN_WHITELIST_OPT_DIR\n\tif (opt_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_OPT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_OPT_DIR);\n\t}\n\n\t// mask the real /dev directory, currently mounted on RUN_WHITELIST_DEV_DIR\n\tif (dev_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_DEV_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_DEV_DIR);\n\t}\n\n\t// mask the real /media directory, currently mounted on RUN_WHITELIST_MEDIA_DIR\n\tif (media_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MEDIA_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MEDIA_DIR);\n\t}\n\n\t// mask the real /mnt directory, currently mounted on RUN_WHITELIST_MNT_DIR\n\tif (mnt_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MNT_DIR);\n\t}\n\n\t// mask the real /srv directory, currently mounted on RUN_WHITELIST_SRV_DIR\n\tif (srv_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_SRV_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_SRV_DIR);\n\t}\n\n\t// mask the real /etc directory, currently mounted on RUN_WHITELIST_ETC_DIR\n\tif (etc_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_ETC_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_ETC_DIR);\n\t}\n\n\t// mask the real /usr/share directory, currently mounted on RUN_WHITELIST_SHARE_DIR\n\tif (share_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_SHARE_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_SHARE_DIR);\n\t}\n\n\t// mask the real /sys/module directory, currently mounted on RUN_WHITELIST_MODULE_DIR\n\tif (module_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MODULE_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MODULE_DIR);\n\t}\n\n\t// mask the real /run/user/$uid directory, currently mounted on RUN_WHITELIST_MODULE_DIR\n\tif (run_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_RUN_USER_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_RUN_USER_DIR);\n\t}\n\n\tfree(runuser);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid whitelist path %s\\n\", new_name);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_mnt",
          "args": [
            "0"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "fs_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "658-675",
          "snippet": "void fs_mnt(const int enforce) {\n\tif (enforce) {\n\t\t// disable-mnt set in firejail.config\n\t\t// overriding with noblacklist is not possible in this case\n\t\tdisable_file(BLACKLIST_FILE, \"/mnt\");\n\t\tdisable_file(BLACKLIST_FILE, \"/media\");\n\t\tdisable_file(BLACKLIST_FILE, \"/run/mount\");\n\t\tdisable_file(BLACKLIST_FILE, \"/run/media\");\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tprofile_add(\"blacklist /mnt\");\n\t\tprofile_add(\"blacklist /media\");\n\t\tprofile_add(\"blacklist /run/mount\");\n\t\tprofile_add(\"blacklist /run/media\");\n\t\tEUID_ROOT();\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_mnt(const int enforce) {\n\tif (enforce) {\n\t\t// disable-mnt set in firejail.config\n\t\t// overriding with noblacklist is not possible in this case\n\t\tdisable_file(BLACKLIST_FILE, \"/mnt\");\n\t\tdisable_file(BLACKLIST_FILE, \"/media\");\n\t\tdisable_file(BLACKLIST_FILE, \"/run/mount\");\n\t\tdisable_file(BLACKLIST_FILE, \"/run/media\");\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tprofile_add(\"blacklist /mnt\");\n\t\tprofile_add(\"blacklist /media\");\n\t\tprofile_add(\"blacklist /run/mount\");\n\t\tprofile_add(\"blacklist /run/media\");\n\t\tEUID_ROOT();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_proc_sys_dev_boot",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "fs_proc_sys_dev_boot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "679-794",
          "snippet": "void fs_proc_sys_dev_boot(void) {\n\n\tif (arg_debug)\n\t\tprintf(\"Remounting /proc and /proc/sys filesystems\\n\");\n\tif (mount(\"proc\", \"/proc\", \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc\");\n\tfs_logger(\"remount /proc\");\n\n\t// remount /proc/sys readonly\n\tif (mount(\"/proc/sys\", \"/proc/sys\", NULL, MS_BIND | MS_REC, NULL) < 0 ||\n\t    mount(NULL, \"/proc/sys\", NULL, MS_BIND | MS_REMOUNT | MS_RDONLY | MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\tfs_logger(\"read-only /proc/sys\");\n\n\n\t/* Mount a version of /sys that describes the network namespace */\n\tif (arg_debug)\n\t\tprintf(\"Remounting /sys directory\\n\");\n\t// if this is an overlay, don't try to unmount, just mount a new sysfs\n\tif (!arg_overlay) {\n\t\tif (umount2(\"/sys\", MNT_DETACH) < 0 && !cfg.chrootdir)\n\t\t\tfwarning(\"failed to unmount /sys\\n\");\n\t}\n\tif (mount(\"sysfs\", \"/sys\", \"sysfs\", MS_RDONLY|MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_REC, NULL) < 0)\n\t\tfwarning(\"failed to mount /sys\\n\");\n\telse\n\t\tfs_logger(\"remount /sys\");\n\n\tdisable_file(BLACKLIST_FILE, \"/sys/firmware\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/hypervisor\");\n\t{ // allow user access to some directories in /sys/ by specifying 'noblacklist' option\n\t\tEUID_USER();\n\t\tprofile_add(\"blacklist /sys/fs\");\n\t\tprofile_add(\"blacklist /sys/module\");\n\t\tEUID_ROOT();\n\t}\n\tdisable_file(BLACKLIST_FILE, \"/sys/power\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/debug\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/vmcoreinfo\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/uevent_helper\");\n\n\t// various /proc/sys files\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/security\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/efi/vars\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/fs/binfmt_misc\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/core_pattern\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/modprobe\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sysrq-trigger\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/hotplug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/vm/panic_on_oom\");\n\n\t// various /proc files\n\tdisable_file(BLACKLIST_FILE, \"/proc/irq\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/bus\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/config.gz\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sched_debug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_list\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_stats\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kcore\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kallsyms\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/mem\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kmem\");\n\n\t// remove kernel symbol information\n\tif (!arg_allow_debuggers) {\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/src/linux\");\n\t\tdisable_file(BLACKLIST_FILE, \"/lib/modules\");\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/lib/debug\");\n\t\tdisable_file(BLACKLIST_FILE, \"/boot\");\n\t}\n\n\t// disable /selinux\n\tdisable_file(BLACKLIST_FILE, \"/selinux\");\n\n\t// disable /dev/port\n\tdisable_file(BLACKLIST_FILE, \"/dev/port\");\n\n\n\n\t// disable various ipc sockets in /run/user\n\tif (!arg_writable_run_user) {\n\t\tstruct stat s;\n\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/run/user/%d\", getuid()) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (is_dir(fname)) { // older distros don't have this directory\n\t\t\t// disable /run/user/{uid}/gnupg\n\t\t\tchar *fnamegpg;\n\t\t\tif (asprintf(&fnamegpg, \"/run/user/%d/gnupg\", getuid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (create_empty_dir_as_user(fnamegpg, 0700))\n\t\t\t\tfs_logger2(\"create\", fnamegpg);\n\t\t\tif (stat(fnamegpg, &s) == 0)\n\t\t\t\tdisable_file(BLACKLIST_FILE, fnamegpg);\n\t\t\tfree(fnamegpg);\n\n\t\t\t// disable /run/user/{uid}/systemd\n\t\t\tchar *fnamesysd;\n\t\t\tif (asprintf(&fnamesysd, \"/run/user/%d/systemd\", getuid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (create_empty_dir_as_user(fnamesysd, 0755))\n\t\t\t\tfs_logger2(\"create\", fnamesysd);\n\t\t\tif (stat(fnamesysd, &s) == 0)\n\t\t\t\tdisable_file(BLACKLIST_FILE, fnamesysd);\n\t\t\tfree(fnamesysd);\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (getuid() != 0) {\n\t\t// disable /dev/kmsg and /proc/kmsg\n\t\tdisable_file(BLACKLIST_FILE, \"/dev/kmsg\");\n\t\tdisable_file(BLACKLIST_FILE, \"/proc/kmsg\");\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_proc_sys_dev_boot(void) {\n\n\tif (arg_debug)\n\t\tprintf(\"Remounting /proc and /proc/sys filesystems\\n\");\n\tif (mount(\"proc\", \"/proc\", \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc\");\n\tfs_logger(\"remount /proc\");\n\n\t// remount /proc/sys readonly\n\tif (mount(\"/proc/sys\", \"/proc/sys\", NULL, MS_BIND | MS_REC, NULL) < 0 ||\n\t    mount(NULL, \"/proc/sys\", NULL, MS_BIND | MS_REMOUNT | MS_RDONLY | MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\tfs_logger(\"read-only /proc/sys\");\n\n\n\t/* Mount a version of /sys that describes the network namespace */\n\tif (arg_debug)\n\t\tprintf(\"Remounting /sys directory\\n\");\n\t// if this is an overlay, don't try to unmount, just mount a new sysfs\n\tif (!arg_overlay) {\n\t\tif (umount2(\"/sys\", MNT_DETACH) < 0 && !cfg.chrootdir)\n\t\t\tfwarning(\"failed to unmount /sys\\n\");\n\t}\n\tif (mount(\"sysfs\", \"/sys\", \"sysfs\", MS_RDONLY|MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_REC, NULL) < 0)\n\t\tfwarning(\"failed to mount /sys\\n\");\n\telse\n\t\tfs_logger(\"remount /sys\");\n\n\tdisable_file(BLACKLIST_FILE, \"/sys/firmware\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/hypervisor\");\n\t{ // allow user access to some directories in /sys/ by specifying 'noblacklist' option\n\t\tEUID_USER();\n\t\tprofile_add(\"blacklist /sys/fs\");\n\t\tprofile_add(\"blacklist /sys/module\");\n\t\tEUID_ROOT();\n\t}\n\tdisable_file(BLACKLIST_FILE, \"/sys/power\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/debug\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/vmcoreinfo\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/uevent_helper\");\n\n\t// various /proc/sys files\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/security\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/efi/vars\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/fs/binfmt_misc\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/core_pattern\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/modprobe\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sysrq-trigger\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/hotplug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/vm/panic_on_oom\");\n\n\t// various /proc files\n\tdisable_file(BLACKLIST_FILE, \"/proc/irq\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/bus\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/config.gz\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sched_debug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_list\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_stats\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kcore\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kallsyms\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/mem\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kmem\");\n\n\t// remove kernel symbol information\n\tif (!arg_allow_debuggers) {\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/src/linux\");\n\t\tdisable_file(BLACKLIST_FILE, \"/lib/modules\");\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/lib/debug\");\n\t\tdisable_file(BLACKLIST_FILE, \"/boot\");\n\t}\n\n\t// disable /selinux\n\tdisable_file(BLACKLIST_FILE, \"/selinux\");\n\n\t// disable /dev/port\n\tdisable_file(BLACKLIST_FILE, \"/dev/port\");\n\n\n\n\t// disable various ipc sockets in /run/user\n\tif (!arg_writable_run_user) {\n\t\tstruct stat s;\n\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/run/user/%d\", getuid()) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (is_dir(fname)) { // older distros don't have this directory\n\t\t\t// disable /run/user/{uid}/gnupg\n\t\t\tchar *fnamegpg;\n\t\t\tif (asprintf(&fnamegpg, \"/run/user/%d/gnupg\", getuid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (create_empty_dir_as_user(fnamegpg, 0700))\n\t\t\t\tfs_logger2(\"create\", fnamegpg);\n\t\t\tif (stat(fnamegpg, &s) == 0)\n\t\t\t\tdisable_file(BLACKLIST_FILE, fnamegpg);\n\t\t\tfree(fnamegpg);\n\n\t\t\t// disable /run/user/{uid}/systemd\n\t\t\tchar *fnamesysd;\n\t\t\tif (asprintf(&fnamesysd, \"/run/user/%d/systemd\", getuid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (create_empty_dir_as_user(fnamesysd, 0755))\n\t\t\t\tfs_logger2(\"create\", fnamesysd);\n\t\t\tif (stat(fnamesysd, &s) == 0)\n\t\t\t\tdisable_file(BLACKLIST_FILE, fnamesysd);\n\t\t\tfree(fnamesysd);\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (getuid() != 0) {\n\t\t// disable /dev/kmsg and /proc/kmsg\n\t\tdisable_file(BLACKLIST_FILE, \"/dev/kmsg\");\n\t\tdisable_file(BLACKLIST_FILE, \"/proc/kmsg\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "netns_mounts",
          "args": [
            "arg_netns"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "netns_mounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/netns.c",
          "lines": "88-114",
          "snippet": "void netns_mounts(const char *nsname) {\n\tchar *etcdir = netns_etc_dir(nsname);\n\tchar *netns_name, *etc_name;\n\tstruct dirent *entry;\n\tDIR *dir;\n\n\tdir = opendir(etcdir);\n\tif (!dir) {\n\t\tfree(etcdir);\n\t\treturn;\n\t}\n\twhile ((entry = readdir(dir))) {\n\t\tif (!strcmp(entry->d_name, \".\") || !strcmp(entry->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (asprintf(&netns_name, \"%s/%s\", etcdir, entry->d_name) < 0 ||\n\t\t    asprintf(&etc_name, \"/etc/%s\", entry->d_name) < 0)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(netns_name, etc_name, \"none\", MS_BIND, 0) < 0) {\n\t\t\tfwarning(\"bind %s -> %s failed: %s\\n\",\n\t\t\t\tnetns_name, etc_name, strerror(errno));\n\t\t}\n\t\tfree(netns_name);\n\t\tfree(etc_name);\n\t}\n\tclosedir(dir);\n\tfree(etcdir);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include \"firejail.h\"\n\nvoid netns_mounts(const char *nsname) {\n\tchar *etcdir = netns_etc_dir(nsname);\n\tchar *netns_name, *etc_name;\n\tstruct dirent *entry;\n\tDIR *dir;\n\n\tdir = opendir(etcdir);\n\tif (!dir) {\n\t\tfree(etcdir);\n\t\treturn;\n\t}\n\twhile ((entry = readdir(dir))) {\n\t\tif (!strcmp(entry->d_name, \".\") || !strcmp(entry->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (asprintf(&netns_name, \"%s/%s\", etcdir, entry->d_name) < 0 ||\n\t\t    asprintf(&etc_name, \"/etc/%s\", entry->d_name) < 0)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(netns_name, etc_name, \"none\", MS_BIND, 0) < 0) {\n\t\t\tfwarning(\"bind %s -> %s failed: %s\\n\",\n\t\t\t\tnetns_name, etc_name, strerror(errno));\n\t\t}\n\t\tfree(netns_name);\n\t\tfree(etc_name);\n\t}\n\tclosedir(dir);\n\tfree(etcdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_mount_hosts_file",
          "args": [],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "fs_mount_hosts_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_hostname.c",
          "lines": "212-236",
          "snippet": "void fs_mount_hosts_file(void) {\n\tif (arg_debug)\n\t\tprintf(\"Loading user hosts file\\n\");\n\n\t// check /etc/hosts file\n\tstruct stat s;\n\tif (stat(\"/etc/hosts\", &s) == -1)\n\t\tgoto errexit;\n\t// not a link\n\tif (is_link(\"/etc/hosts\"))\n\t\tgoto errexit;\n\t// owned by root\n\tif (s.st_uid != 0)\n\t\tgoto errexit;\n\n\t// bind-mount the file on top of /etc/hostname\n\tif (mount(RUN_HOSTS_FILE, \"/etc/hosts\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind /etc/hosts\");\n\tfs_logger(\"create /etc/hosts\");\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid /etc/hosts file\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_mount_hosts_file(void) {\n\tif (arg_debug)\n\t\tprintf(\"Loading user hosts file\\n\");\n\n\t// check /etc/hosts file\n\tstruct stat s;\n\tif (stat(\"/etc/hosts\", &s) == -1)\n\t\tgoto errexit;\n\t// not a link\n\tif (is_link(\"/etc/hosts\"))\n\t\tgoto errexit;\n\t// owned by root\n\tif (s.st_uid != 0)\n\t\tgoto errexit;\n\n\t// bind-mount the file on top of /etc/hostname\n\tif (mount(RUN_HOSTS_FILE, \"/etc/hosts\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind /etc/hosts\");\n\tfs_logger(\"create /etc/hosts\");\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid /etc/hosts file\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_hostname",
          "args": [
            "cfg.hostname"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "fs_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_hostname.c",
          "lines": "28-89",
          "snippet": "void fs_hostname(const char *hostname) {\n\tstruct stat s;\n\n\t// create a new /etc/hostname\n\tif (stat(\"/etc/hostname\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/hostname file\\n\");\n\n\t\tcreate_empty_file_as_root(RUN_HOSTNAME_FILE, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tif (mount(RUN_HOSTNAME_FILE, \"/etc/hostname\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind /etc/hostname\");\n\t\tfs_logger(\"create /etc/hostname\");\n\t}\n\n\t// create a new /etc/hosts\n\tif (cfg.hosts_file == NULL && stat(\"/etc/hosts\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/hosts file\\n\");\n\t\t// copy /etc/host into our new file, and modify it on the fly\n\t\t/* coverity[toctou] */\n\t\tFILE *fp1 = fopen(\"/etc/hosts\", \"r\");\n\t\tif (!fp1)\n\t\t\tgoto errexit;\n\n\t\tFILE *fp2 = fopen(RUN_HOSTS_FILE, \"w\");\n\t\tif (!fp2) {\n\t\t\tfclose(fp1);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\tchar buf[4096];\n\t\tint done = 0;\n\t\twhile (fgets(buf, sizeof(buf), fp1)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\n\t\t\t// copy line\n\t\t\tif (strstr(buf, \"127.0.0.1\") && done == 0) {\n\t\t\t\tdone = 1;\n\t\t\t\tfprintf(fp2, \"%s %s\\n\", buf, hostname);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfprintf(fp2, \"%s\\n\", buf);\n\t\t}\n\t\tfclose(fp1);\n\t\t// mode and owner\n\t\tSET_PERMS_STREAM(fp2, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp2);\n\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tfs_mount_hosts_file();\n\t}\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot create hostname file\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_hostname(const char *hostname) {\n\tstruct stat s;\n\n\t// create a new /etc/hostname\n\tif (stat(\"/etc/hostname\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/hostname file\\n\");\n\n\t\tcreate_empty_file_as_root(RUN_HOSTNAME_FILE, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tif (mount(RUN_HOSTNAME_FILE, \"/etc/hostname\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind /etc/hostname\");\n\t\tfs_logger(\"create /etc/hostname\");\n\t}\n\n\t// create a new /etc/hosts\n\tif (cfg.hosts_file == NULL && stat(\"/etc/hosts\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/hosts file\\n\");\n\t\t// copy /etc/host into our new file, and modify it on the fly\n\t\t/* coverity[toctou] */\n\t\tFILE *fp1 = fopen(\"/etc/hosts\", \"r\");\n\t\tif (!fp1)\n\t\t\tgoto errexit;\n\n\t\tFILE *fp2 = fopen(RUN_HOSTS_FILE, \"w\");\n\t\tif (!fp2) {\n\t\t\tfclose(fp1);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\tchar buf[4096];\n\t\tint done = 0;\n\t\twhile (fgets(buf, sizeof(buf), fp1)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\n\t\t\t// copy line\n\t\t\tif (strstr(buf, \"127.0.0.1\") && done == 0) {\n\t\t\t\tdone = 1;\n\t\t\t\tfprintf(fp2, \"%s %s\\n\", buf, hostname);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfprintf(fp2, \"%s\\n\", buf);\n\t\t}\n\t\tfclose(fp1);\n\t\t// mode and owner\n\t\tSET_PERMS_STREAM(fp2, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp2);\n\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tfs_mount_hosts_file();\n\t}\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot create hostname file\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_session_disable",
          "args": [],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "dbus_session_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/dbus.c",
          "lines": "22-63",
          "snippet": "void dbus_session_disable(void) {\n\tif (!checkcfg(CFG_DBUS)) {\n\t\tfwarning(\"D-Bus handling is disabled in Firejail configuration file\\n\");\n\t\treturn;\n\t}\n\n\tchar *path;\n\tif (asprintf(&path, \"/run/user/%d/bus\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\tchar *env_var;\n\tif (asprintf(&env_var, \"DBUS_SESSION_BUS_ADDRESS=unix:path=%s\", path) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// set a new environment variable: DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/<UID>/bus\n\tif (setenv(\"DBUS_SESSION_BUS_ADDRESS\", env_var, 1) == -1) {\n\t\tfprintf(stderr, \"Error: cannot modify DBUS_SESSION_BUS_ADDRESS required by --nodbus\\n\");\n\t\texit(1);\n\t}\n\n\t// blacklist the path\n\tdisable_file_or_dir(path);\n\tfree(path);\n\tfree(env_var);\n\n\t// look for a possible abstract unix socket\n\n\t// --net=none\n\tif (arg_nonetwork)\n\t\treturn;\n\n\t// --net=eth0\n\tif (any_bridge_configured())\n\t\treturn;\n\n\t// --protocol=unix\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol && !strstr(cfg.protocol, \"unix\"))\n\t\treturn;\n#endif\n\n\tfwarning(\"An abstract unix socket for session D-BUS might still be available. Use --net or remove unix from --protocol set.\\n\");\n}",
          "includes": [
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n\nvoid dbus_session_disable(void) {\n\tif (!checkcfg(CFG_DBUS)) {\n\t\tfwarning(\"D-Bus handling is disabled in Firejail configuration file\\n\");\n\t\treturn;\n\t}\n\n\tchar *path;\n\tif (asprintf(&path, \"/run/user/%d/bus\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\tchar *env_var;\n\tif (asprintf(&env_var, \"DBUS_SESSION_BUS_ADDRESS=unix:path=%s\", path) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// set a new environment variable: DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/<UID>/bus\n\tif (setenv(\"DBUS_SESSION_BUS_ADDRESS\", env_var, 1) == -1) {\n\t\tfprintf(stderr, \"Error: cannot modify DBUS_SESSION_BUS_ADDRESS required by --nodbus\\n\");\n\t\texit(1);\n\t}\n\n\t// blacklist the path\n\tdisable_file_or_dir(path);\n\tfree(path);\n\tfree(env_var);\n\n\t// look for a possible abstract unix socket\n\n\t// --net=none\n\tif (arg_nonetwork)\n\t\treturn;\n\n\t// --net=eth0\n\tif (any_bridge_configured())\n\t\treturn;\n\n\t// --protocol=unix\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol && !strstr(cfg.protocol, \"unix\"))\n\t\treturn;\n#endif\n\n\tfwarning(\"An abstract unix socket for session D-BUS might still be available. Use --net or remove unix from --protocol set.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_private_tmp",
          "args": [],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_tmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "1501-1540",
          "snippet": "void fs_private_tmp(void) {\n\t// check XAUTHORITY file, KDE keeps it under /tmp\n\tchar *xauth = getenv(\"XAUTHORITY\");\n\tif (xauth) {\n\t\tchar *rp = realpath(xauth, NULL);\n\t\tif (rp && strncmp(rp, \"/tmp/\", 5) == 0) {\n\t\t\tchar *cmd;\n\t\t\tif (asprintf(&cmd, \"whitelist %s\", rp) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tprofile_add(cmd); // profile_add does not duplicate the string\n\t\t}\n\t\tif (rp)\n\t\t\tfree(rp);\n\t}\n\n\t// whitelist x11 directory\n\tprofile_add(\"whitelist /tmp/.X11-unix\");\n\n\t// whitelist any pulse* file in /tmp directory\n\t// some distros use PulseAudio sockets under /tmp instead of the socket in /urn/user\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tchar *cmd;\n\t\t\tif (asprintf(&cmd, \"whitelist /tmp/%s\", entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tprofile_add(cmd); // profile_add does not duplicate the string\n\t\t}\n\t}\n\tclosedir(dir);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_private_tmp(void) {\n\t// check XAUTHORITY file, KDE keeps it under /tmp\n\tchar *xauth = getenv(\"XAUTHORITY\");\n\tif (xauth) {\n\t\tchar *rp = realpath(xauth, NULL);\n\t\tif (rp && strncmp(rp, \"/tmp/\", 5) == 0) {\n\t\t\tchar *cmd;\n\t\t\tif (asprintf(&cmd, \"whitelist %s\", rp) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tprofile_add(cmd); // profile_add does not duplicate the string\n\t\t}\n\t\tif (rp)\n\t\t\tfree(rp);\n\t}\n\n\t// whitelist x11 directory\n\tprofile_add(\"whitelist /tmp/.X11-unix\");\n\n\t// whitelist any pulse* file in /tmp directory\n\t// some distros use PulseAudio sockets under /tmp instead of the socket in /urn/user\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tchar *cmd;\n\t\t\tif (asprintf(&cmd, \"whitelist /tmp/%s\", entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tprofile_add(cmd); // profile_add does not duplicate the string\n\t\t}\n\t}\n\tclosedir(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_private_cache",
          "args": [],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "1543-1565",
          "snippet": "void fs_private_cache(void) {\n\tchar *cache;\n\tif (asprintf(&cache, \"%s/.cache\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// check if ~/.cache is a valid destination\n\tstruct stat s;\n\tif (lstat(cache, &s) == -1) {\n\t\tfwarning(\"cannot find %s, tmpfs not mounted\\n\", cache);\n\t\tfree(cache);\n\t\treturn;\n\t}\n\tif (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfwarning(\"%s is a symbolic link, tmpfs not mounted\\n\", cache);\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it\\n\", cache);\n\t\tfree(cache);\n\t\treturn;\n\t}\n\t// do the mount\n\tfs_tmpfs(cache, getuid()); // check ownership of ~/.cache\n\tfree(cache);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private_cache(void) {\n\tchar *cache;\n\tif (asprintf(&cache, \"%s/.cache\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// check if ~/.cache is a valid destination\n\tstruct stat s;\n\tif (lstat(cache, &s) == -1) {\n\t\tfwarning(\"cannot find %s, tmpfs not mounted\\n\", cache);\n\t\tfree(cache);\n\t\treturn;\n\t}\n\tif (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfwarning(\"%s is a symbolic link, tmpfs not mounted\\n\", cache);\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it\\n\", cache);\n\t\tfree(cache);\n\t\treturn;\n\t}\n\t// do the mount\n\tfs_tmpfs(cache, getuid()); // check ownership of ~/.cache\n\tfree(cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_private_lib",
          "args": [],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_lib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_lib.c",
          "lines": "315-384",
          "snippet": "void fs_private_lib(void) {\n#ifndef __x86_64__\n\tfwarning(\"private-lib feature is currently available only on amd64 platforms\\n\");\n\treturn;\n#endif\n\tchar *private_list = cfg.lib_private_keep;\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Starting private-lib processing: program %s, shell %s\\n\",\n\t\t\t(cfg.original_program_index > 0)? cfg.original_argv[cfg.original_program_index]: \"none\",\n\t\t(arg_shell_none)? \"none\": cfg.shell);\n\n\t// create /run/firejail/mnt/lib directory\n\tmkdir_attr(RUN_LIB_DIR, 0755, 0, 0);\n\n\t// install standard C libraries\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Installing standard C library\\n\");\n\tfslib_install_stdc();\n\n\t// start timetrace\n\ttimetrace_start();\n\n\t// copy the libs in the new lib directory for the main exe\n\tif (cfg.original_program_index > 0) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Installing sandboxed program libraries\\n\");\n\t\tfslib_install_list(cfg.original_argv[cfg.original_program_index]);\n\t}\n\n\t// for the shell\n\tif (!arg_shell_none) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Installing shell libraries\\n\");\n\n\t\tfslib_install_list(cfg.shell);\n\t\t// a shell is useless without some basic commands\n\t\tfslib_install_list(\"/bin/ls,/bin/cat,/bin/mv,/bin/rm\");\n\n\t}\n\n\t// for the listed libs and directories\n\tif (private_list && *private_list != '\\0') {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Processing private-lib files\\n\");\n\t\tfslib_install_list(private_list);\n\t}\n\n\t// for private-bin files\n\tif (arg_private_bin && cfg.bin_private_lib && *cfg.bin_private_lib != '\\0') {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Processing private-bin files\\n\");\n\t\tfslib_install_list(cfg.bin_private_lib);\n\t}\n\tfmessage(\"Program libraries installed in %0.2f ms\\n\", timetrace_end());\n\n\t// install the reset of the system libraries\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Installing system libraries\\n\");\n\tfslib_install_system();\n\n\t// bring in firejail directory for --trace and seccomp post exec\n\t// bring in firejail executable libraries in case we are redirected here by a firejail symlink from /usr/local/bin/firejail\n\tfslib_install_list(\"/usr/bin/firejail,firejail\"); // todo: use the installed path for the executable\n\n\tfmessage(\"Installed %d %s and %d %s\\n\", lib_cnt, (lib_cnt == 1)? \"library\": \"libraries\",\n\t\tdir_cnt, (dir_cnt == 1)? \"directory\": \"directories\");\n\n\t// mount lib filesystem\n\tmount_directories();\n}",
          "includes": [
            "#include <glob.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"../include/ldd_utils.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fslib_install_stdc(void);",
            "extern void fslib_install_system(void);",
            "static int lib_cnt = 0;",
            "static int dir_cnt = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <glob.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"../include/ldd_utils.h\"\n#include \"firejail.h\"\n\nextern void fslib_install_stdc(void);\nextern void fslib_install_system(void);\nstatic int lib_cnt = 0;\nstatic int dir_cnt = 0;\n\nvoid fs_private_lib(void) {\n#ifndef __x86_64__\n\tfwarning(\"private-lib feature is currently available only on amd64 platforms\\n\");\n\treturn;\n#endif\n\tchar *private_list = cfg.lib_private_keep;\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Starting private-lib processing: program %s, shell %s\\n\",\n\t\t\t(cfg.original_program_index > 0)? cfg.original_argv[cfg.original_program_index]: \"none\",\n\t\t(arg_shell_none)? \"none\": cfg.shell);\n\n\t// create /run/firejail/mnt/lib directory\n\tmkdir_attr(RUN_LIB_DIR, 0755, 0, 0);\n\n\t// install standard C libraries\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Installing standard C library\\n\");\n\tfslib_install_stdc();\n\n\t// start timetrace\n\ttimetrace_start();\n\n\t// copy the libs in the new lib directory for the main exe\n\tif (cfg.original_program_index > 0) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Installing sandboxed program libraries\\n\");\n\t\tfslib_install_list(cfg.original_argv[cfg.original_program_index]);\n\t}\n\n\t// for the shell\n\tif (!arg_shell_none) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Installing shell libraries\\n\");\n\n\t\tfslib_install_list(cfg.shell);\n\t\t// a shell is useless without some basic commands\n\t\tfslib_install_list(\"/bin/ls,/bin/cat,/bin/mv,/bin/rm\");\n\n\t}\n\n\t// for the listed libs and directories\n\tif (private_list && *private_list != '\\0') {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Processing private-lib files\\n\");\n\t\tfslib_install_list(private_list);\n\t}\n\n\t// for private-bin files\n\tif (arg_private_bin && cfg.bin_private_lib && *cfg.bin_private_lib != '\\0') {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Processing private-bin files\\n\");\n\t\tfslib_install_list(cfg.bin_private_lib);\n\t}\n\tfmessage(\"Program libraries installed in %0.2f ms\\n\", timetrace_end());\n\n\t// install the reset of the system libraries\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Installing system libraries\\n\");\n\tfslib_install_system();\n\n\t// bring in firejail directory for --trace and seccomp post exec\n\t// bring in firejail executable libraries in case we are redirected here by a firejail symlink from /usr/local/bin/firejail\n\tfslib_install_list(\"/usr/bin/firejail,firejail\"); // todo: use the installed path for the executable\n\n\tfmessage(\"Installed %d %s and %d %s\\n\", lib_cnt, (lib_cnt == 1)? \"library\": \"libraries\",\n\t\tdir_cnt, (dir_cnt == 1)? \"directory\": \"directories\");\n\n\t// mount lib filesystem\n\tmount_directories();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_private_bin_list",
          "args": [],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_bin_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_bin.c",
          "lines": "269-313",
          "snippet": "void fs_private_bin_list(void) {\n\tchar *private_list = cfg.bin_private_keep;\n\tassert(private_list);\n\n\t// start timetrace\n\ttimetrace_start();\n\n\t// create /run/firejail/mnt/bin directory\n\tmkdir_attr(RUN_BIN_DIR, 0755, 0, 0);\n\n\tif (arg_debug)\n\t\tprintf(\"Copying files in the new bin directory\\n\");\n\n\t// copy the list of files in the new home directory\n\tchar *dlist = strdup(private_list);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-bin argument\\n\");\n\t\texit(1);\n\t}\n\tglobbing(ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tglobbing(ptr);\n\tfree(dlist);\n\tfs_logger_print();\n\n\t// mount-bind\n\tint i = 0;\n\twhile (paths[i]) {\n\t\tstruct stat s;\n\t\tif (stat(paths[i], &s) == 0) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_BIN_DIR, paths[i]);\n\t\t\tif (mount(RUN_BIN_DIR, paths[i], NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\tfs_logger2(\"tmpfs\", paths[i]);\n\t\t\tfs_logger2(\"mount\", paths[i]);\n\t\t}\n\t\ti++;\n\t}\n\tfmessage(\"%d %s installed in %0.2f ms\\n\", prog_cnt, (prog_cnt == 1)? \"program\": \"programs\", timetrace_end());\n}",
          "includes": [
            "#include <glob.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int prog_cnt = 0;",
            "static char *paths[] = {\n\t\"/usr/local/bin\",\n\t\"/usr/bin\",\n\t\"/bin\",\n\t\"/usr/games\",\n\t\"/usr/local/games\",\n\t\"/usr/local/sbin\",\n\t\"/usr/sbin\",\n\t\"/sbin\",\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <glob.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int prog_cnt = 0;\nstatic char *paths[] = {\n\t\"/usr/local/bin\",\n\t\"/usr/bin\",\n\t\"/bin\",\n\t\"/usr/games\",\n\t\"/usr/local/games\",\n\t\"/usr/local/sbin\",\n\t\"/usr/sbin\",\n\t\"/sbin\",\n\tNULL\n};\n\nvoid fs_private_bin_list(void) {\n\tchar *private_list = cfg.bin_private_keep;\n\tassert(private_list);\n\n\t// start timetrace\n\ttimetrace_start();\n\n\t// create /run/firejail/mnt/bin directory\n\tmkdir_attr(RUN_BIN_DIR, 0755, 0, 0);\n\n\tif (arg_debug)\n\t\tprintf(\"Copying files in the new bin directory\\n\");\n\n\t// copy the list of files in the new home directory\n\tchar *dlist = strdup(private_list);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-bin argument\\n\");\n\t\texit(1);\n\t}\n\tglobbing(ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tglobbing(ptr);\n\tfree(dlist);\n\tfs_logger_print();\n\n\t// mount-bind\n\tint i = 0;\n\twhile (paths[i]) {\n\t\tstruct stat s;\n\t\tif (stat(paths[i], &s) == 0) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_BIN_DIR, paths[i]);\n\t\t\tif (mount(RUN_BIN_DIR, paths[i], NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\tfs_logger2(\"tmpfs\", paths[i]);\n\t\t\tfs_logger2(\"mount\", paths[i]);\n\t\t}\n\t\ti++;\n\t}\n\tfmessage(\"%d %s installed in %0.2f ms\\n\", prog_cnt, (prog_cnt == 1)? \"program\": \"programs\", timetrace_end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&tmp",
            "\"%s,xauth\"",
            "cfg.bin_private_keep"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_private_dir_list",
          "args": [
            "\"/srv\"",
            "RUN_SRV_DIR",
            "cfg.srv_private_keep"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_dir_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_etc.c",
          "lines": "140-186",
          "snippet": "void fs_private_dir_list(const char *private_dir, const char *private_run_dir, const char *private_list) {\n\tassert(private_dir);\n\tassert(private_run_dir);\n\tassert(private_list);\n\n\ttimetrace_start();\n\n\t// create /run/firejail/mnt/etc directory\n\tmkdir_attr(private_run_dir, 0755, 0, 0);\n\tfs_logger2(\"tmpfs\", private_dir);\n\n\tfs_logger_print();\t// save the current log\n\n\n\t// copy the list of files in the new etc directory\n\t// using a new child process with root privileges\n\tif (*private_list != '\\0') {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Copying files in the new %s directory:\\n\", private_dir);\n\n\t\t// copy the list of files in the new home directory\n\t\tchar *dlist = strdup(private_list);\n\t\tif (!dlist)\n\t\t\terrExit(\"strdup\");\n\n\n\t\tchar *ptr = strtok(dlist, \",\");\n\t\tif (!ptr) {\n\t\t\tfprintf(stderr, \"Error: invalid private %s argument\\n\", private_dir);\n\t\t\texit(1);\n\t\t}\n\t\tduplicate(ptr, private_dir, private_run_dir);\n\n\t\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\t\tduplicate(ptr, private_dir, private_run_dir);\n\t\tfree(dlist);\n\t\tfs_logger_print();\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_run_dir, private_dir);\n\tif (mount(private_run_dir, private_dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"mount\", private_dir);\n\n\tfmessage(\"Private %s installed in %0.2f ms\\n\", private_dir, timetrace_end());\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private_dir_list(const char *private_dir, const char *private_run_dir, const char *private_list) {\n\tassert(private_dir);\n\tassert(private_run_dir);\n\tassert(private_list);\n\n\ttimetrace_start();\n\n\t// create /run/firejail/mnt/etc directory\n\tmkdir_attr(private_run_dir, 0755, 0, 0);\n\tfs_logger2(\"tmpfs\", private_dir);\n\n\tfs_logger_print();\t// save the current log\n\n\n\t// copy the list of files in the new etc directory\n\t// using a new child process with root privileges\n\tif (*private_list != '\\0') {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Copying files in the new %s directory:\\n\", private_dir);\n\n\t\t// copy the list of files in the new home directory\n\t\tchar *dlist = strdup(private_list);\n\t\tif (!dlist)\n\t\t\terrExit(\"strdup\");\n\n\n\t\tchar *ptr = strtok(dlist, \",\");\n\t\tif (!ptr) {\n\t\t\tfprintf(stderr, \"Error: invalid private %s argument\\n\", private_dir);\n\t\t\texit(1);\n\t\t}\n\t\tduplicate(ptr, private_dir, private_run_dir);\n\n\t\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\t\tduplicate(ptr, private_dir, private_run_dir);\n\t\tfree(dlist);\n\t\tfs_logger_print();\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_run_dir, private_dir);\n\tif (mount(private_run_dir, private_dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"mount\", private_dir);\n\n\tfmessage(\"Private %s installed in %0.2f ms\\n\", private_dir, timetrace_end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_trace_preload",
          "args": [],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "fs_trace_preload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_trace.c",
          "lines": "29-44",
          "snippet": "void fs_trace_preload(void) {\n\tstruct stat s;\n\n\t// create an empty /etc/ld.so.preload\n\tif (stat(\"/etc/ld.so.preload\", &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating an empty /etc/ld.so.preload file\\n\");\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/etc/ld.so.preload\", \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp);\n\t\tfs_logger(\"touch /etc/ld.so.preload\");\n\t}\n}",
          "includes": [
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_trace_preload(void) {\n\tstruct stat s;\n\n\t// create an empty /etc/ld.so.preload\n\tif (stat(\"/etc/ld.so.preload\", &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating an empty /etc/ld.so.preload file\\n\");\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/etc/ld.so.preload\", \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp);\n\t\tfs_logger(\"touch /etc/ld.so.preload\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_private_dev",
          "args": [],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_dev.c",
          "lines": "203-315",
          "snippet": "void fs_private_dev(void){\n\t// install a new /dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on /dev\\n\");\n\n\t// create DRI_DIR\n\t// keep a copy of dev directory\n\tmkdir_attr(RUN_DEV_DIR, 0755, 0, 0);\n\tif (mount(\"/dev\", RUN_DEV_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\n\t// create DEVLOG_FILE\n\tint have_devlog = 0;\n\tstruct stat s;\n\tif (stat(\"/dev/log\", &s) == 0) {\n\t\thave_devlog = 1;\n\t\tFILE *fp = fopen(RUN_DEVLOG_FILE, \"w\");\n\t\tif (!fp)\n\t\t\thave_devlog = 0;\n\t\telse {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tfclose(fp);\n\t\t\tif (mount(\"/dev/log\", RUN_DEVLOG_FILE, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /dev/log\");\n\t\t}\n\t}\n\n\t// mount tmpfs on top of /dev\n\tif (mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"tmpfs /dev\");\n\n\t// optional devices: sound, video cards etc...\n\tdeventry_mount();\n\n\t// bring back /dev/log\n\tif (have_devlog) {\n\t\tFILE *fp = fopen(\"/dev/log\", \"w\");\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tfclose(fp);\n\t\t\tif (mount(RUN_DEVLOG_FILE, \"/dev/log\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /dev/log\");\n\t\t\tfs_logger(\"clone /dev/log\");\n\t\t}\n\t}\n\n\t// bring forward the current /dev/shm directory if necessary\n\tif (arg_debug)\n\t\tprintf(\"Process /dev/shm directory\\n\");\n\tprocess_dev_shm();\n\n\tif (mount(RUN_RO_DIR, RUN_DEV_DIR, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"disable run dev directory\");\n\n\t// create default devices\n\tcreate_char_dev(\"/dev/zero\", 0666, 1, 5); // mknod -m 666 /dev/zero c 1 5\n\tfs_logger(\"mknod /dev/zero\");\n\tcreate_char_dev(\"/dev/null\", 0666, 1, 3); // mknod -m 666 /dev/null c 1 3\n\tfs_logger(\"mknod /dev/null\");\n\tcreate_char_dev(\"/dev/full\", 0666, 1, 7); // mknod -m 666 /dev/full c 1 7\n\tfs_logger(\"mknod /dev/full\");\n\tcreate_char_dev(\"/dev/random\", 0666, 1, 8); // Mknod -m 666 /dev/random c 1 8\n\tfs_logger(\"mknod /dev/random\");\n\tcreate_char_dev(\"/dev/urandom\", 0666, 1, 9); // mknod -m 666 /dev/urandom c 1 9\n\tfs_logger(\"mknod /dev/urandom\");\n\tcreate_char_dev(\"/dev/tty\", 0666,  5, 0); // mknod -m 666 /dev/tty c 5 0\n\tfs_logger(\"mknod /dev/tty\");\n#if 0\n\tcreate_dev(\"/dev/tty0\", \"mknod -m 666 /dev/tty0 c 4 0\");\n\tcreate_dev(\"/dev/console\", \"mknod -m 622 /dev/console c 5 1\");\n#endif\n\n\t// pseudo-terminal\n\tmkdir_attr(\"/dev/pts\", 0755, 0, 0);\n\tfs_logger(\"mkdir /dev/pts\");\n\tfs_logger(\"create /dev/pts\");\n\tcreate_char_dev(\"/dev/pts/ptmx\", 0666, 5, 2); //\"mknod -m 666 /dev/pts/ptmx c 5 2\");\n\tfs_logger(\"mknod /dev/pts/ptmx\");\n\tcreate_link(\"/dev/pts/ptmx\", \"/dev/ptmx\");\n\n// code before github issue #351\n\t// mount -vt devpts -o newinstance -o ptmxmode=0666 devpts //dev/pts\n//\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,  \"newinstance,ptmxmode=0666\") < 0)\n//\t\terrExit(\"mounting /dev/pts\");\n\n\n\t// mount /dev/pts\n\tgid_t ttygid = get_group_id(\"tty\");\n\tchar *data;\n\tif (asprintf(&data, \"newinstance,gid=%d,mode=620,ptmxmode=0666\", (int) ttygid) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,  data) < 0)\n\t\terrExit(\"mounting /dev/pts\");\n\tfree(data);\n\tfs_logger(\"clone /dev/pts\");\n\n\t// stdin, stdout, stderr\n#if 0\n\tcreate_link(\"/proc/self/fd\", \"/dev/fd\");\n\tcreate_link(\"/proc/self/fd/0\", \"/dev/stdin\");\n\tcreate_link(\"/proc/self/fd/1\", \"/dev/stdout\");\n\tcreate_link(\"/proc/self/fd/2\", \"/dev/stderr\");\n#endif\n\n\t// symlinks for DVD/CD players\n\tif (stat(\"/dev/sr0\", &s) == 0) {\n\t\tcreate_link(\"/dev/sr0\", \"/dev/cdrom\");\n\t\tcreate_link(\"/dev/sr0\", \"/dev/cdrw\");\n\t\tcreate_link(\"/dev/sr0\", \"/dev/dvd\");\n\t\tcreate_link(\"/dev/sr0\", \"/dev/dvdrw\");\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/sysmacros.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/sysmacros.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic DevEntry dev[] = {\n\t{\"/dev/snd\", RUN_DEV_DIR \"/snd\", DEV_SOUND},\t// sound device\n\t{\"/dev/dri\", RUN_DEV_DIR \"/dri\", DEV_3D},\t\t// 3d device\n\t{\"/dev/nvidia0\", RUN_DEV_DIR \"/nvidia0\", DEV_3D},\n\t{\"/dev/nvidia1\", RUN_DEV_DIR \"/nvidia1\", DEV_3D},\n\t{\"/dev/nvidia2\", RUN_DEV_DIR \"/nvidia2\", DEV_3D},\n\t{\"/dev/nvidia3\", RUN_DEV_DIR \"/nvidia3\", DEV_3D},\n\t{\"/dev/nvidia4\", RUN_DEV_DIR \"/nvidia4\", DEV_3D},\n\t{\"/dev/nvidia5\", RUN_DEV_DIR \"/nvidia5\", DEV_3D},\n\t{\"/dev/nvidia6\", RUN_DEV_DIR \"/nvidia6\", DEV_3D},\n\t{\"/dev/nvidia7\", RUN_DEV_DIR \"/nvidia7\", DEV_3D},\n\t{\"/dev/nvidia8\", RUN_DEV_DIR \"/nvidia8\", DEV_3D},\n\t{\"/dev/nvidia9\", RUN_DEV_DIR \"/nvidia9\", DEV_3D},\n\t{\"/dev/nvidiactl\", RUN_DEV_DIR \"/nvidiactl\", DEV_3D},\n\t{\"/dev/nvidia-modeset\", RUN_DEV_DIR \"/nvidia-modeset\", DEV_3D},\n\t{\"/dev/nvidia-uvm\", RUN_DEV_DIR \"/nvidia-uvm\", DEV_3D},\n\t{\"/dev/video0\", RUN_DEV_DIR \"/video0\", DEV_VIDEO}, // video camera devices\n\t{\"/dev/video1\", RUN_DEV_DIR \"/video1\", DEV_VIDEO},\n\t{\"/dev/video2\", RUN_DEV_DIR \"/video2\", DEV_VIDEO},\n\t{\"/dev/video3\", RUN_DEV_DIR \"/video3\", DEV_VIDEO},\n\t{\"/dev/video4\", RUN_DEV_DIR \"/video4\", DEV_VIDEO},\n\t{\"/dev/video5\", RUN_DEV_DIR \"/video5\", DEV_VIDEO},\n\t{\"/dev/video6\", RUN_DEV_DIR \"/video6\", DEV_VIDEO},\n\t{\"/dev/video7\", RUN_DEV_DIR \"/video7\", DEV_VIDEO},\n\t{\"/dev/video8\", RUN_DEV_DIR \"/video8\", DEV_VIDEO},\n\t{\"/dev/video9\", RUN_DEV_DIR \"/video9\", DEV_VIDEO},\n\t{\"/dev/dvb\", RUN_DEV_DIR \"/dvb\", DEV_TV}, // DVB (Digital Video Broadcasting) - TV device\n\t{\"/dev/sr0\", RUN_DEV_DIR \"/sr0\", DEV_DVD}, // for DVD and audio CD players\n\t{\"/dev/hidraw0\", RUN_DEV_DIR \"/hidraw0\", DEV_U2F},\n\t{\"/dev/hidraw1\", RUN_DEV_DIR \"/hidraw1\", DEV_U2F},\n\t{\"/dev/hidraw2\", RUN_DEV_DIR \"/hidraw2\", DEV_U2F},\n\t{\"/dev/hidraw3\", RUN_DEV_DIR \"/hidraw3\", DEV_U2F},\n\t{\"/dev/hidraw4\", RUN_DEV_DIR \"/hidraw4\", DEV_U2F},\n\t{\"/dev/hidraw5\", RUN_DEV_DIR \"/hidraw5\", DEV_U2F},\n\t{\"/dev/hidraw6\", RUN_DEV_DIR \"/hidraw6\", DEV_U2F},\n\t{\"/dev/hidraw7\", RUN_DEV_DIR \"/hidraw7\", DEV_U2F},\n\t{\"/dev/hidraw8\", RUN_DEV_DIR \"/hidraw8\", DEV_U2F},\n\t{\"/dev/hidraw9\", RUN_DEV_DIR \"/hidraw9\", DEV_U2F},\n\t{\"/dev/usb\", RUN_DEV_DIR \"/usb\", DEV_U2F},\t// USB devices such as Yubikey, U2F\n\t{NULL, NULL, DEV_NONE}\n};\n\nvoid fs_private_dev(void){\n\t// install a new /dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on /dev\\n\");\n\n\t// create DRI_DIR\n\t// keep a copy of dev directory\n\tmkdir_attr(RUN_DEV_DIR, 0755, 0, 0);\n\tif (mount(\"/dev\", RUN_DEV_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\n\t// create DEVLOG_FILE\n\tint have_devlog = 0;\n\tstruct stat s;\n\tif (stat(\"/dev/log\", &s) == 0) {\n\t\thave_devlog = 1;\n\t\tFILE *fp = fopen(RUN_DEVLOG_FILE, \"w\");\n\t\tif (!fp)\n\t\t\thave_devlog = 0;\n\t\telse {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tfclose(fp);\n\t\t\tif (mount(\"/dev/log\", RUN_DEVLOG_FILE, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /dev/log\");\n\t\t}\n\t}\n\n\t// mount tmpfs on top of /dev\n\tif (mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"tmpfs /dev\");\n\n\t// optional devices: sound, video cards etc...\n\tdeventry_mount();\n\n\t// bring back /dev/log\n\tif (have_devlog) {\n\t\tFILE *fp = fopen(\"/dev/log\", \"w\");\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tfclose(fp);\n\t\t\tif (mount(RUN_DEVLOG_FILE, \"/dev/log\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /dev/log\");\n\t\t\tfs_logger(\"clone /dev/log\");\n\t\t}\n\t}\n\n\t// bring forward the current /dev/shm directory if necessary\n\tif (arg_debug)\n\t\tprintf(\"Process /dev/shm directory\\n\");\n\tprocess_dev_shm();\n\n\tif (mount(RUN_RO_DIR, RUN_DEV_DIR, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"disable run dev directory\");\n\n\t// create default devices\n\tcreate_char_dev(\"/dev/zero\", 0666, 1, 5); // mknod -m 666 /dev/zero c 1 5\n\tfs_logger(\"mknod /dev/zero\");\n\tcreate_char_dev(\"/dev/null\", 0666, 1, 3); // mknod -m 666 /dev/null c 1 3\n\tfs_logger(\"mknod /dev/null\");\n\tcreate_char_dev(\"/dev/full\", 0666, 1, 7); // mknod -m 666 /dev/full c 1 7\n\tfs_logger(\"mknod /dev/full\");\n\tcreate_char_dev(\"/dev/random\", 0666, 1, 8); // Mknod -m 666 /dev/random c 1 8\n\tfs_logger(\"mknod /dev/random\");\n\tcreate_char_dev(\"/dev/urandom\", 0666, 1, 9); // mknod -m 666 /dev/urandom c 1 9\n\tfs_logger(\"mknod /dev/urandom\");\n\tcreate_char_dev(\"/dev/tty\", 0666,  5, 0); // mknod -m 666 /dev/tty c 5 0\n\tfs_logger(\"mknod /dev/tty\");\n#if 0\n\tcreate_dev(\"/dev/tty0\", \"mknod -m 666 /dev/tty0 c 4 0\");\n\tcreate_dev(\"/dev/console\", \"mknod -m 622 /dev/console c 5 1\");\n#endif\n\n\t// pseudo-terminal\n\tmkdir_attr(\"/dev/pts\", 0755, 0, 0);\n\tfs_logger(\"mkdir /dev/pts\");\n\tfs_logger(\"create /dev/pts\");\n\tcreate_char_dev(\"/dev/pts/ptmx\", 0666, 5, 2); //\"mknod -m 666 /dev/pts/ptmx c 5 2\");\n\tfs_logger(\"mknod /dev/pts/ptmx\");\n\tcreate_link(\"/dev/pts/ptmx\", \"/dev/ptmx\");\n\n// code before github issue #351\n\t// mount -vt devpts -o newinstance -o ptmxmode=0666 devpts //dev/pts\n//\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,  \"newinstance,ptmxmode=0666\") < 0)\n//\t\terrExit(\"mounting /dev/pts\");\n\n\n\t// mount /dev/pts\n\tgid_t ttygid = get_group_id(\"tty\");\n\tchar *data;\n\tif (asprintf(&data, \"newinstance,gid=%d,mode=620,ptmxmode=0666\", (int) ttygid) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,  data) < 0)\n\t\terrExit(\"mounting /dev/pts\");\n\tfree(data);\n\tfs_logger(\"clone /dev/pts\");\n\n\t// stdin, stdout, stderr\n#if 0\n\tcreate_link(\"/proc/self/fd\", \"/dev/fd\");\n\tcreate_link(\"/proc/self/fd/0\", \"/dev/stdin\");\n\tcreate_link(\"/proc/self/fd/1\", \"/dev/stdout\");\n\tcreate_link(\"/proc/self/fd/2\", \"/dev/stderr\");\n#endif\n\n\t// symlinks for DVD/CD players\n\tif (stat(\"/dev/sr0\", &s) == 0) {\n\t\tcreate_link(\"/dev/sr0\", \"/dev/cdrom\");\n\t\tcreate_link(\"/dev/sr0\", \"/dev/cdrw\");\n\t\tcreate_link(\"/dev/sr0\", \"/dev/dvd\");\n\t\tcreate_link(\"/dev/sr0\", \"/dev/dvdrw\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_private_home_list",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_home_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "471-540",
          "snippet": "void fs_private_home_list(void) {\n\ttimetrace_start();\n\n\tchar *homedir = cfg.homedir;\n\tchar *private_list = cfg.home_private_keep;\n\tassert(homedir);\n\tassert(private_list);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\n\t// create /run/firejail/mnt/home directory\n\tmkdir_attr(RUN_HOME_DIR, 0755, uid, gid);\n\tfs_logger_print();\t// save the current log\n\n\tif (arg_debug)\n\t\tprintf(\"Copying files in the new home:\\n\");\n\n\t// copy the list of files in the new home directory\n\tchar *dlist = strdup(cfg.home_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-home argument\\n\");\n\t\texit(1);\n\t}\n\tduplicate(ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tduplicate(ptr);\n\n\tfs_logger_print();\t// save the current log\n\tfree(dlist);\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_HOME_DIR, homedir);\n\n\tif (mount(RUN_HOME_DIR, homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"tmpfs\", homedir);\n\n\tif (uid != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\n\tskel(homedir, uid, gid);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Home directory installed in %0.2f ms\\n\", timetrace_end());\n\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private_home_list(void) {\n\ttimetrace_start();\n\n\tchar *homedir = cfg.homedir;\n\tchar *private_list = cfg.home_private_keep;\n\tassert(homedir);\n\tassert(private_list);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\n\t// create /run/firejail/mnt/home directory\n\tmkdir_attr(RUN_HOME_DIR, 0755, uid, gid);\n\tfs_logger_print();\t// save the current log\n\n\tif (arg_debug)\n\t\tprintf(\"Copying files in the new home:\\n\");\n\n\t// copy the list of files in the new home directory\n\tchar *dlist = strdup(cfg.home_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-home argument\\n\");\n\t\texit(1);\n\t}\n\tduplicate(ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tduplicate(ptr);\n\n\tfs_logger_print();\t// save the current log\n\tfree(dlist);\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_HOME_DIR, homedir);\n\n\tif (mount(RUN_HOME_DIR, homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"tmpfs\", homedir);\n\n\tif (uid != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\n\tskel(homedir, uid, gid);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Home directory installed in %0.2f ms\\n\", timetrace_end());\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_private_homedir",
          "args": [],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_homedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_home.c",
          "lines": "223-292",
          "snippet": "void fs_private_homedir(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_homedir = cfg.home_private;\n\tassert(homedir);\n\tassert(private_homedir);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\n\t// mount bind private_homedir on top of homedir\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_homedir, homedir);\n\t// get a file descriptor for private_homedir, fails if there is any symlink\n\tint fd = safe_fd(private_homedir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\t// check if new home directory is owned by the user\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != getuid()) {\n\t\tfprintf(stderr, \"Error: private directory is not owned by the current user\\n\");\n\t\texit(1);\n\t}\n\tif ((S_IRWXU & s.st_mode) != S_IRWXU)\n\t\tfwarning(\"no full permissions on private directory\\n\");\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(proc, homedir, NULL, MS_NOSUID | MS_NODEV | MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(proc);\n\tclose(fd);\n\n\tfs_logger3(\"mount-bind\", private_homedir, cfg.homedir);\n\tfs_logger2(\"whitelist\", cfg.homedir);\n// preserve mode and ownership\n//\tif (chown(homedir, s.st_uid, s.st_gid) == -1)\n//\t\terrExit(\"mount-bind chown\");\n//\tif (chmod(homedir, s.st_mode) == -1)\n//\t\terrExit(\"mount-bind chmod\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /root\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /home\");\n\t}\n\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private_homedir(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_homedir = cfg.home_private;\n\tassert(homedir);\n\tassert(private_homedir);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\n\t// mount bind private_homedir on top of homedir\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_homedir, homedir);\n\t// get a file descriptor for private_homedir, fails if there is any symlink\n\tint fd = safe_fd(private_homedir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\t// check if new home directory is owned by the user\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != getuid()) {\n\t\tfprintf(stderr, \"Error: private directory is not owned by the current user\\n\");\n\t\texit(1);\n\t}\n\tif ((S_IRWXU & s.st_mode) != S_IRWXU)\n\t\tfwarning(\"no full permissions on private directory\\n\");\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(proc, homedir, NULL, MS_NOSUID | MS_NODEV | MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(proc);\n\tclose(fd);\n\n\tfs_logger3(\"mount-bind\", private_homedir, cfg.homedir);\n\tfs_logger2(\"whitelist\", cfg.homedir);\n// preserve mode and ownership\n//\tif (chown(homedir, s.st_uid, s.st_gid) == -1)\n//\t\terrExit(\"mount-bind chown\");\n//\tif (chmod(homedir, s.st_mode) == -1)\n//\t\terrExit(\"mount-bind chmod\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /root\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /home\");\n\t}\n\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_basic_fs",
          "args": [],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "fs_basic_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "820-863",
          "snippet": "void fs_basic_fs(void) {\n\tuid_t uid = getuid();\n\n\tif (arg_debug)\n\t\tprintf(\"Basic read-only filesystem:\\n\");\n\tif (!arg_writable_etc) {\n\t\tfs_rdonly(\"/etc\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/etc\");\n\t}\n\tif (!arg_writable_var) {\n\t\tfs_rdonly(\"/var\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/var\");\n\t}\n\tfs_rdonly(\"/bin\");\n\tfs_rdonly(\"/sbin\");\n\tfs_rdonly(\"/lib\");\n\tfs_rdonly(\"/lib64\");\n\tfs_rdonly(\"/lib32\");\n\tfs_rdonly(\"/libx32\");\n\tfs_rdonly(\"/usr\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t  fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\telse\n\t\tfs_rdwr(\"/var/log\");\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (uid)\n\t\tdisable_config();\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_basic_fs(void) {\n\tuid_t uid = getuid();\n\n\tif (arg_debug)\n\t\tprintf(\"Basic read-only filesystem:\\n\");\n\tif (!arg_writable_etc) {\n\t\tfs_rdonly(\"/etc\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/etc\");\n\t}\n\tif (!arg_writable_var) {\n\t\tfs_rdonly(\"/var\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/var\");\n\t}\n\tfs_rdonly(\"/bin\");\n\tfs_rdonly(\"/sbin\");\n\tfs_rdonly(\"/lib\");\n\tfs_rdonly(\"/lib64\");\n\tfs_rdonly(\"/lib32\");\n\tfs_rdonly(\"/libx32\");\n\tfs_rdonly(\"/usr\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t  fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\telse\n\t\tfs_rdwr(\"/var/log\");\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (uid)\n\t\tdisable_config();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_overlayfs",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "fs_overlayfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "954-1209",
          "snippet": "void fs_overlayfs(void) {\n\tstruct stat s;\n\n\t// check kernel version\n\tstruct utsname u;\n\tint rv = uname(&u);\n\tif (rv != 0)\n\t\terrExit(\"uname\");\n\tint major;\n\tint minor;\n\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Linux kernel version %d.%d\\n\", major, minor);\n\tint oldkernel = 0;\n\tif (major < 3) {\n\t\tfprintf(stderr, \"Error: minimum kernel version required 3.x\\n\");\n\t\texit(1);\n\t}\n\tif (major == 3 && minor < 18)\n\t\toldkernel = 1;\n\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tmkdir_attr(oroot, 0755, 0, 0);\n\n\t// set base for working and diff directories\n\tchar *basedir = RUN_MNT_DIR;\n\tint basefd = -1;\n\n\tif (arg_overlay_keep) {\n\t\tbasedir = cfg.overlay_dir;\n\t\tassert(basedir);\n\t\t// get a file descriptor for ~/.firejail, fails if there is any symlink\n\t\tchar *firejail;\n\t\tif (asprintf(&firejail, \"%s/.firejail\", cfg.homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tint fd = safe_fd(firejail, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\terrExit(\"safe_fd\");\n\t\tfree(firejail);\n\t\t// create basedir if it doesn't exist\n\t\t// the new directory will be owned by root\n\t\tconst char *dirname = gnu_basename(basedir);\n\t\tif (mkdirat(fd, dirname, 0755) == -1 && errno != EEXIST) {\n\t\t\tperror(\"mkdir\");\n\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", basedir);\n\t\t\texit(1);\n\t\t}\n\t\t// open basedir\n\t\tbasefd = openat(fd, dirname, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tclose(fd);\n\t}\n\telse {\n\t\tbasefd = open(basedir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t}\n\tif (basefd == -1) {\n\t\tperror(\"open\");\n\t\tfprintf(stderr, \"Error: cannot open overlay directory %s\\n\", basedir);\n\t\texit(1);\n\t}\n\n\t// confirm once more base is owned by root\n\tif (fstat(basefd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: overlay directory %s is not owned by the root user\\n\", basedir);\n\t\texit(1);\n\t}\n\t// confirm permissions of base are 0755\n\tif (((S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) & s.st_mode) != (S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)) {\n\t\tfprintf(stderr, \"Error: invalid permissions on overlay directory %s\\n\", basedir);\n\t\texit(1);\n\t}\n\n\t// create diff and work directories inside base\n\t// no need to check arg_overlay_reuse\n\tchar *odiff;\n\tif (asprintf(&odiff, \"%s/odiff\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// the new directory will be owned by root\n\tif (mkdirat(basefd, \"odiff\", 0755) == -1 && errno != EEXIST) {\n\t\tperror(\"mkdir\");\n\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", odiff);\n\t\texit(1);\n\t}\n\tASSERT_PERMS(odiff, 0, 0, 0755);\n\n\tchar *owork;\n\tif (asprintf(&owork, \"%s/owork\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// the new directory will be owned by root\n\tif (mkdirat(basefd, \"owork\", 0755) == -1 && errno != EEXIST) {\n\t\tperror(\"mkdir\");\n\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", owork);\n\t\texit(1);\n\t}\n\tASSERT_PERMS(owork, 0, 0, 0755);\n\n\t// mount overlayfs\n\tif (arg_debug)\n\t\tprintf(\"Mounting OverlayFS\\n\");\n\tchar *option;\n\tif (oldkernel) { // old Ubuntu/OpenSUSE kernels\n\t\tif (arg_overlay_keep) {\n\t\t\tfprintf(stderr, \"Error: option --overlay= not available for kernels older than 3.18\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s\", odiff) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlayfs\", oroot, \"overlayfs\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t}\n\telse { // kernel 3.18 or newer\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s,workdir=%s\", odiff, owork) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlay\", oroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\n\t\t//***************************\n\t\t// issue #263 start code\n\t\t// My setup has a separate mount point for /home. When the overlay is mounted,\n\t\t// the overlay does not contain the original /home contents.\n\t\t// I added code to create a second overlay for /home if the overlay home dir is empty and this seems to work\n\t\t// @dshmgh, Jan 2016\n\t\t{\n\t\t\tchar *overlayhome;\n\t\t\tstruct stat s;\n\t\t\tchar *hroot;\n\t\t\tchar *hdiff;\n\t\t\tchar *hwork;\n\n\t\t\t// dons add debug\n\t\t\tif (arg_debug) printf (\"DEBUG: chroot dirs are oroot %s  odiff %s  owork %s\\n\",oroot,odiff,owork);\n\n\t\t\t// BEFORE NEXT, WE NEED TO TEST IF /home has any contents or do we need to mount it?\n\t\t\t// must create var for oroot/cfg.homedir\n\t\t\tif (asprintf(&overlayhome, \"%s%s\", oroot, cfg.homedir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug) printf (\"DEBUG: overlayhome var holds ##%s##\\n\", overlayhome);\n\n\t\t\t// if no homedir in overlay -- create another overlay for /home\n\t\t\tif (stat(cfg.homedir, &s) == 0 && stat(overlayhome, &s) == -1) {\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (asprintf(&hdiff, \"%s/hdiff\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t// the new directory will be owned by root\n\t\t\t\tif (mkdirat(basefd, \"hdiff\", 0755) == -1 && errno != EEXIST) {\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", hdiff);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tASSERT_PERMS(hdiff, 0, 0, 0755);\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (asprintf(&hwork, \"%s/hwork\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t// the new directory will be owned by root\n\t\t\t\tif (mkdirat(basefd, \"hwork\", 0755) == -1 && errno != EEXIST) {\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", hwork);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tASSERT_PERMS(hwork, 0, 0, 0755);\n\n\t\t\t\t// no homedir in overlay so now mount another overlay for /home\n\t\t\t\tif (asprintf(&hroot, \"%s/home\", oroot) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (asprintf(&option, \"lowerdir=/home,upperdir=%s,workdir=%s\", hdiff, hwork) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (mount(\"overlay\", hroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\t\t\terrExit(\"mounting overlayfs for mounted home directory\");\n\n\t\t\t\tprintf(\"OverlayFS for /home configured in %s directory\\n\", basedir);\n\t\t\t\tfree(hroot);\n\t\t\t\tfree(hdiff);\n\t\t\t\tfree(hwork);\n\n\t\t\t} // stat(overlayhome)\n\t\t\tfree(overlayhome);\n\t\t}\n\t\t// issue #263 end code\n\t\t//***************************\n\t}\n\tfmessage(\"OverlayFS configured in %s directory\\n\", basedir);\n\tclose(basefd);\n\n\t// /dev, /run and /tmp are not covered by the overlay\n\t// mount-bind dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev\\n\");\n\tchar *dev;\n\tif (asprintf(&dev, \"%s/dev\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/dev\", dev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"whitelist /dev\");\n\n\t// mount-bind run directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /run\\n\");\n\tchar *run;\n\tif (asprintf(&run, \"%s/run\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/run\", run, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /run\");\n\tfs_logger(\"whitelist /run\");\n\n\t// mount-bind tmp directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /tmp\\n\");\n\tchar *tmp;\n\tif (asprintf(&tmp, \"%s/tmp\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/tmp\", tmp, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /tmp\");\n\tfs_logger(\"whitelist /tmp\");\n\n\t// chroot in the new filesystem\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\tif (chroot(oroot) == -1)\n\t\terrExit(\"chroot\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\tif (!arg_private_dev)\n//\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t\tfs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n\n\t// cleanup and exit\n\tfree(option);\n\tfree(odiff);\n\tfree(owork);\n\tfree(dev);\n\tfree(run);\n\tfree(tmp);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_overlayfs(void) {\n\tstruct stat s;\n\n\t// check kernel version\n\tstruct utsname u;\n\tint rv = uname(&u);\n\tif (rv != 0)\n\t\terrExit(\"uname\");\n\tint major;\n\tint minor;\n\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Linux kernel version %d.%d\\n\", major, minor);\n\tint oldkernel = 0;\n\tif (major < 3) {\n\t\tfprintf(stderr, \"Error: minimum kernel version required 3.x\\n\");\n\t\texit(1);\n\t}\n\tif (major == 3 && minor < 18)\n\t\toldkernel = 1;\n\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tmkdir_attr(oroot, 0755, 0, 0);\n\n\t// set base for working and diff directories\n\tchar *basedir = RUN_MNT_DIR;\n\tint basefd = -1;\n\n\tif (arg_overlay_keep) {\n\t\tbasedir = cfg.overlay_dir;\n\t\tassert(basedir);\n\t\t// get a file descriptor for ~/.firejail, fails if there is any symlink\n\t\tchar *firejail;\n\t\tif (asprintf(&firejail, \"%s/.firejail\", cfg.homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tint fd = safe_fd(firejail, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\terrExit(\"safe_fd\");\n\t\tfree(firejail);\n\t\t// create basedir if it doesn't exist\n\t\t// the new directory will be owned by root\n\t\tconst char *dirname = gnu_basename(basedir);\n\t\tif (mkdirat(fd, dirname, 0755) == -1 && errno != EEXIST) {\n\t\t\tperror(\"mkdir\");\n\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", basedir);\n\t\t\texit(1);\n\t\t}\n\t\t// open basedir\n\t\tbasefd = openat(fd, dirname, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tclose(fd);\n\t}\n\telse {\n\t\tbasefd = open(basedir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t}\n\tif (basefd == -1) {\n\t\tperror(\"open\");\n\t\tfprintf(stderr, \"Error: cannot open overlay directory %s\\n\", basedir);\n\t\texit(1);\n\t}\n\n\t// confirm once more base is owned by root\n\tif (fstat(basefd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: overlay directory %s is not owned by the root user\\n\", basedir);\n\t\texit(1);\n\t}\n\t// confirm permissions of base are 0755\n\tif (((S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) & s.st_mode) != (S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)) {\n\t\tfprintf(stderr, \"Error: invalid permissions on overlay directory %s\\n\", basedir);\n\t\texit(1);\n\t}\n\n\t// create diff and work directories inside base\n\t// no need to check arg_overlay_reuse\n\tchar *odiff;\n\tif (asprintf(&odiff, \"%s/odiff\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// the new directory will be owned by root\n\tif (mkdirat(basefd, \"odiff\", 0755) == -1 && errno != EEXIST) {\n\t\tperror(\"mkdir\");\n\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", odiff);\n\t\texit(1);\n\t}\n\tASSERT_PERMS(odiff, 0, 0, 0755);\n\n\tchar *owork;\n\tif (asprintf(&owork, \"%s/owork\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// the new directory will be owned by root\n\tif (mkdirat(basefd, \"owork\", 0755) == -1 && errno != EEXIST) {\n\t\tperror(\"mkdir\");\n\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", owork);\n\t\texit(1);\n\t}\n\tASSERT_PERMS(owork, 0, 0, 0755);\n\n\t// mount overlayfs\n\tif (arg_debug)\n\t\tprintf(\"Mounting OverlayFS\\n\");\n\tchar *option;\n\tif (oldkernel) { // old Ubuntu/OpenSUSE kernels\n\t\tif (arg_overlay_keep) {\n\t\t\tfprintf(stderr, \"Error: option --overlay= not available for kernels older than 3.18\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s\", odiff) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlayfs\", oroot, \"overlayfs\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t}\n\telse { // kernel 3.18 or newer\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s,workdir=%s\", odiff, owork) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlay\", oroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\n\t\t//***************************\n\t\t// issue #263 start code\n\t\t// My setup has a separate mount point for /home. When the overlay is mounted,\n\t\t// the overlay does not contain the original /home contents.\n\t\t// I added code to create a second overlay for /home if the overlay home dir is empty and this seems to work\n\t\t// @dshmgh, Jan 2016\n\t\t{\n\t\t\tchar *overlayhome;\n\t\t\tstruct stat s;\n\t\t\tchar *hroot;\n\t\t\tchar *hdiff;\n\t\t\tchar *hwork;\n\n\t\t\t// dons add debug\n\t\t\tif (arg_debug) printf (\"DEBUG: chroot dirs are oroot %s  odiff %s  owork %s\\n\",oroot,odiff,owork);\n\n\t\t\t// BEFORE NEXT, WE NEED TO TEST IF /home has any contents or do we need to mount it?\n\t\t\t// must create var for oroot/cfg.homedir\n\t\t\tif (asprintf(&overlayhome, \"%s%s\", oroot, cfg.homedir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug) printf (\"DEBUG: overlayhome var holds ##%s##\\n\", overlayhome);\n\n\t\t\t// if no homedir in overlay -- create another overlay for /home\n\t\t\tif (stat(cfg.homedir, &s) == 0 && stat(overlayhome, &s) == -1) {\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (asprintf(&hdiff, \"%s/hdiff\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t// the new directory will be owned by root\n\t\t\t\tif (mkdirat(basefd, \"hdiff\", 0755) == -1 && errno != EEXIST) {\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", hdiff);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tASSERT_PERMS(hdiff, 0, 0, 0755);\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (asprintf(&hwork, \"%s/hwork\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t// the new directory will be owned by root\n\t\t\t\tif (mkdirat(basefd, \"hwork\", 0755) == -1 && errno != EEXIST) {\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", hwork);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tASSERT_PERMS(hwork, 0, 0, 0755);\n\n\t\t\t\t// no homedir in overlay so now mount another overlay for /home\n\t\t\t\tif (asprintf(&hroot, \"%s/home\", oroot) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (asprintf(&option, \"lowerdir=/home,upperdir=%s,workdir=%s\", hdiff, hwork) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (mount(\"overlay\", hroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\t\t\terrExit(\"mounting overlayfs for mounted home directory\");\n\n\t\t\t\tprintf(\"OverlayFS for /home configured in %s directory\\n\", basedir);\n\t\t\t\tfree(hroot);\n\t\t\t\tfree(hdiff);\n\t\t\t\tfree(hwork);\n\n\t\t\t} // stat(overlayhome)\n\t\t\tfree(overlayhome);\n\t\t}\n\t\t// issue #263 end code\n\t\t//***************************\n\t}\n\tfmessage(\"OverlayFS configured in %s directory\\n\", basedir);\n\tclose(basefd);\n\n\t// /dev, /run and /tmp are not covered by the overlay\n\t// mount-bind dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev\\n\");\n\tchar *dev;\n\tif (asprintf(&dev, \"%s/dev\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/dev\", dev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"whitelist /dev\");\n\n\t// mount-bind run directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /run\\n\");\n\tchar *run;\n\tif (asprintf(&run, \"%s/run\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/run\", run, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /run\");\n\tfs_logger(\"whitelist /run\");\n\n\t// mount-bind tmp directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /tmp\\n\");\n\tchar *tmp;\n\tif (asprintf(&tmp, \"%s/tmp\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/tmp\", tmp, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /tmp\");\n\tfs_logger(\"whitelist /tmp\");\n\n\t// chroot in the new filesystem\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\tif (chroot(oroot) == -1)\n\t\terrExit(\"chroot\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\tif (!arg_private_dev)\n//\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t\tfs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n\n\t// cleanup and exit\n\tfree(option);\n\tfree(odiff);\n\tfree(owork);\n\tfree(dev);\n\tfree(run);\n\tfree(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_chroot",
          "args": [
            "cfg.chrootdir"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "fs_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs.c",
          "lines": "1366-1497",
          "snippet": "void fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/wait.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);",
            "static void fs_rdwr_rec(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\nstatic void fs_rdwr_rec(const char *dir);\n\nvoid fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_store_hosts_file",
          "args": [],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "fs_store_hosts_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_hostname.c",
          "lines": "208-210",
          "snippet": "void fs_store_hosts_file(void) {\n\tcopy_file_from_user_to_root(cfg.hosts_file, RUN_HOSTS_FILE, 0, 0, 0644); // root needed\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_store_hosts_file(void) {\n\tcopy_file_from_user_to_root(cfg.hosts_file, RUN_HOSTS_FILE, 0, 0, 0644); // root needed\n}"
        }
      },
      {
        "call_info": {
          "callee": "enforce_filters",
          "args": [],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "enforce_filters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "568-580",
          "snippet": "static void enforce_filters(void) {\n\t// enforce NO_NEW_PRIVS\n\targ_nonewprivs = 1;\n\tforce_nonewprivs = 1;\n\n\t// disable all capabilities\n\tfmessage(\"\\n**     Warning: dropping all Linux capabilities     **\\n\");\n\targ_caps_drop_all = 1;\n\n\t// drop all supplementary groups; /etc/group file inside chroot\n\t// is controlled by a regular usr\n\targ_nogroups = 1;\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int force_nonewprivs = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int force_nonewprivs = 0;\n\nstatic void enforce_filters(void) {\n\t// enforce NO_NEW_PRIVS\n\targ_nonewprivs = 1;\n\tforce_nonewprivs = 1;\n\n\t// disable all capabilities\n\tfmessage(\"\\n**     Warning: dropping all Linux capabilities     **\\n\");\n\targ_caps_drop_all = 1;\n\n\t// drop all supplementary groups; /etc/group file inside chroot\n\t// is controlled by a regular usr\n\targ_nogroups = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sbox_run",
          "args": [
            "SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP",
            "5",
            "PATH_FSECCOMP",
            "\"protocol\"",
            "\"build\"",
            "cfg.protocol",
            "RUN_SECCOMP_PROTOCOL"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "sbox_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sbox.c",
          "lines": "107-223",
          "snippet": "int sbox_run(unsigned filter, int num, ...) {\n\tEUID_ROOT();\n\n\tint i;\n\tva_list valist;\n\tva_start(valist, num);\n\n\t// build argument list\n\tchar *arg[num + 1];\n\tfor (i = 0; i < num; i++)\n\t\targ[i] = va_arg(valist, char*);\n\targ[i] = NULL;\n\tva_end(valist);\n\n\tif (arg_debug) {\n\t\tprintf(\"sbox run: \");\n\t\tfor (i = 0; i <= num; i++)\n\t\t\tprintf(\"%s \", arg[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// clean the new process\n\t\tclearenv();\n\n\t\tif (filter & SBOX_STDIN_FROM_FILE) {\n\t\t\tint fd;\n\t\t\tif((fd = open(SBOX_STDIN_FILE, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr,\"Error: cannot open %s\\n\", SBOX_STDIN_FILE);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tdup2(fd,STDIN_FILENO);\n\t\t\tclose(fd);\n\t\t}\n\t\telse if ((filter & SBOX_ALLOW_STDIN) == 0) {\n\t\t\tint fd = open(\"/dev/null\",O_RDWR, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse // the user could run the sandbox without /dev/null\n\t\t\t\tclose(STDIN_FILENO);\n\t\t}\n\n\t\t// close all other file descriptors\n\t\tint max = 20; // getdtablesize() is overkill for a firejail process\n\t\tfor (i = 3; i < max; i++)\n\t\t\tclose(i); // close open files\n\n\t\tumask(027);\n\n\t\t// apply filters\n\t\tif (filter & SBOX_CAPS_NONE) {\n\t\t\tcaps_drop_all();\n\t\t}\n\t\telse if (filter & SBOX_CAPS_NETWORK) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_NET_ADMIN;\n\t\t\tset |=  ((uint64_t) 1) << CAP_NET_RAW;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\t\telse if (filter & SBOX_CAPS_HIDEPID) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_SYS_PTRACE;\n\t\t\tset |=  ((uint64_t) 1) << CAP_SYS_PACCT;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\n\t\tif (filter & SBOX_SECCOMP) {\n\t\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\t\t}\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\t\t\tperror(\"prctl(PR_SET_SECCOMP)\");\n\t\t\t}\n\t\t}\n\n\t\tif (filter & SBOX_ROOT) {\n\t\t\t// elevate privileges in order to get grsecurity working\n\t\t\tif (setreuid(0, 0))\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0))\n\t\t\t\terrExit(\"setregid\");\n\t\t}\n\t\telse if (filter & SBOX_USER)\n\t\t\tdrop_privs(1);\n\n\t\tclearenv();\n\n\t\t// --quiet is passed as an environment variable\n\t\tif (arg_quiet)\n\t\t\tsetenv(\"FIREJAIL_QUIET\", \"yes\", 1);\n\n\t\tif (arg[0])\t// get rid of scan-build warning\n\t\t\texecvp(arg[0], arg);\n\t\telse\n\t\t\tassert(0);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tint status;\n\tif (waitpid(child, &status, 0) == -1 ) {\n\t\terrExit(\"waitpid\");\n\t}\n\tif (WIFEXITED(status) && status != 0) {\n\t\tfprintf(stderr, \"Error: failed to run %s\\n\", arg[0]);\n\t\texit(1);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"../include/seccomp.h\"",
            "#include <sys/wait.h>",
            "#include <stdarg.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sock_filter filter[] = {\n\tVALIDATE_ARCHITECTURE,\n\tEXAMINE_SYSCALL,\n\n#if defined(__x86_64__)\n#define X32_SYSCALL_BIT 0x40000000\n\t// handle X32 ABI\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, X32_SYSCALL_BIT, 1, 0),\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, 0, 1, 0),\n\tRETURN_ERRNO(EPERM),\n#endif\n\n\t// syscall list\n#ifdef SYS_mount\n\tBLACKLIST(SYS_mount),  // mount/unmount filesystems\n#endif\n#ifdef SYS_umount2\n\tBLACKLIST(SYS_umount2),\n#endif\n#ifdef SYS_ptrace\n\tBLACKLIST(SYS_ptrace), // trace processes\n#endif\n#ifdef SYS_kexec_file_load\n\tBLACKLIST(SYS_kexec_file_load),\n#endif\n#ifdef SYS_kexec_load\n\tBLACKLIST(SYS_kexec_load), // loading a different kernel\n#endif\n#ifdef SYS_name_to_handle_at\n\tBLACKLIST(SYS_name_to_handle_at),\n#endif\n#ifdef SYS_open_by_handle_at\n\tBLACKLIST(SYS_open_by_handle_at), // open by handle\n#endif\n#ifdef SYS_init_module\n\tBLACKLIST(SYS_init_module), // kernel module handling\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\tBLACKLIST(SYS_finit_module),\n#endif\n#ifdef SYS_create_module\n\tBLACKLIST(SYS_create_module),\n#endif\n#ifdef SYS_delete_module\n\tBLACKLIST(SYS_delete_module),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioperm\n\tBLACKLIST(SYS_ioperm),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioprio_set\n\tBLACKLIST(SYS_ioprio_set),\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\tBLACKLIST(SYS_ni_syscall),\n#endif\n#ifdef SYS_swapon\n\tBLACKLIST(SYS_swapon), // swap on/off\n#endif\n#ifdef SYS_swapoff\n\tBLACKLIST(SYS_swapoff),\n#endif\n#ifdef SYS_syslog\n\tBLACKLIST(SYS_syslog), // kernel printk control\n#endif\n\tRETURN_ALLOW\n};",
            "static struct sock_fprog prog = {\n\t.len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),\n\t.filter = filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/seccomp.h\"\n#include <sys/wait.h>\n#include <stdarg.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic struct sock_filter filter[] = {\n\tVALIDATE_ARCHITECTURE,\n\tEXAMINE_SYSCALL,\n\n#if defined(__x86_64__)\n#define X32_SYSCALL_BIT 0x40000000\n\t// handle X32 ABI\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, X32_SYSCALL_BIT, 1, 0),\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, 0, 1, 0),\n\tRETURN_ERRNO(EPERM),\n#endif\n\n\t// syscall list\n#ifdef SYS_mount\n\tBLACKLIST(SYS_mount),  // mount/unmount filesystems\n#endif\n#ifdef SYS_umount2\n\tBLACKLIST(SYS_umount2),\n#endif\n#ifdef SYS_ptrace\n\tBLACKLIST(SYS_ptrace), // trace processes\n#endif\n#ifdef SYS_kexec_file_load\n\tBLACKLIST(SYS_kexec_file_load),\n#endif\n#ifdef SYS_kexec_load\n\tBLACKLIST(SYS_kexec_load), // loading a different kernel\n#endif\n#ifdef SYS_name_to_handle_at\n\tBLACKLIST(SYS_name_to_handle_at),\n#endif\n#ifdef SYS_open_by_handle_at\n\tBLACKLIST(SYS_open_by_handle_at), // open by handle\n#endif\n#ifdef SYS_init_module\n\tBLACKLIST(SYS_init_module), // kernel module handling\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\tBLACKLIST(SYS_finit_module),\n#endif\n#ifdef SYS_create_module\n\tBLACKLIST(SYS_create_module),\n#endif\n#ifdef SYS_delete_module\n\tBLACKLIST(SYS_delete_module),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioperm\n\tBLACKLIST(SYS_ioperm),\n#endif\n#ifdef SYS_iopl\n\tBLACKLIST(SYS_iopl), // io permissions\n#endif\n#ifdef \tSYS_ioprio_set\n\tBLACKLIST(SYS_ioprio_set),\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\tBLACKLIST(SYS_ni_syscall),\n#endif\n#ifdef SYS_swapon\n\tBLACKLIST(SYS_swapon), // swap on/off\n#endif\n#ifdef SYS_swapoff\n\tBLACKLIST(SYS_swapoff),\n#endif\n#ifdef SYS_syslog\n\tBLACKLIST(SYS_syslog), // kernel printk control\n#endif\n\tRETURN_ALLOW\n};\nstatic struct sock_fprog prog = {\n\t.len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),\n\t.filter = filter,\n};\n\nint sbox_run(unsigned filter, int num, ...) {\n\tEUID_ROOT();\n\n\tint i;\n\tva_list valist;\n\tva_start(valist, num);\n\n\t// build argument list\n\tchar *arg[num + 1];\n\tfor (i = 0; i < num; i++)\n\t\targ[i] = va_arg(valist, char*);\n\targ[i] = NULL;\n\tva_end(valist);\n\n\tif (arg_debug) {\n\t\tprintf(\"sbox run: \");\n\t\tfor (i = 0; i <= num; i++)\n\t\t\tprintf(\"%s \", arg[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// clean the new process\n\t\tclearenv();\n\n\t\tif (filter & SBOX_STDIN_FROM_FILE) {\n\t\t\tint fd;\n\t\t\tif((fd = open(SBOX_STDIN_FILE, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr,\"Error: cannot open %s\\n\", SBOX_STDIN_FILE);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tdup2(fd,STDIN_FILENO);\n\t\t\tclose(fd);\n\t\t}\n\t\telse if ((filter & SBOX_ALLOW_STDIN) == 0) {\n\t\t\tint fd = open(\"/dev/null\",O_RDWR, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse // the user could run the sandbox without /dev/null\n\t\t\t\tclose(STDIN_FILENO);\n\t\t}\n\n\t\t// close all other file descriptors\n\t\tint max = 20; // getdtablesize() is overkill for a firejail process\n\t\tfor (i = 3; i < max; i++)\n\t\t\tclose(i); // close open files\n\n\t\tumask(027);\n\n\t\t// apply filters\n\t\tif (filter & SBOX_CAPS_NONE) {\n\t\t\tcaps_drop_all();\n\t\t}\n\t\telse if (filter & SBOX_CAPS_NETWORK) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_NET_ADMIN;\n\t\t\tset |=  ((uint64_t) 1) << CAP_NET_RAW;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\t\telse if (filter & SBOX_CAPS_HIDEPID) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_SYS_PTRACE;\n\t\t\tset |=  ((uint64_t) 1) << CAP_SYS_PACCT;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\n\t\tif (filter & SBOX_SECCOMP) {\n\t\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\t\t}\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\t\t\tperror(\"prctl(PR_SET_SECCOMP)\");\n\t\t\t}\n\t\t}\n\n\t\tif (filter & SBOX_ROOT) {\n\t\t\t// elevate privileges in order to get grsecurity working\n\t\t\tif (setreuid(0, 0))\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0))\n\t\t\t\terrExit(\"setregid\");\n\t\t}\n\t\telse if (filter & SBOX_USER)\n\t\t\tdrop_privs(1);\n\n\t\tclearenv();\n\n\t\t// --quiet is passed as an environment variable\n\t\tif (arg_quiet)\n\t\t\tsetenv(\"FIREJAIL_QUIET\", \"yes\", 1);\n\n\t\tif (arg[0])\t// get rid of scan-build warning\n\t\t\texecvp(arg[0], arg);\n\t\telse\n\t\t\tassert(0);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tint status;\n\tif (waitpid(child, &status, 0) == -1 ) {\n\t\terrExit(\"waitpid\");\n\t}\n\tif (WIFEXITED(status) && status != 0) {\n\t\tfprintf(stderr, \"Error: failed to run %s\\n\", arg[0]);\n\t\texit(1);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Build protocol filter: %s\\n\"",
            "cfg.protocol"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_ibus_load",
          "args": [],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "env_ibus_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
          "lines": "54-114",
          "snippet": "void env_ibus_load(void) {\n\tEUID_ASSERT();\n\n\t// check ~/.config/ibus/bus directory\n\tchar *dirname;\n\tif (asprintf(&dirname, \"%s/.config/ibus/bus\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(dirname, &s) == -1)\n\t\treturn;\n\n\t// find the file\n\t/* coverity[toctou] */\n\tDIR *dir = opendir(dirname);\n\tif (!dir) {\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\t// check the file name ends in \"unix-0\"\n\t\tchar *ptr = strstr(entry->d_name, \"unix-0\");\n\t\tif (!ptr)\n\t\t\tcontinue;\n\t\tif (strlen(ptr) != 6)\n\t\t\tcontinue;\n\n\t\t// open the file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tfree(fname);\n\t\tif (!fp)\n\t\t\tcontinue;\n\n\t\t// read the file\n\t\tconst int maxline = 4096;\n\t\tchar buf[maxline];\n\t\twhile (fgets(buf, maxline, fp)) {\n\t\t\tif (strncmp(buf, \"IBUS_\", 5) != 0)\n\t\t\t\tcontinue;\n\t\t\tchar *ptr = strchr(buf, '=');\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"%s\\n\", buf);\n\t\t\tenv_store(buf, SETENV);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tfree(dirname);\n\tclosedir(dir);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_ibus_load(void) {\n\tEUID_ASSERT();\n\n\t// check ~/.config/ibus/bus directory\n\tchar *dirname;\n\tif (asprintf(&dirname, \"%s/.config/ibus/bus\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(dirname, &s) == -1)\n\t\treturn;\n\n\t// find the file\n\t/* coverity[toctou] */\n\tDIR *dir = opendir(dirname);\n\tif (!dir) {\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\t// check the file name ends in \"unix-0\"\n\t\tchar *ptr = strstr(entry->d_name, \"unix-0\");\n\t\tif (!ptr)\n\t\t\tcontinue;\n\t\tif (strlen(ptr) != 6)\n\t\t\tcontinue;\n\n\t\t// open the file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tfree(fname);\n\t\tif (!fp)\n\t\t\tcontinue;\n\n\t\t// read the file\n\t\tconst int maxline = 4096;\n\t\tchar buf[maxline];\n\t\twhile (fgets(buf, maxline, fp)) {\n\t\t\tif (strncmp(buf, \"IBUS_\", 5) != 0)\n\t\t\t\tcontinue;\n\t\t\tchar *ptr = strchr(buf, '=');\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"%s\\n\", buf);\n\t\t\tenv_store(buf, SETENV);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tfree(dirname);\n\tclosedir(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "any_interface_configured",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "any_interface_configured",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/firejail.h",
          "lines": "308-313",
          "snippet": "static inline int any_interface_configured(void) {\n\tif (cfg.interface0.configured || cfg.interface1.configured || cfg.interface2.configured || cfg.interface3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include \"../include/euid_common.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <stdarg.h>\n#include \"../include/euid_common.h\"\n#include \"../include/common.h\"\n\nstatic inline int any_interface_configured(void) {\n\tif (cfg.interface0.configured || cfg.interface1.configured || cfg.interface2.configured || cfg.interface3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "any_bridge_configured",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "any_bridge_configured",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/firejail.h",
          "lines": "301-306",
          "snippet": "static inline int any_bridge_configured(void) {\n\tif (cfg.bridge0.configured || cfg.bridge1.configured || cfg.bridge2.configured || cfg.bridge3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include \"../include/euid_common.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <stdarg.h>\n#include \"../include/euid_common.h\"\n#include \"../include/common.h\"\n\nstatic inline int any_bridge_configured(void) {\n\tif (cfg.bridge0.configured || cfg.bridge1.configured || cfg.bridge2.configured || cfg.bridge3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"\\n\""
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "189-198",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.defaultgw"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Network namespace enabled\\n\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_add_route",
          "args": [
            "0",
            "0",
            "cfg.defaultgw"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "net_add_route",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network.c",
          "lines": "182-215",
          "snippet": "int net_add_route(uint32_t ip, uint32_t mask, uint32_t gw) {\n\tint sock;\n\tstruct rtentry route;\n\tstruct sockaddr_in *addr;\n\tint err = 0;\n\n\t// create the socket\n\tif((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&route, 0, sizeof(route));\n\n\taddr = (struct sockaddr_in*) &route.rt_gateway;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(gw);\n\n\taddr = (struct sockaddr_in*) &route.rt_dst;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(ip);\n\n\taddr = (struct sockaddr_in*) &route.rt_genmask;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(mask);\n\n\troute.rt_flags = RTF_UP | RTF_GATEWAY;\n\troute.rt_metric = 0;\n\tif ((err = ioctl(sock, SIOCADDRT, &route)) != 0) {\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_add_route(uint32_t ip, uint32_t mask, uint32_t gw) {\n\tint sock;\n\tstruct rtentry route;\n\tstruct sockaddr_in *addr;\n\tint err = 0;\n\n\t// create the socket\n\tif((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&route, 0, sizeof(route));\n\n\taddr = (struct sockaddr_in*) &route.rt_gateway;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(gw);\n\n\taddr = (struct sockaddr_in*) &route.rt_dst;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(ip);\n\n\taddr = (struct sockaddr_in*) &route.rt_genmask;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(mask);\n\n\troute.rt_flags = RTF_UP | RTF_GATEWAY;\n\troute.rt_metric = 0;\n\tif ((err = ioctl(sock, SIOCADDRT, &route)) != 0) {\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_config_interface",
          "args": [
            "cfg.interface3.dev",
            "cfg.interface3.ip",
            "cfg.interface3.mask",
            "cfg.interface3.mtu"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "net_config_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network.c",
          "lines": "283-304",
          "snippet": "void net_config_interface(const char *dev, uint32_t ip, uint32_t mask, int mtu) {\n\tassert(dev);\n\n\tchar *ipstr;\n\tif (asprintf(&ipstr, \"%llu\", (long long unsigned) ip) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *maskstr;\n\tif (asprintf(&maskstr, \"%llu\", (long long unsigned) mask) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *mtustr;\n\tif (asprintf(&mtustr, \"%d\", mtu) == -1)\n\t\terrExit(\"asprintf\");\n\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 7,\n\t\tPATH_FNET, \"config\", \"interface\", dev, ipstr, maskstr, mtustr);\n\n\tfree(ipstr);\n\tfree(maskstr);\n\tfree(mtustr);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_config_interface(const char *dev, uint32_t ip, uint32_t mask, int mtu) {\n\tassert(dev);\n\n\tchar *ipstr;\n\tif (asprintf(&ipstr, \"%llu\", (long long unsigned) ip) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *maskstr;\n\tif (asprintf(&maskstr, \"%llu\", (long long unsigned) mask) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *mtustr;\n\tif (asprintf(&mtustr, \"%d\", mtu) == -1)\n\t\terrExit(\"asprintf\");\n\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 7,\n\t\tPATH_FNET, \"config\", \"interface\", dev, ipstr, maskstr, mtustr);\n\n\tfree(ipstr);\n\tfree(maskstr);\n\tfree(mtustr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(cfg.interface3.ip)",
            "cfg.interface3.dev"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.interface3.ip"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(cfg.interface2.ip)",
            "cfg.interface2.dev"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.interface2.ip"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(cfg.interface1.ip)",
            "cfg.interface1.dev"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.interface1.ip"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(cfg.interface0.ip)",
            "cfg.interface0.dev"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.interface0.ip"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandbox_if_up",
          "args": [
            "&cfg.bridge3"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "sandbox_if_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "185-233",
          "snippet": "static void sandbox_if_up(Bridge *br) {\n\tassert(br);\n\tif (!br->configured)\n\t\treturn;\n\n\tchar *dev = br->devsandbox;\n\tnet_if_up(dev);\n\n\tif (br->arg_ip_none == 1);\t// do nothing\n\telse if (br->arg_ip_none == 0 && br->macvlan == 0) {\n\t\tif (br->ipsandbox == br->ip) {\n\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\texit(1);\n\t\t}\n\n\t\t// just assign the address\n\t\tassert(br->ipsandbox);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\telse if (br->arg_ip_none == 0 && br->macvlan == 1) {\n\t\t// reassign the macvlan address\n\t\tif (br->ipsandbox == 0)\n\t\t\t// ip address assigned by arp-scan for a macvlan device\n\t\t\tbr->ipsandbox = arp_assign(dev, br); //br->ip, br->mask);\n\t\telse {\n\t\t\tif (br->ipsandbox == br->ip) {\n\t\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tuint32_t rv = arp_check(dev, br->ipsandbox);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Error: the address %d.%d.%d.%d is already in use.\\n\", PRINT_IP(br->ipsandbox));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\n\tif (br->ip6sandbox)\n\t\t net_if_ip6(dev, br->ip6sandbox);\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void sandbox_if_up(Bridge *br) {\n\tassert(br);\n\tif (!br->configured)\n\t\treturn;\n\n\tchar *dev = br->devsandbox;\n\tnet_if_up(dev);\n\n\tif (br->arg_ip_none == 1);\t// do nothing\n\telse if (br->arg_ip_none == 0 && br->macvlan == 0) {\n\t\tif (br->ipsandbox == br->ip) {\n\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\texit(1);\n\t\t}\n\n\t\t// just assign the address\n\t\tassert(br->ipsandbox);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\telse if (br->arg_ip_none == 0 && br->macvlan == 1) {\n\t\t// reassign the macvlan address\n\t\tif (br->ipsandbox == 0)\n\t\t\t// ip address assigned by arp-scan for a macvlan device\n\t\t\tbr->ipsandbox = arp_assign(dev, br); //br->ip, br->mask);\n\t\telse {\n\t\t\tif (br->ipsandbox == br->ip) {\n\t\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tuint32_t rv = arp_check(dev, br->ipsandbox);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Error: the address %d.%d.%d.%d is already in use.\\n\", PRINT_IP(br->ipsandbox));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\n\tif (br->ip6sandbox)\n\t\t net_if_ip6(dev, br->ip6sandbox);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_config_mac",
          "args": [
            "cfg.bridge3.devsandbox",
            "cfg.bridge3.macsandbox"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "net_config_mac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network.c",
          "lines": "250-261",
          "snippet": "int net_config_mac(const char *ifname, const unsigned char mac[6]) {\n\tchar *macstr;\n\tif (asprintf(&macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\",\n\t\tmac[0], mac[1], mac[2], mac[3], mac[4], mac[5]) == -1)\n\t\terrExit(\"asprintf\");\n\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 5,\n\t\tPATH_FNET, \"config\", \"mac\", ifname, macstr);\n\n\tfree(macstr);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_config_mac(const char *ifname, const unsigned char mac[6]) {\n\tchar *macstr;\n\tif (asprintf(&macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\",\n\t\tmac[0], mac[1], mac[2], mac[3], mac[4], mac[5]) == -1)\n\t\terrExit(\"asprintf\");\n\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 5,\n\t\tPATH_FNET, \"config\", \"mac\", ifname, macstr);\n\n\tfree(macstr);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mac_not_zero",
          "args": [
            "cfg.bridge3.macsandbox"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "mac_not_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "102-110",
          "snippet": "static inline int mac_not_zero(const unsigned char mac[6]) {\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (mac[i] != 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline int mac_not_zero(const unsigned char mac[6]) {\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (mac[i] != 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_if_up",
          "args": [
            "\"lo\""
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network.c",
          "lines": "158-165",
          "snippet": "void net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3,\n\t\tPATH_FNET, \"ifup\", ifname);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3,\n\t\tPATH_FNET, \"ifup\", ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Network namespace '%s' activated\\n\"",
            "arg_netns"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Network namespace enabled, only loopback interface available\\n\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netfilter6",
          "args": [
            "arg_netfilter6_file"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "netfilter6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/netfilter.c",
          "lines": "93-134",
          "snippet": "void netfilter6(const char *fname) {\n\tif (fname == NULL)\n\t\treturn;\n\n\t// find iptables command\n\tchar *ip6tables = NULL;\n\tchar *ip6tables_restore = NULL;\n\tstruct stat s;\n\tif (stat(\"/sbin/ip6tables\", &s) == 0) {\n\t\tip6tables = \"/sbin/ip6tables\";\n\t\tip6tables_restore = \"/sbin/ip6tables-restore\";\n\t}\n\telse if (stat(\"/usr/sbin/ip6tables\", &s) == 0) {\n\t\tip6tables = \"/usr/sbin/ip6tables\";\n\t\tip6tables_restore = \"/usr/sbin/ip6tables-restore\";\n\t}\n\tif (ip6tables == NULL || ip6tables_restore == NULL) {\n\t\tfprintf(stderr, \"Error: ip6tables command not found, netfilter6 not configured\\n\");\n\t\treturn;\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Installing IPv6 firewall\\n\");\n\n\t// create an empty user-owned SBOX_STDIN_FILE\n\tcreate_empty_file_as_root(SBOX_STDIN_FILE, 0644);\n\tif (set_perms(SBOX_STDIN_FILE, getuid(), getgid(), 0644))\n\t\terrExit(\"set_perms\");\n\n\tsbox_run(SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP, 3, PATH_FNETFILTER, fname, SBOX_STDIN_FILE);\n\n\t// first run of iptables on this platform installs a number of kernel modules such as ip_tables, x_tables, iptable_filter\n\t// we run this command with caps and seccomp disabled in order to allow the loading of these modules\n\tsbox_run(SBOX_ROOT | SBOX_STDIN_FROM_FILE, 1, ip6tables_restore);\n\tunlink(SBOX_STDIN_FILE);\n\n\t// debug\n\tif (arg_debug)\n\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, ip6tables, \"-vL\");\n\n\treturn;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid netfilter6(const char *fname) {\n\tif (fname == NULL)\n\t\treturn;\n\n\t// find iptables command\n\tchar *ip6tables = NULL;\n\tchar *ip6tables_restore = NULL;\n\tstruct stat s;\n\tif (stat(\"/sbin/ip6tables\", &s) == 0) {\n\t\tip6tables = \"/sbin/ip6tables\";\n\t\tip6tables_restore = \"/sbin/ip6tables-restore\";\n\t}\n\telse if (stat(\"/usr/sbin/ip6tables\", &s) == 0) {\n\t\tip6tables = \"/usr/sbin/ip6tables\";\n\t\tip6tables_restore = \"/usr/sbin/ip6tables-restore\";\n\t}\n\tif (ip6tables == NULL || ip6tables_restore == NULL) {\n\t\tfprintf(stderr, \"Error: ip6tables command not found, netfilter6 not configured\\n\");\n\t\treturn;\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Installing IPv6 firewall\\n\");\n\n\t// create an empty user-owned SBOX_STDIN_FILE\n\tcreate_empty_file_as_root(SBOX_STDIN_FILE, 0644);\n\tif (set_perms(SBOX_STDIN_FILE, getuid(), getgid(), 0644))\n\t\terrExit(\"set_perms\");\n\n\tsbox_run(SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP, 3, PATH_FNETFILTER, fname, SBOX_STDIN_FILE);\n\n\t// first run of iptables on this platform installs a number of kernel modules such as ip_tables, x_tables, iptable_filter\n\t// we run this command with caps and seccomp disabled in order to allow the loading of these modules\n\tsbox_run(SBOX_ROOT | SBOX_STDIN_FROM_FILE, 1, ip6tables_restore);\n\tunlink(SBOX_STDIN_FILE);\n\n\t// debug\n\tif (arg_debug)\n\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, ip6tables, \"-vL\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"install mount namespace\""
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger2int",
          "args": [
            "\"sandbox pid:\"",
            "(int) sandbox_pid"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting \" RUN_FIREJAIL_LIB_DIR"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "LIBDIR \"/firejail\"",
            "RUN_FIREJAIL_LIB_DIR",
            "\"none\"",
            "MS_BIND",
            "NULL"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preproc_mount_mnt_dir",
          "args": [],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "preproc_mount_mnt_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/preproc.c",
          "lines": "78-111",
          "snippet": "void preproc_mount_mnt_dir(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\n#ifdef HAVE_SECCOMP\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tmpfs_mounted = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int tmpfs_mounted = 0;\n\nvoid preproc_mount_mnt_dir(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\n#ifdef HAVE_SECCOMP\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chk_chroot",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "chk_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "235-250",
          "snippet": "static void chk_chroot(void) {\n\t// if we are starting firejail inside some other container technology, we don't care about this\n\tchar *mycont = getenv(\"container\");\n\tif (mycont)\n\t\treturn;\n\n\t// check if this is a regular chroot\n\tstruct stat s;\n\tif (stat(\"/\", &s) == 0) {\n\t\tif (s.st_ino != 2)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: cannot mount filesystem as slave\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void chk_chroot(void) {\n\t// if we are starting firejail inside some other container technology, we don't care about this\n\tchar *mycont = getenv(\"container\");\n\tif (mycont)\n\t\treturn;\n\n\t// check if this is a regular chroot\n\tstruct stat s;\n\tif (stat(\"/\", &s) == 0) {\n\t\tif (s.st_ino != 2)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: cannot mount filesystem as slave\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/\"",
            "NULL",
            "MS_SLAVE | MS_REC",
            "NULL"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"sethostname\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sethostname",
          "args": [
            "cfg.hostname",
            "strlen(cfg.hostname)"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg.hostname"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"PID namespace installed\\n\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Initializing child process\\n\""
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\n#define CLONE_NEWUSER\t0x10000000\n\nstatic int force_nonewprivs = 0;\n\nint sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\"Initializing child process\\n\");\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n\n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\"PID namespace installed\\n\");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\"sethostname\");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t// ... and mount a tmpfs on top of /run/firejail/mnt directory\n\tpreproc_mount_mnt_dir();\n\t// bind-mount firejail binaries and helper programs\n\tif (mount(LIBDIR \"/firejail\", RUN_FIREJAIL_LIB_DIR, \"none\", MS_BIND, NULL) < 0)\n\t\terrExit(\"mounting \" RUN_FIREJAIL_LIB_DIR);\n\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\"sandbox name:\", cfg.name);\n\tfs_logger2int(\"sandbox pid:\", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\"sandbox filesystem: chroot\");\n\telse if (arg_overlay)\n\t\tfs_logger(\"sandbox filesystem: overlay\");\n\telse\n\t\tfs_logger(\"sandbox filesystem: local\");\n\tfs_logger(\"install mount namespace\");\n\n\t//****************************\n\t// netfilter\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\"lo\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled, only loopback interface available\\n\");\n\t}\n\telse if (arg_netns) {\n\t\tnetns(arg_netns);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace '%s' activated\\n\", arg_netns);\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\"lo\");\n\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\n\n\t\t// moving an interface in a namespace using --interface will reset the interface configuration;\n\t\t// we need to put the configuration back\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_config_interface(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t}\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_config_interface(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t}\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_config_interface(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t}\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_config_interface(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t}\n\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfwarning(\"cannot configure default route\\n\");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled\\n\");\n\t}\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tfmessage(\"\\n\");\n\t\t\tif (any_bridge_configured() || any_interface_configured()) {\n\t\t\t\tif (arg_scan)\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3, PATH_FNET, \"printif\", \"scan\");\n\t\t\t\telse\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET, \"printif\");\n\n\t\t\t}\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tfmessage(\"Default gateway configuration failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tfmessage(\"Default gateway %d.%d.%d.%d\\n\", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns1);\n\t\t\tif (cfg.dns2 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns2);\n\t\t\tif (cfg.dns3 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns3);\n\t\t\tif (cfg.dns4 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns4);\n\t\t\tfmessage(\"\\n\");\n\t\t}\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tenv_ibus_load();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// fs pre-processing:\n\t//  - build seccomp filters\n\t//  - create an empty /etc/ld.so.preload\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Build protocol filter: %s\\n\", cfg.protocol);\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\tPATH_FSECCOMP, \"protocol\", \"build\", cfg.protocol, RUN_SECCOMP_PROTOCOL);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\tif (arg_seccomp && (cfg.seccomp_list || cfg.seccomp_list_drop || cfg.seccomp_list_keep))\n\t\targ_seccomp_postexec = 1;\n#endif\n\n\t// need ld.so.preload if tracing or seccomp with any non-default lists\n\tbool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec;\n\t// for --appimage, --chroot and --overlay* we force NO_NEW_PRIVS\n\t// and drop all capabilities\n\tif (getuid() != 0 && (arg_appimage || cfg.chrootdir || arg_overlay)) {\n\t\tenforce_filters();\n\t\tneed_preload = arg_trace || arg_tracelog;\n\t}\n\n\t// trace pre-install\n\tif (need_preload)\n\t\tfs_trace_preload();\n\n\t// store hosts file\n\tif (cfg.hosts_file)\n\t\tfs_store_hosts_file();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_CHROOT\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (need_preload)\n\t\t\tfs_trace_preload();\n\t}\n\telse\n#endif\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\n\t\tfs_overlayfs();\n\telse\n#endif\n\t\tfs_basic_fs();\n\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private=directory feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private=directory feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private-home= feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private-home= feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev)\n\t\tfs_private_dev();\n\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-etc feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-etc feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/etc\", RUN_ETC_DIR, cfg.etc_private_keep);\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (need_preload)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\n\tif (arg_private_opt) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-opt feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-opt feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/opt\", RUN_OPT_DIR, cfg.opt_private_keep);\n\t\t}\n\t}\n\n\tif (arg_private_srv) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-srv feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-srv feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/srv\", RUN_SRV_DIR, cfg.srv_private_keep);\n\t\t}\n\t}\n\n\t// private-bin is disabled for appimages\n\tif (arg_private_bin && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-bin feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-bin feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \"%s,xauth\", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\n\t// private-lib is disabled for appimages\n\tif (arg_private_lib && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-lib feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-lib feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_lib();\n\t\t}\n\t}\n\n\tif (arg_private_cache) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-cache feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-cache feature is disabled in overlay\\n\");\n\t\telse\n\t\t\tfs_private_cache();\n\t}\n\n\tif (arg_private_tmp) {\n\t\t// private-tmp is implemented as a whitelist\n\t\tEUID_USER();\n\t\tfs_private_tmp();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// Session D-BUS\n\t//****************************\n\tif (arg_nodbus)\n\t\tdbus_session_disable();\n\n\n\t//****************************\n\t// hosts and hostname\n\t//****************************\n\tif (cfg.hostname)\n\t\tfs_hostname(cfg.hostname);\n\n\tif (cfg.hosts_file)\n\t\tfs_mount_hosts_file();\n\n\t//****************************\n\t// /etc overrides from the network namespace\n\t//****************************\n\tif (arg_netns)\n\t\tnetns_mounts(arg_netns);\n\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directory\n\t//****************************\n\tfs_proc_sys_dev_boot();\n\n\t//****************************\n\t// handle /mnt and /media\n\t//****************************\n\tif (checkcfg(CFG_DISABLE_MNT))\n\t\tfs_mnt(1);\n\telse if (arg_disable_mnt)\n\t\tfs_mnt(0);\n\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ...\n\tfs_whitelist();\n\n\t// ... followed by blacklist commands\n\tfs_blacklist(); // mkdir and mkfile are processed all over again\n\n\t//****************************\n\t// nosound/no3d/notv/novideo and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse if (!arg_noautopulse)\n\t\tpulseaudio_init();\n\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\n\tif (arg_notv)\n\t\tfs_dev_disable_tv();\n\n\tif (arg_nodvd)\n\t\tfs_dev_disable_dvd();\n\n\tif (arg_nou2f)\n\t        fs_dev_disable_u2f();\n\n\tif (arg_novideo)\n\t\tfs_dev_disable_video();\n\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (need_preload)\n\t\tfs_trace();\n\n\t//****************************\n\t// set dns\n\t//****************************\n\tfs_resolvconf();\n\n\t//****************************\n\t// fs post-processing\n\t//****************************\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tEUID_USER();\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\n\tif (!cwd) {\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t}\n\tif (arg_debug) {\n\t\tchar *cpath = get_current_dir_name();\n\t\tif (cpath) {\n\t\t\tprintf(\"Current directory: %s\\n\", cpath);\n\t\t\tfree(cpath);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\n\t// save original umask\n\tsave_umask();\n\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// save state of nonewprivs\n\tsave_nonewprivs();\n\n\t// set capabilities\n\tset_caps();\n\n\t// save cpu affinity mask to CPU_CFG file\n\tsave_cpu();\n\n\t// save cgroup in CGROUP_CFG file\n\tsave_cgroup();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n#ifdef SYS_socket\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install protocol filter: %s\\n\", cfg.protocol);\n\t\tseccomp_load(RUN_SECCOMP_PROTOCOL);\t// install filter\n\t\tprotocol_filter_save();\t// save filter in RUN_PROTOCOL_CFG\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_PROTOCOL);\n\t\t(void) rv;\n\t}\n#endif\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse\n\t\t\tseccomp_filter_drop();\n\n\t}\n\telse { // clean seccomp files under /run/firejail/mnt\n\t\tint rv = unlink(RUN_SECCOMP_CFG);\n\t\trv |= unlink(RUN_SECCOMP_32);\n\t\t(void) rv;\n\t}\n\n\tif (arg_memory_deny_write_execute) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install memory write&execute filter\\n\");\n\t\tseccomp_load(RUN_SECCOMP_MDWX);\t// install filter\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_MDWX);\n\t\t(void) rv;\n\t}\n#endif\n\n\t//****************************************\n\t// communicate progress of sandbox set up\n\t// to --join\n\t//****************************************\n\n\tFILE *rj = create_ready_for_join_file();\n\n\t//****************************************\n\t// create a new user namespace\n\t//     - too early to drop privileges\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfwarning(\"cannot create a new user namespace, going forward without it...\\n\");\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n\n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"noroot user namespace installed\\n\");\n\t\tset_caps();\n\t}\n\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif (prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {\n\t\t\tfwarning(\"cannot set NO_NEW_PRIVS, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\t\tif (force_nonewprivs) {\n\t\t\t\tfprintf(stderr, \"Error: NO_NEW_PRIVS required for this sandbox, exiting ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (arg_debug)\n\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t}\n\n\t//****************************************\n\t// drop privileges\n\t//****************************************\n\tdrop_privs(arg_nogroups);\n\n\t// kill the sandbox in case the parent died\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t//****************************************\n\t// set cpu affinity\n\t//****************************************\n\n\tif (cfg.cpus)\n\t\tset_cpu_affinity();\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\"fork\");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (checkcfg(CFG_APPARMOR) && arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\"firejail-default\")) {\n\t\t\t\tfwarning(\"Cannot confine the application using AppArmor.\\n\"\n\t\t\t\t\t\"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\"\n\t\t\t\t\t\"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\");\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\"AppArmor enabled\\n\");\n\t\t}\n#endif\n\t\t// set nice and rlimits\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\t\tset_rlimits();\n\n\t\tstart_application(0, rj);\n\t}\n\n\tfclose(rj);\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "enforce_filters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "568-580",
    "snippet": "static void enforce_filters(void) {\n\t// enforce NO_NEW_PRIVS\n\targ_nonewprivs = 1;\n\tforce_nonewprivs = 1;\n\n\t// disable all capabilities\n\tfmessage(\"\\n**     Warning: dropping all Linux capabilities     **\\n\");\n\targ_caps_drop_all = 1;\n\n\t// drop all supplementary groups; /etc/group file inside chroot\n\t// is controlled by a regular usr\n\targ_nogroups = 1;\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int force_nonewprivs = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"\\n**     Warning: dropping all Linux capabilities     **\\n\""
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "189-198",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int force_nonewprivs = 0;\n\nstatic void enforce_filters(void) {\n\t// enforce NO_NEW_PRIVS\n\targ_nonewprivs = 1;\n\tforce_nonewprivs = 1;\n\n\t// disable all capabilities\n\tfmessage(\"\\n**     Warning: dropping all Linux capabilities     **\\n\");\n\targ_caps_drop_all = 1;\n\n\t// drop all supplementary groups; /etc/group file inside chroot\n\t// is controlled by a regular usr\n\targ_nogroups = 1;\n}"
  },
  {
    "function_name": "start_application",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "432-566",
    "snippet": "void start_application(int no_sandbox, FILE *fp) {\n\t// set environment\n\tif (no_sandbox == 0) {\n\t\tenv_defaults();\n\t\tenv_apply();\n\t}\n\t// restore original umask\n\tumask(orig_umask);\n\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tint rv = ok_to_run(cfg.original_argv[cfg.original_program_index]);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\tif (rv)\n\t\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: no suitable %s executable found\\n\", cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "arg[0]",
            "arg"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_install_filters",
          "args": [],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_install_filters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/seccomp.c",
          "lines": "63-84",
          "snippet": "int seccomp_install_filters(void) {\n\tint r = 0;\n\tFilterList *fl = filter_list_head;\n\tif (fl) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tfor (; fl; fl = fl->next) {\n\t\t\tassert(fl->fname);\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Installing %s seccomp filter\\n\", fl->fname);\n\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &fl->prog)) {\n\n\t\t\t\tif (!err_printed)\n\t\t\t\t\tfwarning(\"seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\t\t\terr_printed = 1;\n\t\t\t\tr = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include \"../include/seccomp.h\"\n#include \"firejail.h\"\n\nint seccomp_install_filters(void) {\n\tint r = 0;\n\tFilterList *fl = filter_list_head;\n\tif (fl) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tfor (; fl; fl = fl->next) {\n\t\t\tassert(fl->fname);\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Installing %s seccomp filter\\n\", fl->fname);\n\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &fl->prog)) {\n\n\t\t\t\tif (!err_printed)\n\t\t\t\t\tfwarning(\"seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\t\t\terr_printed = 1;\n\t\t\t\tr = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gcov_dump",
          "args": [],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"ready\\n\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_time",
          "args": [],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "print_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "359-373",
          "snippet": "static void print_time(void) {\n\tif (start_timestamp) {\n\t\tunsigned long long end_timestamp = getticks();\n\t\t// measure 1 ms\n\t\tusleep(1000);\n\t\tunsigned long long onems = getticks() - end_timestamp;\n\t\tif (onems) {\n\t\t\tfmessage(\"Child process initialized in %.02f ms\\n\",\n\t\t\t\t(float) (end_timestamp - start_timestamp) / (float) onems);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfmessage(\"Child process initialized\\n\");\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void print_time(void) {\n\tif (start_timestamp) {\n\t\tunsigned long long end_timestamp = getticks();\n\t\t// measure 1 ms\n\t\tusleep(1000);\n\t\tunsigned long long onems = getticks() - end_timestamp;\n\t\tif (onems) {\n\t\t\tfmessage(\"Child process initialized in %.02f ms\\n\",\n\t\t\t\t(float) (end_timestamp - start_timestamp) / (float) onems);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfmessage(\"Child process initialized\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"execvp argument %d: %s\\n\"",
            "i",
            "arg[i]"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logmsg",
          "args": [
            "msg"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "logmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "210-217",
          "snippet": "void logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&msg",
            "\"sandbox %d, execvp into %s\"",
            "sandbox_pid",
            "cfg.command_line"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index < 5"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Running %s command through %s\\n\"",
            "cfg.command_line",
            "cfg.shell"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Starting %s login shell\\n\"",
            "cfg.shell"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cfg.command_line"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cfg.shell"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no suitable %s executable found\\n\"",
            "cfg.original_argv[cfg.original_program_index]"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "cfg.original_argv[cfg.original_program_index]",
            "&cfg.original_argv[cfg.original_program_index]"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gcov_dump",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"ready\\n\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ok_to_run",
          "args": [
            "cfg.original_argv[cfg.original_program_index]"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "ok_to_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "384-430",
          "snippet": "static int ok_to_run(const char *program) {\n\tif (strstr(program, \"/\")) {\n\t\tif (access(program, X_OK) == 0) // it will also dereference symlinks\n\t\t\treturn 1;\n\t}\n\telse { // search $PATH\n\t\tchar *path1 = getenv(\"PATH\");\n\t\tif (path1) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Searching $PATH for %s\\n\", program);\n\t\t\tchar *path2 = strdup(path1);\n\t\t\tif (!path2)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// use path2 to count the entries\n\t\t\tchar *ptr = strtok(path2, \":\");\n\t\t\twhile (ptr) {\n\t\t\t\tchar *fname;\n\n\t\t\t\tif (asprintf(&fname, \"%s/%s\", ptr, program) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"trying #%s#\\n\", fname);\n\n\t\t\t\tstruct stat s;\n\t\t\t\tint rv = stat(fname, &s);\n\t\t\t\tif (rv == 0) {\n\t\t\t\t\tif (access(fname, X_OK) == 0) {\n\t\t\t\t\t\tfree(path2);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Error: execute permission denied for %s\\n\", fname);\n\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfree(fname);\n\t\t\t\tptr = strtok(NULL, \":\");\n\t\t\t}\n\t\t\tfree(path2);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int ok_to_run(const char *program) {\n\tif (strstr(program, \"/\")) {\n\t\tif (access(program, X_OK) == 0) // it will also dereference symlinks\n\t\t\treturn 1;\n\t}\n\telse { // search $PATH\n\t\tchar *path1 = getenv(\"PATH\");\n\t\tif (path1) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Searching $PATH for %s\\n\", program);\n\t\t\tchar *path2 = strdup(path1);\n\t\t\tif (!path2)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// use path2 to count the entries\n\t\t\tchar *ptr = strtok(path2, \":\");\n\t\t\twhile (ptr) {\n\t\t\t\tchar *fname;\n\n\t\t\t\tif (asprintf(&fname, \"%s/%s\", ptr, program) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"trying #%s#\\n\", fname);\n\n\t\t\t\tstruct stat s;\n\t\t\t\tint rv = stat(fname, &s);\n\t\t\t\tif (rv == 0) {\n\t\t\t\t\tif (access(fname, X_OK) == 0) {\n\t\t\t\t\t\tfree(path2);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Error: execute permission denied for %s\\n\", fname);\n\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfree(fname);\n\t\t\t\tptr = strtok(NULL, \":\");\n\t\t\t}\n\t\t\tfree(path2);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --shell=none configured, but no program specified\\n\""
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"execvp argument %d: %s\\n\"",
            "i - cfg.original_program_index",
            "cfg.original_argv[i]"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execl\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "arg_audit_prog",
            "arg_audit_prog",
            "NULL"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gcov_dump",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"ready\\n\""
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "arg_audit_prog"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LD_PRELOAD=%s\\n\"",
            "getenv(\"LD_PRELOAD\")"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"starting application\\n\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "orig_umask"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "extract_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/join.c",
          "lines": "240-256",
          "snippet": "static void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}",
          "includes": [
            "#include <sys/prctl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/prctl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_umask(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_UMASK_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(fname, \"re\");\n\tfree(fname);\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open umask file\\n\");\n\t\texit(1);\n\t}\n\tif (fscanf(fp, \"%3o\", &orig_umask) < 1) {\n\t\tfprintf(stderr, \"Error: cannot read umask\\n\");\n\t\texit(1);\n\t}\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_apply",
          "args": [],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "env_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
          "lines": "209-222",
          "snippet": "void env_apply(void) {\n\tEnv *env = envlist;\n\n\twhile (env) {\n\t\tif (env->op == SETENV) {\n\t\t\tif (setenv(env->name, env->value, 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\telse if (env->op == RMENV) {\n\t\t\tunsetenv(env->name);\n\t\t}\n\t\tenv = env->next;\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Env *envlist = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic Env *envlist = NULL;\n\nvoid env_apply(void) {\n\tEnv *env = envlist;\n\n\twhile (env) {\n\t\tif (env->op == SETENV) {\n\t\t\tif (setenv(env->name, env->value, 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\telse if (env->op == RMENV) {\n\t\t\tunsetenv(env->name);\n\t\t}\n\t\tenv = env->next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_defaults",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "env_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/env.c",
          "lines": "118-164",
          "snippet": "void env_defaults(void) {\n\t// Qt fixes\n\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n\tif (setenv(\"QML_DISABLE_DISK_CACHE\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n//\tif (setenv(\"QTWEBENGINE_DISABLE_SANDBOX\", \"1\", 1) < 0)\n//\t\terrExit(\"setenv\");\n//\tif (setenv(\"MOZ_NO_REMOTE, \"1\", 1) < 0)\n//\t\terrExit(\"setenv\");\n\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\terrExit(\"setenv\");\n\tif (!cfg.shell)\n\t\tcfg.shell = guess_shell();\n\tif (cfg.shell && setenv(\"SHELL\", cfg.shell, 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// spawn KIO slaves inside the sandbox\n\tif (setenv(\"KDE_FORK_SLAVES\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// set prompt color to green\n\tint set_prompt = 0;\n\tif (checkcfg(CFG_FIREJAIL_PROMPT))\n\t\tset_prompt = 1;\n\telse { // check FIREJAIL_PROMPT=\"yes\" environment variable\n\t\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\t\tif (prompt && strcmp(prompt, \"yes\") == 0)\n\t\t\tset_prompt = 1;\n\t}\n\n\tif (set_prompt) {\n\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\telse {\n\t\t// remove PROMPT_COMMAND\n\t\tif (setenv(\"PROMPT_COMMAND\", \":\", 1) < 0) // unsetenv() will not work here, bash still picks it up from somewhere\n\t\t\terrExit(\"setenv\");\n\t}\n\n\t// set the window title\n\tif (!arg_quiet)\n\t\tprintf(\"\\033]0;firejail %s\\007\", cfg.window_title);\n\tfflush(0);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_defaults(void) {\n\t// Qt fixes\n\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n\tif (setenv(\"QML_DISABLE_DISK_CACHE\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n//\tif (setenv(\"QTWEBENGINE_DISABLE_SANDBOX\", \"1\", 1) < 0)\n//\t\terrExit(\"setenv\");\n//\tif (setenv(\"MOZ_NO_REMOTE, \"1\", 1) < 0)\n//\t\terrExit(\"setenv\");\n\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\terrExit(\"setenv\");\n\tif (!cfg.shell)\n\t\tcfg.shell = guess_shell();\n\tif (cfg.shell && setenv(\"SHELL\", cfg.shell, 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// spawn KIO slaves inside the sandbox\n\tif (setenv(\"KDE_FORK_SLAVES\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// set prompt color to green\n\tint set_prompt = 0;\n\tif (checkcfg(CFG_FIREJAIL_PROMPT))\n\t\tset_prompt = 1;\n\telse { // check FIREJAIL_PROMPT=\"yes\" environment variable\n\t\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\t\tif (prompt && strcmp(prompt, \"yes\") == 0)\n\t\t\tset_prompt = 1;\n\t}\n\n\tif (set_prompt) {\n\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\telse {\n\t\t// remove PROMPT_COMMAND\n\t\tif (setenv(\"PROMPT_COMMAND\", \":\", 1) < 0) // unsetenv() will not work here, bash still picks it up from somewhere\n\t\t\terrExit(\"setenv\");\n\t}\n\n\t// set the window title\n\tif (!arg_quiet)\n\t\tprintf(\"\\033]0;firejail %s\\007\", cfg.window_title);\n\tfflush(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid start_application(int no_sandbox, FILE *fp) {\n\t// set environment\n\tif (no_sandbox == 0) {\n\t\tenv_defaults();\n\t\tenv_apply();\n\t}\n\t// restore original umask\n\tumask(orig_umask);\n\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tint rv = ok_to_run(cfg.original_argv[cfg.original_program_index]);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\tif (rv)\n\t\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: no suitable %s executable found\\n\", cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}"
  },
  {
    "function_name": "ok_to_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "384-430",
    "snippet": "static int ok_to_run(const char *program) {\n\tif (strstr(program, \"/\")) {\n\t\tif (access(program, X_OK) == 0) // it will also dereference symlinks\n\t\t\treturn 1;\n\t}\n\telse { // search $PATH\n\t\tchar *path1 = getenv(\"PATH\");\n\t\tif (path1) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Searching $PATH for %s\\n\", program);\n\t\t\tchar *path2 = strdup(path1);\n\t\t\tif (!path2)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// use path2 to count the entries\n\t\t\tchar *ptr = strtok(path2, \":\");\n\t\t\twhile (ptr) {\n\t\t\t\tchar *fname;\n\n\t\t\t\tif (asprintf(&fname, \"%s/%s\", ptr, program) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"trying #%s#\\n\", fname);\n\n\t\t\t\tstruct stat s;\n\t\t\t\tint rv = stat(fname, &s);\n\t\t\t\tif (rv == 0) {\n\t\t\t\t\tif (access(fname, X_OK) == 0) {\n\t\t\t\t\t\tfree(path2);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Error: execute permission denied for %s\\n\", fname);\n\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfree(fname);\n\t\t\t\tptr = strtok(NULL, \":\");\n\t\t\t}\n\t\t\tfree(path2);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path2"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\":\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: execute permission denied for %s\\n\"",
            "fname"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path2"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "fname",
            "X_OK"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "478-485",
          "snippet": "int access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_access_t orig_access = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_access_t orig_access = NULL;\n\nint access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"trying #%s#\\n\"",
            "fname"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/%s\"",
            "ptr",
            "program"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "path2",
            "\":\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path1"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Searching $PATH for %s\\n\"",
            "program"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "program",
            "\"/\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int ok_to_run(const char *program) {\n\tif (strstr(program, \"/\")) {\n\t\tif (access(program, X_OK) == 0) // it will also dereference symlinks\n\t\t\treturn 1;\n\t}\n\telse { // search $PATH\n\t\tchar *path1 = getenv(\"PATH\");\n\t\tif (path1) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Searching $PATH for %s\\n\", program);\n\t\t\tchar *path2 = strdup(path1);\n\t\t\tif (!path2)\n\t\t\t\terrExit(\"strdup\");\n\n\t\t\t// use path2 to count the entries\n\t\t\tchar *ptr = strtok(path2, \":\");\n\t\t\twhile (ptr) {\n\t\t\t\tchar *fname;\n\n\t\t\t\tif (asprintf(&fname, \"%s/%s\", ptr, program) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"trying #%s#\\n\", fname);\n\n\t\t\t\tstruct stat s;\n\t\t\t\tint rv = stat(fname, &s);\n\t\t\t\tif (rv == 0) {\n\t\t\t\t\tif (access(fname, X_OK) == 0) {\n\t\t\t\t\t\tfree(path2);\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(stderr, \"Error: execute permission denied for %s\\n\", fname);\n\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfree(fname);\n\t\t\t\tptr = strtok(NULL, \":\");\n\t\t\t}\n\t\t\tfree(path2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "print_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "359-373",
    "snippet": "static void print_time(void) {\n\tif (start_timestamp) {\n\t\tunsigned long long end_timestamp = getticks();\n\t\t// measure 1 ms\n\t\tusleep(1000);\n\t\tunsigned long long onems = getticks() - end_timestamp;\n\t\tif (onems) {\n\t\t\tfmessage(\"Child process initialized in %.02f ms\\n\",\n\t\t\t\t(float) (end_timestamp - start_timestamp) / (float) onems);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfmessage(\"Child process initialized\\n\");\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"Child process initialized\\n\""
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "189-198",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getticks",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "getticks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/common.h",
          "lines": "113-125",
          "snippet": "static inline unsigned long long getticks(void) {\n#if defined(__x86_64__)\n\tunsigned a, d;\n\tasm volatile(\"rdtsc\" : \"=a\" (a), \"=d\" (d));\n\treturn ((unsigned long long)a) | (((unsigned long long)d) << 32);\n#elif defined(__i386__)\n\tunsigned long long ret;\n\t__asm__ __volatile__(\"rdtsc\" : \"=A\" (ret));\n\treturn ret;\n#else\n\treturn 0; // not implemented\n#endif\n}",
          "includes": [
            "#include <assert.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline unsigned long long getticks(void) {\n#if defined(__x86_64__)\n\tunsigned a, d;\n\tasm volatile(\"rdtsc\" : \"=a\" (a), \"=d\" (d));\n\treturn ((unsigned long long)a) | (((unsigned long long)d) << 32);\n#elif defined(__i386__)\n\tunsigned long long ret;\n\t__asm__ __volatile__(\"rdtsc\" : \"=A\" (ret));\n\treturn ret;\n#else\n\treturn 0; // not implemented\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void print_time(void) {\n\tif (start_timestamp) {\n\t\tunsigned long long end_timestamp = getticks();\n\t\t// measure 1 ms\n\t\tusleep(1000);\n\t\tunsigned long long onems = getticks() - end_timestamp;\n\t\tif (onems) {\n\t\t\tfmessage(\"Child process initialized in %.02f ms\\n\",\n\t\t\t\t(float) (end_timestamp - start_timestamp) / (float) onems);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfmessage(\"Child process initialized\\n\");\n}"
  },
  {
    "function_name": "monitor_application",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "252-357",
    "snippet": "static int monitor_application(pid_t app_pid) {\n\tEUID_ASSERT();\n\tmonitored_pid = app_pid;\n\n\t// block signals and install handler\n\tsigset_t oldmask, newmask;\n\tsigemptyset(&oldmask);\n\tsigemptyset(&newmask);\n\tsigaddset(&newmask, SIGTERM);\n\tsigaddset(&newmask, SIGINT);\n\tsigprocmask(SIG_BLOCK, &newmask, &oldmask);\n\tinstall_handler();\n\n\t// handle --timeout\n\tint options = 0;;\n\tunsigned timeout = 0;\n\tif (cfg.timeout) {\n\t\toptions = WNOHANG;\n\t\ttimeout = cfg.timeout;\n\t}\n\n\tint status = 0;\n\twhile (monitored_pid) {\n\t\tusleep(20000);\n\t\tchar *msg;\n\t\tif (asprintf(&msg, \"monitoring pid %d\\n\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tlogmsg(msg);\n\t\tif (arg_debug)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tfree(msg);\n\n\t\tpid_t rv;\n\t\tdo {\n\t\t\t// handle signals asynchronously\n\t\t\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\t\t\trv = waitpid(-1, &status, options);\n\n\t\t\t// block signals again\n\t\t\tsigprocmask(SIG_BLOCK, &newmask, NULL);\n\n\t\t\tif (rv == -1) { // we can get here if we have processes joining the sandbox (ECHILD)\n\t\t\t\tsleep(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// handle --timeout\n\t\t\tif (options) {\n\t\t\t\tif (--timeout == 0)  {\n\t\t\t\t\tkill(-1, SIGTERM);\n\t\t\t\t\tsleep(1);\n\t\t\t\t\tflush_stdin();\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsleep(1);\n\t\t\t}\n\t\t}\n\t\twhile(rv != monitored_pid);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Sandbox monitor: waitpid %d retval %d status %d\\n\", monitored_pid, rv, status);\n\n\t\tDIR *dir;\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t// sleep 2 seconds and try again\n\t\t\tsleep(2);\n\t\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent *entry;\n\t\tmonitored_pid = 0;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tunsigned pid;\n\t\t\tif (sscanf(entry->d_name, \"%u\", &pid) != 1)\n\t\t\t\tcontinue;\n\t\t\tif (pid == 1)\n\t\t\t\tcontinue;\n\n\t\t\t// todo: make this generic\n\t\t\t// Dillo browser leaves a dpid process running, we need to shut it down\n\t\t\tint found = 0;\n\t\t\tif (strcmp(cfg.command_name, \"dillo\") == 0) {\n\t\t\t\tchar *pidname = pid_proc_comm(pid);\n\t\t\t\tif (pidname && strcmp(pidname, \"dpid\") == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tfree(pidname);\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\n\t\t\tmonitored_pid = pid;\n\t\t\tbreak;\n\t\t}\n\t\tclosedir(dir);\n\n\t\tif (monitored_pid != 0 && arg_debug)\n\t\t\tprintf(\"Sandbox monitor: monitoring %d\\n\", monitored_pid);\n\t}\n\n\t// return the latest exit status.\n\treturn status;\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int monitored_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Sandbox monitor: monitoring %d\\n\"",
            "monitored_pid"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pidname"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pidname",
            "\"dpid\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_proc_comm",
          "args": [
            "pid"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "pid_proc_comm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/common.c",
          "lines": "128-164",
          "snippet": "char *pid_proc_comm(const pid_t pid) {\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/comm\", pid) == -1)\n\t\treturn NULL;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn NULL;\n\t}\n\tfree(fname);\n\n\t// read file\n\tchar buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// remove \\n\n\tchar *ptr = strchr(buffer, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\t// return a malloc copy of the command line\n\tchar *rv = strdup(buffer);\n\tif (!rv)\n\t\treturn NULL;\n\tif (strlen(rv) == 0) {\n\t\tfree(rv);\n\t\treturn NULL;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"../include/common.h\"",
            "#include <string.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <sys/syscall.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define BUFLEN 4096",
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdio.h>\n\n#define BUFLEN 4096\n#define BUFLEN 4096\n\nchar *pid_proc_comm(const pid_t pid) {\n\t// open /proc/pid/cmdline file\n\tchar *fname;\n\tint fd;\n\tif (asprintf(&fname, \"/proc/%d/comm\", pid) == -1)\n\t\treturn NULL;\n\tif ((fd = open(fname, O_RDONLY)) < 0) {\n\t\tfree(fname);\n\t\treturn NULL;\n\t}\n\tfree(fname);\n\n\t// read file\n\tchar buffer[BUFLEN];\n\tssize_t len;\n\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) <= 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\n\t// remove \\n\n\tchar *ptr = strchr(buffer, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\n\t// return a malloc copy of the command line\n\tchar *rv = strdup(buffer);\n\tif (!rv)\n\t\treturn NULL;\n\tif (strlen(rv) == 0) {\n\t\tfree(rv);\n\t\treturn NULL;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cfg.command_name",
            "\"dillo\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "entry->d_name",
            "\"%u\"",
            "&pid"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open /proc directory\\n\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/proc\""
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "466-473",
          "snippet": "DIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_opendir_t orig_opendir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_opendir_t orig_opendir = NULL;\n\nDIR *opendir(const char *pathname) {\n\tif (!orig_opendir)\n\t\torig_opendir = (orig_opendir_t)dlsym(RTLD_NEXT, \"opendir\");\n\n\tDIR *rv = orig_opendir(pathname);\n\tprintf(\"%u:%s:opendir %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "firemon_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "90-121",
          "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios tlocal;",
            "static struct termios twait;",
            "static int terminal_set = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Sandbox monitor: waitpid %d retval %d status %d\\n\"",
            "monitored_pid",
            "rv",
            "status"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "err_exit_cannot_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnetfilter/main.c",
          "lines": "53-56",
          "snippet": "static void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}",
          "includes": [
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/common.h\"\n\nstatic void err_exit_cannot_open_file(const char *fname) {\n\tfprintf(stderr, \"Error fnetfilter: cannot open %s\\n\", fname);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_stdin",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "flush_stdin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "959-969",
          "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "-1",
            "SIGTERM"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_BLOCK",
            "&newmask",
            "NULL"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "-1",
            "&status",
            "options"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&oldmask",
            "NULL"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "msg"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logmsg",
          "args": [
            "msg"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "logmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "210-217",
          "snippet": "void logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&msg",
            "\"monitoring pid %d\\n\"",
            "monitored_pid"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "20000"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "install_handler",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "install_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
          "lines": "94-110",
          "snippet": "static void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// block SIGTERM while handling SIGINT\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGTERM);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGINT, &sga, NULL);\n\n\t// block SIGINT while handling SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGINT);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}",
          "includes": [
            "#include <syscall.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// block SIGTERM while handling SIGINT\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGTERM);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGINT, &sga, NULL);\n\n\t// block SIGINT while handling SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGINT);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_BLOCK",
            "&newmask",
            "&oldmask"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&newmask",
            "SIGINT"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&newmask",
            "SIGTERM"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&newmask"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&oldmask"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int monitored_pid = 0;\n\nstatic int monitor_application(pid_t app_pid) {\n\tEUID_ASSERT();\n\tmonitored_pid = app_pid;\n\n\t// block signals and install handler\n\tsigset_t oldmask, newmask;\n\tsigemptyset(&oldmask);\n\tsigemptyset(&newmask);\n\tsigaddset(&newmask, SIGTERM);\n\tsigaddset(&newmask, SIGINT);\n\tsigprocmask(SIG_BLOCK, &newmask, &oldmask);\n\tinstall_handler();\n\n\t// handle --timeout\n\tint options = 0;;\n\tunsigned timeout = 0;\n\tif (cfg.timeout) {\n\t\toptions = WNOHANG;\n\t\ttimeout = cfg.timeout;\n\t}\n\n\tint status = 0;\n\twhile (monitored_pid) {\n\t\tusleep(20000);\n\t\tchar *msg;\n\t\tif (asprintf(&msg, \"monitoring pid %d\\n\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tlogmsg(msg);\n\t\tif (arg_debug)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tfree(msg);\n\n\t\tpid_t rv;\n\t\tdo {\n\t\t\t// handle signals asynchronously\n\t\t\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\t\t\trv = waitpid(-1, &status, options);\n\n\t\t\t// block signals again\n\t\t\tsigprocmask(SIG_BLOCK, &newmask, NULL);\n\n\t\t\tif (rv == -1) { // we can get here if we have processes joining the sandbox (ECHILD)\n\t\t\t\tsleep(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// handle --timeout\n\t\t\tif (options) {\n\t\t\t\tif (--timeout == 0)  {\n\t\t\t\t\tkill(-1, SIGTERM);\n\t\t\t\t\tsleep(1);\n\t\t\t\t\tflush_stdin();\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsleep(1);\n\t\t\t}\n\t\t}\n\t\twhile(rv != monitored_pid);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Sandbox monitor: waitpid %d retval %d status %d\\n\", monitored_pid, rv, status);\n\n\t\tDIR *dir;\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t// sleep 2 seconds and try again\n\t\t\tsleep(2);\n\t\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent *entry;\n\t\tmonitored_pid = 0;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tunsigned pid;\n\t\t\tif (sscanf(entry->d_name, \"%u\", &pid) != 1)\n\t\t\t\tcontinue;\n\t\t\tif (pid == 1)\n\t\t\t\tcontinue;\n\n\t\t\t// todo: make this generic\n\t\t\t// Dillo browser leaves a dpid process running, we need to shut it down\n\t\t\tint found = 0;\n\t\t\tif (strcmp(cfg.command_name, \"dillo\") == 0) {\n\t\t\t\tchar *pidname = pid_proc_comm(pid);\n\t\t\t\tif (pidname && strcmp(pidname, \"dpid\") == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tfree(pidname);\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\n\t\t\tmonitored_pid = pid;\n\t\t\tbreak;\n\t\t}\n\t\tclosedir(dir);\n\n\t\tif (monitored_pid != 0 && arg_debug)\n\t\t\tprintf(\"Sandbox monitor: monitoring %d\\n\", monitored_pid);\n\t}\n\n\t// return the latest exit status.\n\treturn status;\n}"
  },
  {
    "function_name": "chk_chroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "235-250",
    "snippet": "static void chk_chroot(void) {\n\t// if we are starting firejail inside some other container technology, we don't care about this\n\tchar *mycont = getenv(\"container\");\n\tif (mycont)\n\t\treturn;\n\n\t// check if this is a regular chroot\n\tstruct stat s;\n\tif (stat(\"/\", &s) == 0) {\n\t\tif (s.st_ino != 2)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: cannot mount filesystem as slave\\n\");\n\texit(1);\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot mount filesystem as slave\\n\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/\"",
            "&s"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"container\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void chk_chroot(void) {\n\t// if we are starting firejail inside some other container technology, we don't care about this\n\tchar *mycont = getenv(\"container\");\n\tif (mycont)\n\t\treturn;\n\n\t// check if this is a regular chroot\n\tstruct stat s;\n\tif (stat(\"/\", &s) == 0) {\n\t\tif (s.st_ino != 2)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: cannot mount filesystem as slave\\n\");\n\texit(1);\n}"
  },
  {
    "function_name": "sandbox_if_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "185-233",
    "snippet": "static void sandbox_if_up(Bridge *br) {\n\tassert(br);\n\tif (!br->configured)\n\t\treturn;\n\n\tchar *dev = br->devsandbox;\n\tnet_if_up(dev);\n\n\tif (br->arg_ip_none == 1);\t// do nothing\n\telse if (br->arg_ip_none == 0 && br->macvlan == 0) {\n\t\tif (br->ipsandbox == br->ip) {\n\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\texit(1);\n\t\t}\n\n\t\t// just assign the address\n\t\tassert(br->ipsandbox);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\telse if (br->arg_ip_none == 0 && br->macvlan == 1) {\n\t\t// reassign the macvlan address\n\t\tif (br->ipsandbox == 0)\n\t\t\t// ip address assigned by arp-scan for a macvlan device\n\t\t\tbr->ipsandbox = arp_assign(dev, br); //br->ip, br->mask);\n\t\telse {\n\t\t\tif (br->ipsandbox == br->ip) {\n\t\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tuint32_t rv = arp_check(dev, br->ipsandbox);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Error: the address %d.%d.%d.%d is already in use.\\n\", PRINT_IP(br->ipsandbox));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\n\tif (br->ip6sandbox)\n\t\t net_if_ip6(dev, br->ip6sandbox);\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_if_ip6",
          "args": [
            "dev",
            "br->ip6sandbox"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_ip6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network.c",
          "lines": "170-179",
          "snippet": "void net_if_ip6(const char *ifname, const char *addr6) {\n\tif (strchr(addr6, ':') == NULL) {\n\t\tfprintf(stderr, \"Error: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 5,\n\t\tPATH_FNET, \"config\", \"ipv6\", ifname, addr6);\n\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_ip6(const char *ifname, const char *addr6) {\n\tif (strchr(addr6, ':') == NULL) {\n\t\tfprintf(stderr, \"Error: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 5,\n\t\tPATH_FNET, \"config\", \"ipv6\", ifname, addr6);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_announce",
          "args": [
            "dev",
            "br"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "arp_announce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/arp.c",
          "lines": "45-113",
          "snippet": "void arp_announce(const char *dev, Bridge *br) {\n\t// RFC 5227 - using a source and destination IP address of the interface\n\tuint32_t srcaddr = br->ipsandbox;\n\tuint32_t destaddr = br->ipsandbox;\n\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Announce %d.%d.%d.%d ...\\n\", PRINT_IP(destaddr));\n\n\t// find interface address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\n\tsrcaddr = htonl(srcaddr);\n\tdestaddr = htonl(destaddr);\n\n\t// Find interface MAC address\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ - 1);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\n\t// configure layer2 socket address information\n\tstruct sockaddr_ll addr;\n\tmemset(&addr, 0, sizeof(addr));\n\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\terrExit(\"if_nametoindex\");\n\taddr.sll_family = AF_PACKET;\n\tmemcpy (addr.sll_addr, ifr.ifr_hwaddr.sa_data, 6);\n\taddr.sll_halen = ETH_ALEN;\n\n\t// build the arp packet header\n\tArpHdr hdr;\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.htype = htons(1);\n\thdr.ptype = htons(ETH_P_IP);\n\thdr.hlen = 6;\n\thdr.plen = 4;\n\thdr.opcode = htons(1); //ARPOP_REQUEST\n\tmemcpy(hdr.sender_mac, ifr.ifr_hwaddr.sa_data, 6);\n\tmemcpy(hdr.sender_ip, (uint8_t *)&srcaddr, 4);\n\tmemcpy(hdr.target_ip, (uint8_t *)&destaddr, 4);\n\n\t// build ethernet frame\n\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\tmemset(frame, 0, sizeof(frame));\n\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\tmemcpy(frame + 6, ifr.ifr_hwaddr.sa_data, 6);\n\tframe[12] = ETH_P_ARP / 256;\n\tframe[13] = ETH_P_ARP % 256;\n\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\tint len;\n\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\terrExit(\"send\");\n\tfflush(0);\n\tclose(sock);\n}",
          "includes": [
            "#include <linux/if_packet.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_packet.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include \"firejail.h\"\n\nvoid arp_announce(const char *dev, Bridge *br) {\n\t// RFC 5227 - using a source and destination IP address of the interface\n\tuint32_t srcaddr = br->ipsandbox;\n\tuint32_t destaddr = br->ipsandbox;\n\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Announce %d.%d.%d.%d ...\\n\", PRINT_IP(destaddr));\n\n\t// find interface address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\n\tsrcaddr = htonl(srcaddr);\n\tdestaddr = htonl(destaddr);\n\n\t// Find interface MAC address\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ - 1);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\n\t// configure layer2 socket address information\n\tstruct sockaddr_ll addr;\n\tmemset(&addr, 0, sizeof(addr));\n\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\terrExit(\"if_nametoindex\");\n\taddr.sll_family = AF_PACKET;\n\tmemcpy (addr.sll_addr, ifr.ifr_hwaddr.sa_data, 6);\n\taddr.sll_halen = ETH_ALEN;\n\n\t// build the arp packet header\n\tArpHdr hdr;\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.htype = htons(1);\n\thdr.ptype = htons(ETH_P_IP);\n\thdr.hlen = 6;\n\thdr.plen = 4;\n\thdr.opcode = htons(1); //ARPOP_REQUEST\n\tmemcpy(hdr.sender_mac, ifr.ifr_hwaddr.sa_data, 6);\n\tmemcpy(hdr.sender_ip, (uint8_t *)&srcaddr, 4);\n\tmemcpy(hdr.target_ip, (uint8_t *)&destaddr, 4);\n\n\t// build ethernet frame\n\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\tmemset(frame, 0, sizeof(frame));\n\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\tmemcpy(frame + 6, ifr.ifr_hwaddr.sa_data, 6);\n\tframe[12] = ETH_P_ARP / 256;\n\tframe[13] = ETH_P_ARP % 256;\n\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\tint len;\n\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\terrExit(\"send\");\n\tfflush(0);\n\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_config_interface",
          "args": [
            "dev",
            "br->ipsandbox",
            "br->mask",
            "br->mtu"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "net_config_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network.c",
          "lines": "283-304",
          "snippet": "void net_config_interface(const char *dev, uint32_t ip, uint32_t mask, int mtu) {\n\tassert(dev);\n\n\tchar *ipstr;\n\tif (asprintf(&ipstr, \"%llu\", (long long unsigned) ip) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *maskstr;\n\tif (asprintf(&maskstr, \"%llu\", (long long unsigned) mask) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *mtustr;\n\tif (asprintf(&mtustr, \"%d\", mtu) == -1)\n\t\terrExit(\"asprintf\");\n\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 7,\n\t\tPATH_FNET, \"config\", \"interface\", dev, ipstr, maskstr, mtustr);\n\n\tfree(ipstr);\n\tfree(maskstr);\n\tfree(mtustr);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_config_interface(const char *dev, uint32_t ip, uint32_t mask, int mtu) {\n\tassert(dev);\n\n\tchar *ipstr;\n\tif (asprintf(&ipstr, \"%llu\", (long long unsigned) ip) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *maskstr;\n\tif (asprintf(&maskstr, \"%llu\", (long long unsigned) mask) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *mtustr;\n\tif (asprintf(&mtustr, \"%d\", mtu) == -1)\n\t\terrExit(\"asprintf\");\n\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 7,\n\t\tPATH_FNET, \"config\", \"interface\", dev, ipstr, maskstr, mtustr);\n\n\tfree(ipstr);\n\tfree(maskstr);\n\tfree(mtustr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(br->ipsandbox)",
            "dev"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: the address %d.%d.%d.%d is already in use.\\n\"",
            "PRINT_IP(br->ipsandbox)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_check",
          "args": [
            "dev",
            "br->ipsandbox"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "arp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/arp.c",
          "lines": "118-245",
          "snippet": "int arp_check(const char *dev, uint32_t destaddr) {\n\t// RFC 5227 - using a source IP address of 0 for probing\n\tuint32_t srcaddr = 0;\n\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Trying %d.%d.%d.%d ...\\n\", PRINT_IP(destaddr));\n\n\t// find interface address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\n\tsrcaddr = htonl(srcaddr);\n\tdestaddr = htonl(destaddr);\n\n\t// Find interface MAC address\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ - 1);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\n\t// configure layer2 socket address information\n\tstruct sockaddr_ll addr;\n\tmemset(&addr, 0, sizeof(addr));\n\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\terrExit(\"if_nametoindex\");\n\taddr.sll_family = AF_PACKET;\n\tmemcpy (addr.sll_addr, ifr.ifr_hwaddr.sa_data, 6);\n\taddr.sll_halen = ETH_ALEN;\n\n\t// build the arp packet header\n\tArpHdr hdr;\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.htype = htons(1);\n\thdr.ptype = htons(ETH_P_IP);\n\thdr.hlen = 6;\n\thdr.plen = 4;\n\thdr.opcode = htons(1); //ARPOP_REQUEST\n\tmemcpy(hdr.sender_mac, ifr.ifr_hwaddr.sa_data, 6);\n\tmemcpy(hdr.sender_ip, (uint8_t *)&srcaddr, 4);\n\tmemcpy(hdr.target_ip, (uint8_t *)&destaddr, 4);\n\n\t// build ethernet frame\n\tuint8_t frame[ETH_FRAME_LEN]; // includes eth header, vlan, and crc\n\tmemset(frame, 0, sizeof(frame));\n\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\tmemcpy(frame + 6, ifr.ifr_hwaddr.sa_data, 6);\n\tframe[12] = ETH_P_ARP / 256;\n\tframe[13] = ETH_P_ARP % 256;\n\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\tint len;\n\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\terrExit(\"send\");\n\tfflush(0);\n\n\t// send two probes at 0.5 seconds interva;\n\tint  cnt = checkcfg(CFG_ARP_PROBES);\n\tuint8_t framerx[ETH_FRAME_LEN]; // includes eth header, vlan, and crc\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(sock, &fds);\n\tint maxfd = sock;\n\tstruct timeval ts;\n\tts.tv_sec = 0; // 0.5 seconds wait time\n\tts.tv_usec = 500000;\n\twhile (1) {\n\t\tint nready = select(maxfd + 1,  &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\t\telse if (nready == 0) { // timeout\n\t\t\tif (--cnt <= 0) {\n\t\t\t\tclose(sock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\t\t\terrExit(\"send\");\n\t\t\tts.tv_sec = 0; // 0.5 seconds wait time\n\t\t\tts.tv_usec = 500000;\n\t\t\tfflush(0);\n\t\t}\n\t\telse {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, framerx, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\t\t\tif (framerx[12] != (ETH_P_ARP / 256) || framerx[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\t\t\tmemcpy(&hdr, framerx + 14, sizeof(ArpHdr));\n\t\t\tif (hdr.opcode == htons(1))\n\t\t\t\tcontinue;\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(ifr.ifr_hwaddr.sa_data, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != srcaddr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// it will never get here!\n\tclose(sock);\n\treturn -1;\n}",
          "includes": [
            "#include <linux/if_packet.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_packet.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include \"firejail.h\"\n\nint arp_check(const char *dev, uint32_t destaddr) {\n\t// RFC 5227 - using a source IP address of 0 for probing\n\tuint32_t srcaddr = 0;\n\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Trying %d.%d.%d.%d ...\\n\", PRINT_IP(destaddr));\n\n\t// find interface address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\n\tsrcaddr = htonl(srcaddr);\n\tdestaddr = htonl(destaddr);\n\n\t// Find interface MAC address\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ - 1);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\n\t// configure layer2 socket address information\n\tstruct sockaddr_ll addr;\n\tmemset(&addr, 0, sizeof(addr));\n\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\terrExit(\"if_nametoindex\");\n\taddr.sll_family = AF_PACKET;\n\tmemcpy (addr.sll_addr, ifr.ifr_hwaddr.sa_data, 6);\n\taddr.sll_halen = ETH_ALEN;\n\n\t// build the arp packet header\n\tArpHdr hdr;\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.htype = htons(1);\n\thdr.ptype = htons(ETH_P_IP);\n\thdr.hlen = 6;\n\thdr.plen = 4;\n\thdr.opcode = htons(1); //ARPOP_REQUEST\n\tmemcpy(hdr.sender_mac, ifr.ifr_hwaddr.sa_data, 6);\n\tmemcpy(hdr.sender_ip, (uint8_t *)&srcaddr, 4);\n\tmemcpy(hdr.target_ip, (uint8_t *)&destaddr, 4);\n\n\t// build ethernet frame\n\tuint8_t frame[ETH_FRAME_LEN]; // includes eth header, vlan, and crc\n\tmemset(frame, 0, sizeof(frame));\n\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\tmemcpy(frame + 6, ifr.ifr_hwaddr.sa_data, 6);\n\tframe[12] = ETH_P_ARP / 256;\n\tframe[13] = ETH_P_ARP % 256;\n\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\tint len;\n\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\terrExit(\"send\");\n\tfflush(0);\n\n\t// send two probes at 0.5 seconds interva;\n\tint  cnt = checkcfg(CFG_ARP_PROBES);\n\tuint8_t framerx[ETH_FRAME_LEN]; // includes eth header, vlan, and crc\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(sock, &fds);\n\tint maxfd = sock;\n\tstruct timeval ts;\n\tts.tv_sec = 0; // 0.5 seconds wait time\n\tts.tv_usec = 500000;\n\twhile (1) {\n\t\tint nready = select(maxfd + 1,  &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\t\telse if (nready == 0) { // timeout\n\t\t\tif (--cnt <= 0) {\n\t\t\t\tclose(sock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\t\t\terrExit(\"send\");\n\t\t\tts.tv_sec = 0; // 0.5 seconds wait time\n\t\t\tts.tv_usec = 500000;\n\t\t\tfflush(0);\n\t\t}\n\t\telse {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, framerx, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\t\t\tif (framerx[12] != (ETH_P_ARP / 256) || framerx[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\t\t\tmemcpy(&hdr, framerx + 14, sizeof(ArpHdr));\n\t\t\tif (hdr.opcode == htons(1))\n\t\t\t\tcontinue;\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(ifr.ifr_hwaddr.sa_data, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != srcaddr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// it will never get here!\n\tclose(sock);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %d.%d.%d.%d is interface %s address.\\n\"",
            "PRINT_IP(br->ipsandbox)",
            "br->dev"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_assign",
          "args": [
            "dev",
            "br"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "arp_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/arp.c",
          "lines": "352-373",
          "snippet": "uint32_t arp_assign(const char *dev, Bridge *br) {\n\tassert(br);\n\tuint32_t ip = 0;\n\n\t// try two random IP addresses\n\tip = arp_random(dev, br);\n\tif (!ip)\n\t\tip = arp_random(dev, br);\n\n\t// try all possible IP addresses one by one\n\tif (!ip)\n\t\tip = arp_sequential(dev, br);\n\n\t// print result\n\tif (!ip) {\n\t\tfprintf(stderr, \"Error: cannot assign an IP address; it looks like all of them are in use.\\n\");\n\t\tlogerr(\"Cannot assign an IP address; it looks like all of them are in use.\");\n\t\texit(1);\n\t}\n\n\treturn ip;\n}",
          "includes": [
            "#include <linux/if_packet.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_packet.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include \"firejail.h\"\n\nuint32_t arp_assign(const char *dev, Bridge *br) {\n\tassert(br);\n\tuint32_t ip = 0;\n\n\t// try two random IP addresses\n\tip = arp_random(dev, br);\n\tif (!ip)\n\t\tip = arp_random(dev, br);\n\n\t// try all possible IP addresses one by one\n\tif (!ip)\n\t\tip = arp_sequential(dev, br);\n\n\t// print result\n\tif (!ip) {\n\t\tfprintf(stderr, \"Error: cannot assign an IP address; it looks like all of them are in use.\\n\");\n\t\tlogerr(\"Cannot assign an IP address; it looks like all of them are in use.\");\n\t\texit(1);\n\t}\n\n\treturn ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(br->ipsandbox)",
            "dev"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br->ipsandbox"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %d.%d.%d.%d is interface %s address.\\n\"",
            "PRINT_IP(br->ipsandbox)",
            "br->dev"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_if_up",
          "args": [
            "dev"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/network.c",
          "lines": "158-165",
          "snippet": "void net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3,\n\t\tPATH_FNET, \"ifup\", ifname);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3,\n\t\tPATH_FNET, \"ifup\", ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void sandbox_if_up(Bridge *br) {\n\tassert(br);\n\tif (!br->configured)\n\t\treturn;\n\n\tchar *dev = br->devsandbox;\n\tnet_if_up(dev);\n\n\tif (br->arg_ip_none == 1);\t// do nothing\n\telse if (br->arg_ip_none == 0 && br->macvlan == 0) {\n\t\tif (br->ipsandbox == br->ip) {\n\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\texit(1);\n\t\t}\n\n\t\t// just assign the address\n\t\tassert(br->ipsandbox);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\telse if (br->arg_ip_none == 0 && br->macvlan == 1) {\n\t\t// reassign the macvlan address\n\t\tif (br->ipsandbox == 0)\n\t\t\t// ip address assigned by arp-scan for a macvlan device\n\t\t\tbr->ipsandbox = arp_assign(dev, br); //br->ip, br->mask);\n\t\telse {\n\t\t\tif (br->ipsandbox == br->ip) {\n\t\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tuint32_t rv = arp_check(dev, br->ipsandbox);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Error: the address %d.%d.%d.%d is already in use.\\n\", PRINT_IP(br->ipsandbox));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\n\tif (br->ip6sandbox)\n\t\t net_if_ip6(dev, br->ip6sandbox);\n}"
  },
  {
    "function_name": "create_ready_for_join_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "173-183",
    "snippet": "static FILE *create_ready_for_join_file(void) {\n\tFILE *fp = fopen(RUN_READY_FOR_JOIN, \"wxe\");\n\tif (fp) {\n\t\tASSERT_PERMS_STREAM(fp, 0, 0, 0644);\n\t\treturn fp;\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_READY_FOR_JOIN);\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create %s\\n\"",
            "RUN_READY_FOR_JOIN"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS_STREAM",
          "args": [
            "fp",
            "0",
            "0",
            "0644"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "RUN_READY_FOR_JOIN",
            "\"wxe\""
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic FILE *create_ready_for_join_file(void) {\n\tFILE *fp = fopen(RUN_READY_FOR_JOIN, \"wxe\");\n\tif (fp) {\n\t\tASSERT_PERMS_STREAM(fp, 0, 0, 0644);\n\t\treturn fp;\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_READY_FOR_JOIN);\n\t\texit(1);\n\t}\n}"
  },
  {
    "function_name": "save_umask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "160-171",
    "snippet": "static void save_umask(void) {\n\tFILE *fp = fopen(RUN_UMASK_FILE, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"%o\\n\", orig_umask);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save umask\\n\");\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot save umask\\n\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "0",
            "0",
            "0644"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"%o\\n\"",
            "orig_umask"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "RUN_UMASK_FILE",
            "\"wxe\""
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void save_umask(void) {\n\tFILE *fp = fopen(RUN_UMASK_FILE, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"%o\\n\", orig_umask);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save umask\\n\");\n\t\texit(1);\n\t}\n}"
  },
  {
    "function_name": "save_nonewprivs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "144-158",
    "snippet": "static void save_nonewprivs(void) {\n\tif (arg_nonewprivs == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_NONEWPRIVS_CFG, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nonewprivs state\\n\");\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot save nonewprivs state\\n\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "0",
            "0",
            "0644"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "RUN_NONEWPRIVS_CFG",
            "\"wxe\""
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void save_nonewprivs(void) {\n\tif (arg_nonewprivs == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_NONEWPRIVS_CFG, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nonewprivs state\\n\");\n\t\texit(1);\n\t}\n}"
  },
  {
    "function_name": "save_nogroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "128-142",
    "snippet": "static void save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot save nogroups state\\n\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "0",
            "0",
            "0644"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "RUN_GROUPS_CFG",
            "\"w\""
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n}"
  },
  {
    "function_name": "set_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "112-126",
    "snippet": "static void set_caps(void) {\n\tif (arg_caps_drop_all)\n\t\tcaps_drop_all();\n\telse if (arg_caps_drop)\n\t\tcaps_drop_list(arg_caps_list);\n\telse if (arg_caps_keep)\n\t\tcaps_keep_list(arg_caps_list);\n\telse if (arg_caps_default_filter)\n\t\tcaps_default_filter();\n\n\t// drop discretionary access control capabilities for root sandboxes\n\t// if caps.keep, the user has to set it manually in the list\n\tif (!arg_caps_keep)\n\t\tcaps_drop_dac_override();\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "caps_drop_dac_override",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "caps_drop_dac_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/caps.c",
          "lines": "252-262",
          "snippet": "void caps_drop_dac_override(void) {\n\tif (getuid() == 0 && !arg_noprofile) {\n\t\tif (prctl(PR_CAPBSET_DROP, CAP_DAC_OVERRIDE, 0, 0, 0));\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Drop CAP_DAC_OVERRIDE\\n\");\n\n\t\tif (prctl(PR_CAPBSET_DROP, CAP_DAC_READ_SEARCH, 0, 0, 0));\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Drop CAP_DAC_READ_SEARCH\\n\");\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nvoid caps_drop_dac_override(void) {\n\tif (getuid() == 0 && !arg_noprofile) {\n\t\tif (prctl(PR_CAPBSET_DROP, CAP_DAC_OVERRIDE, 0, 0, 0));\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Drop CAP_DAC_OVERRIDE\\n\");\n\n\t\tif (prctl(PR_CAPBSET_DROP, CAP_DAC_READ_SEARCH, 0, 0, 0));\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Drop CAP_DAC_READ_SEARCH\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "caps_default_filter",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "caps_default_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/caps.c",
          "lines": "264-313",
          "snippet": "int caps_default_filter(void) {\n\t// drop capabilities\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_MODULE, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_MODULE\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_RAWIO, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_RAWIO\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_BOOT, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_BOOT\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_NICE, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_NICE\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_TTY_CONFIG, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_TTY_CONFIG\\n\");\n\n#ifdef CAP_SYSLOG\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYSLOG, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYSLOG\\n\");\n#endif\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_MKNOD, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_MKNOD\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_ADMIN, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_ADMIN\\n\");\n\n\treturn 0;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot drop capabilities\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nint caps_default_filter(void) {\n\t// drop capabilities\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_MODULE, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_MODULE\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_RAWIO, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_RAWIO\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_BOOT, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_BOOT\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_NICE, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_NICE\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_TTY_CONFIG, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_TTY_CONFIG\\n\");\n\n#ifdef CAP_SYSLOG\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYSLOG, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYSLOG\\n\");\n#endif\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_MKNOD, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_MKNOD\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_ADMIN, 0, 0, 0))\n\t\tgoto errexit;\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_ADMIN\\n\");\n\n\treturn 0;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot drop capabilities\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "caps_keep_list",
          "args": [
            "arg_caps_list"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "caps_keep_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/caps.c",
          "lines": "362-366",
          "snippet": "void caps_keep_list(const char *clist) {\n\tfilter = 0;\n\tcaps_check_list(clist, caps_set_bit);\n\tcaps_set(filter);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t filter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nstatic uint64_t filter;\n\nvoid caps_keep_list(const char *clist) {\n\tfilter = 0;\n\tcaps_check_list(clist, caps_set_bit);\n\tcaps_set(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "caps_drop_list",
          "args": [
            "arg_caps_list"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "caps_drop_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/caps.c",
          "lines": "355-360",
          "snippet": "void caps_drop_list(const char *clist) {\n\tfilter = 0;\n\tfilter--;\n\tcaps_check_list(clist, caps_reset_bit);\n\tcaps_set(filter);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t filter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nstatic uint64_t filter;\n\nvoid caps_drop_list(const char *clist) {\n\tfilter = 0;\n\tfilter--;\n\tcaps_check_list(clist, caps_reset_bit);\n\tcaps_set(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "caps_drop_all",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "caps_drop_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/caps.c",
          "lines": "315-325",
          "snippet": "void caps_drop_all(void) {\n\tif (arg_debug)\n\t\tprintf(\"Dropping all capabilities\\n\");\n\n\tunsigned long cap;\n\tfor (cap=0; cap <= 63; cap++) {\n\t\tint code = prctl(PR_CAPBSET_DROP, cap, 0, 0, 0);\n\t\tif (code == -1 && errno != EINVAL)\n\t\t\terrExit(\"PR_CAPBSET_DROP\");\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nvoid caps_drop_all(void) {\n\tif (arg_debug)\n\t\tprintf(\"Dropping all capabilities\\n\");\n\n\tunsigned long cap;\n\tfor (cap=0; cap <= 63; cap++) {\n\t\tint code = prctl(PR_CAPBSET_DROP, cap, 0, 0, 0);\n\t\tif (code == -1 && errno != EINVAL)\n\t\t\terrExit(\"PR_CAPBSET_DROP\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void set_caps(void) {\n\tif (arg_caps_drop_all)\n\t\tcaps_drop_all();\n\telse if (arg_caps_drop)\n\t\tcaps_drop_list(arg_caps_list);\n\telse if (arg_caps_keep)\n\t\tcaps_keep_list(arg_caps_list);\n\telse if (arg_caps_default_filter)\n\t\tcaps_default_filter();\n\n\t// drop discretionary access control capabilities for root sandboxes\n\t// if caps.keep, the user has to set it manually in the list\n\tif (!arg_caps_keep)\n\t\tcaps_drop_dac_override();\n}"
  },
  {
    "function_name": "install_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "94-110",
    "snippet": "static void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// block SIGTERM while handling SIGINT\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGTERM);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGINT, &sga, NULL);\n\n\t// block SIGINT while handling SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGINT);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGTERM",
            "&sga",
            "NULL"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&sga.sa_mask",
            "SIGINT"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sga.sa_mask"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGINT",
            "&sga",
            "NULL"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&sga.sa_mask",
            "SIGTERM"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sga.sa_mask"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void install_handler(void) {\n\tstruct sigaction sga;\n\n\t// block SIGTERM while handling SIGINT\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGTERM);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGINT, &sga, NULL);\n\n\t// block SIGINT while handling SIGTERM\n\tsigemptyset(&sga.sa_mask);\n\tsigaddset(&sga.sa_mask, SIGINT);\n\tsga.sa_handler = sandbox_handler;\n\tsga.sa_flags = 0;\n\tsigaction(SIGTERM, &sga, NULL);\n}"
  },
  {
    "function_name": "sandbox_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
    "lines": "55-92",
    "snippet": "static void sandbox_handler(int sig){\n\tusleep(10000); // don't race to print a message\n\tfmessage(\"\\nChild received signal %d, shutting down the sandbox...\\n\", sig);\n\n\t// broadcast sigterm to all processes in the group\n\tkill(-1, SIGTERM);\n\tsleep(1);\n\n\tif (monitored_pid) {\n\t\tint monsec = 9;\n\t\tchar *monfile;\n\t\tif (asprintf(&monfile, \"/proc/%d/cmdline\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\twhile (monsec) {\n\t\t\tFILE *fp = fopen(monfile, \"r\");\n\t\t\tif (!fp)\n\t\t\t\tbreak;\n\n\t\t\tchar c;\n\t\t\tsize_t count = fread(&c, 1, 1, fp);\n\t\t\tfclose(fp);\n\t\t\tif (count == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Waiting on PID %d to finish\\n\", monitored_pid);\n\t\t\tsleep(1);\n\t\t\tmonsec--;\n\t\t}\n\t\tfree(monfile);\n\t}\n\n\t// broadcast a SIGKILL\n\tkill(-1, SIGKILL);\n\tflush_stdin();\n\n\texit(sig);\n}",
    "includes": [
      "#include <syscall.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int monitored_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "sig"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_stdin",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "flush_stdin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "959-969",
          "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "-1",
            "SIGKILL"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "monfile"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "firemon_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "90-121",
          "snippet": "void firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct termios tlocal;",
            "static struct termios twait;",
            "static int terminal_set = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nstatic struct termios tlocal;\nstatic struct termios twait;\nstatic int terminal_set = 0;\n\nvoid firemon_sleep(int st) {\n\tif (terminal_set == 0) {\n\t\ttcgetattr(0, &twait);          // get current terminal attributes; 0 is the file descriptor for stdin\n\t\tmemcpy(&tlocal, &twait, sizeof(tlocal));\n\t\ttwait.c_lflag &= ~ICANON;      // disable canonical mode\n\t\ttwait.c_lflag &= ~ECHO;\t// no echo\n\t\ttwait.c_cc[VMIN] = 1;          // wait until at least one keystroke available\n\t\ttwait.c_cc[VTIME] = 0;         // no timeout\n\t\tterminal_set = 1;\n\t}\n\ttcsetattr(0, TCSANOW, &twait);\n\n\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(0,&fds);\n\tint maxfd = 1;\n\n\tstruct timeval ts;\n\tts.tv_sec = st;\n\tts.tv_usec = 0;\n\n\tint ready = select(maxfd, &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t(void) ready;\n\tif( FD_ISSET(0, &fds)) {\n\t\tgetchar();\n\t\ttcsetattr(0, TCSANOW, &tlocal);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\ttcsetattr(0, TCSANOW, &tlocal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Waiting on PID %d to finish\\n\"",
            "monitored_pid"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&c",
            "1",
            "1",
            "fp"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "monfile",
            "\"r\""
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&monfile",
            "\"/proc/%d/cmdline\"",
            "monitored_pid"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "-1",
            "SIGTERM"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmessage",
          "args": [
            "\"\\nChild received signal %d, shutting down the sandbox...\\n\"",
            "sig"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "fmessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "189-198",
          "snippet": "void fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10000"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int monitored_pid = 0;\n\nstatic void sandbox_handler(int sig){\n\tusleep(10000); // don't race to print a message\n\tfmessage(\"\\nChild received signal %d, shutting down the sandbox...\\n\", sig);\n\n\t// broadcast sigterm to all processes in the group\n\tkill(-1, SIGTERM);\n\tsleep(1);\n\n\tif (monitored_pid) {\n\t\tint monsec = 9;\n\t\tchar *monfile;\n\t\tif (asprintf(&monfile, \"/proc/%d/cmdline\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\twhile (monsec) {\n\t\t\tFILE *fp = fopen(monfile, \"r\");\n\t\t\tif (!fp)\n\t\t\t\tbreak;\n\n\t\t\tchar c;\n\t\t\tsize_t count = fread(&c, 1, 1, fp);\n\t\t\tfclose(fp);\n\t\t\tif (count == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Waiting on PID %d to finish\\n\", monitored_pid);\n\t\t\tsleep(1);\n\t\t\tmonsec--;\n\t\t}\n\t\tfree(monfile);\n\t}\n\n\t// broadcast a SIGKILL\n\tkill(-1, SIGKILL);\n\tflush_stdin();\n\n\texit(sig);\n}"
  }
]