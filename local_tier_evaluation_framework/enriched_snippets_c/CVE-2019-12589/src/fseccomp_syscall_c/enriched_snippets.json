[
  {
    "function_name": "syscalls_in_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
    "lines": "571-591",
    "snippet": "void syscalls_in_list(const char *list, const char *slist, int fd, char **prelist, char **postlist) {\n\t(void) fd;\n\tSyscallCheckList sl;\n\t// these syscalls are used by firejail after the seccomp filter is initialized\n\tsl.slist = slist;\n\tsl.prelist = NULL;\n\tsl.postlist = NULL;\n\tsyscall_check_list(list, syscall_in_list, 0, 0, &sl);\n\tif (!arg_quiet) {\n\t\tprintf(\"Seccomp list in: %s,\", list);\n\t\tif (sl.slist)\n\t\t\tprintf(\" check list: %s,\", sl.slist);\n\t\tif (sl.prelist)\n\t\t\tprintf(\" prelist: %s,\", sl.prelist);\n\t\tif (sl.postlist)\n\t\t\tprintf(\" postlist: %s\", sl.postlist);\n\t\tprintf(\"\\n\");\n\t}\n\t*prelist = sl.prelist;\n\t*postlist = sl.postlist;\n}",
    "includes": [
      "#include <sys/syscall.h>",
      "#include <stdio.h>",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" postlist: %s\"",
            "sl.postlist"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" prelist: %s,\"",
            "sl.prelist"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" check list: %s,\"",
            "sl.slist"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Seccomp list in: %s,\"",
            "list"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_check_list",
          "args": [
            "list",
            "syscall_in_list",
            "0",
            "0",
            "&sl"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_check_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "469-519",
          "snippet": "int syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nint syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nvoid syscalls_in_list(const char *list, const char *slist, int fd, char **prelist, char **postlist) {\n\t(void) fd;\n\tSyscallCheckList sl;\n\t// these syscalls are used by firejail after the seccomp filter is initialized\n\tsl.slist = slist;\n\tsl.prelist = NULL;\n\tsl.postlist = NULL;\n\tsyscall_check_list(list, syscall_in_list, 0, 0, &sl);\n\tif (!arg_quiet) {\n\t\tprintf(\"Seccomp list in: %s,\", list);\n\t\tif (sl.slist)\n\t\t\tprintf(\" check list: %s,\", sl.slist);\n\t\tif (sl.prelist)\n\t\t\tprintf(\" prelist: %s,\", sl.prelist);\n\t\tif (sl.postlist)\n\t\t\tprintf(\" postlist: %s\", sl.postlist);\n\t\tprintf(\"\\n\");\n\t}\n\t*prelist = sl.prelist;\n\t*postlist = sl.postlist;\n}"
  },
  {
    "function_name": "syscall_in_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
    "lines": "530-568",
    "snippet": "static void syscall_in_list(int fd, int syscall, int arg, void *ptrarg) {\n\t(void) fd;\n\t(void)arg;\n\tSyscallCheckList *ptr = ptrarg;\n\tSyscallCheckList sl;\n\tsl.found = false;\n\tsl.syscall = syscall;\n\tsyscall_check_list(ptr->slist, find_syscall, fd, 0, &sl);\n\t// if found in the problem list, add to post-exec list\n\tif (sl.found) {\n\t\tif (ptr->postlist) {\n\t\t\tif (asprintf(&ptr->postlist, \"%s,%s\", ptr->postlist, syscall_find_nr(syscall)) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\telse\n\t\t\tptr->postlist = strdup(syscall_find_nr(syscall));\n\t}\n\telse { // no problem, add to pre-exec list\n\t\t// build syscall:error_no\n\t\tchar *newcall = NULL;\n\t\tif (arg != 0) {\n\t\t\tif (asprintf(&newcall, \"%s:%s\", syscall_find_nr(syscall), errno_find_nr(arg)) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\telse {\n\t\t\tnewcall = strdup(syscall_find_nr(syscall));\n\t\t\tif (!newcall)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\n\t\tif (ptr->prelist) {\n\t\t\tif (asprintf(&ptr->prelist, \"%s,%s\", ptr->prelist, newcall) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tfree(newcall);\n\t\t}\n\t\telse\n\t\t\tptr->prelist = newcall;\n\t}\n}",
    "includes": [
      "#include <sys/syscall.h>",
      "#include <stdio.h>",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newcall"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&ptr->prelist",
            "\"%s,%s\"",
            "ptr->prelist",
            "newcall"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "syscall_find_nr(syscall)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_find_nr",
          "args": [
            "syscall"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_find_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "394-403",
          "snippet": "const char *syscall_find_nr(int nr) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (nr == syslist[i].nr)\n\t\t\treturn syslist[i].name;\n\t}\n\n\treturn \"unknown\";\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};\n\nconst char *syscall_find_nr(int nr) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (nr == syslist[i].nr)\n\t\t\treturn syslist[i].name;\n\t}\n\n\treturn \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&newcall",
            "\"%s:%s\"",
            "syscall_find_nr(syscall)",
            "errno_find_nr(arg)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errno_find_nr",
          "args": [
            "arg"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "errno_find_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/errno.c",
          "lines": "184-193",
          "snippet": "char *errno_find_nr(int nr) {\n\tint i;\n\tint elems = sizeof(errnolist) / sizeof(errnolist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (nr == errnolist[i].nr)\n\t\t\treturn errnolist[i].name;\n\t}\n\n\treturn \"unknown\";\n}",
          "includes": [
            "#include <errno.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrnoEntry errnolist[] = {\n//\n// code generated using tools/extract-errnos\n//\n\t{\"EPERM\", EPERM},\n\t{\"ENOENT\", ENOENT},\n\t{\"ESRCH\", ESRCH},\n\t{\"EINTR\", EINTR},\n\t{\"EIO\", EIO},\n\t{\"ENXIO\", ENXIO},\n\t{\"E2BIG\", E2BIG},\n\t{\"ENOEXEC\", ENOEXEC},\n\t{\"EBADF\", EBADF},\n\t{\"ECHILD\", ECHILD},\n\t{\"EAGAIN\", EAGAIN},\n\t{\"ENOMEM\", ENOMEM},\n\t{\"EACCES\", EACCES},\n\t{\"EFAULT\", EFAULT},\n\t{\"ENOTBLK\", ENOTBLK},\n\t{\"EBUSY\", EBUSY},\n\t{\"EEXIST\", EEXIST},\n\t{\"EXDEV\", EXDEV},\n\t{\"ENODEV\", ENODEV},\n\t{\"ENOTDIR\", ENOTDIR},\n\t{\"EISDIR\", EISDIR},\n\t{\"EINVAL\", EINVAL},\n\t{\"ENFILE\", ENFILE},\n\t{\"EMFILE\", EMFILE},\n\t{\"ENOTTY\", ENOTTY},\n\t{\"ETXTBSY\", ETXTBSY},\n\t{\"EFBIG\", EFBIG},\n\t{\"ENOSPC\", ENOSPC},\n\t{\"ESPIPE\", ESPIPE},\n\t{\"EROFS\", EROFS},\n\t{\"EMLINK\", EMLINK},\n\t{\"EPIPE\", EPIPE},\n\t{\"EDOM\", EDOM},\n\t{\"ERANGE\", ERANGE},\n\t{\"EDEADLK\", EDEADLK},\n\t{\"ENAMETOOLONG\", ENAMETOOLONG},\n\t{\"ENOLCK\", ENOLCK},\n\t{\"ENOSYS\", ENOSYS},\n\t{\"ENOTEMPTY\", ENOTEMPTY},\n\t{\"ELOOP\", ELOOP},\n\t{\"EWOULDBLOCK\", EWOULDBLOCK},\n\t{\"ENOMSG\", ENOMSG},\n\t{\"EIDRM\", EIDRM},\n\t{\"ECHRNG\", ECHRNG},\n\t{\"EL2NSYNC\", EL2NSYNC},\n\t{\"EL3HLT\", EL3HLT},\n\t{\"EL3RST\", EL3RST},\n\t{\"ELNRNG\", ELNRNG},\n\t{\"EUNATCH\", EUNATCH},\n\t{\"ENOCSI\", ENOCSI},\n\t{\"EL2HLT\", EL2HLT},\n\t{\"EBADE\", EBADE},\n\t{\"EBADR\", EBADR},\n\t{\"EXFULL\", EXFULL},\n\t{\"ENOANO\", ENOANO},\n\t{\"EBADRQC\", EBADRQC},\n\t{\"EBADSLT\", EBADSLT},\n\t{\"EDEADLOCK\", EDEADLOCK},\n\t{\"EBFONT\", EBFONT},\n\t{\"ENOSTR\", ENOSTR},\n\t{\"ENODATA\", ENODATA},\n\t{\"ETIME\", ETIME},\n\t{\"ENOSR\", ENOSR},\n\t{\"ENONET\", ENONET},\n\t{\"ENOPKG\", ENOPKG},\n\t{\"EREMOTE\", EREMOTE},\n\t{\"ENOLINK\", ENOLINK},\n\t{\"EADV\", EADV},\n\t{\"ESRMNT\", ESRMNT},\n\t{\"ECOMM\", ECOMM},\n\t{\"EPROTO\", EPROTO},\n\t{\"EMULTIHOP\", EMULTIHOP},\n\t{\"EDOTDOT\", EDOTDOT},\n\t{\"EBADMSG\", EBADMSG},\n\t{\"EOVERFLOW\", EOVERFLOW},\n\t{\"ENOTUNIQ\", ENOTUNIQ},\n\t{\"EBADFD\", EBADFD},\n\t{\"EREMCHG\", EREMCHG},\n\t{\"ELIBACC\", ELIBACC},\n\t{\"ELIBBAD\", ELIBBAD},\n\t{\"ELIBSCN\", ELIBSCN},\n\t{\"ELIBMAX\", ELIBMAX},\n\t{\"ELIBEXEC\", ELIBEXEC},\n\t{\"EILSEQ\", EILSEQ},\n\t{\"ERESTART\", ERESTART},\n\t{\"ESTRPIPE\", ESTRPIPE},\n\t{\"EUSERS\", EUSERS},\n\t{\"ENOTSOCK\", ENOTSOCK},\n\t{\"EDESTADDRREQ\", EDESTADDRREQ},\n\t{\"EMSGSIZE\", EMSGSIZE},\n\t{\"EPROTOTYPE\", EPROTOTYPE},\n\t{\"ENOPROTOOPT\", ENOPROTOOPT},\n\t{\"EPROTONOSUPPORT\", EPROTONOSUPPORT},\n\t{\"ESOCKTNOSUPPORT\", ESOCKTNOSUPPORT},\n\t{\"EOPNOTSUPP\", EOPNOTSUPP},\n\t{\"EPFNOSUPPORT\", EPFNOSUPPORT},\n\t{\"EAFNOSUPPORT\", EAFNOSUPPORT},\n\t{\"EADDRINUSE\", EADDRINUSE},\n\t{\"EADDRNOTAVAIL\", EADDRNOTAVAIL},\n\t{\"ENETDOWN\", ENETDOWN},\n\t{\"ENETUNREACH\", ENETUNREACH},\n\t{\"ENETRESET\", ENETRESET},\n\t{\"ECONNABORTED\", ECONNABORTED},\n\t{\"ECONNRESET\", ECONNRESET},\n\t{\"ENOBUFS\", ENOBUFS},\n\t{\"EISCONN\", EISCONN},\n\t{\"ENOTCONN\", ENOTCONN},\n\t{\"ESHUTDOWN\", ESHUTDOWN},\n\t{\"ETOOMANYREFS\", ETOOMANYREFS},\n\t{\"ETIMEDOUT\", ETIMEDOUT},\n\t{\"ECONNREFUSED\", ECONNREFUSED},\n\t{\"EHOSTDOWN\", EHOSTDOWN},\n\t{\"EHOSTUNREACH\", EHOSTUNREACH},\n\t{\"EALREADY\", EALREADY},\n\t{\"EINPROGRESS\", EINPROGRESS},\n\t{\"ESTALE\", ESTALE},\n\t{\"EUCLEAN\", EUCLEAN},\n\t{\"ENOTNAM\", ENOTNAM},\n\t{\"ENAVAIL\", ENAVAIL},\n\t{\"EISNAM\", EISNAM},\n\t{\"EREMOTEIO\", EREMOTEIO},\n\t{\"EDQUOT\", EDQUOT},\n\t{\"ENOMEDIUM\", ENOMEDIUM},\n\t{\"EMEDIUMTYPE\", EMEDIUMTYPE},\n\t{\"ECANCELED\", ECANCELED},\n\t{\"ENOKEY\", ENOKEY},\n\t{\"EKEYEXPIRED\", EKEYEXPIRED},\n\t{\"EKEYREVOKED\", EKEYREVOKED},\n\t{\"EKEYREJECTED\", EKEYREJECTED},\n\t{\"EOWNERDEAD\", EOWNERDEAD},\n\t{\"ENOTRECOVERABLE\", ENOTRECOVERABLE},\n\t{\"ERFKILL\", ERFKILL},\n\t{\"EHWPOISON\", EHWPOISON},\n\t{\"ENOTSUP\", ENOTSUP},\n#ifdef \tENOATTR\n\t{\"ENOATTR\", ENOATTR},\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include \"fseccomp.h\"\n\nstatic ErrnoEntry errnolist[] = {\n//\n// code generated using tools/extract-errnos\n//\n\t{\"EPERM\", EPERM},\n\t{\"ENOENT\", ENOENT},\n\t{\"ESRCH\", ESRCH},\n\t{\"EINTR\", EINTR},\n\t{\"EIO\", EIO},\n\t{\"ENXIO\", ENXIO},\n\t{\"E2BIG\", E2BIG},\n\t{\"ENOEXEC\", ENOEXEC},\n\t{\"EBADF\", EBADF},\n\t{\"ECHILD\", ECHILD},\n\t{\"EAGAIN\", EAGAIN},\n\t{\"ENOMEM\", ENOMEM},\n\t{\"EACCES\", EACCES},\n\t{\"EFAULT\", EFAULT},\n\t{\"ENOTBLK\", ENOTBLK},\n\t{\"EBUSY\", EBUSY},\n\t{\"EEXIST\", EEXIST},\n\t{\"EXDEV\", EXDEV},\n\t{\"ENODEV\", ENODEV},\n\t{\"ENOTDIR\", ENOTDIR},\n\t{\"EISDIR\", EISDIR},\n\t{\"EINVAL\", EINVAL},\n\t{\"ENFILE\", ENFILE},\n\t{\"EMFILE\", EMFILE},\n\t{\"ENOTTY\", ENOTTY},\n\t{\"ETXTBSY\", ETXTBSY},\n\t{\"EFBIG\", EFBIG},\n\t{\"ENOSPC\", ENOSPC},\n\t{\"ESPIPE\", ESPIPE},\n\t{\"EROFS\", EROFS},\n\t{\"EMLINK\", EMLINK},\n\t{\"EPIPE\", EPIPE},\n\t{\"EDOM\", EDOM},\n\t{\"ERANGE\", ERANGE},\n\t{\"EDEADLK\", EDEADLK},\n\t{\"ENAMETOOLONG\", ENAMETOOLONG},\n\t{\"ENOLCK\", ENOLCK},\n\t{\"ENOSYS\", ENOSYS},\n\t{\"ENOTEMPTY\", ENOTEMPTY},\n\t{\"ELOOP\", ELOOP},\n\t{\"EWOULDBLOCK\", EWOULDBLOCK},\n\t{\"ENOMSG\", ENOMSG},\n\t{\"EIDRM\", EIDRM},\n\t{\"ECHRNG\", ECHRNG},\n\t{\"EL2NSYNC\", EL2NSYNC},\n\t{\"EL3HLT\", EL3HLT},\n\t{\"EL3RST\", EL3RST},\n\t{\"ELNRNG\", ELNRNG},\n\t{\"EUNATCH\", EUNATCH},\n\t{\"ENOCSI\", ENOCSI},\n\t{\"EL2HLT\", EL2HLT},\n\t{\"EBADE\", EBADE},\n\t{\"EBADR\", EBADR},\n\t{\"EXFULL\", EXFULL},\n\t{\"ENOANO\", ENOANO},\n\t{\"EBADRQC\", EBADRQC},\n\t{\"EBADSLT\", EBADSLT},\n\t{\"EDEADLOCK\", EDEADLOCK},\n\t{\"EBFONT\", EBFONT},\n\t{\"ENOSTR\", ENOSTR},\n\t{\"ENODATA\", ENODATA},\n\t{\"ETIME\", ETIME},\n\t{\"ENOSR\", ENOSR},\n\t{\"ENONET\", ENONET},\n\t{\"ENOPKG\", ENOPKG},\n\t{\"EREMOTE\", EREMOTE},\n\t{\"ENOLINK\", ENOLINK},\n\t{\"EADV\", EADV},\n\t{\"ESRMNT\", ESRMNT},\n\t{\"ECOMM\", ECOMM},\n\t{\"EPROTO\", EPROTO},\n\t{\"EMULTIHOP\", EMULTIHOP},\n\t{\"EDOTDOT\", EDOTDOT},\n\t{\"EBADMSG\", EBADMSG},\n\t{\"EOVERFLOW\", EOVERFLOW},\n\t{\"ENOTUNIQ\", ENOTUNIQ},\n\t{\"EBADFD\", EBADFD},\n\t{\"EREMCHG\", EREMCHG},\n\t{\"ELIBACC\", ELIBACC},\n\t{\"ELIBBAD\", ELIBBAD},\n\t{\"ELIBSCN\", ELIBSCN},\n\t{\"ELIBMAX\", ELIBMAX},\n\t{\"ELIBEXEC\", ELIBEXEC},\n\t{\"EILSEQ\", EILSEQ},\n\t{\"ERESTART\", ERESTART},\n\t{\"ESTRPIPE\", ESTRPIPE},\n\t{\"EUSERS\", EUSERS},\n\t{\"ENOTSOCK\", ENOTSOCK},\n\t{\"EDESTADDRREQ\", EDESTADDRREQ},\n\t{\"EMSGSIZE\", EMSGSIZE},\n\t{\"EPROTOTYPE\", EPROTOTYPE},\n\t{\"ENOPROTOOPT\", ENOPROTOOPT},\n\t{\"EPROTONOSUPPORT\", EPROTONOSUPPORT},\n\t{\"ESOCKTNOSUPPORT\", ESOCKTNOSUPPORT},\n\t{\"EOPNOTSUPP\", EOPNOTSUPP},\n\t{\"EPFNOSUPPORT\", EPFNOSUPPORT},\n\t{\"EAFNOSUPPORT\", EAFNOSUPPORT},\n\t{\"EADDRINUSE\", EADDRINUSE},\n\t{\"EADDRNOTAVAIL\", EADDRNOTAVAIL},\n\t{\"ENETDOWN\", ENETDOWN},\n\t{\"ENETUNREACH\", ENETUNREACH},\n\t{\"ENETRESET\", ENETRESET},\n\t{\"ECONNABORTED\", ECONNABORTED},\n\t{\"ECONNRESET\", ECONNRESET},\n\t{\"ENOBUFS\", ENOBUFS},\n\t{\"EISCONN\", EISCONN},\n\t{\"ENOTCONN\", ENOTCONN},\n\t{\"ESHUTDOWN\", ESHUTDOWN},\n\t{\"ETOOMANYREFS\", ETOOMANYREFS},\n\t{\"ETIMEDOUT\", ETIMEDOUT},\n\t{\"ECONNREFUSED\", ECONNREFUSED},\n\t{\"EHOSTDOWN\", EHOSTDOWN},\n\t{\"EHOSTUNREACH\", EHOSTUNREACH},\n\t{\"EALREADY\", EALREADY},\n\t{\"EINPROGRESS\", EINPROGRESS},\n\t{\"ESTALE\", ESTALE},\n\t{\"EUCLEAN\", EUCLEAN},\n\t{\"ENOTNAM\", ENOTNAM},\n\t{\"ENAVAIL\", ENAVAIL},\n\t{\"EISNAM\", EISNAM},\n\t{\"EREMOTEIO\", EREMOTEIO},\n\t{\"EDQUOT\", EDQUOT},\n\t{\"ENOMEDIUM\", ENOMEDIUM},\n\t{\"EMEDIUMTYPE\", EMEDIUMTYPE},\n\t{\"ECANCELED\", ECANCELED},\n\t{\"ENOKEY\", ENOKEY},\n\t{\"EKEYEXPIRED\", EKEYEXPIRED},\n\t{\"EKEYREVOKED\", EKEYREVOKED},\n\t{\"EKEYREJECTED\", EKEYREJECTED},\n\t{\"EOWNERDEAD\", EOWNERDEAD},\n\t{\"ENOTRECOVERABLE\", ENOTRECOVERABLE},\n\t{\"ERFKILL\", ERFKILL},\n\t{\"EHWPOISON\", EHWPOISON},\n\t{\"ENOTSUP\", ENOTSUP},\n#ifdef \tENOATTR\n\t{\"ENOATTR\", ENOATTR},\n#endif\n};\n\nchar *errno_find_nr(int nr) {\n\tint i;\n\tint elems = sizeof(errnolist) / sizeof(errnolist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (nr == errnolist[i].nr)\n\t\t\treturn errnolist[i].name;\n\t}\n\n\treturn \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "syscall_find_nr(syscall)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&ptr->postlist",
            "\"%s,%s\"",
            "ptr->postlist",
            "syscall_find_nr(syscall)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_check_list",
          "args": [
            "ptr->slist",
            "find_syscall",
            "fd",
            "0",
            "&sl"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_check_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "469-519",
          "snippet": "int syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nint syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic void syscall_in_list(int fd, int syscall, int arg, void *ptrarg) {\n\t(void) fd;\n\t(void)arg;\n\tSyscallCheckList *ptr = ptrarg;\n\tSyscallCheckList sl;\n\tsl.found = false;\n\tsl.syscall = syscall;\n\tsyscall_check_list(ptr->slist, find_syscall, fd, 0, &sl);\n\t// if found in the problem list, add to post-exec list\n\tif (sl.found) {\n\t\tif (ptr->postlist) {\n\t\t\tif (asprintf(&ptr->postlist, \"%s,%s\", ptr->postlist, syscall_find_nr(syscall)) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\telse\n\t\t\tptr->postlist = strdup(syscall_find_nr(syscall));\n\t}\n\telse { // no problem, add to pre-exec list\n\t\t// build syscall:error_no\n\t\tchar *newcall = NULL;\n\t\tif (arg != 0) {\n\t\t\tif (asprintf(&newcall, \"%s:%s\", syscall_find_nr(syscall), errno_find_nr(arg)) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\telse {\n\t\t\tnewcall = strdup(syscall_find_nr(syscall));\n\t\t\tif (!newcall)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\n\t\tif (ptr->prelist) {\n\t\t\tif (asprintf(&ptr->prelist, \"%s,%s\", ptr->prelist, newcall) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tfree(newcall);\n\t\t}\n\t\telse\n\t\t\tptr->prelist = newcall;\n\t}\n}"
  },
  {
    "function_name": "find_syscall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
    "lines": "521-527",
    "snippet": "static void find_syscall(int fd, int syscall, int arg, void *ptrarg) {\n\t(void)fd;\n\t(void) arg;\n\tSyscallCheckList *ptr = ptrarg;\n\tif (syscall == ptr->syscall)\n\t\tptr->found = true;\n}",
    "includes": [
      "#include <sys/syscall.h>",
      "#include <stdio.h>",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic void find_syscall(int fd, int syscall, int arg, void *ptrarg) {\n\t(void)fd;\n\t(void) arg;\n\tSyscallCheckList *ptr = ptrarg;\n\tif (syscall == ptr->syscall)\n\t\tptr->found = true;\n}"
  },
  {
    "function_name": "syscall_check_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
    "lines": "469-519",
    "snippet": "int syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}",
    "includes": [
      "#include <sys/syscall.h>",
      "#include <stdio.h>",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\",\"",
            "&saveptr"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "fd",
            "syscall_nr",
            "arg",
            "ptrarg"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "remove_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "881-897",
          "snippet": "static int remove_callback(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf) {\n\t(void) sb;\n\t(void) typeflag;\n\t(void) ftwbuf;\n\tassert(fpath);\n\n\tif (strcmp(fpath, \".\") == 0)\n\t\treturn 0;\n\n\tif (remove(fpath)) {\t// removes the link not the actual file\n\t\tperror(\"remove\");\n\t\tfprintf(stderr, \"Error: cannot remove file from user .firejail directory: %s\\n\", fpath);\n\t\texit(1);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nstatic int remove_callback(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf) {\n\t(void) sb;\n\t(void) typeflag;\n\t(void) ftwbuf;\n\tassert(fpath);\n\n\tif (strcmp(fpath, \".\") == 0)\n\t\treturn 0;\n\n\tif (remove(fpath)) {\t// removes the link not the actual file\n\t\tperror(\"remove\");\n\t\tfprintf(stderr, \"Error: cannot remove file from user .firejail directory: %s\\n\", fpath);\n\t\texit(1);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_add_errno",
          "args": [
            "fd",
            "syscall_nr",
            "error_nr",
            "ptrarg"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "filter_add_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/seccomp_file.c",
          "lines": "83-89",
          "snippet": "void filter_add_errno(int fd, int syscall, int arg, void *ptrarg) {\n\t(void) ptrarg;\n\tstruct sock_filter filter[] = {\n\t\tBLACKLIST_ERRNO(syscall, arg)\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include \"../include/seccomp.h\"",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include \"../include/seccomp.h\"\n#include \"fseccomp.h\"\n\nvoid filter_add_errno(int fd, int syscall, int arg, void *ptrarg) {\n\t(void) ptrarg;\n\tstruct sock_filter filter[] = {\n\t\tBLACKLIST_ERRNO(syscall, arg)\n\t};\n\twrite_to_file(fd, filter, sizeof(filter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_process_name",
          "args": [
            "ptr",
            "&syscall_nr",
            "&error_nr"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_process_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "428-466",
          "snippet": "static void syscall_process_name(const char *name, int *syscall_nr, int *error_nr) {\n\tassert(name);\n\tif (strlen(name) == 0)\n\t\tgoto error;\n\t*error_nr = -1;\n\n\t// syntax check\n\tchar *str = strdup(name);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *syscall_name = str;\n\tchar *error_name = strchr(str, ':');\n\tif (error_name) {\n\t\t*error_name = '\\0';\n\t\terror_name++;\n\t}\n\tif (strlen(syscall_name) == 0) {\n\t\tfree(str);\n\t\tgoto error;\n\t}\n\n\tif (*syscall_name == '$')\n\t\t*syscall_nr = strtol(syscall_name + 1, NULL, 0);\n\telse\n\t\t*syscall_nr = syscall_find_name(syscall_name);\n\tif (error_name) {\n\t\t*error_nr = errno_find_name(error_name);\n\t\tif (*error_nr == -1)\n\t\t\t*syscall_nr = -1;\n\t}\n\n\tfree(str);\n\treturn;\n\nerror:\n\tfprintf(stderr, \"Error fseccomp: invalid syscall list entry %s\\n\", name);\n\texit(1);\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic void syscall_process_name(const char *name, int *syscall_nr, int *error_nr) {\n\tassert(name);\n\tif (strlen(name) == 0)\n\t\tgoto error;\n\t*error_nr = -1;\n\n\t// syntax check\n\tchar *str = strdup(name);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *syscall_name = str;\n\tchar *error_name = strchr(str, ':');\n\tif (error_name) {\n\t\t*error_name = '\\0';\n\t\terror_name++;\n\t}\n\tif (strlen(syscall_name) == 0) {\n\t\tfree(str);\n\t\tgoto error;\n\t}\n\n\tif (*syscall_name == '$')\n\t\t*syscall_nr = strtol(syscall_name + 1, NULL, 0);\n\telse\n\t\t*syscall_nr = syscall_find_name(syscall_name);\n\tif (error_name) {\n\t\t*error_nr = errno_find_name(error_name);\n\t\tif (*error_nr == -1)\n\t\t\t*syscall_nr = -1;\n\t}\n\n\tfree(str);\n\treturn;\n\nerror:\n\tfprintf(stderr, \"Error fseccomp: invalid syscall list entry %s\\n\", name);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_check_list",
          "args": [
            "new_list",
            "callback",
            "fd",
            "arg",
            "ptrarg"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_check_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "469-519",
          "snippet": "int syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: unknown syscall group %s\\n\"",
            "ptr"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_find_group",
          "args": [
            "ptr"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_find_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "414-423",
          "snippet": "static const char *syscall_find_group(const char *name) {\n\tint i;\n\tint elems = sizeof(sysgroups) / sizeof(sysgroups[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (strcmp(name, sysgroups[i].name) == 0)\n\t\t\treturn sysgroups[i].list;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const SyscallGroupList sysgroups[] = {\n\t{ .name = \"@clock\", .list =\n#ifdef SYS_adjtimex\n\t  \"adjtimex,\"\n#endif\n#ifdef SYS_clock_adjtime\n\t  \"clock_adjtime,\"\n#endif\n#ifdef SYS_clock_settime\n\t  \"clock_settime,\"\n#endif\n#ifdef SYS_settimeofday\n\t  \"settimeofday,\"\n#endif\n#ifdef SYS_stime\n\t  \"stime\"\n#endif\n\t},\n\t{ .name = \"@cpu-emulation\", .list =\n#ifdef SYS_modify_ldt\n\t  \"modify_ldt,\"\n#endif\n#ifdef SYS_subpage_prot\n\t  \"subpage_prot,\"\n#endif\n#ifdef SYS_switch_endian\n\t  \"switch_endian,\"\n#endif\n#ifdef SYS_vm86\n\t  \"vm86,\"\n#endif\n#ifdef SYS_vm86old\n\t  \"vm86old\"\n#endif\n#if !defined(SYS_modify_ldt) && !defined(SYS_subpage_prot) && !defined(SYS_switch_endian) && !defined(SYS_vm86) && !defined(SYS_vm86old)\n\t  \"__dummy_syscall__\" // workaround for arm64, s390x and sparc64 which don't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@debug\", .list =\n#ifdef SYS_lookup_dcookie\n\t  \"lookup_dcookie,\"\n#endif\n#ifdef SYS_perf_event_open\n\t  \"perf_event_open,\"\n#endif\n#ifdef SYS_process_vm_writev\n\t  \"process_vm_writev,\"\n#endif\n#ifdef SYS_rtas\n\t  \"rtas,\"\n#endif\n#ifdef SYS_s390_runtime_instr\n\t  \"s390_runtime_instr,\"\n#endif\n#ifdef SYS_sys_debug_setcontext\n\t  \"sys_debug_setcontext,\"\n#endif\n\t},\n\t{ .name = \"@default\", .list =\n\t  \"@cpu-emulation,\"\n\t  \"@debug,\"\n\t  \"@obsolete,\"\n\t  \"@privileged,\"\n\t  \"@resources,\"\n#ifdef SYS_open_by_handle_at\n\t  \"open_by_handle_at,\"\n#endif\n#ifdef SYS_name_to_handle_at\n\t  \"name_to_handle_at,\"\n#endif\n#ifdef SYS_ioprio_set\n\t  \"ioprio_set,\"\n#endif\n#ifdef SYS_ni_syscall\n\t  \"ni_syscall,\"\n#endif\n#ifdef SYS_syslog\n\t  \"syslog,\"\n#endif\n#ifdef SYS_fanotify_init\n\t  \"fanotify_init,\"\n#endif\n#ifdef SYS_kcmp\n\t  \"kcmp,\"\n#endif\n#ifdef SYS_add_key\n\t  \"add_key,\"\n#endif\n#ifdef SYS_request_key\n\t  \"request_key,\"\n#endif\n#ifdef SYS_keyctl\n\t  \"keyctl,\"\n#endif\n#ifdef SYS_io_setup\n\t  \"io_setup,\"\n#endif\n#ifdef SYS_io_destroy\n\t  \"io_destroy,\"\n#endif\n#ifdef SYS_io_getevents\n\t  \"io_getevents,\"\n#endif\n#ifdef SYS_io_submit\n\t  \"io_submit,\"\n#endif\n#ifdef SYS_io_cancel\n\t  \"io_cancel,\"\n#endif\n#ifdef SYS_remap_file_pages\n\t  \"remap_file_pages,\"\n#endif\n#ifdef SYS_vmsplice\n\t  \"vmsplice,\"\n#endif\n#ifdef SYS_umount\n\t  \"umount,\"\n#endif\n#ifdef SYS_userfaultfd\n\t  \"userfaultfd,\"\n#endif\n//#ifdef SYS_mincore\t// 0.9.57 - problem fixed in Linux kernel 5.0; on 4.x it will break kodi, mpv, totem\n//\t  \"mincore\"\n//#endif\n\t},\n\t{ .name = \"@default-nodebuggers\", .list =\n\t  \"@default,\"\n#ifdef SYS_ptrace\n\t  \"ptrace,\"\n#endif\n#ifdef SYS_personality\n\t  \"personality,\"\n#endif\n#ifdef SYS_process_vm_readv\n\t  \"process_vm_readv\"\n#endif\n\t},\n\t{ .name = \"@default-keep\", .list =\n\t  \"execve,\"\n\t  \"prctl\"\n\t},\n\t{ .name = \"@module\", .list =\n#ifdef SYS_delete_module\n\t  \"delete_module,\"\n#endif\n#ifdef SYS_finit_module\n\t  \"finit_module,\"\n#endif\n#ifdef SYS_init_module\n\t  \"init_module\"\n#endif\n\t},\n\t{ .name = \"@obsolete\", .list =\n#ifdef SYS__sysctl\n\t  \"_sysctl,\"\n#endif\n#ifdef SYS_afs_syscall\n\t  \"afs_syscall,\"\n#endif\n#ifdef SYS_bdflush\n\t  \"bdflush,\"\n#endif\n#ifdef SYS_break\n\t  \"break,\"\n#endif\n#ifdef SYS_create_module\n\t  \"create_module,\"\n#endif\n#ifdef SYS_ftime\n\t  \"ftime,\"\n#endif\n#ifdef SYS_get_kernel_syms\n\t  \"get_kernel_syms,\"\n#endif\n#ifdef SYS_getpmsg\n\t  \"getpmsg,\"\n#endif\n#ifdef SYS_gtty\n\t  \"gtty,\"\n#endif\n#ifdef SYS_lock\n\t  \"lock,\"\n#endif\n#ifdef SYS_mpx\n\t  \"mpx,\"\n#endif\n#ifdef SYS_prof\n\t  \"prof,\"\n#endif\n#ifdef SYS_profil\n\t  \"profil,\"\n#endif\n#ifdef SYS_putpmsg\n\t  \"putpmsg,\"\n#endif\n#ifdef SYS_query_module\n\t  \"query_module,\"\n#endif\n#ifdef SYS_security\n\t  \"security,\"\n#endif\n#ifdef SYS_sgetmask\n\t  \"sgetmask,\"\n#endif\n#ifdef SYS_ssetmask\n\t  \"ssetmask,\"\n#endif\n#ifdef SYS_stty\n\t  \"stty,\"\n#endif\n#ifdef SYS_sysfs\n\t  \"sysfs,\"\n#endif\n#ifdef SYS_tuxcall\n\t  \"tuxcall,\"\n#endif\n#ifdef SYS_ulimit\n\t  \"ulimit,\"\n#endif\n#ifdef SYS_uselib\n\t  \"uselib,\"\n#endif\n#ifdef SYS_ustat\n\t  \"ustat,\"\n#endif\n#ifdef SYS_vserver\n\t  \"vserver\"\n#endif\n#if !defined(SYS__sysctl) && !defined(SYS_afs_syscall) && !defined(SYS_bdflush) && !defined(SYS_break) && !defined(SYS_create_module) && !defined(SYS_ftime) && !defined(SYS_get_kernel_syms) && !defined(SYS_getpmsg) && !defined(SYS_gtty) && !defined(SYS_lock) && !defined(SYS_mpx) && !defined(SYS_prof) && !defined(SYS_profil) && !defined(SYS_putpmsg) && !defined(SYS_query_module) && !defined(SYS_security) && !defined(SYS_sgetmask) && !defined(SYS_ssetmask) && !defined(SYS_stty) && !defined(SYS_sysfs) && !defined(SYS_tuxcall) && !defined(SYS_ulimit) && !defined(SYS_uselib) && !defined(SYS_ustat) && !defined(SYS_vserver)\n\t  \"__dummy_syscall__\" // workaround for arm64 which doesn't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@privileged\", .list =\n\t  \"@clock,\"\n\t  \"@module,\"\n\t  \"@raw-io,\"\n\t  \"@reboot,\"\n\t  \"@swap,\"\n#ifdef SYS_acct\n\t  \"acct,\"\n#endif\n#ifdef SYS_bpf\n\t  \"bpf,\"\n#endif\n#ifdef SYS_chroot\n\t  \"chroot,\"\n#endif\n#ifdef SYS_mount\n\t  \"mount,\"\n#endif\n#ifdef SYS_nfsservctl\n\t  \"nfsservctl,\"\n#endif\n#ifdef SYS_pivot_root\n\t  \"pivot_root,\"\n#endif\n#ifdef SYS_setdomainname\n\t  \"setdomainname,\"\n#endif\n#ifdef SYS_sethostname\n\t  \"sethostname,\"\n#endif\n#ifdef SYS_umount2\n\t  \"umount2,\"\n#endif\n#ifdef SYS_vhangup\n\t  \"vhangup\"\n#endif\n\t},\n\t{ .name = \"@raw-io\", .list =\n#ifdef SYS_ioperm\n\t  \"ioperm,\"\n#endif\n#ifdef SYS_iopl\n\t  \"iopl,\"\n#endif\n#ifdef SYS_pciconfig_iobase\n\t  \"pciconfig_iobase,\"\n#endif\n#ifdef SYS_pciconfig_read\n\t  \"pciconfig_read,\"\n#endif\n#ifdef SYS_pciconfig_write\n\t  \"pciconfig_write,\"\n#endif\n#ifdef SYS_s390_mmio_read\n\t  \"s390_mmio_read,\"\n#endif\n#ifdef SYS_s390_mmio_write\n\t  \"s390_mmio_write\"\n#endif\n#if !defined(SYS_ioperm) && !defined(SYS_iopl) && !defined(SYS_pciconfig_iobase) && !defined(SYS_pciconfig_read) && !defined(SYS_pciconfig_write) && !defined(SYS_s390_mmio_read) && !defined(SYS_s390_mmio_write)\n\t  \"__dummy_syscall__\" // workaround for s390x which doesn't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@reboot\", .list =\n#ifdef SYS_kexec_load\n\t  \"kexec_load,\"\n#endif\n#ifdef SYS_kexec_file_load\n\t  \"kexec_file_load,\"\n#endif\n#ifdef SYS_reboot\n\t  \"reboot,\"\n#endif\n\t},\n\t{ .name = \"@resources\", .list =\n#ifdef SYS_set_mempolicy\n\t  \"set_mempolicy,\"\n#endif\n#ifdef SYS_migrate_pages\n\t  \"migrate_pages,\"\n#endif\n#ifdef SYS_move_pages\n\t  \"move_pages,\"\n#endif\n#ifdef SYS_mbind\n\t  \"mbind\"\n#endif\n\t},\n\t{ .name = \"@swap\", .list =\n#ifdef SYS_swapon\n\t  \"swapon,\"\n#endif\n#ifdef SYS_swapoff\n\t  \"swapoff\"\n#endif\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic const SyscallGroupList sysgroups[] = {\n\t{ .name = \"@clock\", .list =\n#ifdef SYS_adjtimex\n\t  \"adjtimex,\"\n#endif\n#ifdef SYS_clock_adjtime\n\t  \"clock_adjtime,\"\n#endif\n#ifdef SYS_clock_settime\n\t  \"clock_settime,\"\n#endif\n#ifdef SYS_settimeofday\n\t  \"settimeofday,\"\n#endif\n#ifdef SYS_stime\n\t  \"stime\"\n#endif\n\t},\n\t{ .name = \"@cpu-emulation\", .list =\n#ifdef SYS_modify_ldt\n\t  \"modify_ldt,\"\n#endif\n#ifdef SYS_subpage_prot\n\t  \"subpage_prot,\"\n#endif\n#ifdef SYS_switch_endian\n\t  \"switch_endian,\"\n#endif\n#ifdef SYS_vm86\n\t  \"vm86,\"\n#endif\n#ifdef SYS_vm86old\n\t  \"vm86old\"\n#endif\n#if !defined(SYS_modify_ldt) && !defined(SYS_subpage_prot) && !defined(SYS_switch_endian) && !defined(SYS_vm86) && !defined(SYS_vm86old)\n\t  \"__dummy_syscall__\" // workaround for arm64, s390x and sparc64 which don't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@debug\", .list =\n#ifdef SYS_lookup_dcookie\n\t  \"lookup_dcookie,\"\n#endif\n#ifdef SYS_perf_event_open\n\t  \"perf_event_open,\"\n#endif\n#ifdef SYS_process_vm_writev\n\t  \"process_vm_writev,\"\n#endif\n#ifdef SYS_rtas\n\t  \"rtas,\"\n#endif\n#ifdef SYS_s390_runtime_instr\n\t  \"s390_runtime_instr,\"\n#endif\n#ifdef SYS_sys_debug_setcontext\n\t  \"sys_debug_setcontext,\"\n#endif\n\t},\n\t{ .name = \"@default\", .list =\n\t  \"@cpu-emulation,\"\n\t  \"@debug,\"\n\t  \"@obsolete,\"\n\t  \"@privileged,\"\n\t  \"@resources,\"\n#ifdef SYS_open_by_handle_at\n\t  \"open_by_handle_at,\"\n#endif\n#ifdef SYS_name_to_handle_at\n\t  \"name_to_handle_at,\"\n#endif\n#ifdef SYS_ioprio_set\n\t  \"ioprio_set,\"\n#endif\n#ifdef SYS_ni_syscall\n\t  \"ni_syscall,\"\n#endif\n#ifdef SYS_syslog\n\t  \"syslog,\"\n#endif\n#ifdef SYS_fanotify_init\n\t  \"fanotify_init,\"\n#endif\n#ifdef SYS_kcmp\n\t  \"kcmp,\"\n#endif\n#ifdef SYS_add_key\n\t  \"add_key,\"\n#endif\n#ifdef SYS_request_key\n\t  \"request_key,\"\n#endif\n#ifdef SYS_keyctl\n\t  \"keyctl,\"\n#endif\n#ifdef SYS_io_setup\n\t  \"io_setup,\"\n#endif\n#ifdef SYS_io_destroy\n\t  \"io_destroy,\"\n#endif\n#ifdef SYS_io_getevents\n\t  \"io_getevents,\"\n#endif\n#ifdef SYS_io_submit\n\t  \"io_submit,\"\n#endif\n#ifdef SYS_io_cancel\n\t  \"io_cancel,\"\n#endif\n#ifdef SYS_remap_file_pages\n\t  \"remap_file_pages,\"\n#endif\n#ifdef SYS_vmsplice\n\t  \"vmsplice,\"\n#endif\n#ifdef SYS_umount\n\t  \"umount,\"\n#endif\n#ifdef SYS_userfaultfd\n\t  \"userfaultfd,\"\n#endif\n//#ifdef SYS_mincore\t// 0.9.57 - problem fixed in Linux kernel 5.0; on 4.x it will break kodi, mpv, totem\n//\t  \"mincore\"\n//#endif\n\t},\n\t{ .name = \"@default-nodebuggers\", .list =\n\t  \"@default,\"\n#ifdef SYS_ptrace\n\t  \"ptrace,\"\n#endif\n#ifdef SYS_personality\n\t  \"personality,\"\n#endif\n#ifdef SYS_process_vm_readv\n\t  \"process_vm_readv\"\n#endif\n\t},\n\t{ .name = \"@default-keep\", .list =\n\t  \"execve,\"\n\t  \"prctl\"\n\t},\n\t{ .name = \"@module\", .list =\n#ifdef SYS_delete_module\n\t  \"delete_module,\"\n#endif\n#ifdef SYS_finit_module\n\t  \"finit_module,\"\n#endif\n#ifdef SYS_init_module\n\t  \"init_module\"\n#endif\n\t},\n\t{ .name = \"@obsolete\", .list =\n#ifdef SYS__sysctl\n\t  \"_sysctl,\"\n#endif\n#ifdef SYS_afs_syscall\n\t  \"afs_syscall,\"\n#endif\n#ifdef SYS_bdflush\n\t  \"bdflush,\"\n#endif\n#ifdef SYS_break\n\t  \"break,\"\n#endif\n#ifdef SYS_create_module\n\t  \"create_module,\"\n#endif\n#ifdef SYS_ftime\n\t  \"ftime,\"\n#endif\n#ifdef SYS_get_kernel_syms\n\t  \"get_kernel_syms,\"\n#endif\n#ifdef SYS_getpmsg\n\t  \"getpmsg,\"\n#endif\n#ifdef SYS_gtty\n\t  \"gtty,\"\n#endif\n#ifdef SYS_lock\n\t  \"lock,\"\n#endif\n#ifdef SYS_mpx\n\t  \"mpx,\"\n#endif\n#ifdef SYS_prof\n\t  \"prof,\"\n#endif\n#ifdef SYS_profil\n\t  \"profil,\"\n#endif\n#ifdef SYS_putpmsg\n\t  \"putpmsg,\"\n#endif\n#ifdef SYS_query_module\n\t  \"query_module,\"\n#endif\n#ifdef SYS_security\n\t  \"security,\"\n#endif\n#ifdef SYS_sgetmask\n\t  \"sgetmask,\"\n#endif\n#ifdef SYS_ssetmask\n\t  \"ssetmask,\"\n#endif\n#ifdef SYS_stty\n\t  \"stty,\"\n#endif\n#ifdef SYS_sysfs\n\t  \"sysfs,\"\n#endif\n#ifdef SYS_tuxcall\n\t  \"tuxcall,\"\n#endif\n#ifdef SYS_ulimit\n\t  \"ulimit,\"\n#endif\n#ifdef SYS_uselib\n\t  \"uselib,\"\n#endif\n#ifdef SYS_ustat\n\t  \"ustat,\"\n#endif\n#ifdef SYS_vserver\n\t  \"vserver\"\n#endif\n#if !defined(SYS__sysctl) && !defined(SYS_afs_syscall) && !defined(SYS_bdflush) && !defined(SYS_break) && !defined(SYS_create_module) && !defined(SYS_ftime) && !defined(SYS_get_kernel_syms) && !defined(SYS_getpmsg) && !defined(SYS_gtty) && !defined(SYS_lock) && !defined(SYS_mpx) && !defined(SYS_prof) && !defined(SYS_profil) && !defined(SYS_putpmsg) && !defined(SYS_query_module) && !defined(SYS_security) && !defined(SYS_sgetmask) && !defined(SYS_ssetmask) && !defined(SYS_stty) && !defined(SYS_sysfs) && !defined(SYS_tuxcall) && !defined(SYS_ulimit) && !defined(SYS_uselib) && !defined(SYS_ustat) && !defined(SYS_vserver)\n\t  \"__dummy_syscall__\" // workaround for arm64 which doesn't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@privileged\", .list =\n\t  \"@clock,\"\n\t  \"@module,\"\n\t  \"@raw-io,\"\n\t  \"@reboot,\"\n\t  \"@swap,\"\n#ifdef SYS_acct\n\t  \"acct,\"\n#endif\n#ifdef SYS_bpf\n\t  \"bpf,\"\n#endif\n#ifdef SYS_chroot\n\t  \"chroot,\"\n#endif\n#ifdef SYS_mount\n\t  \"mount,\"\n#endif\n#ifdef SYS_nfsservctl\n\t  \"nfsservctl,\"\n#endif\n#ifdef SYS_pivot_root\n\t  \"pivot_root,\"\n#endif\n#ifdef SYS_setdomainname\n\t  \"setdomainname,\"\n#endif\n#ifdef SYS_sethostname\n\t  \"sethostname,\"\n#endif\n#ifdef SYS_umount2\n\t  \"umount2,\"\n#endif\n#ifdef SYS_vhangup\n\t  \"vhangup\"\n#endif\n\t},\n\t{ .name = \"@raw-io\", .list =\n#ifdef SYS_ioperm\n\t  \"ioperm,\"\n#endif\n#ifdef SYS_iopl\n\t  \"iopl,\"\n#endif\n#ifdef SYS_pciconfig_iobase\n\t  \"pciconfig_iobase,\"\n#endif\n#ifdef SYS_pciconfig_read\n\t  \"pciconfig_read,\"\n#endif\n#ifdef SYS_pciconfig_write\n\t  \"pciconfig_write,\"\n#endif\n#ifdef SYS_s390_mmio_read\n\t  \"s390_mmio_read,\"\n#endif\n#ifdef SYS_s390_mmio_write\n\t  \"s390_mmio_write\"\n#endif\n#if !defined(SYS_ioperm) && !defined(SYS_iopl) && !defined(SYS_pciconfig_iobase) && !defined(SYS_pciconfig_read) && !defined(SYS_pciconfig_write) && !defined(SYS_s390_mmio_read) && !defined(SYS_s390_mmio_write)\n\t  \"__dummy_syscall__\" // workaround for s390x which doesn't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@reboot\", .list =\n#ifdef SYS_kexec_load\n\t  \"kexec_load,\"\n#endif\n#ifdef SYS_kexec_file_load\n\t  \"kexec_file_load,\"\n#endif\n#ifdef SYS_reboot\n\t  \"reboot,\"\n#endif\n\t},\n\t{ .name = \"@resources\", .list =\n#ifdef SYS_set_mempolicy\n\t  \"set_mempolicy,\"\n#endif\n#ifdef SYS_migrate_pages\n\t  \"migrate_pages,\"\n#endif\n#ifdef SYS_move_pages\n\t  \"move_pages,\"\n#endif\n#ifdef SYS_mbind\n\t  \"mbind\"\n#endif\n\t},\n\t{ .name = \"@swap\", .list =\n#ifdef SYS_swapon\n\t  \"swapon,\"\n#endif\n#ifdef SYS_swapoff\n\t  \"swapoff\"\n#endif\n\t}\n};\n\nstatic const char *syscall_find_group(const char *name) {\n\tint i;\n\tint elems = sizeof(sysgroups) / sizeof(sysgroups[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (strcmp(name, sysgroups[i].name) == 0)\n\t\t\treturn sysgroups[i].list;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: empty syscall lists are not allowed\\n\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "str",
            "\",\"",
            "&saveptr"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "slist"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: empty syscall lists are not allowed\\n\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nint syscall_check_list(const char *slist, void (*callback)(int fd, int syscall, int arg, void *ptrarg), int fd, int arg, void *ptrarg) {\n\t// don't allow empty lists\n\tif (slist == NULL || *slist == '\\0') {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(slist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *saveptr;\n\tchar *ptr = strtok_r(str, \",\", &saveptr);\n\tif (ptr == NULL) {\n\t\tfprintf(stderr, \"Error fseccomp: empty syscall lists are not allowed\\n\");\n\t\texit(1);\n\t}\n\n\twhile (ptr) {\n\t\tint syscall_nr;\n\t\tint error_nr;\n\t\tif (*ptr == '@') {\n\t\t\tconst char *new_list = syscall_find_group(ptr);\n\t\t\tif (!new_list) {\n\t\t\t\tfprintf(stderr, \"Error fseccomp: unknown syscall group %s\\n\", ptr);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsyscall_check_list(new_list, callback, fd, arg, ptrarg);\n\t\t}\n\t\telse {\n\t\t\tsyscall_process_name(ptr, &syscall_nr, &error_nr);\n\t\t\tif (syscall_nr == -1) {;}\n\t\t\telse if (callback != NULL) {\n\t\t\t\tif (error_nr != -1 && fd != 0) {\n\t\t\t\t\tfilter_add_errno(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse if (error_nr != -1 && fd == 0) {\n\t\t\t\t\tcallback(fd, syscall_nr, error_nr, ptrarg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(fd, syscall_nr, arg, ptrarg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tptr = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(str);\n\treturn 0;\n}"
  },
  {
    "function_name": "syscall_process_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
    "lines": "428-466",
    "snippet": "static void syscall_process_name(const char *name, int *syscall_nr, int *error_nr) {\n\tassert(name);\n\tif (strlen(name) == 0)\n\t\tgoto error;\n\t*error_nr = -1;\n\n\t// syntax check\n\tchar *str = strdup(name);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *syscall_name = str;\n\tchar *error_name = strchr(str, ':');\n\tif (error_name) {\n\t\t*error_name = '\\0';\n\t\terror_name++;\n\t}\n\tif (strlen(syscall_name) == 0) {\n\t\tfree(str);\n\t\tgoto error;\n\t}\n\n\tif (*syscall_name == '$')\n\t\t*syscall_nr = strtol(syscall_name + 1, NULL, 0);\n\telse\n\t\t*syscall_nr = syscall_find_name(syscall_name);\n\tif (error_name) {\n\t\t*error_nr = errno_find_name(error_name);\n\t\tif (*error_nr == -1)\n\t\t\t*syscall_nr = -1;\n\t}\n\n\tfree(str);\n\treturn;\n\nerror:\n\tfprintf(stderr, \"Error fseccomp: invalid syscall list entry %s\\n\", name);\n\texit(1);\n}",
    "includes": [
      "#include <sys/syscall.h>",
      "#include <stdio.h>",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error fseccomp: invalid syscall list entry %s\\n\"",
            "name"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errno_find_name",
          "args": [
            "error_name"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "errno_find_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/errno.c",
          "lines": "173-182",
          "snippet": "int errno_find_name(const char *name) {\n\tint i;\n\tint elems = sizeof(errnolist) / sizeof(errnolist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (strcasecmp(name, errnolist[i].name) == 0)\n\t\t\treturn errnolist[i].nr;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <errno.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrnoEntry errnolist[] = {\n//\n// code generated using tools/extract-errnos\n//\n\t{\"EPERM\", EPERM},\n\t{\"ENOENT\", ENOENT},\n\t{\"ESRCH\", ESRCH},\n\t{\"EINTR\", EINTR},\n\t{\"EIO\", EIO},\n\t{\"ENXIO\", ENXIO},\n\t{\"E2BIG\", E2BIG},\n\t{\"ENOEXEC\", ENOEXEC},\n\t{\"EBADF\", EBADF},\n\t{\"ECHILD\", ECHILD},\n\t{\"EAGAIN\", EAGAIN},\n\t{\"ENOMEM\", ENOMEM},\n\t{\"EACCES\", EACCES},\n\t{\"EFAULT\", EFAULT},\n\t{\"ENOTBLK\", ENOTBLK},\n\t{\"EBUSY\", EBUSY},\n\t{\"EEXIST\", EEXIST},\n\t{\"EXDEV\", EXDEV},\n\t{\"ENODEV\", ENODEV},\n\t{\"ENOTDIR\", ENOTDIR},\n\t{\"EISDIR\", EISDIR},\n\t{\"EINVAL\", EINVAL},\n\t{\"ENFILE\", ENFILE},\n\t{\"EMFILE\", EMFILE},\n\t{\"ENOTTY\", ENOTTY},\n\t{\"ETXTBSY\", ETXTBSY},\n\t{\"EFBIG\", EFBIG},\n\t{\"ENOSPC\", ENOSPC},\n\t{\"ESPIPE\", ESPIPE},\n\t{\"EROFS\", EROFS},\n\t{\"EMLINK\", EMLINK},\n\t{\"EPIPE\", EPIPE},\n\t{\"EDOM\", EDOM},\n\t{\"ERANGE\", ERANGE},\n\t{\"EDEADLK\", EDEADLK},\n\t{\"ENAMETOOLONG\", ENAMETOOLONG},\n\t{\"ENOLCK\", ENOLCK},\n\t{\"ENOSYS\", ENOSYS},\n\t{\"ENOTEMPTY\", ENOTEMPTY},\n\t{\"ELOOP\", ELOOP},\n\t{\"EWOULDBLOCK\", EWOULDBLOCK},\n\t{\"ENOMSG\", ENOMSG},\n\t{\"EIDRM\", EIDRM},\n\t{\"ECHRNG\", ECHRNG},\n\t{\"EL2NSYNC\", EL2NSYNC},\n\t{\"EL3HLT\", EL3HLT},\n\t{\"EL3RST\", EL3RST},\n\t{\"ELNRNG\", ELNRNG},\n\t{\"EUNATCH\", EUNATCH},\n\t{\"ENOCSI\", ENOCSI},\n\t{\"EL2HLT\", EL2HLT},\n\t{\"EBADE\", EBADE},\n\t{\"EBADR\", EBADR},\n\t{\"EXFULL\", EXFULL},\n\t{\"ENOANO\", ENOANO},\n\t{\"EBADRQC\", EBADRQC},\n\t{\"EBADSLT\", EBADSLT},\n\t{\"EDEADLOCK\", EDEADLOCK},\n\t{\"EBFONT\", EBFONT},\n\t{\"ENOSTR\", ENOSTR},\n\t{\"ENODATA\", ENODATA},\n\t{\"ETIME\", ETIME},\n\t{\"ENOSR\", ENOSR},\n\t{\"ENONET\", ENONET},\n\t{\"ENOPKG\", ENOPKG},\n\t{\"EREMOTE\", EREMOTE},\n\t{\"ENOLINK\", ENOLINK},\n\t{\"EADV\", EADV},\n\t{\"ESRMNT\", ESRMNT},\n\t{\"ECOMM\", ECOMM},\n\t{\"EPROTO\", EPROTO},\n\t{\"EMULTIHOP\", EMULTIHOP},\n\t{\"EDOTDOT\", EDOTDOT},\n\t{\"EBADMSG\", EBADMSG},\n\t{\"EOVERFLOW\", EOVERFLOW},\n\t{\"ENOTUNIQ\", ENOTUNIQ},\n\t{\"EBADFD\", EBADFD},\n\t{\"EREMCHG\", EREMCHG},\n\t{\"ELIBACC\", ELIBACC},\n\t{\"ELIBBAD\", ELIBBAD},\n\t{\"ELIBSCN\", ELIBSCN},\n\t{\"ELIBMAX\", ELIBMAX},\n\t{\"ELIBEXEC\", ELIBEXEC},\n\t{\"EILSEQ\", EILSEQ},\n\t{\"ERESTART\", ERESTART},\n\t{\"ESTRPIPE\", ESTRPIPE},\n\t{\"EUSERS\", EUSERS},\n\t{\"ENOTSOCK\", ENOTSOCK},\n\t{\"EDESTADDRREQ\", EDESTADDRREQ},\n\t{\"EMSGSIZE\", EMSGSIZE},\n\t{\"EPROTOTYPE\", EPROTOTYPE},\n\t{\"ENOPROTOOPT\", ENOPROTOOPT},\n\t{\"EPROTONOSUPPORT\", EPROTONOSUPPORT},\n\t{\"ESOCKTNOSUPPORT\", ESOCKTNOSUPPORT},\n\t{\"EOPNOTSUPP\", EOPNOTSUPP},\n\t{\"EPFNOSUPPORT\", EPFNOSUPPORT},\n\t{\"EAFNOSUPPORT\", EAFNOSUPPORT},\n\t{\"EADDRINUSE\", EADDRINUSE},\n\t{\"EADDRNOTAVAIL\", EADDRNOTAVAIL},\n\t{\"ENETDOWN\", ENETDOWN},\n\t{\"ENETUNREACH\", ENETUNREACH},\n\t{\"ENETRESET\", ENETRESET},\n\t{\"ECONNABORTED\", ECONNABORTED},\n\t{\"ECONNRESET\", ECONNRESET},\n\t{\"ENOBUFS\", ENOBUFS},\n\t{\"EISCONN\", EISCONN},\n\t{\"ENOTCONN\", ENOTCONN},\n\t{\"ESHUTDOWN\", ESHUTDOWN},\n\t{\"ETOOMANYREFS\", ETOOMANYREFS},\n\t{\"ETIMEDOUT\", ETIMEDOUT},\n\t{\"ECONNREFUSED\", ECONNREFUSED},\n\t{\"EHOSTDOWN\", EHOSTDOWN},\n\t{\"EHOSTUNREACH\", EHOSTUNREACH},\n\t{\"EALREADY\", EALREADY},\n\t{\"EINPROGRESS\", EINPROGRESS},\n\t{\"ESTALE\", ESTALE},\n\t{\"EUCLEAN\", EUCLEAN},\n\t{\"ENOTNAM\", ENOTNAM},\n\t{\"ENAVAIL\", ENAVAIL},\n\t{\"EISNAM\", EISNAM},\n\t{\"EREMOTEIO\", EREMOTEIO},\n\t{\"EDQUOT\", EDQUOT},\n\t{\"ENOMEDIUM\", ENOMEDIUM},\n\t{\"EMEDIUMTYPE\", EMEDIUMTYPE},\n\t{\"ECANCELED\", ECANCELED},\n\t{\"ENOKEY\", ENOKEY},\n\t{\"EKEYEXPIRED\", EKEYEXPIRED},\n\t{\"EKEYREVOKED\", EKEYREVOKED},\n\t{\"EKEYREJECTED\", EKEYREJECTED},\n\t{\"EOWNERDEAD\", EOWNERDEAD},\n\t{\"ENOTRECOVERABLE\", ENOTRECOVERABLE},\n\t{\"ERFKILL\", ERFKILL},\n\t{\"EHWPOISON\", EHWPOISON},\n\t{\"ENOTSUP\", ENOTSUP},\n#ifdef \tENOATTR\n\t{\"ENOATTR\", ENOATTR},\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include \"fseccomp.h\"\n\nstatic ErrnoEntry errnolist[] = {\n//\n// code generated using tools/extract-errnos\n//\n\t{\"EPERM\", EPERM},\n\t{\"ENOENT\", ENOENT},\n\t{\"ESRCH\", ESRCH},\n\t{\"EINTR\", EINTR},\n\t{\"EIO\", EIO},\n\t{\"ENXIO\", ENXIO},\n\t{\"E2BIG\", E2BIG},\n\t{\"ENOEXEC\", ENOEXEC},\n\t{\"EBADF\", EBADF},\n\t{\"ECHILD\", ECHILD},\n\t{\"EAGAIN\", EAGAIN},\n\t{\"ENOMEM\", ENOMEM},\n\t{\"EACCES\", EACCES},\n\t{\"EFAULT\", EFAULT},\n\t{\"ENOTBLK\", ENOTBLK},\n\t{\"EBUSY\", EBUSY},\n\t{\"EEXIST\", EEXIST},\n\t{\"EXDEV\", EXDEV},\n\t{\"ENODEV\", ENODEV},\n\t{\"ENOTDIR\", ENOTDIR},\n\t{\"EISDIR\", EISDIR},\n\t{\"EINVAL\", EINVAL},\n\t{\"ENFILE\", ENFILE},\n\t{\"EMFILE\", EMFILE},\n\t{\"ENOTTY\", ENOTTY},\n\t{\"ETXTBSY\", ETXTBSY},\n\t{\"EFBIG\", EFBIG},\n\t{\"ENOSPC\", ENOSPC},\n\t{\"ESPIPE\", ESPIPE},\n\t{\"EROFS\", EROFS},\n\t{\"EMLINK\", EMLINK},\n\t{\"EPIPE\", EPIPE},\n\t{\"EDOM\", EDOM},\n\t{\"ERANGE\", ERANGE},\n\t{\"EDEADLK\", EDEADLK},\n\t{\"ENAMETOOLONG\", ENAMETOOLONG},\n\t{\"ENOLCK\", ENOLCK},\n\t{\"ENOSYS\", ENOSYS},\n\t{\"ENOTEMPTY\", ENOTEMPTY},\n\t{\"ELOOP\", ELOOP},\n\t{\"EWOULDBLOCK\", EWOULDBLOCK},\n\t{\"ENOMSG\", ENOMSG},\n\t{\"EIDRM\", EIDRM},\n\t{\"ECHRNG\", ECHRNG},\n\t{\"EL2NSYNC\", EL2NSYNC},\n\t{\"EL3HLT\", EL3HLT},\n\t{\"EL3RST\", EL3RST},\n\t{\"ELNRNG\", ELNRNG},\n\t{\"EUNATCH\", EUNATCH},\n\t{\"ENOCSI\", ENOCSI},\n\t{\"EL2HLT\", EL2HLT},\n\t{\"EBADE\", EBADE},\n\t{\"EBADR\", EBADR},\n\t{\"EXFULL\", EXFULL},\n\t{\"ENOANO\", ENOANO},\n\t{\"EBADRQC\", EBADRQC},\n\t{\"EBADSLT\", EBADSLT},\n\t{\"EDEADLOCK\", EDEADLOCK},\n\t{\"EBFONT\", EBFONT},\n\t{\"ENOSTR\", ENOSTR},\n\t{\"ENODATA\", ENODATA},\n\t{\"ETIME\", ETIME},\n\t{\"ENOSR\", ENOSR},\n\t{\"ENONET\", ENONET},\n\t{\"ENOPKG\", ENOPKG},\n\t{\"EREMOTE\", EREMOTE},\n\t{\"ENOLINK\", ENOLINK},\n\t{\"EADV\", EADV},\n\t{\"ESRMNT\", ESRMNT},\n\t{\"ECOMM\", ECOMM},\n\t{\"EPROTO\", EPROTO},\n\t{\"EMULTIHOP\", EMULTIHOP},\n\t{\"EDOTDOT\", EDOTDOT},\n\t{\"EBADMSG\", EBADMSG},\n\t{\"EOVERFLOW\", EOVERFLOW},\n\t{\"ENOTUNIQ\", ENOTUNIQ},\n\t{\"EBADFD\", EBADFD},\n\t{\"EREMCHG\", EREMCHG},\n\t{\"ELIBACC\", ELIBACC},\n\t{\"ELIBBAD\", ELIBBAD},\n\t{\"ELIBSCN\", ELIBSCN},\n\t{\"ELIBMAX\", ELIBMAX},\n\t{\"ELIBEXEC\", ELIBEXEC},\n\t{\"EILSEQ\", EILSEQ},\n\t{\"ERESTART\", ERESTART},\n\t{\"ESTRPIPE\", ESTRPIPE},\n\t{\"EUSERS\", EUSERS},\n\t{\"ENOTSOCK\", ENOTSOCK},\n\t{\"EDESTADDRREQ\", EDESTADDRREQ},\n\t{\"EMSGSIZE\", EMSGSIZE},\n\t{\"EPROTOTYPE\", EPROTOTYPE},\n\t{\"ENOPROTOOPT\", ENOPROTOOPT},\n\t{\"EPROTONOSUPPORT\", EPROTONOSUPPORT},\n\t{\"ESOCKTNOSUPPORT\", ESOCKTNOSUPPORT},\n\t{\"EOPNOTSUPP\", EOPNOTSUPP},\n\t{\"EPFNOSUPPORT\", EPFNOSUPPORT},\n\t{\"EAFNOSUPPORT\", EAFNOSUPPORT},\n\t{\"EADDRINUSE\", EADDRINUSE},\n\t{\"EADDRNOTAVAIL\", EADDRNOTAVAIL},\n\t{\"ENETDOWN\", ENETDOWN},\n\t{\"ENETUNREACH\", ENETUNREACH},\n\t{\"ENETRESET\", ENETRESET},\n\t{\"ECONNABORTED\", ECONNABORTED},\n\t{\"ECONNRESET\", ECONNRESET},\n\t{\"ENOBUFS\", ENOBUFS},\n\t{\"EISCONN\", EISCONN},\n\t{\"ENOTCONN\", ENOTCONN},\n\t{\"ESHUTDOWN\", ESHUTDOWN},\n\t{\"ETOOMANYREFS\", ETOOMANYREFS},\n\t{\"ETIMEDOUT\", ETIMEDOUT},\n\t{\"ECONNREFUSED\", ECONNREFUSED},\n\t{\"EHOSTDOWN\", EHOSTDOWN},\n\t{\"EHOSTUNREACH\", EHOSTUNREACH},\n\t{\"EALREADY\", EALREADY},\n\t{\"EINPROGRESS\", EINPROGRESS},\n\t{\"ESTALE\", ESTALE},\n\t{\"EUCLEAN\", EUCLEAN},\n\t{\"ENOTNAM\", ENOTNAM},\n\t{\"ENAVAIL\", ENAVAIL},\n\t{\"EISNAM\", EISNAM},\n\t{\"EREMOTEIO\", EREMOTEIO},\n\t{\"EDQUOT\", EDQUOT},\n\t{\"ENOMEDIUM\", ENOMEDIUM},\n\t{\"EMEDIUMTYPE\", EMEDIUMTYPE},\n\t{\"ECANCELED\", ECANCELED},\n\t{\"ENOKEY\", ENOKEY},\n\t{\"EKEYEXPIRED\", EKEYEXPIRED},\n\t{\"EKEYREVOKED\", EKEYREVOKED},\n\t{\"EKEYREJECTED\", EKEYREJECTED},\n\t{\"EOWNERDEAD\", EOWNERDEAD},\n\t{\"ENOTRECOVERABLE\", ENOTRECOVERABLE},\n\t{\"ERFKILL\", ERFKILL},\n\t{\"EHWPOISON\", EHWPOISON},\n\t{\"ENOTSUP\", ENOTSUP},\n#ifdef \tENOATTR\n\t{\"ENOATTR\", ENOATTR},\n#endif\n};\n\nint errno_find_name(const char *name) {\n\tint i;\n\tint elems = sizeof(errnolist) / sizeof(errnolist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (strcasecmp(name, errnolist[i].name) == 0)\n\t\t\treturn errnolist[i].nr;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_find_name",
          "args": [
            "syscall_name"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_find_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
          "lines": "383-392",
          "snippet": "static int syscall_find_name(const char *name) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (strcmp(name, syslist[i].name) == 0)\n\t\t\treturn syslist[i].nr;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <sys/syscall.h>",
            "#include <stdio.h>",
            "#include \"fseccomp.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};\n\nstatic int syscall_find_name(const char *name) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (strcmp(name, syslist[i].name) == 0)\n\t\t\treturn syslist[i].nr;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "syscall_name + 1",
            "NULL",
            "0"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "syscall_name"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "':'"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic void syscall_process_name(const char *name, int *syscall_nr, int *error_nr) {\n\tassert(name);\n\tif (strlen(name) == 0)\n\t\tgoto error;\n\t*error_nr = -1;\n\n\t// syntax check\n\tchar *str = strdup(name);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *syscall_name = str;\n\tchar *error_name = strchr(str, ':');\n\tif (error_name) {\n\t\t*error_name = '\\0';\n\t\terror_name++;\n\t}\n\tif (strlen(syscall_name) == 0) {\n\t\tfree(str);\n\t\tgoto error;\n\t}\n\n\tif (*syscall_name == '$')\n\t\t*syscall_nr = strtol(syscall_name + 1, NULL, 0);\n\telse\n\t\t*syscall_nr = syscall_find_name(syscall_name);\n\tif (error_name) {\n\t\t*error_nr = errno_find_name(error_name);\n\t\tif (*error_nr == -1)\n\t\t\t*syscall_nr = -1;\n\t}\n\n\tfree(str);\n\treturn;\n\nerror:\n\tfprintf(stderr, \"Error fseccomp: invalid syscall list entry %s\\n\", name);\n\texit(1);\n}"
  },
  {
    "function_name": "syscall_find_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
    "lines": "414-423",
    "snippet": "static const char *syscall_find_group(const char *name) {\n\tint i;\n\tint elems = sizeof(sysgroups) / sizeof(sysgroups[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (strcmp(name, sysgroups[i].name) == 0)\n\t\t\treturn sysgroups[i].list;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <sys/syscall.h>",
      "#include <stdio.h>",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const SyscallGroupList sysgroups[] = {\n\t{ .name = \"@clock\", .list =\n#ifdef SYS_adjtimex\n\t  \"adjtimex,\"\n#endif\n#ifdef SYS_clock_adjtime\n\t  \"clock_adjtime,\"\n#endif\n#ifdef SYS_clock_settime\n\t  \"clock_settime,\"\n#endif\n#ifdef SYS_settimeofday\n\t  \"settimeofday,\"\n#endif\n#ifdef SYS_stime\n\t  \"stime\"\n#endif\n\t},\n\t{ .name = \"@cpu-emulation\", .list =\n#ifdef SYS_modify_ldt\n\t  \"modify_ldt,\"\n#endif\n#ifdef SYS_subpage_prot\n\t  \"subpage_prot,\"\n#endif\n#ifdef SYS_switch_endian\n\t  \"switch_endian,\"\n#endif\n#ifdef SYS_vm86\n\t  \"vm86,\"\n#endif\n#ifdef SYS_vm86old\n\t  \"vm86old\"\n#endif\n#if !defined(SYS_modify_ldt) && !defined(SYS_subpage_prot) && !defined(SYS_switch_endian) && !defined(SYS_vm86) && !defined(SYS_vm86old)\n\t  \"__dummy_syscall__\" // workaround for arm64, s390x and sparc64 which don't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@debug\", .list =\n#ifdef SYS_lookup_dcookie\n\t  \"lookup_dcookie,\"\n#endif\n#ifdef SYS_perf_event_open\n\t  \"perf_event_open,\"\n#endif\n#ifdef SYS_process_vm_writev\n\t  \"process_vm_writev,\"\n#endif\n#ifdef SYS_rtas\n\t  \"rtas,\"\n#endif\n#ifdef SYS_s390_runtime_instr\n\t  \"s390_runtime_instr,\"\n#endif\n#ifdef SYS_sys_debug_setcontext\n\t  \"sys_debug_setcontext,\"\n#endif\n\t},\n\t{ .name = \"@default\", .list =\n\t  \"@cpu-emulation,\"\n\t  \"@debug,\"\n\t  \"@obsolete,\"\n\t  \"@privileged,\"\n\t  \"@resources,\"\n#ifdef SYS_open_by_handle_at\n\t  \"open_by_handle_at,\"\n#endif\n#ifdef SYS_name_to_handle_at\n\t  \"name_to_handle_at,\"\n#endif\n#ifdef SYS_ioprio_set\n\t  \"ioprio_set,\"\n#endif\n#ifdef SYS_ni_syscall\n\t  \"ni_syscall,\"\n#endif\n#ifdef SYS_syslog\n\t  \"syslog,\"\n#endif\n#ifdef SYS_fanotify_init\n\t  \"fanotify_init,\"\n#endif\n#ifdef SYS_kcmp\n\t  \"kcmp,\"\n#endif\n#ifdef SYS_add_key\n\t  \"add_key,\"\n#endif\n#ifdef SYS_request_key\n\t  \"request_key,\"\n#endif\n#ifdef SYS_keyctl\n\t  \"keyctl,\"\n#endif\n#ifdef SYS_io_setup\n\t  \"io_setup,\"\n#endif\n#ifdef SYS_io_destroy\n\t  \"io_destroy,\"\n#endif\n#ifdef SYS_io_getevents\n\t  \"io_getevents,\"\n#endif\n#ifdef SYS_io_submit\n\t  \"io_submit,\"\n#endif\n#ifdef SYS_io_cancel\n\t  \"io_cancel,\"\n#endif\n#ifdef SYS_remap_file_pages\n\t  \"remap_file_pages,\"\n#endif\n#ifdef SYS_vmsplice\n\t  \"vmsplice,\"\n#endif\n#ifdef SYS_umount\n\t  \"umount,\"\n#endif\n#ifdef SYS_userfaultfd\n\t  \"userfaultfd,\"\n#endif\n//#ifdef SYS_mincore\t// 0.9.57 - problem fixed in Linux kernel 5.0; on 4.x it will break kodi, mpv, totem\n//\t  \"mincore\"\n//#endif\n\t},\n\t{ .name = \"@default-nodebuggers\", .list =\n\t  \"@default,\"\n#ifdef SYS_ptrace\n\t  \"ptrace,\"\n#endif\n#ifdef SYS_personality\n\t  \"personality,\"\n#endif\n#ifdef SYS_process_vm_readv\n\t  \"process_vm_readv\"\n#endif\n\t},\n\t{ .name = \"@default-keep\", .list =\n\t  \"execve,\"\n\t  \"prctl\"\n\t},\n\t{ .name = \"@module\", .list =\n#ifdef SYS_delete_module\n\t  \"delete_module,\"\n#endif\n#ifdef SYS_finit_module\n\t  \"finit_module,\"\n#endif\n#ifdef SYS_init_module\n\t  \"init_module\"\n#endif\n\t},\n\t{ .name = \"@obsolete\", .list =\n#ifdef SYS__sysctl\n\t  \"_sysctl,\"\n#endif\n#ifdef SYS_afs_syscall\n\t  \"afs_syscall,\"\n#endif\n#ifdef SYS_bdflush\n\t  \"bdflush,\"\n#endif\n#ifdef SYS_break\n\t  \"break,\"\n#endif\n#ifdef SYS_create_module\n\t  \"create_module,\"\n#endif\n#ifdef SYS_ftime\n\t  \"ftime,\"\n#endif\n#ifdef SYS_get_kernel_syms\n\t  \"get_kernel_syms,\"\n#endif\n#ifdef SYS_getpmsg\n\t  \"getpmsg,\"\n#endif\n#ifdef SYS_gtty\n\t  \"gtty,\"\n#endif\n#ifdef SYS_lock\n\t  \"lock,\"\n#endif\n#ifdef SYS_mpx\n\t  \"mpx,\"\n#endif\n#ifdef SYS_prof\n\t  \"prof,\"\n#endif\n#ifdef SYS_profil\n\t  \"profil,\"\n#endif\n#ifdef SYS_putpmsg\n\t  \"putpmsg,\"\n#endif\n#ifdef SYS_query_module\n\t  \"query_module,\"\n#endif\n#ifdef SYS_security\n\t  \"security,\"\n#endif\n#ifdef SYS_sgetmask\n\t  \"sgetmask,\"\n#endif\n#ifdef SYS_ssetmask\n\t  \"ssetmask,\"\n#endif\n#ifdef SYS_stty\n\t  \"stty,\"\n#endif\n#ifdef SYS_sysfs\n\t  \"sysfs,\"\n#endif\n#ifdef SYS_tuxcall\n\t  \"tuxcall,\"\n#endif\n#ifdef SYS_ulimit\n\t  \"ulimit,\"\n#endif\n#ifdef SYS_uselib\n\t  \"uselib,\"\n#endif\n#ifdef SYS_ustat\n\t  \"ustat,\"\n#endif\n#ifdef SYS_vserver\n\t  \"vserver\"\n#endif\n#if !defined(SYS__sysctl) && !defined(SYS_afs_syscall) && !defined(SYS_bdflush) && !defined(SYS_break) && !defined(SYS_create_module) && !defined(SYS_ftime) && !defined(SYS_get_kernel_syms) && !defined(SYS_getpmsg) && !defined(SYS_gtty) && !defined(SYS_lock) && !defined(SYS_mpx) && !defined(SYS_prof) && !defined(SYS_profil) && !defined(SYS_putpmsg) && !defined(SYS_query_module) && !defined(SYS_security) && !defined(SYS_sgetmask) && !defined(SYS_ssetmask) && !defined(SYS_stty) && !defined(SYS_sysfs) && !defined(SYS_tuxcall) && !defined(SYS_ulimit) && !defined(SYS_uselib) && !defined(SYS_ustat) && !defined(SYS_vserver)\n\t  \"__dummy_syscall__\" // workaround for arm64 which doesn't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@privileged\", .list =\n\t  \"@clock,\"\n\t  \"@module,\"\n\t  \"@raw-io,\"\n\t  \"@reboot,\"\n\t  \"@swap,\"\n#ifdef SYS_acct\n\t  \"acct,\"\n#endif\n#ifdef SYS_bpf\n\t  \"bpf,\"\n#endif\n#ifdef SYS_chroot\n\t  \"chroot,\"\n#endif\n#ifdef SYS_mount\n\t  \"mount,\"\n#endif\n#ifdef SYS_nfsservctl\n\t  \"nfsservctl,\"\n#endif\n#ifdef SYS_pivot_root\n\t  \"pivot_root,\"\n#endif\n#ifdef SYS_setdomainname\n\t  \"setdomainname,\"\n#endif\n#ifdef SYS_sethostname\n\t  \"sethostname,\"\n#endif\n#ifdef SYS_umount2\n\t  \"umount2,\"\n#endif\n#ifdef SYS_vhangup\n\t  \"vhangup\"\n#endif\n\t},\n\t{ .name = \"@raw-io\", .list =\n#ifdef SYS_ioperm\n\t  \"ioperm,\"\n#endif\n#ifdef SYS_iopl\n\t  \"iopl,\"\n#endif\n#ifdef SYS_pciconfig_iobase\n\t  \"pciconfig_iobase,\"\n#endif\n#ifdef SYS_pciconfig_read\n\t  \"pciconfig_read,\"\n#endif\n#ifdef SYS_pciconfig_write\n\t  \"pciconfig_write,\"\n#endif\n#ifdef SYS_s390_mmio_read\n\t  \"s390_mmio_read,\"\n#endif\n#ifdef SYS_s390_mmio_write\n\t  \"s390_mmio_write\"\n#endif\n#if !defined(SYS_ioperm) && !defined(SYS_iopl) && !defined(SYS_pciconfig_iobase) && !defined(SYS_pciconfig_read) && !defined(SYS_pciconfig_write) && !defined(SYS_s390_mmio_read) && !defined(SYS_s390_mmio_write)\n\t  \"__dummy_syscall__\" // workaround for s390x which doesn't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@reboot\", .list =\n#ifdef SYS_kexec_load\n\t  \"kexec_load,\"\n#endif\n#ifdef SYS_kexec_file_load\n\t  \"kexec_file_load,\"\n#endif\n#ifdef SYS_reboot\n\t  \"reboot,\"\n#endif\n\t},\n\t{ .name = \"@resources\", .list =\n#ifdef SYS_set_mempolicy\n\t  \"set_mempolicy,\"\n#endif\n#ifdef SYS_migrate_pages\n\t  \"migrate_pages,\"\n#endif\n#ifdef SYS_move_pages\n\t  \"move_pages,\"\n#endif\n#ifdef SYS_mbind\n\t  \"mbind\"\n#endif\n\t},\n\t{ .name = \"@swap\", .list =\n#ifdef SYS_swapon\n\t  \"swapon,\"\n#endif\n#ifdef SYS_swapoff\n\t  \"swapoff\"\n#endif\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "sysgroups[i].name"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic const SyscallGroupList sysgroups[] = {\n\t{ .name = \"@clock\", .list =\n#ifdef SYS_adjtimex\n\t  \"adjtimex,\"\n#endif\n#ifdef SYS_clock_adjtime\n\t  \"clock_adjtime,\"\n#endif\n#ifdef SYS_clock_settime\n\t  \"clock_settime,\"\n#endif\n#ifdef SYS_settimeofday\n\t  \"settimeofday,\"\n#endif\n#ifdef SYS_stime\n\t  \"stime\"\n#endif\n\t},\n\t{ .name = \"@cpu-emulation\", .list =\n#ifdef SYS_modify_ldt\n\t  \"modify_ldt,\"\n#endif\n#ifdef SYS_subpage_prot\n\t  \"subpage_prot,\"\n#endif\n#ifdef SYS_switch_endian\n\t  \"switch_endian,\"\n#endif\n#ifdef SYS_vm86\n\t  \"vm86,\"\n#endif\n#ifdef SYS_vm86old\n\t  \"vm86old\"\n#endif\n#if !defined(SYS_modify_ldt) && !defined(SYS_subpage_prot) && !defined(SYS_switch_endian) && !defined(SYS_vm86) && !defined(SYS_vm86old)\n\t  \"__dummy_syscall__\" // workaround for arm64, s390x and sparc64 which don't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@debug\", .list =\n#ifdef SYS_lookup_dcookie\n\t  \"lookup_dcookie,\"\n#endif\n#ifdef SYS_perf_event_open\n\t  \"perf_event_open,\"\n#endif\n#ifdef SYS_process_vm_writev\n\t  \"process_vm_writev,\"\n#endif\n#ifdef SYS_rtas\n\t  \"rtas,\"\n#endif\n#ifdef SYS_s390_runtime_instr\n\t  \"s390_runtime_instr,\"\n#endif\n#ifdef SYS_sys_debug_setcontext\n\t  \"sys_debug_setcontext,\"\n#endif\n\t},\n\t{ .name = \"@default\", .list =\n\t  \"@cpu-emulation,\"\n\t  \"@debug,\"\n\t  \"@obsolete,\"\n\t  \"@privileged,\"\n\t  \"@resources,\"\n#ifdef SYS_open_by_handle_at\n\t  \"open_by_handle_at,\"\n#endif\n#ifdef SYS_name_to_handle_at\n\t  \"name_to_handle_at,\"\n#endif\n#ifdef SYS_ioprio_set\n\t  \"ioprio_set,\"\n#endif\n#ifdef SYS_ni_syscall\n\t  \"ni_syscall,\"\n#endif\n#ifdef SYS_syslog\n\t  \"syslog,\"\n#endif\n#ifdef SYS_fanotify_init\n\t  \"fanotify_init,\"\n#endif\n#ifdef SYS_kcmp\n\t  \"kcmp,\"\n#endif\n#ifdef SYS_add_key\n\t  \"add_key,\"\n#endif\n#ifdef SYS_request_key\n\t  \"request_key,\"\n#endif\n#ifdef SYS_keyctl\n\t  \"keyctl,\"\n#endif\n#ifdef SYS_io_setup\n\t  \"io_setup,\"\n#endif\n#ifdef SYS_io_destroy\n\t  \"io_destroy,\"\n#endif\n#ifdef SYS_io_getevents\n\t  \"io_getevents,\"\n#endif\n#ifdef SYS_io_submit\n\t  \"io_submit,\"\n#endif\n#ifdef SYS_io_cancel\n\t  \"io_cancel,\"\n#endif\n#ifdef SYS_remap_file_pages\n\t  \"remap_file_pages,\"\n#endif\n#ifdef SYS_vmsplice\n\t  \"vmsplice,\"\n#endif\n#ifdef SYS_umount\n\t  \"umount,\"\n#endif\n#ifdef SYS_userfaultfd\n\t  \"userfaultfd,\"\n#endif\n//#ifdef SYS_mincore\t// 0.9.57 - problem fixed in Linux kernel 5.0; on 4.x it will break kodi, mpv, totem\n//\t  \"mincore\"\n//#endif\n\t},\n\t{ .name = \"@default-nodebuggers\", .list =\n\t  \"@default,\"\n#ifdef SYS_ptrace\n\t  \"ptrace,\"\n#endif\n#ifdef SYS_personality\n\t  \"personality,\"\n#endif\n#ifdef SYS_process_vm_readv\n\t  \"process_vm_readv\"\n#endif\n\t},\n\t{ .name = \"@default-keep\", .list =\n\t  \"execve,\"\n\t  \"prctl\"\n\t},\n\t{ .name = \"@module\", .list =\n#ifdef SYS_delete_module\n\t  \"delete_module,\"\n#endif\n#ifdef SYS_finit_module\n\t  \"finit_module,\"\n#endif\n#ifdef SYS_init_module\n\t  \"init_module\"\n#endif\n\t},\n\t{ .name = \"@obsolete\", .list =\n#ifdef SYS__sysctl\n\t  \"_sysctl,\"\n#endif\n#ifdef SYS_afs_syscall\n\t  \"afs_syscall,\"\n#endif\n#ifdef SYS_bdflush\n\t  \"bdflush,\"\n#endif\n#ifdef SYS_break\n\t  \"break,\"\n#endif\n#ifdef SYS_create_module\n\t  \"create_module,\"\n#endif\n#ifdef SYS_ftime\n\t  \"ftime,\"\n#endif\n#ifdef SYS_get_kernel_syms\n\t  \"get_kernel_syms,\"\n#endif\n#ifdef SYS_getpmsg\n\t  \"getpmsg,\"\n#endif\n#ifdef SYS_gtty\n\t  \"gtty,\"\n#endif\n#ifdef SYS_lock\n\t  \"lock,\"\n#endif\n#ifdef SYS_mpx\n\t  \"mpx,\"\n#endif\n#ifdef SYS_prof\n\t  \"prof,\"\n#endif\n#ifdef SYS_profil\n\t  \"profil,\"\n#endif\n#ifdef SYS_putpmsg\n\t  \"putpmsg,\"\n#endif\n#ifdef SYS_query_module\n\t  \"query_module,\"\n#endif\n#ifdef SYS_security\n\t  \"security,\"\n#endif\n#ifdef SYS_sgetmask\n\t  \"sgetmask,\"\n#endif\n#ifdef SYS_ssetmask\n\t  \"ssetmask,\"\n#endif\n#ifdef SYS_stty\n\t  \"stty,\"\n#endif\n#ifdef SYS_sysfs\n\t  \"sysfs,\"\n#endif\n#ifdef SYS_tuxcall\n\t  \"tuxcall,\"\n#endif\n#ifdef SYS_ulimit\n\t  \"ulimit,\"\n#endif\n#ifdef SYS_uselib\n\t  \"uselib,\"\n#endif\n#ifdef SYS_ustat\n\t  \"ustat,\"\n#endif\n#ifdef SYS_vserver\n\t  \"vserver\"\n#endif\n#if !defined(SYS__sysctl) && !defined(SYS_afs_syscall) && !defined(SYS_bdflush) && !defined(SYS_break) && !defined(SYS_create_module) && !defined(SYS_ftime) && !defined(SYS_get_kernel_syms) && !defined(SYS_getpmsg) && !defined(SYS_gtty) && !defined(SYS_lock) && !defined(SYS_mpx) && !defined(SYS_prof) && !defined(SYS_profil) && !defined(SYS_putpmsg) && !defined(SYS_query_module) && !defined(SYS_security) && !defined(SYS_sgetmask) && !defined(SYS_ssetmask) && !defined(SYS_stty) && !defined(SYS_sysfs) && !defined(SYS_tuxcall) && !defined(SYS_ulimit) && !defined(SYS_uselib) && !defined(SYS_ustat) && !defined(SYS_vserver)\n\t  \"__dummy_syscall__\" // workaround for arm64 which doesn't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@privileged\", .list =\n\t  \"@clock,\"\n\t  \"@module,\"\n\t  \"@raw-io,\"\n\t  \"@reboot,\"\n\t  \"@swap,\"\n#ifdef SYS_acct\n\t  \"acct,\"\n#endif\n#ifdef SYS_bpf\n\t  \"bpf,\"\n#endif\n#ifdef SYS_chroot\n\t  \"chroot,\"\n#endif\n#ifdef SYS_mount\n\t  \"mount,\"\n#endif\n#ifdef SYS_nfsservctl\n\t  \"nfsservctl,\"\n#endif\n#ifdef SYS_pivot_root\n\t  \"pivot_root,\"\n#endif\n#ifdef SYS_setdomainname\n\t  \"setdomainname,\"\n#endif\n#ifdef SYS_sethostname\n\t  \"sethostname,\"\n#endif\n#ifdef SYS_umount2\n\t  \"umount2,\"\n#endif\n#ifdef SYS_vhangup\n\t  \"vhangup\"\n#endif\n\t},\n\t{ .name = \"@raw-io\", .list =\n#ifdef SYS_ioperm\n\t  \"ioperm,\"\n#endif\n#ifdef SYS_iopl\n\t  \"iopl,\"\n#endif\n#ifdef SYS_pciconfig_iobase\n\t  \"pciconfig_iobase,\"\n#endif\n#ifdef SYS_pciconfig_read\n\t  \"pciconfig_read,\"\n#endif\n#ifdef SYS_pciconfig_write\n\t  \"pciconfig_write,\"\n#endif\n#ifdef SYS_s390_mmio_read\n\t  \"s390_mmio_read,\"\n#endif\n#ifdef SYS_s390_mmio_write\n\t  \"s390_mmio_write\"\n#endif\n#if !defined(SYS_ioperm) && !defined(SYS_iopl) && !defined(SYS_pciconfig_iobase) && !defined(SYS_pciconfig_read) && !defined(SYS_pciconfig_write) && !defined(SYS_s390_mmio_read) && !defined(SYS_s390_mmio_write)\n\t  \"__dummy_syscall__\" // workaround for s390x which doesn't have any of above defined and empty syscall lists are not allowed\n#endif\n\t},\n\t{ .name = \"@reboot\", .list =\n#ifdef SYS_kexec_load\n\t  \"kexec_load,\"\n#endif\n#ifdef SYS_kexec_file_load\n\t  \"kexec_file_load,\"\n#endif\n#ifdef SYS_reboot\n\t  \"reboot,\"\n#endif\n\t},\n\t{ .name = \"@resources\", .list =\n#ifdef SYS_set_mempolicy\n\t  \"set_mempolicy,\"\n#endif\n#ifdef SYS_migrate_pages\n\t  \"migrate_pages,\"\n#endif\n#ifdef SYS_move_pages\n\t  \"move_pages,\"\n#endif\n#ifdef SYS_mbind\n\t  \"mbind\"\n#endif\n\t},\n\t{ .name = \"@swap\", .list =\n#ifdef SYS_swapon\n\t  \"swapon,\"\n#endif\n#ifdef SYS_swapoff\n\t  \"swapoff\"\n#endif\n\t}\n};\n\nstatic const char *syscall_find_group(const char *name) {\n\tint i;\n\tint elems = sizeof(sysgroups) / sizeof(sysgroups[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (strcmp(name, sysgroups[i].name) == 0)\n\t\t\treturn sysgroups[i].list;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "syscall_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
    "lines": "405-412",
    "snippet": "void syscall_print(void) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tprintf(\"%d\\t- %s\\n\", syslist[i].nr, syslist[i].name);\n\t}\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <sys/syscall.h>",
      "#include <stdio.h>",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%d\\t- %s\\n\"",
            "syslist[i].nr",
            "syslist[i].name"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};\n\nvoid syscall_print(void) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tprintf(\"%d\\t- %s\\n\", syslist[i].nr, syslist[i].name);\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "syscall_find_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
    "lines": "394-403",
    "snippet": "const char *syscall_find_nr(int nr) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (nr == syslist[i].nr)\n\t\t\treturn syslist[i].name;\n\t}\n\n\treturn \"unknown\";\n}",
    "includes": [
      "#include <sys/syscall.h>",
      "#include <stdio.h>",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};\n\nconst char *syscall_find_nr(int nr) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (nr == syslist[i].nr)\n\t\t\treturn syslist[i].name;\n\t}\n\n\treturn \"unknown\";\n}"
  },
  {
    "function_name": "syscall_find_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fseccomp/syscall.c",
    "lines": "383-392",
    "snippet": "static int syscall_find_name(const char *name) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (strcmp(name, syslist[i].name) == 0)\n\t\t\treturn syslist[i].nr;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include <sys/syscall.h>",
      "#include <stdio.h>",
      "#include \"fseccomp.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "syslist[i].name"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/syscall.h>\n#include <stdio.h>\n#include \"fseccomp.h\"\n\nstatic const SyscallEntry syslist[] = {\n//\n// code generated using tools/extract-syscall\n//\n#include \"../include/syscall.h\"\n//\n// end of generated code\n//\n};\n\nstatic int syscall_find_name(const char *name) {\n\tint i;\n\tint elems = sizeof(syslist) / sizeof(syslist[0]);\n\tfor (i = 0; i < elems; i++) {\n\t\tif (strcmp(name, syslist[i].name) == 0)\n\t\t\treturn syslist[i].nr;\n\t}\n\n\treturn -1;\n}"
  }
]