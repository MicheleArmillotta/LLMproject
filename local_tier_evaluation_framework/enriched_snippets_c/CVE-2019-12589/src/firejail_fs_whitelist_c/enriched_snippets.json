[
  {
    "function_name": "fs_whitelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_whitelist.c",
    "lines": "331-1070",
    "snippet": "void fs_whitelist(void) {\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\n\tif (asprintf(&runuser, \"/run/user/%u\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\trunuser_len = strlen(runuser);\n\thomedir_len = strlen(cfg.homedir);\n\n\tchar *new_name = NULL;\n\tint home_dir = 0;\t// /home/user directory flag\n\tint tmp_dir = 0;\t// /tmp directory flag\n\tint media_dir = 0;\t// /media directory flag\n\tint mnt_dir = 0;\t// /mnt directory flag\n\tint var_dir = 0;\t\t// /var directory flag\n\tint dev_dir = 0;\t\t// /dev directory flag\n\tint opt_dir = 0;\t\t// /opt directory flag\n\tint srv_dir = 0;                // /srv directory flag\n\tint etc_dir = 0;                // /etc directory flag\n\tint share_dir = 0;                // /usr/share directory flag\n\tint module_dir = 0;                // /sys/module directory flag\n\tint run_dir = 0;                // /run/user/$uid directory flag\n\n\tsize_t nowhitelist_c = 0;\n\tsize_t nowhitelist_m = 32;\n\tchar **nowhitelist = calloc(nowhitelist_m, sizeof(*nowhitelist));\n\tif (nowhitelist == NULL)\n\t\terrExit(\"failed allocating memory for nowhitelist entries\");\n\n\t// verify whitelist files, extract symbolic links, etc.\n\tEUID_USER();\n\tstruct stat s;\n\twhile (entry) {\n\t\tint nowhitelist_flag = 0;\n\n\t\t// handle only whitelist and nowhitelist commands\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0)\n\t\t\tnowhitelist_flag = 0;\n\t\telse if (strncmp(entry->data, \"nowhitelist \", 12) == 0)\n\t\t\tnowhitelist_flag = 1;\n\t\telse {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\tchar *dataptr = (nowhitelist_flag)? entry->data + 12: entry->data + 10;\n\n\t\t// replace ~/ or ${HOME} into /home/username or resolve macro\n\t\tnew_name = expand_macros(dataptr);\n\t\tassert(new_name);\n\n\t\t// mount empty home directory if resolving the macro was not successful\n\t\tif (is_macro(new_name) && macro_id(new_name) > -1) {\n\t\t\t// no warning if home does not exist (e.g. in a chroot)\n\t\t\tif (stat(cfg.homedir, &s) == 0 && !nowhitelist_flag && !arg_private) {\n\t\t\t\thome_dir = 1;\n\t\t\t\tif (!arg_quiet) {\n\t\t\t\t\tfprintf(stderr, \"***\\n\");\n\t\t\t\t\tfprintf(stderr, \"*** Warning: cannot whitelist %s directory\\n\", new_name);\n\t\t\t\t\tfprintf(stderr, \"*** Any file saved in this directory will be lost when the sandbox is closed.\\n\");\n\t\t\t\t\tfprintf(stderr, \"***\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// remove trailing slashes and single dots\n\t\tif (!nowhitelist_flag)\n\t\t\ttrim_trailing_slash_or_dot(new_name);\n\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tfprintf(stderr, \"Debug %d: new_name #%s#, %s\\n\", __LINE__, new_name, (nowhitelist_flag)? \"nowhitelist\": \"whitelist\");\n\n\t\t// valid path referenced to filesystem root\n\t\tif (*new_name != '/') {\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tfprintf(stderr, \"Debug %d: \\n\", __LINE__);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\t// extract the absolute path of the file\n\t\t// realpath function will fail with ENOENT if the file is not found or with EACCES if user has no permission\n\t\t// special processing for /dev/fd, /dev/stdin, /dev/stdout and /dev/stderr\n\t\tchar *fname;\n\t\tif (strcmp(new_name, \"/dev/fd\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd\");\n\t\telse if (strcmp(new_name, \"/dev/stdin\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/0\");\n\t\telse if (strcmp(new_name, \"/dev/stdout\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/1\");\n\t\telse if (strcmp(new_name, \"/dev/stderr\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/2\");\n\t\telse\n\t\t\tfname = realpath(new_name, NULL);\n\n\t\tif (!fname) {\n\t\t\t// file not found, blank the entry in the list and continue\n\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\tprintf(\"Removed whitelist/nowhitelist path: %s\\n\", entry->data);\n\t\t\t\tprintf(\"\\texpanded: %s\\n\", new_name);\n\t\t\t\tprintf(\"\\treal path: (null)\\n\");\n\t\t\t\tprintf(\"\\t\");fflush(0);\n\t\t\t\tperror(\"realpath\");\n\t\t\t}\n\n\t\t\t// if 1 the file was not found; mount an empty directory\n\t\t\tif (!nowhitelist_flag) {\n\t\t\t\tif (strncmp(new_name, cfg.homedir, homedir_len) == 0 && new_name[homedir_len] == '/') {\n\t\t\t\t\tif(!arg_private)\n\t\t\t\t\t\thome_dir = 1;\n\t\t\t\t}\n\t\t\t\telse if (strncmp(new_name, \"/tmp/\", 5) == 0)\n\t\t\t\t\ttmp_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/media/\", 7) == 0)\n\t\t\t\t\tmedia_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/mnt/\", 5) == 0)\n\t\t\t\t\tmnt_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/var/\", 5) == 0)\n\t\t\t\t\tvar_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/dev/\", 5) == 0)\n\t\t\t\t\tdev_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/opt/\", 5) == 0)\n\t\t\t\t\topt_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/srv/\", 5) == 0)\n\t\t\t\t\tsrv_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/etc/\", 5) == 0)\n\t\t\t\t\tetc_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/usr/share/\", 11) == 0)\n\t\t\t\t\tshare_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/sys/module/\", 12) == 0)\n\t\t\t\t\tmodule_dir = 1;\n\t\t\t\telse if (strncmp(new_name, runuser, runuser_len) == 0 && new_name[runuser_len] == '/')\n\t\t\t\t\trun_dir = 1;\n\t\t\t}\n\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (arg_debug_whitelists)\n\t\t\tprintf(\"real path %s\\n\", fname);\n\n\t\tif (nowhitelist_flag) {\n\t\t\t// store the path in nowhitelist array\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Storing nowhitelist %s\\n\", fname);\n\n\t\t\tif (nowhitelist_c >= nowhitelist_m) {\n\t\t\t\tnowhitelist_m *= 2;\n\t\t\t\tnowhitelist = realloc(nowhitelist, sizeof(*nowhitelist) * nowhitelist_m);\n\t\t\t\tif (nowhitelist == NULL)\n\t\t\t\t\terrExit(\"failed increasing memory for nowhitelist entries\");\n\t\t\t}\n\t\t\tnowhitelist[nowhitelist_c++] = fname;\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// check for supported directories\n\t\tif (strncmp(new_name, cfg.homedir, homedir_len) == 0 && new_name[homedir_len] == '/') {\n\t\t\t// whitelisting home directory is disabled if --private option is present\n\t\t\tif (arg_private) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"\\\"%s\\\" disabled by --private\\n\", entry->data);\n\n\t\t\t\tentry->data = EMPTY_STRING;\n\t\t\t\tentry = entry->next;\n\t\t\t\tfree(fname);\n\t\t\t\tfree(new_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tentry->home_dir = 1;\n\t\t\thome_dir = 1;\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tfprintf(stderr, \"Debug %d: fname #%s#, cfg.homedir #%s#\\n\",\n\t\t\t\t\t__LINE__, fname, cfg.homedir);\n\n\t\t\t// both path and absolute path are in user home,\n\t\t\t// if not check if the symlink destination is owned by the user\n\t\t\tif (strncmp(fname, cfg.homedir, homedir_len) != 0 || fname[homedir_len] != '/') {\n\t\t\t\tif (checkcfg(CFG_FOLLOW_SYMLINK_AS_USER)) {\n\t\t\t\t\tif (stat(fname, &s) == 0 && s.st_uid != getuid()) {\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\tgoto errexit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/tmp/\", 5) == 0) {\n\t\t\tentry->tmp_dir = 1;\n\t\t\ttmp_dir = 1;\n\n\t\t\t// both path and absolute path are under /tmp\n\t\t\tif (strncmp(fname, \"/tmp/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/media/\", 7) == 0) {\n\t\t\tentry->media_dir = 1;\n\t\t\tmedia_dir = 1;\n\t\t\t// both path and absolute path are under /media\n\t\t\tif (strncmp(fname, \"/media/\", 7) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/mnt/\", 5) == 0) {\n\t\t\tentry->mnt_dir = 1;\n\t\t\tmnt_dir = 1;\n\t\t\t// both path and absolute path are under /mnt\n\t\t\tif (strncmp(fname, \"/mnt/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/var/\", 5) == 0) {\n\t\t\tentry->var_dir = 1;\n\t\t\tvar_dir = 1;\n\t\t\t// both path and absolute path are under /var\n\t\t\t// exceptions: /var/tmp, /var/run and /var/lock\n\t\t\tif (strcmp(new_name, \"/var/run\")== 0 && strcmp(fname, \"/run\") == 0);\n\t\t\telse if (strcmp(new_name, \"/var/lock\")== 0 && strcmp(fname, \"/run/lock\") == 0);\n\t\t\telse if (strcmp(new_name, \"/var/tmp\")== 0 && strcmp(fname, \"/tmp\") == 0);\n\t\t\telse {\n\t\t\t\t// both path and absolute path are under /var\n\t\t\t\tif (strncmp(fname, \"/var/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/dev/\", 5) == 0) {\n\t\t\tentry->dev_dir = 1;\n\t\t\tdev_dir = 1;\n\t\t\t// special handling for /dev/shm\n\t\t\t// on some platforms (Debian wheezy, Ubuntu 14.04), it is a symlink to /run/shm\n\t\t\tif (strcmp(new_name, \"/dev/shm\") == 0 && strcmp(fname, \"/run/shm\") == 0);\n\t\t\t// special handling for /dev/log, which can be a symlink to /run/systemd/journal/dev-log\n\t\t\telse if (strcmp(new_name, \"/dev/log\") == 0 && strcmp(fname, \"/run/systemd/journal/dev-log\") == 0);\n\t\t\t// special processing for /proc/self/fd files\n\t\t\telse if (strcmp(new_name, \"/dev/fd\") == 0 && strcmp(fname, \"/proc/self/fd\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stdin\") == 0 && strcmp(fname, \"/proc/self/fd/0\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stdout\") == 0 && strcmp(fname, \"/proc/self/fd/1\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stderr\") == 0 && strcmp(fname, \"/proc/self/fd/2\") == 0);\n\t\t\telse {\n\t\t\t\t// both path and absolute path are under /dev\n\t\t\t\tif (strncmp(fname, \"/dev/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/opt/\", 5) == 0) {\n\t\t\tentry->opt_dir = 1;\n\t\t\topt_dir = 1;\n\t\t\t// both path and absolute path are under /dev\n\t\t\tif (strncmp(fname, \"/opt/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/srv/\", 5) == 0) {\n\t\t\tentry->srv_dir = 1;\n\t\t\tsrv_dir = 1;\n\t\t\t// both path and absolute path are under /srv\n\t\t\tif (strncmp(fname, \"/srv/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/etc/\", 5) == 0) {\n\t\t\tentry->etc_dir = 1;\n\t\t\tetc_dir = 1;\n\t\t\t// special handling for some of the symlinks\n\t\t\tif (strcmp(new_name, \"/etc/localtime\") == 0);\n\t\t\telse if (strcmp(new_name, \"/etc/mtab\") == 0);\n\t\t\telse if (strcmp(new_name, \"/etc/os-release\") == 0);\n\t\t\t// both path and absolute path are under /etc\n\t\t\telse {\n\t\t\t\tif (strncmp(fname, \"/etc/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/usr/share/\", 11) == 0) {\n\t\t\tentry->share_dir = 1;\n\t\t\tshare_dir = 1;\n\t\t\t// both path and absolute path are under /etc\n\t\t\tif (strncmp(fname, \"/usr/share/\", 11) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/sys/module/\", 12) == 0) {\n\t\t\tentry->module_dir = 1;\n\t\t\tmodule_dir = 1;\n\t\t\t// both path and absolute path are under /sys/module\n\t\t\tif (strncmp(fname, \"/sys/module/\", 12) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, runuser, runuser_len) == 0 && new_name[runuser_len] == '/') {\n\t\t\tentry->run_dir = 1;\n\t\t\trun_dir = 1;\n\t\t\t// both path and absolute path are under /run/user/$uid\n\t\t\tif (strncmp(fname, runuser, runuser_len) != 0 || fname[runuser_len] != '/') {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfree(fname);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\t// check if the path is in nowhitelist array\n\t\tif (nowhitelist_flag == 0) {\n\t\t\tsize_t i;\n\t\t\tint found = 0;\n\t\t\tfor (i = 0; i < nowhitelist_c; i++) {\n\t\t\t\tif (nowhitelist[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (strcmp(nowhitelist[i], fname) == 0) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"Skip nowhitelisted path %s\\n\", fname);\n\t\t\t\tentry->data = EMPTY_STRING;\n\t\t\t\tentry = entry->next;\n\t\t\t\tfree(fname);\n\t\t\t\tfree(new_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// mark symbolic links\n\t\tif (is_link(new_name))\n\t\t\tentry->link = new_name;\n\t\telse {\n\t\t\tfree(new_name);\n\t\t\tentry->link = NULL;\n\t\t}\n\n\t\t// change file name in entry->data\n\t\tif (strcmp(fname, entry->data + 10) != 0) {\n\t\t\tchar *newdata;\n\t\t\tif (asprintf(&newdata, \"whitelist %s\", fname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tentry->data = newdata;\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Replaced whitelist path: %s\\n\", entry->data);\n\t\t}\n\t\tfree(fname);\n\t\tentry = entry->next;\n\t}\n\n\t// release nowhitelist memory\n\tassert(nowhitelist);\n\tfree(nowhitelist);\n\n\tEUID_ROOT();\n\t// /home/user mountpoint\n\tif (home_dir) {\n\t\t// check if /home/user directory exists\n\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t// keep a copy of real home dir in RUN_WHITELIST_HOME_USER_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_HOME_USER_DIR, 0755, getuid(), getgid());\n\t\t\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_USER_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount a tmpfs and initialize /home/user, overrides --allusers\n\t\t\tfs_private();\n\t\t}\n\t\telse\n\t\t\thome_dir = 0;\n\t}\n\n\t// /tmp mountpoint\n\tif (tmp_dir) {\n\t\t// keep a copy of real /tmp directory in RUN_WHITELIST_TMP_DIR\n\t\tmkdir_attr(RUN_WHITELIST_TMP_DIR, 1777, 0, 0);\n\t\tif (mount(\"/tmp\", RUN_WHITELIST_TMP_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /tmp\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /tmp directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /tmp\");\n\t\tfs_logger(\"tmpfs /tmp\");\n\t}\n\n\t// /media mountpoint\n\tif (media_dir) {\n\t\t// some distros don't have a /media directory\n\t\tif (stat(\"/media\", &s) == 0) {\n\t\t\t// keep a copy of real /media directory in RUN_WHITELIST_MEDIA_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MEDIA_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/media\", RUN_WHITELIST_MEDIA_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /media\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /media directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/media\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /media\");\n\t\t\tfs_logger(\"tmpfs /media\");\n\t\t}\n\t\telse\n\t\t\tmedia_dir = 0;\n\t}\n\n\t// /mnt mountpoint\n\tif (mnt_dir) {\n\t\t// check if /mnt directory exists\n\t\tif (stat(\"/mnt\", &s) == 0) {\n\t\t\t// keep a copy of real /mnt directory in RUN_WHITELIST_MNT_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MNT_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/mnt\", RUN_WHITELIST_MNT_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /mnt\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /mnt directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /mnt\");\n\t\t\tfs_logger(\"tmpfs /mnt\");\n\t\t}\n\t\telse\n\t\t\tmnt_dir = 0;\n\t}\n\n\n\t// /var mountpoint\n\tif (var_dir) {\n\t\t// keep a copy of real /var directory in RUN_WHITELIST_VAR_DIR\n\t\tmkdir_attr(RUN_WHITELIST_VAR_DIR, 0755, 0, 0);\n\t\tif (mount(\"/var\", RUN_WHITELIST_VAR_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /var\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /var directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/var\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /var\");\n\t\tfs_logger(\"tmpfs /var\");\n\t}\n\n\t// /dev mountpoint\n\tif (dev_dir) {\n\t\t// keep a copy of real /dev directory in RUN_WHITELIST_DEV_DIR\n\t\tmkdir_attr(RUN_WHITELIST_DEV_DIR, 0755, 0, 0);\n\t\tif (mount(\"/dev\", RUN_WHITELIST_DEV_DIR, NULL, MS_BIND|MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /dev\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /dev directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /dev\");\n\t\tfs_logger(\"tmpfs /dev\");\n\t}\n\n\t// /opt mountpoint\n\tif (opt_dir) {\n\t\t// check if /opt directory exists\n\t\tif (stat(\"/opt\", &s) == 0) {\n\t\t\t// keep a copy of real /opt directory in RUN_WHITELIST_OPT_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_OPT_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/opt\", RUN_WHITELIST_OPT_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /opt\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /opt directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/opt\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /opt\");\n\t\t\tfs_logger(\"tmpfs /opt\");\n\t\t}\n\t\telse\n\t\t\topt_dir = 0;\n\t}\n\n\t// /srv mountpoint\n\tif (srv_dir) {\n\t\t// check if /srv directory exists\n\t\tif (stat(\"/srv\", &s) == 0) {\n\t\t\t// keep a copy of real /srv directory in RUN_WHITELIST_SRV_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_SRV_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/srv\", RUN_WHITELIST_SRV_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /srv directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/srv\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /srv\");\n\t\t\tfs_logger(\"tmpfs /srv\");\n\t\t}\n\t\telse\n\t\t\tsrv_dir = 0;\n\t}\n\n\t// /etc mountpoint\n\tif (etc_dir) {\n\t\t// check if /etc directory exists\n\t\tif (stat(\"/etc\", &s) == 0) {\n\t\t\t// keep a copy of real /etc directory in RUN_WHITELIST_ETC_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_ETC_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/etc\", RUN_WHITELIST_ETC_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /etc directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/etc\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /etc\");\n\t\t\tfs_logger(\"tmpfs /etc\");\n\t\t}\n\t\telse\n\t\t\tetc_dir = 0;\n\t}\n\n\t// /usr/share mountpoint\n\tif (share_dir) {\n\t\t// check if /usr/share directory exists\n\t\tif (stat(\"/usr/share\", &s) == 0) {\n\t\t\t// keep a copy of real /usr/share directory in RUN_WHITELIST_ETC_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_SHARE_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/usr/share\", RUN_WHITELIST_SHARE_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /usr/share directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/usr/share\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /usr/share\");\n\t\t\tfs_logger(\"tmpfs /usr/share\");\n\t\t}\n\t\telse\n\t\t\tshare_dir = 0;\n\t}\n\n\t// /sys/module mountpoint\n\tif (module_dir) {\n\t\t// check if /sys/module directory exists\n\t\tif (stat(\"/sys/module\", &s) == 0) {\n\t\t\t// keep a copy of real /sys/module directory in RUN_WHITELIST_MODULE_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MODULE_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/sys/module\", RUN_WHITELIST_MODULE_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /sys/module\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /sys/module directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/sys/module\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /sys/module\");\n\t\t\tfs_logger(\"tmpfs /sys/module\");\n\t\t}\n\t\telse\n\t\t\tmodule_dir = 0;\n\t}\n\n\t// /run/user mountpoint\n\tif (run_dir) {\n\t\t// check if /run/user/$uid directory exists\n\t\tif (stat(runuser, &s) == 0) {\n\t\t\t// keep a copy of real /run/user/$uid directory in RUN_WHITELIST_RUN_USER_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_RUN_USER_DIR, 0700, getuid(), getgid());\n\t\t\tif (mount(runuser, RUN_WHITELIST_RUN_USER_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /run/user/$uid\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", runuser);\n\t\t\tchar *options;\n\t\t\tif (asprintf(&options, \"mode=700,uid=%u,gid=%u\", getuid(), getgid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (mount(\"tmpfs\", runuser, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME, options) < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /run/user/<uid>\");\n\t\t\tfree(options);\n\t\t\tfs_logger2(\"tmpfs\", runuser);\n\t\t}\n\t\telse\n\t\t\trun_dir = 0;\n\t}\n\n\n\t// go through profile rules again, and interpret whitelist commands\n\tentry = cfg.profile;\n\twhile (entry) {\n\t\t// handle only whitelist commands\n\t\tif (strncmp(entry->data, \"whitelist \", 10)) {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n//printf(\"here %d#%s#\\n\", __LINE__, entry->data);\n\t\t// whitelist the real file\n\t\twhitelist_path(entry);\n\n\t\t// create the link if any\n\t\tif (entry->link) {\n\t\t\t// if the link is already there, do not bother\n\t\t\tif (lstat(entry->link, &s) != 0) {\n\t\t\t\t// create the path if necessary\n\t\t\t\tint fd = mkpath(entry->link, 0755);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\t\tprintf(\"Debug %d: cannot create symbolic link %s\\n\", __LINE__, entry->link);\n\t\t\t\t\tfree(entry->link);\n\t\t\t\t\tentry->link = NULL;\n\t\t\t\t\tentry = entry->next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// get file name of symlink\n\t\t\t\tconst char *file = gnu_basename(entry->link);\n\t\t\t\t// create the link\n\t\t\t\tint rv = symlinkat(entry->data + 10, fd, file);\n\t\t\t\tif (rv) {\n\t\t\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\t\t\tperror(\"symlink\");\n\t\t\t\t\t\tprintf(\"Debug %d: cannot create symbolic link %s\\n\", __LINE__, entry->link);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"Created symbolic link %s -> %s\\n\", entry->link, entry->data + 10);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tfree(entry->link);\n\t\t\tentry->link = NULL;\n\t\t}\n\n\t\tentry = entry->next;\n\t}\n\n\t// mask the real home directory, currently mounted on RUN_WHITELIST_HOME_DIR\n\tif (home_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_USER_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_USER_DIR);\n\t}\n\n\t// mask the real /tmp directory, currently mounted on RUN_WHITELIST_TMP_DIR\n\tif (tmp_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_TMP_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_TMP_DIR);\n\t}\n\n\t// mask the real /var directory, currently mounted on RUN_WHITELIST_VAR_DIR\n\tif (var_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_VAR_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_VAR_DIR);\n\t}\n\n\t// mask the real /opt directory, currently mounted on RUN_WHITELIST_OPT_DIR\n\tif (opt_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_OPT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_OPT_DIR);\n\t}\n\n\t// mask the real /dev directory, currently mounted on RUN_WHITELIST_DEV_DIR\n\tif (dev_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_DEV_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_DEV_DIR);\n\t}\n\n\t// mask the real /media directory, currently mounted on RUN_WHITELIST_MEDIA_DIR\n\tif (media_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MEDIA_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MEDIA_DIR);\n\t}\n\n\t// mask the real /mnt directory, currently mounted on RUN_WHITELIST_MNT_DIR\n\tif (mnt_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MNT_DIR);\n\t}\n\n\t// mask the real /srv directory, currently mounted on RUN_WHITELIST_SRV_DIR\n\tif (srv_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_SRV_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_SRV_DIR);\n\t}\n\n\t// mask the real /etc directory, currently mounted on RUN_WHITELIST_ETC_DIR\n\tif (etc_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_ETC_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_ETC_DIR);\n\t}\n\n\t// mask the real /usr/share directory, currently mounted on RUN_WHITELIST_SHARE_DIR\n\tif (share_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_SHARE_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_SHARE_DIR);\n\t}\n\n\t// mask the real /sys/module directory, currently mounted on RUN_WHITELIST_MODULE_DIR\n\tif (module_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MODULE_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MODULE_DIR);\n\t}\n\n\t// mask the real /run/user/$uid directory, currently mounted on RUN_WHITELIST_MODULE_DIR\n\tif (run_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_RUN_USER_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_RUN_USER_DIR);\n\t}\n\n\tfree(runuser);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid whitelist path %s\\n\", new_name);\n\texit(1);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define EMPTY_STRING (\"\")"
    ],
    "globals_used": [
      "static size_t homedir_len;",
      "static size_t runuser_len;",
      "static char *runuser;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid whitelist path %s\\n\"",
            "new_name"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "runuser"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_RUN_USER_DIR"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_RUN_USER_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_MODULE_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_SHARE_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_ETC_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_SRV_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_MNT_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_MEDIA_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_DEV_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_OPT_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_VAR_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_TMP_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_HOME_USER_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "entry->link"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Created symbolic link %s -> %s\\n\"",
            "entry->link",
            "entry->data + 10"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Debug %d: cannot create symbolic link %s\\n\"",
            "__LINE__",
            "entry->link"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"symlink\""
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlinkat",
          "args": [
            "entry->data + 10",
            "fd",
            "file"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnu_basename",
          "args": [
            "entry->link"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "gnu_basename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "815-820",
          "snippet": "const char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nconst char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "entry->link"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Debug %d: cannot create symbolic link %s\\n\"",
            "__LINE__",
            "entry->link"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkpath",
          "args": [
            "entry->link",
            "0755"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "mkpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_whitelist.c",
          "lines": "41-113",
          "snippet": "static int mkpath(const char* path, mode_t mode) {\n\tassert(path && *path);\n\tmode |= 0111;\n\n\t// create directories with uid/gid as root or as current user if inside home or run directory\n\tint userprivs = 0;\n\tif (strncmp(path, cfg.homedir, homedir_len) == 0 || strncmp(path, runuser, runuser_len) == 0) {\n\t\tEUID_USER();\n\t\tuserprivs = 1;\n\t}\n\n\t// work on a copy of the path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\t// don't create the last path element\n\tchar *p = strrchr(dup, '/');\n\tassert(p);\n\t*p = '\\0';\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path, return -1 if a symlink is encountered\n\tint done = 0;\n\tint fd = -1;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok); // path is no top level directory\n\twhile (tok) {\n\t\t// create the directory if necessary\n\t\tif (mkdirat(parentfd, tok, mode) == -1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\tclose(parentfd);\n\t\t\t\tfree(dup);\n\t\t\t\tif (userprivs) {\n\t\t\t\t\tEUID_ROOT();\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tdone = 1;\n\t\t// open the directory\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tperror(\"open\");\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\tif (userprivs) {\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t// move on to next path segment\n\t\tclose(parentfd);\n\t\tparentfd = fd;\n\t\ttok = strtok(NULL, \"/\");\n\t}\n\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(dup);\n\tif (userprivs) {\n\t\tEUID_ROOT();\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t homedir_len;",
            "static size_t runuser_len;",
            "static char *runuser;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic size_t homedir_len;\nstatic size_t runuser_len;\nstatic char *runuser;\n\nstatic int mkpath(const char* path, mode_t mode) {\n\tassert(path && *path);\n\tmode |= 0111;\n\n\t// create directories with uid/gid as root or as current user if inside home or run directory\n\tint userprivs = 0;\n\tif (strncmp(path, cfg.homedir, homedir_len) == 0 || strncmp(path, runuser, runuser_len) == 0) {\n\t\tEUID_USER();\n\t\tuserprivs = 1;\n\t}\n\n\t// work on a copy of the path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\t// don't create the last path element\n\tchar *p = strrchr(dup, '/');\n\tassert(p);\n\t*p = '\\0';\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path, return -1 if a symlink is encountered\n\tint done = 0;\n\tint fd = -1;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok); // path is no top level directory\n\twhile (tok) {\n\t\t// create the directory if necessary\n\t\tif (mkdirat(parentfd, tok, mode) == -1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\tclose(parentfd);\n\t\t\t\tfree(dup);\n\t\t\t\tif (userprivs) {\n\t\t\t\t\tEUID_ROOT();\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tdone = 1;\n\t\t// open the directory\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tperror(\"open\");\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\tif (userprivs) {\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t// move on to next path segment\n\t\tclose(parentfd);\n\t\tparentfd = fd;\n\t\ttok = strtok(NULL, \"/\");\n\t}\n\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(dup);\n\tif (userprivs) {\n\t\tEUID_ROOT();\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "entry->link",
            "&s"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "lstat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "453-460",
          "snippet": "int lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char buf[1024];\n\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "whitelist_path",
          "args": [
            "entry"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "whitelist_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_whitelist.c",
          "lines": "115-328",
          "snippet": "static void whitelist_path(ProfileEntry *entry) {\n\tassert(entry);\n\tconst char *path = entry->data + 10;\n\tconst char *fname;\n\tchar *wfile = NULL;\n\n\tif (entry->home_dir) {\n\t\tif (strncmp(path, cfg.homedir, homedir_len) != 0 || path[homedir_len] != '/')\n\t\t\t// either symlink pointing outside home directory\n\t\t\t// or entire home directory, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + homedir_len + 1; // strlen(\"/home/user/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_HOME_USER_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->tmp_dir) {\n\t\tfname = path + 5; // strlen(\"/tmp/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_TMP_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->media_dir) {\n\t\tfname = path + 7; // strlen(\"/media/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MEDIA_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->mnt_dir) {\n\t\tfname = path + 5; // strlen(\"/mnt/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MNT_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->var_dir) {\n\t\tif (strncmp(path, \"/var/\", 5) != 0)\n\t\t\t// symlink pointing outside /var, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/var/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_VAR_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->dev_dir) {\n\t\tif (strncmp(path, \"/dev/\", 5) != 0)\n\t\t\t// symlink pointing outside /dev, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/dev/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_DEV_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->opt_dir) {\n\t\tfname = path + 5; // strlen(\"/opt/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_OPT_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->srv_dir) {\n\t\tfname = path + 5; // strlen(\"/srv/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_SRV_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->etc_dir) {\n\t\tif (strncmp(path, \"/etc/\", 5) != 0)\n\t\t\t// symlink pointing outside /etc, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/etc/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_ETC_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->share_dir) {\n\t\tfname = path + 11; // strlen(\"/usr/share/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_SHARE_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->module_dir) {\n\t\tfname = path + 12; // strlen(\"/sys/module/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MODULE_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->run_dir) {\n\t\tfname = path + runuser_len + 1; // strlen(\"/run/user/$uid/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_RUN_USER_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\tassert(wfile);\n\n\tif (arg_debug || arg_debug_whitelists)\n\t\tprintf(\"Whitelisting %s\\n\", path);\n\n\t// confirm again the mount source exists and there is no symlink\n\tstruct stat wfilestat;\n\tEUID_USER();\n\tint fd = safe_fd(wfile, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tEUID_ROOT();\n\tif (fd == -1) {\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\tif (fstat(fd, &wfilestat) == -1)\n\t\terrExit(\"fstat\");\n\tclose(fd);\n\tif (S_ISLNK(wfilestat.st_mode)) {\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\n#ifdef TEST_MOUNTINFO\n\tprintf(\"TEST_MOUNTINFO\\n\");\n\tpath = \"/etc/.\";\n#endif\n\n\t// create path of the mount target if necessary\n\tint fd2 = mkpath(path, 0755);\n\tif (fd2 == -1) {\n\t\t// something went wrong during path creation or a symlink was found;\n\t\t// if there is a symlink somewhere in the path of the mount target,\n\t\t// assume the file is whitelisted already\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\n\t// get file name of the mount target\n\tconst char *file = gnu_basename(path);\n\n\t// create the mount target if necessary and open it, a symlink is rejected\n\tint fd3 = -1;\n\tif (S_ISDIR(wfilestat.st_mode)) {\n\t\t// directory foo can exist already:\n\t\t// firejail --whitelist=/foo/bar --whitelist=/foo\n\t\tif (mkdirat(fd2, file, 0755) == -1 && errno != EEXIST) {\n\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\tperror(\"mkdir\");\n\t\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\t\t}\n\t\t\tclose(fd2);\n\t\t\tfree(wfile);\n\t\t\treturn;\n\t\t}\n\t\tfd3 = openat(fd2, file, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t}\n\telse {\n\t\t// create an empty file, fails with EEXIST if it is whitelisted already:\n\t\t// firejail --whitelist=/foo --whitelist=/foo/bar\n\t\tfd3 = openat(fd2, file, O_RDONLY|O_CREAT|O_EXCL|O_CLOEXEC, S_IRUSR|S_IWUSR);\n\t}\n\n\tif (fd3 == -1) {\n\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tperror(\"open\");\n\t\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\t\t}\n\t\t}\n\t\tclose(fd2);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\tclose(fd2);\n\n\tfs_logger2(\"whitelist\", path);\n\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd3) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wfile, proc, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(proc);\n\tclose(fd3);\n\n\t// check the last mount operation\n\tMountData *mptr = get_last_mount(); // will do exit(1) if the mount cannot be found\n\n\t// confirm the file was mounted on the right target\n\t// strcmp does not work here, because mptr->dir can be a child mount\n\tsize_t path_len = strlen(path);\n\tif (strncmp(mptr->dir, path, path_len) != 0 ||\n\t   (*(mptr->dir + path_len) != '\\0' && *(mptr->dir + path_len) != '/'))\n\t\terrLogExit(\"invalid whitelist mount\");\n\t// No mounts are allowed on top level directories. A destination such as \"/etc\" is very bad!\n\t//  - there should be more than one '/' char in dest string\n\tif (mptr->dir == strrchr(mptr->dir, '/'))\n\t\terrLogExit(\"invalid whitelist mount\");\n\t// confirm the right file was mounted\n\tint fd4 = safe_fd(path, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd4 == -1)\n\t\terrExit(\"safe_fd\");\n\tstruct stat s;\n\tif (fstat(fd4, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_dev != wfilestat.st_dev || s.st_ino != wfilestat.st_ino)\n\t\terrLogExit(\"invalid whitelist mount\");\n\tclose(fd4);\n\n\tfree(wfile);\n\treturn;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t homedir_len;",
            "static size_t runuser_len;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic size_t homedir_len;\nstatic size_t runuser_len;\n\nstatic void whitelist_path(ProfileEntry *entry) {\n\tassert(entry);\n\tconst char *path = entry->data + 10;\n\tconst char *fname;\n\tchar *wfile = NULL;\n\n\tif (entry->home_dir) {\n\t\tif (strncmp(path, cfg.homedir, homedir_len) != 0 || path[homedir_len] != '/')\n\t\t\t// either symlink pointing outside home directory\n\t\t\t// or entire home directory, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + homedir_len + 1; // strlen(\"/home/user/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_HOME_USER_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->tmp_dir) {\n\t\tfname = path + 5; // strlen(\"/tmp/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_TMP_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->media_dir) {\n\t\tfname = path + 7; // strlen(\"/media/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MEDIA_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->mnt_dir) {\n\t\tfname = path + 5; // strlen(\"/mnt/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MNT_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->var_dir) {\n\t\tif (strncmp(path, \"/var/\", 5) != 0)\n\t\t\t// symlink pointing outside /var, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/var/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_VAR_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->dev_dir) {\n\t\tif (strncmp(path, \"/dev/\", 5) != 0)\n\t\t\t// symlink pointing outside /dev, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/dev/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_DEV_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->opt_dir) {\n\t\tfname = path + 5; // strlen(\"/opt/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_OPT_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->srv_dir) {\n\t\tfname = path + 5; // strlen(\"/srv/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_SRV_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->etc_dir) {\n\t\tif (strncmp(path, \"/etc/\", 5) != 0)\n\t\t\t// symlink pointing outside /etc, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/etc/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_ETC_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->share_dir) {\n\t\tfname = path + 11; // strlen(\"/usr/share/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_SHARE_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->module_dir) {\n\t\tfname = path + 12; // strlen(\"/sys/module/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MODULE_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->run_dir) {\n\t\tfname = path + runuser_len + 1; // strlen(\"/run/user/$uid/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_RUN_USER_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\tassert(wfile);\n\n\tif (arg_debug || arg_debug_whitelists)\n\t\tprintf(\"Whitelisting %s\\n\", path);\n\n\t// confirm again the mount source exists and there is no symlink\n\tstruct stat wfilestat;\n\tEUID_USER();\n\tint fd = safe_fd(wfile, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tEUID_ROOT();\n\tif (fd == -1) {\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\tif (fstat(fd, &wfilestat) == -1)\n\t\terrExit(\"fstat\");\n\tclose(fd);\n\tif (S_ISLNK(wfilestat.st_mode)) {\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\n#ifdef TEST_MOUNTINFO\n\tprintf(\"TEST_MOUNTINFO\\n\");\n\tpath = \"/etc/.\";\n#endif\n\n\t// create path of the mount target if necessary\n\tint fd2 = mkpath(path, 0755);\n\tif (fd2 == -1) {\n\t\t// something went wrong during path creation or a symlink was found;\n\t\t// if there is a symlink somewhere in the path of the mount target,\n\t\t// assume the file is whitelisted already\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\n\t// get file name of the mount target\n\tconst char *file = gnu_basename(path);\n\n\t// create the mount target if necessary and open it, a symlink is rejected\n\tint fd3 = -1;\n\tif (S_ISDIR(wfilestat.st_mode)) {\n\t\t// directory foo can exist already:\n\t\t// firejail --whitelist=/foo/bar --whitelist=/foo\n\t\tif (mkdirat(fd2, file, 0755) == -1 && errno != EEXIST) {\n\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\tperror(\"mkdir\");\n\t\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\t\t}\n\t\t\tclose(fd2);\n\t\t\tfree(wfile);\n\t\t\treturn;\n\t\t}\n\t\tfd3 = openat(fd2, file, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t}\n\telse {\n\t\t// create an empty file, fails with EEXIST if it is whitelisted already:\n\t\t// firejail --whitelist=/foo --whitelist=/foo/bar\n\t\tfd3 = openat(fd2, file, O_RDONLY|O_CREAT|O_EXCL|O_CLOEXEC, S_IRUSR|S_IWUSR);\n\t}\n\n\tif (fd3 == -1) {\n\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tperror(\"open\");\n\t\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\t\t}\n\t\t}\n\t\tclose(fd2);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\tclose(fd2);\n\n\tfs_logger2(\"whitelist\", path);\n\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd3) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wfile, proc, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(proc);\n\tclose(fd3);\n\n\t// check the last mount operation\n\tMountData *mptr = get_last_mount(); // will do exit(1) if the mount cannot be found\n\n\t// confirm the file was mounted on the right target\n\t// strcmp does not work here, because mptr->dir can be a child mount\n\tsize_t path_len = strlen(path);\n\tif (strncmp(mptr->dir, path, path_len) != 0 ||\n\t   (*(mptr->dir + path_len) != '\\0' && *(mptr->dir + path_len) != '/'))\n\t\terrLogExit(\"invalid whitelist mount\");\n\t// No mounts are allowed on top level directories. A destination such as \"/etc\" is very bad!\n\t//  - there should be more than one '/' char in dest string\n\tif (mptr->dir == strrchr(mptr->dir, '/'))\n\t\terrLogExit(\"invalid whitelist mount\");\n\t// confirm the right file was mounted\n\tint fd4 = safe_fd(path, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd4 == -1)\n\t\terrExit(\"safe_fd\");\n\tstruct stat s;\n\tif (fstat(fd4, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_dev != wfilestat.st_dev || s.st_ino != wfilestat.st_ino)\n\t\terrLogExit(\"invalid whitelist mount\");\n\tclose(fd4);\n\n\tfree(wfile);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"whitelist \"",
            "10"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "options"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /run/user/<uid>\""
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "runuser",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME",
            "options"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&options",
            "\"mode=700,uid=%u,gid=%u\"",
            "getuid()",
            "getgid()"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on %s directory\\n\"",
            "runuser"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "runuser",
            "RUN_WHITELIST_RUN_USER_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_attr",
          "args": [
            "RUN_WHITELIST_RUN_USER_DIR",
            "0700",
            "getuid()",
            "getgid()"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1056-1092",
          "snippet": "void mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid) {\n\tassert(fname);\n\tmode &= 07777;\n#if 0\n\tprintf(\"fname %s, uid %d, gid %d, mode %x - \", fname, uid, gid, (unsigned) mode);\n\tif (S_ISLNK(mode))\n\t\tprintf(\"l\");\n\telse if (S_ISDIR(mode))\n\t\tprintf(\"d\");\n\telse if (S_ISCHR(mode))\n\t\tprintf(\"c\");\n\telse if (S_ISBLK(mode))\n\t\tprintf(\"b\");\n\telse if (S_ISSOCK(mode))\n\t\tprintf(\"s\");\n\telse\n\t\tprintf(\"-\");\n\tprintf( (mode & S_IRUSR) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWUSR) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXUSR) ? \"x\" : \"-\");\n\tprintf( (mode & S_IRGRP) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWGRP) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXGRP) ? \"x\" : \"-\");\n\tprintf( (mode & S_IROTH) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWOTH) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXOTH) ? \"x\" : \"-\");\n\tprintf(\"\\n\");\n#endif\n\tif (mkdir(fname, mode) == -1 ||\n\t    chmod(fname, mode) == -1 ||\n\t    chown(fname, uid, gid)) {\n\t    \tfprintf(stderr, \"Error: failed to create %s directory\\n\", fname);\n\t\terrExit(\"mkdir/chmod\");\n\t}\n\n\tASSERT_PERMS(fname, uid, gid, mode);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid) {\n\tassert(fname);\n\tmode &= 07777;\n#if 0\n\tprintf(\"fname %s, uid %d, gid %d, mode %x - \", fname, uid, gid, (unsigned) mode);\n\tif (S_ISLNK(mode))\n\t\tprintf(\"l\");\n\telse if (S_ISDIR(mode))\n\t\tprintf(\"d\");\n\telse if (S_ISCHR(mode))\n\t\tprintf(\"c\");\n\telse if (S_ISBLK(mode))\n\t\tprintf(\"b\");\n\telse if (S_ISSOCK(mode))\n\t\tprintf(\"s\");\n\telse\n\t\tprintf(\"-\");\n\tprintf( (mode & S_IRUSR) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWUSR) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXUSR) ? \"x\" : \"-\");\n\tprintf( (mode & S_IRGRP) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWGRP) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXGRP) ? \"x\" : \"-\");\n\tprintf( (mode & S_IROTH) ? \"r\" : \"-\");\n\tprintf( (mode & S_IWOTH) ? \"w\" : \"-\");\n\tprintf( (mode & S_IXOTH) ? \"x\" : \"-\");\n\tprintf(\"\\n\");\n#endif\n\tif (mkdir(fname, mode) == -1 ||\n\t    chmod(fname, mode) == -1 ||\n\t    chown(fname, uid, gid)) {\n\t    \tfprintf(stderr, \"Error: failed to create %s directory\\n\", fname);\n\t\terrExit(\"mkdir/chmod\");\n\t}\n\n\tASSERT_PERMS(fname, uid, gid, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"tmpfs /sys/module\""
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "120-162",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /sys/module\""
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/sys/module\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /sys/module directory\\n\""
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/sys/module\"",
            "RUN_WHITELIST_MODULE_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /usr/share\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/usr/share\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /usr/share directory\\n\""
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/usr/share\"",
            "RUN_WHITELIST_SHARE_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /etc\""
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/etc\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /etc directory\\n\""
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/etc\"",
            "RUN_WHITELIST_ETC_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /srv\""
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/srv\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /srv directory\\n\""
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/srv\"",
            "RUN_WHITELIST_SRV_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /opt\""
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/opt\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /opt directory\\n\""
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/opt\"",
            "RUN_WHITELIST_OPT_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /dev\""
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/dev\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /dev directory\\n\""
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/dev\"",
            "RUN_WHITELIST_DEV_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "\"mode=755,gid=0\""
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /var\""
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/var\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /var directory\\n\""
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/var\"",
            "RUN_WHITELIST_VAR_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /mnt\""
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/mnt\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /mnt directory\\n\""
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/mnt\"",
            "RUN_WHITELIST_MNT_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /media\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/media\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=755,gid=0\""
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /media directory\\n\""
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/media\"",
            "RUN_WHITELIST_MEDIA_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /tmp\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/tmp\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME",
            "\"mode=1777,gid=0\""
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /tmp directory\\n\""
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/tmp\"",
            "RUN_WHITELIST_TMP_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_private",
          "args": [],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_bin_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_bin.c",
          "lines": "269-313",
          "snippet": "void fs_private_bin_list(void) {\n\tchar *private_list = cfg.bin_private_keep;\n\tassert(private_list);\n\n\t// start timetrace\n\ttimetrace_start();\n\n\t// create /run/firejail/mnt/bin directory\n\tmkdir_attr(RUN_BIN_DIR, 0755, 0, 0);\n\n\tif (arg_debug)\n\t\tprintf(\"Copying files in the new bin directory\\n\");\n\n\t// copy the list of files in the new home directory\n\tchar *dlist = strdup(private_list);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-bin argument\\n\");\n\t\texit(1);\n\t}\n\tglobbing(ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tglobbing(ptr);\n\tfree(dlist);\n\tfs_logger_print();\n\n\t// mount-bind\n\tint i = 0;\n\twhile (paths[i]) {\n\t\tstruct stat s;\n\t\tif (stat(paths[i], &s) == 0) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_BIN_DIR, paths[i]);\n\t\t\tif (mount(RUN_BIN_DIR, paths[i], NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\tfs_logger2(\"tmpfs\", paths[i]);\n\t\t\tfs_logger2(\"mount\", paths[i]);\n\t\t}\n\t\ti++;\n\t}\n\tfmessage(\"%d %s installed in %0.2f ms\\n\", prog_cnt, (prog_cnt == 1)? \"program\": \"programs\", timetrace_end());\n}",
          "includes": [
            "#include <glob.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int prog_cnt = 0;",
            "static char *paths[] = {\n\t\"/usr/local/bin\",\n\t\"/usr/bin\",\n\t\"/bin\",\n\t\"/usr/games\",\n\t\"/usr/local/games\",\n\t\"/usr/local/sbin\",\n\t\"/usr/sbin\",\n\t\"/sbin\",\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <glob.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int prog_cnt = 0;\nstatic char *paths[] = {\n\t\"/usr/local/bin\",\n\t\"/usr/bin\",\n\t\"/bin\",\n\t\"/usr/games\",\n\t\"/usr/local/games\",\n\t\"/usr/local/sbin\",\n\t\"/usr/sbin\",\n\t\"/sbin\",\n\tNULL\n};\n\nvoid fs_private_bin_list(void) {\n\tchar *private_list = cfg.bin_private_keep;\n\tassert(private_list);\n\n\t// start timetrace\n\ttimetrace_start();\n\n\t// create /run/firejail/mnt/bin directory\n\tmkdir_attr(RUN_BIN_DIR, 0755, 0, 0);\n\n\tif (arg_debug)\n\t\tprintf(\"Copying files in the new bin directory\\n\");\n\n\t// copy the list of files in the new home directory\n\tchar *dlist = strdup(private_list);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-bin argument\\n\");\n\t\texit(1);\n\t}\n\tglobbing(ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tglobbing(ptr);\n\tfree(dlist);\n\tfs_logger_print();\n\n\t// mount-bind\n\tint i = 0;\n\twhile (paths[i]) {\n\t\tstruct stat s;\n\t\tif (stat(paths[i], &s) == 0) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_BIN_DIR, paths[i]);\n\t\t\tif (mount(RUN_BIN_DIR, paths[i], NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\tfs_logger2(\"tmpfs\", paths[i]);\n\t\t\tfs_logger2(\"mount\", paths[i]);\n\t\t}\n\t\ti++;\n\t}\n\tfmessage(\"%d %s installed in %0.2f ms\\n\", prog_cnt, (prog_cnt == 1)? \"program\": \"programs\", timetrace_end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "cfg.homedir",
            "RUN_WHITELIST_HOME_USER_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "nowhitelist"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nowhitelist"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Replaced whitelist path: %s\\n\"",
            "entry->data"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&newdata",
            "\"whitelist %s\"",
            "fname"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "entry->data + 10"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_name"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "new_name"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "432-459",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tchar *dup = NULL;\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t// remove trailing slashes and single dots and try again\n\t\t\tdup = strdup(fname);\n\t\t\tif (!dup)\n\t\t\t\terrExit(\"strdup\");\n\t\t\ttrim_trailing_slash_or_dot(dup);\n\t\t\tif (lstat(dup, &s) == 0) {\n\t\t\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\t\t\tfree(dup);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(dup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_name"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Skip nowhitelisted path %s\\n\"",
            "fname"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "nowhitelist[i]",
            "fname"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "runuser",
            "runuser_len"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "runuser",
            "runuser_len"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "\"/sys/module/\"",
            "12"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/sys/module/\"",
            "12"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "\"/usr/share/\"",
            "11"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/usr/share/\"",
            "11"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "\"/etc/\"",
            "5"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/etc/os-release\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/etc/mtab\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/etc/localtime\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/etc/\"",
            "5"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "\"/srv/\"",
            "5"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/srv/\"",
            "5"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "\"/opt/\"",
            "5"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/opt/\"",
            "5"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "\"/dev/\"",
            "5"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/proc/self/fd/2\""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/dev/stderr\""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/proc/self/fd/1\""
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/dev/stdout\""
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/proc/self/fd/0\""
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/dev/stdin\""
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/proc/self/fd\""
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/dev/fd\""
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/run/systemd/journal/dev-log\""
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/dev/log\""
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/run/shm\""
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/dev/shm\""
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/dev/\"",
            "5"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "\"/var/\"",
            "5"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/tmp\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/var/tmp\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/run/lock\""
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/var/lock\""
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/run\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/var/run\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/var/\"",
            "5"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "\"/mnt/\"",
            "5"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/mnt/\"",
            "5"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "\"/media/\"",
            "7"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/media/\"",
            "7"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "\"/tmp/\"",
            "5"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/tmp/\"",
            "5"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_FOLLOW_SYMLINK_AS_USER"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/checkcfg.c",
          "lines": "35-213",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *xpra_extra_params = \"\";",
            "char *xvfb_screen = \"800x600x24\";",
            "char *xvfb_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *xpra_extra_params = \"\";\nchar *xvfb_screen = \"800x600x24\";\nchar *xvfb_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "fname",
            "cfg.homedir",
            "homedir_len"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Debug %d: fname #%s#, cfg.homedir #%s#\\n\"",
            "__LINE__",
            "fname",
            "cfg.homedir"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_name"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\\"%s\\\" disabled by --private\\n\"",
            "entry->data"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "cfg.homedir",
            "homedir_len"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_name"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"failed increasing memory for nowhitelist entries\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "nowhitelist",
            "sizeof(*nowhitelist) * nowhitelist_m"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Storing nowhitelist %s\\n\"",
            "fname"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"real path %s\\n\"",
            "fname"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_name"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "runuser",
            "runuser_len"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/sys/module/\"",
            "12"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/usr/share/\"",
            "11"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/etc/\"",
            "5"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/srv/\"",
            "5"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/opt/\"",
            "5"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/dev/\"",
            "5"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/var/\"",
            "5"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/mnt/\"",
            "5"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/media/\"",
            "7"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "\"/tmp/\"",
            "5"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_name",
            "cfg.homedir",
            "homedir_len"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"realpath\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\t\""
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\treal path: (null)\\n\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\texpanded: %s\\n\"",
            "new_name"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Removed whitelist/nowhitelist path: %s\\n\"",
            "entry->data"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "new_name",
            "NULL"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/proc/self/fd/2\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/dev/stderr\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/proc/self/fd/1\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/dev/stdout\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/proc/self/fd/0\""
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/dev/stdin\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/proc/self/fd\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_name",
            "\"/dev/fd\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Debug %d: \\n\"",
            "__LINE__"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Debug %d: new_name #%s#, %s\\n\"",
            "__LINE__",
            "new_name",
            "(nowhitelist_flag)? \"nowhitelist\": \"whitelist\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trim_trailing_slash_or_dot",
          "args": [
            "new_name"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "trim_trailing_slash_or_dot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "463-477",
          "snippet": "void trim_trailing_slash_or_dot(char *path) {\n\tassert(path);\n\n\tchar *end = strchr(path, '\\0');\n\tif ((end - path) > 1) {\n\t\tend--;\n\t\twhile (*end == '/' ||\n\t\t      (*end == '.' && *(end - 1) == '/')) {\n\t\t\t*end = '\\0';\n\t\t\tend--;\n\t\t\tif (end == path)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid trim_trailing_slash_or_dot(char *path) {\n\tassert(path);\n\n\tchar *end = strchr(path, '\\0');\n\tif ((end - path) > 1) {\n\t\tend--;\n\t\twhile (*end == '/' ||\n\t\t      (*end == '.' && *(end - 1) == '/')) {\n\t\t\t*end = '\\0';\n\t\t\tend--;\n\t\t\tif (end == path)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_name"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"***\\n\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*** Any file saved in this directory will be lost when the sandbox is closed.\\n\""
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*** Warning: cannot whitelist %s directory\\n\"",
            "new_name"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"***\\n\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macro_id",
          "args": [
            "new_name"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_macro",
          "args": [
            "new_name"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "new_name"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_macros",
          "args": [
            "dataptr"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"nowhitelist \"",
            "12"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"whitelist \"",
            "10"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"failed allocating memory for nowhitelist entries\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "nowhitelist_m",
            "sizeof(*nowhitelist)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg.homedir"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&runuser",
            "\"/run/user/%u\"",
            "getuid()"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nstatic size_t homedir_len;\nstatic size_t runuser_len;\nstatic char *runuser;\n\nvoid fs_whitelist(void) {\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\n\tif (asprintf(&runuser, \"/run/user/%u\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\trunuser_len = strlen(runuser);\n\thomedir_len = strlen(cfg.homedir);\n\n\tchar *new_name = NULL;\n\tint home_dir = 0;\t// /home/user directory flag\n\tint tmp_dir = 0;\t// /tmp directory flag\n\tint media_dir = 0;\t// /media directory flag\n\tint mnt_dir = 0;\t// /mnt directory flag\n\tint var_dir = 0;\t\t// /var directory flag\n\tint dev_dir = 0;\t\t// /dev directory flag\n\tint opt_dir = 0;\t\t// /opt directory flag\n\tint srv_dir = 0;                // /srv directory flag\n\tint etc_dir = 0;                // /etc directory flag\n\tint share_dir = 0;                // /usr/share directory flag\n\tint module_dir = 0;                // /sys/module directory flag\n\tint run_dir = 0;                // /run/user/$uid directory flag\n\n\tsize_t nowhitelist_c = 0;\n\tsize_t nowhitelist_m = 32;\n\tchar **nowhitelist = calloc(nowhitelist_m, sizeof(*nowhitelist));\n\tif (nowhitelist == NULL)\n\t\terrExit(\"failed allocating memory for nowhitelist entries\");\n\n\t// verify whitelist files, extract symbolic links, etc.\n\tEUID_USER();\n\tstruct stat s;\n\twhile (entry) {\n\t\tint nowhitelist_flag = 0;\n\n\t\t// handle only whitelist and nowhitelist commands\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0)\n\t\t\tnowhitelist_flag = 0;\n\t\telse if (strncmp(entry->data, \"nowhitelist \", 12) == 0)\n\t\t\tnowhitelist_flag = 1;\n\t\telse {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\tchar *dataptr = (nowhitelist_flag)? entry->data + 12: entry->data + 10;\n\n\t\t// replace ~/ or ${HOME} into /home/username or resolve macro\n\t\tnew_name = expand_macros(dataptr);\n\t\tassert(new_name);\n\n\t\t// mount empty home directory if resolving the macro was not successful\n\t\tif (is_macro(new_name) && macro_id(new_name) > -1) {\n\t\t\t// no warning if home does not exist (e.g. in a chroot)\n\t\t\tif (stat(cfg.homedir, &s) == 0 && !nowhitelist_flag && !arg_private) {\n\t\t\t\thome_dir = 1;\n\t\t\t\tif (!arg_quiet) {\n\t\t\t\t\tfprintf(stderr, \"***\\n\");\n\t\t\t\t\tfprintf(stderr, \"*** Warning: cannot whitelist %s directory\\n\", new_name);\n\t\t\t\t\tfprintf(stderr, \"*** Any file saved in this directory will be lost when the sandbox is closed.\\n\");\n\t\t\t\t\tfprintf(stderr, \"***\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// remove trailing slashes and single dots\n\t\tif (!nowhitelist_flag)\n\t\t\ttrim_trailing_slash_or_dot(new_name);\n\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tfprintf(stderr, \"Debug %d: new_name #%s#, %s\\n\", __LINE__, new_name, (nowhitelist_flag)? \"nowhitelist\": \"whitelist\");\n\n\t\t// valid path referenced to filesystem root\n\t\tif (*new_name != '/') {\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tfprintf(stderr, \"Debug %d: \\n\", __LINE__);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\t// extract the absolute path of the file\n\t\t// realpath function will fail with ENOENT if the file is not found or with EACCES if user has no permission\n\t\t// special processing for /dev/fd, /dev/stdin, /dev/stdout and /dev/stderr\n\t\tchar *fname;\n\t\tif (strcmp(new_name, \"/dev/fd\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd\");\n\t\telse if (strcmp(new_name, \"/dev/stdin\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/0\");\n\t\telse if (strcmp(new_name, \"/dev/stdout\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/1\");\n\t\telse if (strcmp(new_name, \"/dev/stderr\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/2\");\n\t\telse\n\t\t\tfname = realpath(new_name, NULL);\n\n\t\tif (!fname) {\n\t\t\t// file not found, blank the entry in the list and continue\n\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\tprintf(\"Removed whitelist/nowhitelist path: %s\\n\", entry->data);\n\t\t\t\tprintf(\"\\texpanded: %s\\n\", new_name);\n\t\t\t\tprintf(\"\\treal path: (null)\\n\");\n\t\t\t\tprintf(\"\\t\");fflush(0);\n\t\t\t\tperror(\"realpath\");\n\t\t\t}\n\n\t\t\t// if 1 the file was not found; mount an empty directory\n\t\t\tif (!nowhitelist_flag) {\n\t\t\t\tif (strncmp(new_name, cfg.homedir, homedir_len) == 0 && new_name[homedir_len] == '/') {\n\t\t\t\t\tif(!arg_private)\n\t\t\t\t\t\thome_dir = 1;\n\t\t\t\t}\n\t\t\t\telse if (strncmp(new_name, \"/tmp/\", 5) == 0)\n\t\t\t\t\ttmp_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/media/\", 7) == 0)\n\t\t\t\t\tmedia_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/mnt/\", 5) == 0)\n\t\t\t\t\tmnt_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/var/\", 5) == 0)\n\t\t\t\t\tvar_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/dev/\", 5) == 0)\n\t\t\t\t\tdev_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/opt/\", 5) == 0)\n\t\t\t\t\topt_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/srv/\", 5) == 0)\n\t\t\t\t\tsrv_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/etc/\", 5) == 0)\n\t\t\t\t\tetc_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/usr/share/\", 11) == 0)\n\t\t\t\t\tshare_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/sys/module/\", 12) == 0)\n\t\t\t\t\tmodule_dir = 1;\n\t\t\t\telse if (strncmp(new_name, runuser, runuser_len) == 0 && new_name[runuser_len] == '/')\n\t\t\t\t\trun_dir = 1;\n\t\t\t}\n\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (arg_debug_whitelists)\n\t\t\tprintf(\"real path %s\\n\", fname);\n\n\t\tif (nowhitelist_flag) {\n\t\t\t// store the path in nowhitelist array\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Storing nowhitelist %s\\n\", fname);\n\n\t\t\tif (nowhitelist_c >= nowhitelist_m) {\n\t\t\t\tnowhitelist_m *= 2;\n\t\t\t\tnowhitelist = realloc(nowhitelist, sizeof(*nowhitelist) * nowhitelist_m);\n\t\t\t\tif (nowhitelist == NULL)\n\t\t\t\t\terrExit(\"failed increasing memory for nowhitelist entries\");\n\t\t\t}\n\t\t\tnowhitelist[nowhitelist_c++] = fname;\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// check for supported directories\n\t\tif (strncmp(new_name, cfg.homedir, homedir_len) == 0 && new_name[homedir_len] == '/') {\n\t\t\t// whitelisting home directory is disabled if --private option is present\n\t\t\tif (arg_private) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"\\\"%s\\\" disabled by --private\\n\", entry->data);\n\n\t\t\t\tentry->data = EMPTY_STRING;\n\t\t\t\tentry = entry->next;\n\t\t\t\tfree(fname);\n\t\t\t\tfree(new_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tentry->home_dir = 1;\n\t\t\thome_dir = 1;\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tfprintf(stderr, \"Debug %d: fname #%s#, cfg.homedir #%s#\\n\",\n\t\t\t\t\t__LINE__, fname, cfg.homedir);\n\n\t\t\t// both path and absolute path are in user home,\n\t\t\t// if not check if the symlink destination is owned by the user\n\t\t\tif (strncmp(fname, cfg.homedir, homedir_len) != 0 || fname[homedir_len] != '/') {\n\t\t\t\tif (checkcfg(CFG_FOLLOW_SYMLINK_AS_USER)) {\n\t\t\t\t\tif (stat(fname, &s) == 0 && s.st_uid != getuid()) {\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\tgoto errexit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/tmp/\", 5) == 0) {\n\t\t\tentry->tmp_dir = 1;\n\t\t\ttmp_dir = 1;\n\n\t\t\t// both path and absolute path are under /tmp\n\t\t\tif (strncmp(fname, \"/tmp/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/media/\", 7) == 0) {\n\t\t\tentry->media_dir = 1;\n\t\t\tmedia_dir = 1;\n\t\t\t// both path and absolute path are under /media\n\t\t\tif (strncmp(fname, \"/media/\", 7) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/mnt/\", 5) == 0) {\n\t\t\tentry->mnt_dir = 1;\n\t\t\tmnt_dir = 1;\n\t\t\t// both path and absolute path are under /mnt\n\t\t\tif (strncmp(fname, \"/mnt/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/var/\", 5) == 0) {\n\t\t\tentry->var_dir = 1;\n\t\t\tvar_dir = 1;\n\t\t\t// both path and absolute path are under /var\n\t\t\t// exceptions: /var/tmp, /var/run and /var/lock\n\t\t\tif (strcmp(new_name, \"/var/run\")== 0 && strcmp(fname, \"/run\") == 0);\n\t\t\telse if (strcmp(new_name, \"/var/lock\")== 0 && strcmp(fname, \"/run/lock\") == 0);\n\t\t\telse if (strcmp(new_name, \"/var/tmp\")== 0 && strcmp(fname, \"/tmp\") == 0);\n\t\t\telse {\n\t\t\t\t// both path and absolute path are under /var\n\t\t\t\tif (strncmp(fname, \"/var/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/dev/\", 5) == 0) {\n\t\t\tentry->dev_dir = 1;\n\t\t\tdev_dir = 1;\n\t\t\t// special handling for /dev/shm\n\t\t\t// on some platforms (Debian wheezy, Ubuntu 14.04), it is a symlink to /run/shm\n\t\t\tif (strcmp(new_name, \"/dev/shm\") == 0 && strcmp(fname, \"/run/shm\") == 0);\n\t\t\t// special handling for /dev/log, which can be a symlink to /run/systemd/journal/dev-log\n\t\t\telse if (strcmp(new_name, \"/dev/log\") == 0 && strcmp(fname, \"/run/systemd/journal/dev-log\") == 0);\n\t\t\t// special processing for /proc/self/fd files\n\t\t\telse if (strcmp(new_name, \"/dev/fd\") == 0 && strcmp(fname, \"/proc/self/fd\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stdin\") == 0 && strcmp(fname, \"/proc/self/fd/0\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stdout\") == 0 && strcmp(fname, \"/proc/self/fd/1\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stderr\") == 0 && strcmp(fname, \"/proc/self/fd/2\") == 0);\n\t\t\telse {\n\t\t\t\t// both path and absolute path are under /dev\n\t\t\t\tif (strncmp(fname, \"/dev/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/opt/\", 5) == 0) {\n\t\t\tentry->opt_dir = 1;\n\t\t\topt_dir = 1;\n\t\t\t// both path and absolute path are under /dev\n\t\t\tif (strncmp(fname, \"/opt/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/srv/\", 5) == 0) {\n\t\t\tentry->srv_dir = 1;\n\t\t\tsrv_dir = 1;\n\t\t\t// both path and absolute path are under /srv\n\t\t\tif (strncmp(fname, \"/srv/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/etc/\", 5) == 0) {\n\t\t\tentry->etc_dir = 1;\n\t\t\tetc_dir = 1;\n\t\t\t// special handling for some of the symlinks\n\t\t\tif (strcmp(new_name, \"/etc/localtime\") == 0);\n\t\t\telse if (strcmp(new_name, \"/etc/mtab\") == 0);\n\t\t\telse if (strcmp(new_name, \"/etc/os-release\") == 0);\n\t\t\t// both path and absolute path are under /etc\n\t\t\telse {\n\t\t\t\tif (strncmp(fname, \"/etc/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/usr/share/\", 11) == 0) {\n\t\t\tentry->share_dir = 1;\n\t\t\tshare_dir = 1;\n\t\t\t// both path and absolute path are under /etc\n\t\t\tif (strncmp(fname, \"/usr/share/\", 11) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/sys/module/\", 12) == 0) {\n\t\t\tentry->module_dir = 1;\n\t\t\tmodule_dir = 1;\n\t\t\t// both path and absolute path are under /sys/module\n\t\t\tif (strncmp(fname, \"/sys/module/\", 12) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, runuser, runuser_len) == 0 && new_name[runuser_len] == '/') {\n\t\t\tentry->run_dir = 1;\n\t\t\trun_dir = 1;\n\t\t\t// both path and absolute path are under /run/user/$uid\n\t\t\tif (strncmp(fname, runuser, runuser_len) != 0 || fname[runuser_len] != '/') {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfree(fname);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\t// check if the path is in nowhitelist array\n\t\tif (nowhitelist_flag == 0) {\n\t\t\tsize_t i;\n\t\t\tint found = 0;\n\t\t\tfor (i = 0; i < nowhitelist_c; i++) {\n\t\t\t\tif (nowhitelist[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (strcmp(nowhitelist[i], fname) == 0) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"Skip nowhitelisted path %s\\n\", fname);\n\t\t\t\tentry->data = EMPTY_STRING;\n\t\t\t\tentry = entry->next;\n\t\t\t\tfree(fname);\n\t\t\t\tfree(new_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// mark symbolic links\n\t\tif (is_link(new_name))\n\t\t\tentry->link = new_name;\n\t\telse {\n\t\t\tfree(new_name);\n\t\t\tentry->link = NULL;\n\t\t}\n\n\t\t// change file name in entry->data\n\t\tif (strcmp(fname, entry->data + 10) != 0) {\n\t\t\tchar *newdata;\n\t\t\tif (asprintf(&newdata, \"whitelist %s\", fname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tentry->data = newdata;\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Replaced whitelist path: %s\\n\", entry->data);\n\t\t}\n\t\tfree(fname);\n\t\tentry = entry->next;\n\t}\n\n\t// release nowhitelist memory\n\tassert(nowhitelist);\n\tfree(nowhitelist);\n\n\tEUID_ROOT();\n\t// /home/user mountpoint\n\tif (home_dir) {\n\t\t// check if /home/user directory exists\n\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t// keep a copy of real home dir in RUN_WHITELIST_HOME_USER_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_HOME_USER_DIR, 0755, getuid(), getgid());\n\t\t\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_USER_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount a tmpfs and initialize /home/user, overrides --allusers\n\t\t\tfs_private();\n\t\t}\n\t\telse\n\t\t\thome_dir = 0;\n\t}\n\n\t// /tmp mountpoint\n\tif (tmp_dir) {\n\t\t// keep a copy of real /tmp directory in RUN_WHITELIST_TMP_DIR\n\t\tmkdir_attr(RUN_WHITELIST_TMP_DIR, 1777, 0, 0);\n\t\tif (mount(\"/tmp\", RUN_WHITELIST_TMP_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /tmp\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /tmp directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /tmp\");\n\t\tfs_logger(\"tmpfs /tmp\");\n\t}\n\n\t// /media mountpoint\n\tif (media_dir) {\n\t\t// some distros don't have a /media directory\n\t\tif (stat(\"/media\", &s) == 0) {\n\t\t\t// keep a copy of real /media directory in RUN_WHITELIST_MEDIA_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MEDIA_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/media\", RUN_WHITELIST_MEDIA_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /media\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /media directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/media\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /media\");\n\t\t\tfs_logger(\"tmpfs /media\");\n\t\t}\n\t\telse\n\t\t\tmedia_dir = 0;\n\t}\n\n\t// /mnt mountpoint\n\tif (mnt_dir) {\n\t\t// check if /mnt directory exists\n\t\tif (stat(\"/mnt\", &s) == 0) {\n\t\t\t// keep a copy of real /mnt directory in RUN_WHITELIST_MNT_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MNT_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/mnt\", RUN_WHITELIST_MNT_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /mnt\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /mnt directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /mnt\");\n\t\t\tfs_logger(\"tmpfs /mnt\");\n\t\t}\n\t\telse\n\t\t\tmnt_dir = 0;\n\t}\n\n\n\t// /var mountpoint\n\tif (var_dir) {\n\t\t// keep a copy of real /var directory in RUN_WHITELIST_VAR_DIR\n\t\tmkdir_attr(RUN_WHITELIST_VAR_DIR, 0755, 0, 0);\n\t\tif (mount(\"/var\", RUN_WHITELIST_VAR_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /var\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /var directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/var\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /var\");\n\t\tfs_logger(\"tmpfs /var\");\n\t}\n\n\t// /dev mountpoint\n\tif (dev_dir) {\n\t\t// keep a copy of real /dev directory in RUN_WHITELIST_DEV_DIR\n\t\tmkdir_attr(RUN_WHITELIST_DEV_DIR, 0755, 0, 0);\n\t\tif (mount(\"/dev\", RUN_WHITELIST_DEV_DIR, NULL, MS_BIND|MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /dev\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /dev directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /dev\");\n\t\tfs_logger(\"tmpfs /dev\");\n\t}\n\n\t// /opt mountpoint\n\tif (opt_dir) {\n\t\t// check if /opt directory exists\n\t\tif (stat(\"/opt\", &s) == 0) {\n\t\t\t// keep a copy of real /opt directory in RUN_WHITELIST_OPT_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_OPT_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/opt\", RUN_WHITELIST_OPT_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /opt\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /opt directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/opt\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /opt\");\n\t\t\tfs_logger(\"tmpfs /opt\");\n\t\t}\n\t\telse\n\t\t\topt_dir = 0;\n\t}\n\n\t// /srv mountpoint\n\tif (srv_dir) {\n\t\t// check if /srv directory exists\n\t\tif (stat(\"/srv\", &s) == 0) {\n\t\t\t// keep a copy of real /srv directory in RUN_WHITELIST_SRV_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_SRV_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/srv\", RUN_WHITELIST_SRV_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /srv directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/srv\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /srv\");\n\t\t\tfs_logger(\"tmpfs /srv\");\n\t\t}\n\t\telse\n\t\t\tsrv_dir = 0;\n\t}\n\n\t// /etc mountpoint\n\tif (etc_dir) {\n\t\t// check if /etc directory exists\n\t\tif (stat(\"/etc\", &s) == 0) {\n\t\t\t// keep a copy of real /etc directory in RUN_WHITELIST_ETC_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_ETC_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/etc\", RUN_WHITELIST_ETC_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /etc directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/etc\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /etc\");\n\t\t\tfs_logger(\"tmpfs /etc\");\n\t\t}\n\t\telse\n\t\t\tetc_dir = 0;\n\t}\n\n\t// /usr/share mountpoint\n\tif (share_dir) {\n\t\t// check if /usr/share directory exists\n\t\tif (stat(\"/usr/share\", &s) == 0) {\n\t\t\t// keep a copy of real /usr/share directory in RUN_WHITELIST_ETC_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_SHARE_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/usr/share\", RUN_WHITELIST_SHARE_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /usr/share directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/usr/share\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /usr/share\");\n\t\t\tfs_logger(\"tmpfs /usr/share\");\n\t\t}\n\t\telse\n\t\t\tshare_dir = 0;\n\t}\n\n\t// /sys/module mountpoint\n\tif (module_dir) {\n\t\t// check if /sys/module directory exists\n\t\tif (stat(\"/sys/module\", &s) == 0) {\n\t\t\t// keep a copy of real /sys/module directory in RUN_WHITELIST_MODULE_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MODULE_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/sys/module\", RUN_WHITELIST_MODULE_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /sys/module\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /sys/module directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/sys/module\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /sys/module\");\n\t\t\tfs_logger(\"tmpfs /sys/module\");\n\t\t}\n\t\telse\n\t\t\tmodule_dir = 0;\n\t}\n\n\t// /run/user mountpoint\n\tif (run_dir) {\n\t\t// check if /run/user/$uid directory exists\n\t\tif (stat(runuser, &s) == 0) {\n\t\t\t// keep a copy of real /run/user/$uid directory in RUN_WHITELIST_RUN_USER_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_RUN_USER_DIR, 0700, getuid(), getgid());\n\t\t\tif (mount(runuser, RUN_WHITELIST_RUN_USER_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /run/user/$uid\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", runuser);\n\t\t\tchar *options;\n\t\t\tif (asprintf(&options, \"mode=700,uid=%u,gid=%u\", getuid(), getgid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (mount(\"tmpfs\", runuser, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME, options) < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /run/user/<uid>\");\n\t\t\tfree(options);\n\t\t\tfs_logger2(\"tmpfs\", runuser);\n\t\t}\n\t\telse\n\t\t\trun_dir = 0;\n\t}\n\n\n\t// go through profile rules again, and interpret whitelist commands\n\tentry = cfg.profile;\n\twhile (entry) {\n\t\t// handle only whitelist commands\n\t\tif (strncmp(entry->data, \"whitelist \", 10)) {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n//printf(\"here %d#%s#\\n\", __LINE__, entry->data);\n\t\t// whitelist the real file\n\t\twhitelist_path(entry);\n\n\t\t// create the link if any\n\t\tif (entry->link) {\n\t\t\t// if the link is already there, do not bother\n\t\t\tif (lstat(entry->link, &s) != 0) {\n\t\t\t\t// create the path if necessary\n\t\t\t\tint fd = mkpath(entry->link, 0755);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\t\tprintf(\"Debug %d: cannot create symbolic link %s\\n\", __LINE__, entry->link);\n\t\t\t\t\tfree(entry->link);\n\t\t\t\t\tentry->link = NULL;\n\t\t\t\t\tentry = entry->next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// get file name of symlink\n\t\t\t\tconst char *file = gnu_basename(entry->link);\n\t\t\t\t// create the link\n\t\t\t\tint rv = symlinkat(entry->data + 10, fd, file);\n\t\t\t\tif (rv) {\n\t\t\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\t\t\tperror(\"symlink\");\n\t\t\t\t\t\tprintf(\"Debug %d: cannot create symbolic link %s\\n\", __LINE__, entry->link);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"Created symbolic link %s -> %s\\n\", entry->link, entry->data + 10);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tfree(entry->link);\n\t\t\tentry->link = NULL;\n\t\t}\n\n\t\tentry = entry->next;\n\t}\n\n\t// mask the real home directory, currently mounted on RUN_WHITELIST_HOME_DIR\n\tif (home_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_USER_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_USER_DIR);\n\t}\n\n\t// mask the real /tmp directory, currently mounted on RUN_WHITELIST_TMP_DIR\n\tif (tmp_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_TMP_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_TMP_DIR);\n\t}\n\n\t// mask the real /var directory, currently mounted on RUN_WHITELIST_VAR_DIR\n\tif (var_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_VAR_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_VAR_DIR);\n\t}\n\n\t// mask the real /opt directory, currently mounted on RUN_WHITELIST_OPT_DIR\n\tif (opt_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_OPT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_OPT_DIR);\n\t}\n\n\t// mask the real /dev directory, currently mounted on RUN_WHITELIST_DEV_DIR\n\tif (dev_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_DEV_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_DEV_DIR);\n\t}\n\n\t// mask the real /media directory, currently mounted on RUN_WHITELIST_MEDIA_DIR\n\tif (media_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MEDIA_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MEDIA_DIR);\n\t}\n\n\t// mask the real /mnt directory, currently mounted on RUN_WHITELIST_MNT_DIR\n\tif (mnt_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MNT_DIR);\n\t}\n\n\t// mask the real /srv directory, currently mounted on RUN_WHITELIST_SRV_DIR\n\tif (srv_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_SRV_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_SRV_DIR);\n\t}\n\n\t// mask the real /etc directory, currently mounted on RUN_WHITELIST_ETC_DIR\n\tif (etc_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_ETC_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_ETC_DIR);\n\t}\n\n\t// mask the real /usr/share directory, currently mounted on RUN_WHITELIST_SHARE_DIR\n\tif (share_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_SHARE_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_SHARE_DIR);\n\t}\n\n\t// mask the real /sys/module directory, currently mounted on RUN_WHITELIST_MODULE_DIR\n\tif (module_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MODULE_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MODULE_DIR);\n\t}\n\n\t// mask the real /run/user/$uid directory, currently mounted on RUN_WHITELIST_MODULE_DIR\n\tif (run_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_RUN_USER_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_RUN_USER_DIR);\n\t}\n\n\tfree(runuser);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid whitelist path %s\\n\", new_name);\n\texit(1);\n}"
  },
  {
    "function_name": "whitelist_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_whitelist.c",
    "lines": "115-328",
    "snippet": "static void whitelist_path(ProfileEntry *entry) {\n\tassert(entry);\n\tconst char *path = entry->data + 10;\n\tconst char *fname;\n\tchar *wfile = NULL;\n\n\tif (entry->home_dir) {\n\t\tif (strncmp(path, cfg.homedir, homedir_len) != 0 || path[homedir_len] != '/')\n\t\t\t// either symlink pointing outside home directory\n\t\t\t// or entire home directory, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + homedir_len + 1; // strlen(\"/home/user/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_HOME_USER_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->tmp_dir) {\n\t\tfname = path + 5; // strlen(\"/tmp/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_TMP_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->media_dir) {\n\t\tfname = path + 7; // strlen(\"/media/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MEDIA_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->mnt_dir) {\n\t\tfname = path + 5; // strlen(\"/mnt/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MNT_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->var_dir) {\n\t\tif (strncmp(path, \"/var/\", 5) != 0)\n\t\t\t// symlink pointing outside /var, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/var/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_VAR_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->dev_dir) {\n\t\tif (strncmp(path, \"/dev/\", 5) != 0)\n\t\t\t// symlink pointing outside /dev, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/dev/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_DEV_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->opt_dir) {\n\t\tfname = path + 5; // strlen(\"/opt/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_OPT_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->srv_dir) {\n\t\tfname = path + 5; // strlen(\"/srv/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_SRV_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->etc_dir) {\n\t\tif (strncmp(path, \"/etc/\", 5) != 0)\n\t\t\t// symlink pointing outside /etc, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/etc/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_ETC_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->share_dir) {\n\t\tfname = path + 11; // strlen(\"/usr/share/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_SHARE_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->module_dir) {\n\t\tfname = path + 12; // strlen(\"/sys/module/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MODULE_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->run_dir) {\n\t\tfname = path + runuser_len + 1; // strlen(\"/run/user/$uid/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_RUN_USER_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\tassert(wfile);\n\n\tif (arg_debug || arg_debug_whitelists)\n\t\tprintf(\"Whitelisting %s\\n\", path);\n\n\t// confirm again the mount source exists and there is no symlink\n\tstruct stat wfilestat;\n\tEUID_USER();\n\tint fd = safe_fd(wfile, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tEUID_ROOT();\n\tif (fd == -1) {\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\tif (fstat(fd, &wfilestat) == -1)\n\t\terrExit(\"fstat\");\n\tclose(fd);\n\tif (S_ISLNK(wfilestat.st_mode)) {\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\n#ifdef TEST_MOUNTINFO\n\tprintf(\"TEST_MOUNTINFO\\n\");\n\tpath = \"/etc/.\";\n#endif\n\n\t// create path of the mount target if necessary\n\tint fd2 = mkpath(path, 0755);\n\tif (fd2 == -1) {\n\t\t// something went wrong during path creation or a symlink was found;\n\t\t// if there is a symlink somewhere in the path of the mount target,\n\t\t// assume the file is whitelisted already\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\n\t// get file name of the mount target\n\tconst char *file = gnu_basename(path);\n\n\t// create the mount target if necessary and open it, a symlink is rejected\n\tint fd3 = -1;\n\tif (S_ISDIR(wfilestat.st_mode)) {\n\t\t// directory foo can exist already:\n\t\t// firejail --whitelist=/foo/bar --whitelist=/foo\n\t\tif (mkdirat(fd2, file, 0755) == -1 && errno != EEXIST) {\n\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\tperror(\"mkdir\");\n\t\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\t\t}\n\t\t\tclose(fd2);\n\t\t\tfree(wfile);\n\t\t\treturn;\n\t\t}\n\t\tfd3 = openat(fd2, file, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t}\n\telse {\n\t\t// create an empty file, fails with EEXIST if it is whitelisted already:\n\t\t// firejail --whitelist=/foo --whitelist=/foo/bar\n\t\tfd3 = openat(fd2, file, O_RDONLY|O_CREAT|O_EXCL|O_CLOEXEC, S_IRUSR|S_IWUSR);\n\t}\n\n\tif (fd3 == -1) {\n\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tperror(\"open\");\n\t\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\t\t}\n\t\t}\n\t\tclose(fd2);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\tclose(fd2);\n\n\tfs_logger2(\"whitelist\", path);\n\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd3) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wfile, proc, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(proc);\n\tclose(fd3);\n\n\t// check the last mount operation\n\tMountData *mptr = get_last_mount(); // will do exit(1) if the mount cannot be found\n\n\t// confirm the file was mounted on the right target\n\t// strcmp does not work here, because mptr->dir can be a child mount\n\tsize_t path_len = strlen(path);\n\tif (strncmp(mptr->dir, path, path_len) != 0 ||\n\t   (*(mptr->dir + path_len) != '\\0' && *(mptr->dir + path_len) != '/'))\n\t\terrLogExit(\"invalid whitelist mount\");\n\t// No mounts are allowed on top level directories. A destination such as \"/etc\" is very bad!\n\t//  - there should be more than one '/' char in dest string\n\tif (mptr->dir == strrchr(mptr->dir, '/'))\n\t\terrLogExit(\"invalid whitelist mount\");\n\t// confirm the right file was mounted\n\tint fd4 = safe_fd(path, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd4 == -1)\n\t\terrExit(\"safe_fd\");\n\tstruct stat s;\n\tif (fstat(fd4, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_dev != wfilestat.st_dev || s.st_ino != wfilestat.st_ino)\n\t\terrLogExit(\"invalid whitelist mount\");\n\tclose(fd4);\n\n\tfree(wfile);\n\treturn;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t homedir_len;",
      "static size_t runuser_len;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "wfile"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd4"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errLogExit",
          "args": [
            "\"invalid whitelist mount\""
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "errLogExit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "40-57",
          "snippet": "void errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid errLogExit(char* fmt, ...) {\n\tva_list args;\n\tva_start(args,fmt);\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_AUTH);\n\tMountData *m = get_last_mount();\n\n\tchar *msg1;\n\tchar *msg2  = \"Access error\";\n\tif (vasprintf(&msg1, fmt, args) != -1 &&\n\t    asprintf(&msg2, \"Access error: pid %d, last mount name:%s dir:%s type:%s - %s\", getuid(), m->fsname, m->dir, m->fstype, msg1) != -1)\n\t\tsyslog(LOG_CRIT, \"%s\", msg2);\n\tva_end(args);\n\tcloselog();\n\n\tsleep(2);\n\tfprintf(stderr, \"%s\\n\", msg2);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd4",
            "&s"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"safe_fd\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_fd",
          "args": [
            "path",
            "O_PATH|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "safe_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "1143-1209",
          "snippet": "int safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define EMPTY_STRING (\"\")"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define EMPTY_STRING (\"\")\n\nint safe_fd(const char *path, int flags) {\n\tassert(path);\n\n\t// reject empty string, relative path\n\tif (*path != '/')\n\t\tgoto errexit;\n\t// reject \"..\"\n\tif (strstr(path, \"..\"))\n\t\tgoto errexit;\n\tchar *p = strrchr(path, '/');\n\tassert(p);\n\t// reject trailing slash, root directory\n\tif (*(p + 1) == '\\0')\n\t\tgoto errexit;\n\t// reject trailing dot\n\tif (*(p + 1) == '.' && *(p + 2) == '\\0')\n\t\tgoto errexit;\n\n\t// work with a copy of path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path and return -1 if a symlink is encountered\n\tint fd = -1;\n\tchar *current_tok = EMPTY_STRING;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok);\n\twhile (tok) {\n\t\t// open the element, assuming it is a directory; this fails with ENOTDIR if it is a symbolic link\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\t// if the following token is NULL, the current token is the final path element\n\t\t\t// try again to open it, this time using the passed flags, and return -1 or the descriptor\n\t\t\tcurrent_tok = tok;\n\t\t\ttok = strtok(NULL, \"/\");\n\t\t\tif (!tok)\n\t\t\t\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\treturn fd; // -1 if open failed\n\t\t}\n\t\t// move on to next path segment\n\t\tcurrent_tok = tok;\n\t\ttok = strtok(NULL, \"/\");\n\t\tif (tok) {\n\t\t\tclose(parentfd);\n\t\t\tparentfd = fd;\n\t\t}\n\t}\n\n\t// we are here because the last path element exists and is of file type directory\n\t// reopen it using the passed flags\n\tclose(fd);\n\tfd = openat(parentfd, current_tok, flags|O_NOFOLLOW);\n\tclose(parentfd);\n\tfree(dup);\n\treturn fd; // -1 if open failed\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot open \\\"%s\\\", invalid filename\\n\", path);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "mptr->dir",
            "'/'"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "mptr->dir",
            "path",
            "path_len"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "get_last_mount",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "get_last_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/mountinfo.c",
          "lines": "131-152",
          "snippet": "MountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_BUF 4096"
          ],
          "globals_used": [
            "static char mbuf[MAX_BUF];",
            "static MountData mdata;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nstatic char mbuf[MAX_BUF];\nstatic MountData mdata;\n\nMountData *get_last_mount(void) {\n\t// open /proc/self/mountinfo\n\tFILE *fp = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Error: cannot read /proc/self/mountinfo\\n\");\n\t\texit(1);\n\t}\n\n\tmbuf[0] = '\\0';\n\t// go to the last line\n\twhile (fgets(mbuf, MAX_BUF, fp));\n\tfclose(fp);\n\tif (arg_debug)\n\t\tprintf(\"%s\", mbuf);\n\n\tparse_line(mbuf, &mdata);\n\n\tif (arg_debug)\n\t\tprintf(\"mountid=%d fsname=%s dir=%s fstype=%s\\n\", mdata.mountid, mdata.fsname, mdata.dir, mdata.fstype);\n\treturn &mdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "proc"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "wfile",
            "proc",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&proc",
            "\"/proc/self/fd/%d\"",
            "fd3"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"whitelist\"",
            "path"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "wfile"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Debug %d: skip whitelisting of %s\\n\"",
            "__LINE__",
            "path"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"open\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "fd2",
            "file",
            "O_RDONLY|O_CREAT|O_EXCL|O_CLOEXEC",
            "S_IRUSR|S_IWUSR"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "openat64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "299-306",
          "snippet": "int openat64(int dirfd, const char *pathname, int flags, mode_t mode) {\n\tif (!orig_openat64)\n\t\torig_openat64 = (orig_openat64_t)dlsym(RTLD_NEXT, \"openat64\");\n\n\tint rv = orig_openat64(dirfd, pathname, flags, mode);\n\tprintf(\"%u:%s:openat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_openat64_t orig_openat64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_openat64_t orig_openat64 = NULL;\n\nint openat64(int dirfd, const char *pathname, int flags, mode_t mode) {\n\tif (!orig_openat64)\n\t\torig_openat64 = (orig_openat64_t)dlsym(RTLD_NEXT, \"openat64\");\n\n\tint rv = orig_openat64(dirfd, pathname, flags, mode);\n\tprintf(\"%u:%s:openat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "fd2",
            "file",
            "O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "wfile"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Debug %d: skip whitelisting of %s\\n\"",
            "__LINE__",
            "path"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"mkdir\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdirat",
          "args": [
            "fd2",
            "file",
            "0755"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "mkdirat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "393-400",
          "snippet": "int mkdirat(int dirfd, const char *pathname, mode_t mode) {\n\tif (!orig_mkdirat)\n\t\torig_mkdirat = (orig_mkdirat_t)dlsym(RTLD_NEXT, \"mkdirat\");\n\n\tint rv = orig_mkdirat(dirfd, pathname, mode);\n\tprintf(\"%u:%s:mkdirat %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdirat_t orig_mkdirat = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdirat_t orig_mkdirat = NULL;\n\nint mkdirat(int dirfd, const char *pathname, mode_t mode) {\n\tif (!orig_mkdirat)\n\t\torig_mkdirat = (orig_mkdirat_t)dlsym(RTLD_NEXT, \"mkdirat\");\n\n\tint rv = orig_mkdirat(dirfd, pathname, mode);\n\tprintf(\"%u:%s:mkdirat %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "wfilestat.st_mode"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnu_basename",
          "args": [
            "path"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "gnu_basename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/util.c",
          "lines": "815-820",
          "snippet": "const char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nconst char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "wfile"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Debug %d: skip whitelisting of %s\\n\"",
            "__LINE__",
            "path"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkpath",
          "args": [
            "path",
            "0755"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "mkpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_whitelist.c",
          "lines": "41-113",
          "snippet": "static int mkpath(const char* path, mode_t mode) {\n\tassert(path && *path);\n\tmode |= 0111;\n\n\t// create directories with uid/gid as root or as current user if inside home or run directory\n\tint userprivs = 0;\n\tif (strncmp(path, cfg.homedir, homedir_len) == 0 || strncmp(path, runuser, runuser_len) == 0) {\n\t\tEUID_USER();\n\t\tuserprivs = 1;\n\t}\n\n\t// work on a copy of the path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\t// don't create the last path element\n\tchar *p = strrchr(dup, '/');\n\tassert(p);\n\t*p = '\\0';\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path, return -1 if a symlink is encountered\n\tint done = 0;\n\tint fd = -1;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok); // path is no top level directory\n\twhile (tok) {\n\t\t// create the directory if necessary\n\t\tif (mkdirat(parentfd, tok, mode) == -1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\tclose(parentfd);\n\t\t\t\tfree(dup);\n\t\t\t\tif (userprivs) {\n\t\t\t\t\tEUID_ROOT();\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tdone = 1;\n\t\t// open the directory\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tperror(\"open\");\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\tif (userprivs) {\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t// move on to next path segment\n\t\tclose(parentfd);\n\t\tparentfd = fd;\n\t\ttok = strtok(NULL, \"/\");\n\t}\n\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(dup);\n\tif (userprivs) {\n\t\tEUID_ROOT();\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t homedir_len;",
            "static size_t runuser_len;",
            "static char *runuser;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic size_t homedir_len;\nstatic size_t runuser_len;\nstatic char *runuser;\n\nstatic int mkpath(const char* path, mode_t mode) {\n\tassert(path && *path);\n\tmode |= 0111;\n\n\t// create directories with uid/gid as root or as current user if inside home or run directory\n\tint userprivs = 0;\n\tif (strncmp(path, cfg.homedir, homedir_len) == 0 || strncmp(path, runuser, runuser_len) == 0) {\n\t\tEUID_USER();\n\t\tuserprivs = 1;\n\t}\n\n\t// work on a copy of the path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\t// don't create the last path element\n\tchar *p = strrchr(dup, '/');\n\tassert(p);\n\t*p = '\\0';\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path, return -1 if a symlink is encountered\n\tint done = 0;\n\tint fd = -1;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok); // path is no top level directory\n\twhile (tok) {\n\t\t// create the directory if necessary\n\t\tif (mkdirat(parentfd, tok, mode) == -1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\tclose(parentfd);\n\t\t\t\tfree(dup);\n\t\t\t\tif (userprivs) {\n\t\t\t\t\tEUID_ROOT();\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tdone = 1;\n\t\t// open the directory\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tperror(\"open\");\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\tif (userprivs) {\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t// move on to next path segment\n\t\tclose(parentfd);\n\t\tparentfd = fd;\n\t\ttok = strtok(NULL, \"/\");\n\t}\n\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(dup);\n\tif (userprivs) {\n\t\tEUID_ROOT();\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"TEST_MOUNTINFO\\n\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "wfile"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Debug %d: skip whitelisting of %s\\n\"",
            "__LINE__",
            "path"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "wfilestat.st_mode"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fstat\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&wfilestat"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "wfile"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Debug %d: skip whitelisting of %s\\n\"",
            "__LINE__",
            "path"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Whitelisting %s\\n\"",
            "path"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "wfile"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_RUN_USER_DIR",
            "fname"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_MODULE_DIR",
            "fname"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_SHARE_DIR",
            "fname"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_ETC_DIR",
            "fname"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"/etc/\"",
            "5"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_SRV_DIR",
            "fname"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_OPT_DIR",
            "fname"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_DEV_DIR",
            "fname"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"/dev/\"",
            "5"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_VAR_DIR",
            "fname"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"/var/\"",
            "5"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_MNT_DIR",
            "fname"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_MEDIA_DIR",
            "fname"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_TMP_DIR",
            "fname"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wfile",
            "\"%s/%s\"",
            "RUN_WHITELIST_HOME_USER_DIR",
            "fname"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "cfg.homedir",
            "homedir_len"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "entry"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic size_t homedir_len;\nstatic size_t runuser_len;\n\nstatic void whitelist_path(ProfileEntry *entry) {\n\tassert(entry);\n\tconst char *path = entry->data + 10;\n\tconst char *fname;\n\tchar *wfile = NULL;\n\n\tif (entry->home_dir) {\n\t\tif (strncmp(path, cfg.homedir, homedir_len) != 0 || path[homedir_len] != '/')\n\t\t\t// either symlink pointing outside home directory\n\t\t\t// or entire home directory, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + homedir_len + 1; // strlen(\"/home/user/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_HOME_USER_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->tmp_dir) {\n\t\tfname = path + 5; // strlen(\"/tmp/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_TMP_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->media_dir) {\n\t\tfname = path + 7; // strlen(\"/media/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MEDIA_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->mnt_dir) {\n\t\tfname = path + 5; // strlen(\"/mnt/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MNT_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->var_dir) {\n\t\tif (strncmp(path, \"/var/\", 5) != 0)\n\t\t\t// symlink pointing outside /var, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/var/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_VAR_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->dev_dir) {\n\t\tif (strncmp(path, \"/dev/\", 5) != 0)\n\t\t\t// symlink pointing outside /dev, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/dev/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_DEV_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->opt_dir) {\n\t\tfname = path + 5; // strlen(\"/opt/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_OPT_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->srv_dir) {\n\t\tfname = path + 5; // strlen(\"/srv/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_SRV_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->etc_dir) {\n\t\tif (strncmp(path, \"/etc/\", 5) != 0)\n\t\t\t// symlink pointing outside /etc, skip the mount\n\t\t\treturn;\n\n\t\tfname = path + 5; // strlen(\"/etc/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_ETC_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->share_dir) {\n\t\tfname = path + 11; // strlen(\"/usr/share/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_SHARE_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->module_dir) {\n\t\tfname = path + 12; // strlen(\"/sys/module/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_MODULE_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse if (entry->run_dir) {\n\t\tfname = path + runuser_len + 1; // strlen(\"/run/user/$uid/\")\n\n\t\tif (asprintf(&wfile, \"%s/%s\", RUN_WHITELIST_RUN_USER_DIR, fname) == -1)\n\t\t\terrExit(\"asprintf\");\n\t}\n\tassert(wfile);\n\n\tif (arg_debug || arg_debug_whitelists)\n\t\tprintf(\"Whitelisting %s\\n\", path);\n\n\t// confirm again the mount source exists and there is no symlink\n\tstruct stat wfilestat;\n\tEUID_USER();\n\tint fd = safe_fd(wfile, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tEUID_ROOT();\n\tif (fd == -1) {\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\tif (fstat(fd, &wfilestat) == -1)\n\t\terrExit(\"fstat\");\n\tclose(fd);\n\tif (S_ISLNK(wfilestat.st_mode)) {\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\n#ifdef TEST_MOUNTINFO\n\tprintf(\"TEST_MOUNTINFO\\n\");\n\tpath = \"/etc/.\";\n#endif\n\n\t// create path of the mount target if necessary\n\tint fd2 = mkpath(path, 0755);\n\tif (fd2 == -1) {\n\t\t// something went wrong during path creation or a symlink was found;\n\t\t// if there is a symlink somewhere in the path of the mount target,\n\t\t// assume the file is whitelisted already\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\n\t// get file name of the mount target\n\tconst char *file = gnu_basename(path);\n\n\t// create the mount target if necessary and open it, a symlink is rejected\n\tint fd3 = -1;\n\tif (S_ISDIR(wfilestat.st_mode)) {\n\t\t// directory foo can exist already:\n\t\t// firejail --whitelist=/foo/bar --whitelist=/foo\n\t\tif (mkdirat(fd2, file, 0755) == -1 && errno != EEXIST) {\n\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\tperror(\"mkdir\");\n\t\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\t\t}\n\t\t\tclose(fd2);\n\t\t\tfree(wfile);\n\t\t\treturn;\n\t\t}\n\t\tfd3 = openat(fd2, file, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t}\n\telse {\n\t\t// create an empty file, fails with EEXIST if it is whitelisted already:\n\t\t// firejail --whitelist=/foo --whitelist=/foo/bar\n\t\tfd3 = openat(fd2, file, O_RDONLY|O_CREAT|O_EXCL|O_CLOEXEC, S_IRUSR|S_IWUSR);\n\t}\n\n\tif (fd3 == -1) {\n\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tperror(\"open\");\n\t\t\t\tprintf(\"Debug %d: skip whitelisting of %s\\n\", __LINE__, path);\n\t\t\t}\n\t\t}\n\t\tclose(fd2);\n\t\tfree(wfile);\n\t\treturn;\n\t}\n\tclose(fd2);\n\n\tfs_logger2(\"whitelist\", path);\n\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd3) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wfile, proc, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(proc);\n\tclose(fd3);\n\n\t// check the last mount operation\n\tMountData *mptr = get_last_mount(); // will do exit(1) if the mount cannot be found\n\n\t// confirm the file was mounted on the right target\n\t// strcmp does not work here, because mptr->dir can be a child mount\n\tsize_t path_len = strlen(path);\n\tif (strncmp(mptr->dir, path, path_len) != 0 ||\n\t   (*(mptr->dir + path_len) != '\\0' && *(mptr->dir + path_len) != '/'))\n\t\terrLogExit(\"invalid whitelist mount\");\n\t// No mounts are allowed on top level directories. A destination such as \"/etc\" is very bad!\n\t//  - there should be more than one '/' char in dest string\n\tif (mptr->dir == strrchr(mptr->dir, '/'))\n\t\terrLogExit(\"invalid whitelist mount\");\n\t// confirm the right file was mounted\n\tint fd4 = safe_fd(path, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd4 == -1)\n\t\terrExit(\"safe_fd\");\n\tstruct stat s;\n\tif (fstat(fd4, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_dev != wfilestat.st_dev || s.st_ino != wfilestat.st_ino)\n\t\terrLogExit(\"invalid whitelist mount\");\n\tclose(fd4);\n\n\tfree(wfile);\n\treturn;\n}"
  },
  {
    "function_name": "mkpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_whitelist.c",
    "lines": "41-113",
    "snippet": "static int mkpath(const char* path, mode_t mode) {\n\tassert(path && *path);\n\tmode |= 0111;\n\n\t// create directories with uid/gid as root or as current user if inside home or run directory\n\tint userprivs = 0;\n\tif (strncmp(path, cfg.homedir, homedir_len) == 0 || strncmp(path, runuser, runuser_len) == 0) {\n\t\tEUID_USER();\n\t\tuserprivs = 1;\n\t}\n\n\t// work on a copy of the path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\t// don't create the last path element\n\tchar *p = strrchr(dup, '/');\n\tassert(p);\n\t*p = '\\0';\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path, return -1 if a symlink is encountered\n\tint done = 0;\n\tint fd = -1;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok); // path is no top level directory\n\twhile (tok) {\n\t\t// create the directory if necessary\n\t\tif (mkdirat(parentfd, tok, mode) == -1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\tclose(parentfd);\n\t\t\t\tfree(dup);\n\t\t\t\tif (userprivs) {\n\t\t\t\t\tEUID_ROOT();\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tdone = 1;\n\t\t// open the directory\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tperror(\"open\");\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\tif (userprivs) {\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t// move on to next path segment\n\t\tclose(parentfd);\n\t\tparentfd = fd;\n\t\ttok = strtok(NULL, \"/\");\n\t}\n\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(dup);\n\tif (userprivs) {\n\t\tEUID_ROOT();\n\t}\n\treturn fd;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t homedir_len;",
      "static size_t runuser_len;",
      "static char *runuser;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dup"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"mkpath\"",
            "path"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"/\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "parentfd"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dup"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"open\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "parentfd",
            "tok",
            "O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dup"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"mkdir\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdirat",
          "args": [
            "parentfd",
            "tok",
            "mode"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "mkdirat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "393-400",
          "snippet": "int mkdirat(int dirfd, const char *pathname, mode_t mode) {\n\tif (!orig_mkdirat)\n\t\torig_mkdirat = (orig_mkdirat_t)dlsym(RTLD_NEXT, \"mkdirat\");\n\n\tint rv = orig_mkdirat(dirfd, pathname, mode);\n\tprintf(\"%u:%s:mkdirat %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_mkdirat_t orig_mkdirat = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_mkdirat_t orig_mkdirat = NULL;\n\nint mkdirat(int dirfd, const char *pathname, mode_t mode) {\n\tif (!orig_mkdirat)\n\t\torig_mkdirat = (orig_mkdirat_t)dlsym(RTLD_NEXT, \"mkdirat\");\n\n\tint rv = orig_mkdirat(dirfd, pathname, mode);\n\tprintf(\"%u:%s:mkdirat %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tok"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "dup",
            "\"/\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"open\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/\"",
            "O_PATH|O_DIRECTORY|O_CLOEXEC"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "p"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "dup",
            "'/'"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "runuser",
            "runuser_len"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "cfg.homedir",
            "homedir_len"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path && *path"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic size_t homedir_len;\nstatic size_t runuser_len;\nstatic char *runuser;\n\nstatic int mkpath(const char* path, mode_t mode) {\n\tassert(path && *path);\n\tmode |= 0111;\n\n\t// create directories with uid/gid as root or as current user if inside home or run directory\n\tint userprivs = 0;\n\tif (strncmp(path, cfg.homedir, homedir_len) == 0 || strncmp(path, runuser, runuser_len) == 0) {\n\t\tEUID_USER();\n\t\tuserprivs = 1;\n\t}\n\n\t// work on a copy of the path\n\tchar *dup = strdup(path);\n\tif (!dup)\n\t\terrExit(\"strdup\");\n\n\t// don't create the last path element\n\tchar *p = strrchr(dup, '/');\n\tassert(p);\n\t*p = '\\0';\n\n\tint parentfd = open(\"/\", O_PATH|O_DIRECTORY|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"open\");\n\n\t// traverse the path, return -1 if a symlink is encountered\n\tint done = 0;\n\tint fd = -1;\n\tchar *tok = strtok(dup, \"/\");\n\tassert(tok); // path is no top level directory\n\twhile (tok) {\n\t\t// create the directory if necessary\n\t\tif (mkdirat(parentfd, tok, mode) == -1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\tclose(parentfd);\n\t\t\t\tfree(dup);\n\t\t\t\tif (userprivs) {\n\t\t\t\t\tEUID_ROOT();\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tdone = 1;\n\t\t// open the directory\n\t\tfd = openat(parentfd, tok, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1) {\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tperror(\"open\");\n\t\t\tclose(parentfd);\n\t\t\tfree(dup);\n\t\t\tif (userprivs) {\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t// move on to next path segment\n\t\tclose(parentfd);\n\t\tparentfd = fd;\n\t\ttok = strtok(NULL, \"/\");\n\t}\n\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(dup);\n\tif (userprivs) {\n\t\tEUID_ROOT();\n\t}\n\treturn fd;\n}"
  }
]