[
  {
    "function_name": "seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/seccomp.c",
    "lines": "47-62",
    "snippet": "void seccomp(pid_t pid, int print_procs) {\n\tpid_read(pid);\t// include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_seccomp(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include \"firemon.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_seccomp",
          "args": [
            "child"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "print_seccomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/seccomp.c",
          "lines": "23-45",
          "snippet": "static void print_seccomp(int pid) {\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%d/status\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tprintf(\"  Error: cannot open %s\\n\", file);\n\t\tfree(file);\n\t\treturn;\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"Seccomp:\", 8) == 0) {\n\t\t\tprintf(\"  %s\", buf);\n\t\t\tfflush(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n}",
          "includes": [
            "#include \"firemon.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"firemon.h\"\n\n#define MAXBUF 4098\n\nstatic void print_seccomp(int pid) {\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%d/status\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tprintf(\"  Error: cannot open %s\\n\", file);\n\t\tfree(file);\n\t\treturn;\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"Seccomp:\", 8) == 0) {\n\t\t\tprintf(\"  %s\", buf);\n\t\t\tfflush(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_child",
          "args": [
            "i"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/firemon.c",
          "lines": "65-87",
          "snippet": "int find_child(int id) {\n\tint i;\n\tint first_child = -1;\n\n\t// find the first child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 2 && pids[i].parent == id) {\n\t\t\tfirst_child = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (first_child == -1)\n\t\treturn -1;\n\n\t// find the second child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 3 && pids[i].parent == first_child)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <grp.h>",
            "#include <sys/prctl.h>",
            "#include <sys/ioctl.h>",
            "#include <termios.h>",
            "#include <signal.h>",
            "#include \"firemon.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <grp.h>\n#include <sys/prctl.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <signal.h>\n#include \"firemon.h\"\n\nint find_child(int id) {\n\tint i;\n\tint first_child = -1;\n\n\t// find the first child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 2 && pids[i].parent == id) {\n\t\t\tfirst_child = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (first_child == -1)\n\t\treturn -1;\n\n\t// find the second child\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 3 && pids[i].parent == first_child)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_print_list",
          "args": [
            "i",
            "arg_nowrap"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "pid_print_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "271-273",
          "snippet": "void pid_print_list(unsigned index, int nowrap) {\n\tprint_elem(index, nowrap);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\nvoid pid_print_list(unsigned index, int nowrap) {\n\tprint_elem(index, nowrap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_read",
          "args": [
            "pid"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "pid_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/pid.c",
          "lines": "304-428",
          "snippet": "void pid_read(pid_t mon_pid) {\n\tif (pids == NULL) {\n\t\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\t\tif (fp) {\n\t\t\tint val;\n\t\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\t\tif (val >= max_pids)\n\t\t\t\t\tmax_pids = val + 1;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tpids = malloc(sizeof(Process) * max_pids);\n\t\tif (pids == NULL)\n\t\t\terrExit(\"malloc\");\n\t}\n\tmemset(pids, 0, sizeof(Process) * max_pids);\n\tpid_t mypid = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpid_t child = -1;\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (child < 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == mypid)\n\t\t\tcontinue;\n\n\t\t// skip PID 1 just in case we run a sandbox-in-sandbox\n\t\tif (pid == 1)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[PIDS_BUFLEN];\n\t\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"Name:\", 5) == 0) {\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif ((strcmp(ptr, \"firejail\") == 0) && (mon_pid == 0 || mon_pid == pid)) {\n\t\t\t\t\tif (pid_proc_cmdline_x11_xpra_xephyr(pid))\n\t\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t}\n\t\t\tif (strncmp(buf, \"State:\", 6) == 0) {\n\t\t\t\tif (strstr(buf, \"(zombie)\"))\n\t\t\t\t\tpids[pid].zombie = 1;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tunsigned parent = atoi(ptr);\n\t\t\t\tparent %= max_pids;\n\t\t\t\tif (pids[parent].level > 0) {\n\t\t\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t\t\t}\n\t\t\t\tpids[pid].parent = parent;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\t\tchar *ptr = buf + 4;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tpids[pid].uid = atoi(ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\n\tpid_t pid;\n\tfor (pid = 0; pid < max_pids; pid++) {\n\t\tint parent = pids[pid].parent;\n\t\tif (pids[parent].level > 0) {\n\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include \"../include/pid.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [
            "#define PIDS_BUFLEN 4096"
          ],
          "globals_used": [
            "Process *pids = NULL;",
            "int max_pids=32769;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include \"../include/pid.h\"\n#include \"../include/common.h\"\n\n#define PIDS_BUFLEN 4096\n\nProcess *pids = NULL;\nint max_pids=32769;\n\nvoid pid_read(pid_t mon_pid) {\n\tif (pids == NULL) {\n\t\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\t\tif (fp) {\n\t\t\tint val;\n\t\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\t\tif (val >= max_pids)\n\t\t\t\t\tmax_pids = val + 1;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t\tpids = malloc(sizeof(Process) * max_pids);\n\t\tif (pids == NULL)\n\t\t\terrExit(\"malloc\");\n\t}\n\tmemset(pids, 0, sizeof(Process) * max_pids);\n\tpid_t mypid = getpid();\n\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpid_t child = -1;\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (child < 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == mypid)\n\t\t\tcontinue;\n\n\t\t// skip PID 1 just in case we run a sandbox-in-sandbox\n\t\tif (pid == 1)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[PIDS_BUFLEN];\n\t\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"Name:\", 5) == 0) {\n\t\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\t\tif (ptr)\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\tptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif ((strcmp(ptr, \"firejail\") == 0) && (mon_pid == 0 || mon_pid == pid)) {\n\t\t\t\t\tif (pid_proc_cmdline_x11_xpra_xephyr(pid))\n\t\t\t\t\t\tpids[pid].level = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpids[pid].level = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpids[pid].level = -1;\n\t\t\t}\n\t\t\tif (strncmp(buf, \"State:\", 6) == 0) {\n\t\t\t\tif (strstr(buf, \"(zombie)\"))\n\t\t\t\t\tpids[pid].zombie = 1;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tunsigned parent = atoi(ptr);\n\t\t\t\tparent %= max_pids;\n\t\t\t\tif (pids[parent].level > 0) {\n\t\t\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t\t\t}\n\t\t\t\tpids[pid].parent = parent;\n\t\t\t}\n\t\t\telse if (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\t\tchar *ptr = buf + 4;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tpids[pid].uid = atoi(ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\n\tpid_t pid;\n\tfor (pid = 0; pid < max_pids; pid++) {\n\t\tint parent = pids[pid].parent;\n\t\tif (pids[parent].level > 0) {\n\t\t\tpids[pid].level = pids[parent].level + 1;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"firemon.h\"\n\nvoid seccomp(pid_t pid, int print_procs) {\n\tpid_read(pid);\t// include all processes\n\n\t// print processes\n\tint i;\n\tfor (i = 0; i < max_pids; i++) {\n\t\tif (pids[i].level == 1) {\n\t\t\tif (print_procs || pid == 0)\n\t\t\t\tpid_print_list(i, arg_nowrap);\n\t\t\tint child = find_child(i);\n\t\t\tif (child != -1)\n\t\t\t\tprint_seccomp(child);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "print_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firemon/seccomp.c",
    "lines": "23-45",
    "snippet": "static void print_seccomp(int pid) {\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%d/status\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tprintf(\"  Error: cannot open %s\\n\", file);\n\t\tfree(file);\n\t\treturn;\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"Seccomp:\", 8) == 0) {\n\t\t\tprintf(\"  %s\", buf);\n\t\t\tfflush(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n}",
    "includes": [
      "#include \"firemon.h\""
    ],
    "macros_used": [
      "#define MAXBUF 4098"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  %s\"",
            "buf"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"Seccomp:\"",
            "8"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fp"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  Error: cannot open %s\\n\"",
            "file"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&file",
            "\"/proc/%d/status\"",
            "pid"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"firemon.h\"\n\n#define MAXBUF 4098\n\nstatic void print_seccomp(int pid) {\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%d/status\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tprintf(\"  Error: cannot open %s\\n\", file);\n\t\tfree(file);\n\t\treturn;\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tif (strncmp(buf, \"Seccomp:\", 8) == 0) {\n\t\t\tprintf(\"  %s\", buf);\n\t\t\tfflush(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n}"
  }
]