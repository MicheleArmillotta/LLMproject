[
  {
    "function_name": "restricted_shell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/restricted_shell.c",
    "lines": "27-132",
    "snippet": "int restricted_shell(const char *user) {\n\tEUID_ASSERT();\n\tassert(user);\n\n\t// open profile file:\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/login.users\", SYSCONFDIR) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(fname, \"r\");\n\tfree(fname);\n\tif (fp == NULL)\n\t\treturn 0;\n\n\tint lineno = 0;\n\tchar buf[MAX_READ];\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\tlineno++;\n\n\t\t// remove empty spaces at the beginning of the line\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t') {\n\t\t\tptr++;\n\t\t}\n\t\tif (*ptr == '\\n' || *ptr == '#')\n\t\t\tcontinue;\n\n\t\t//\n\t\t// parse line\n\t\t//\n\n\t\t// extract users\n\t\tchar *usr = ptr;\n\t\tchar *args = strchr(usr, ':');\n\t\tif (args == NULL) {\n\t\t\tfprintf(stderr, \"Error: users.conf line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\t*args = '\\0';\n\t\targs++;\n\t\tptr = strchr(args, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// extract firejail command line arguments\n\t\tchar *ptr2 = args;\n\t\tint found = 0;\n\t\twhile (*ptr2 != '\\0') {\n\t\t\tif (*ptr2 != ' ' && *ptr2 != '\\t') {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr2++;\n\t\t}\n\t\t// if nothing follows, continue\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\t// user name globbing\n\t\tif (fnmatch(usr, user, 0) == 0) {\n\t\t    \t// process program arguments\n\n\t\t    \tfullargv[0] = \"firejail\";\n\t\t    \tint i;\n\t\t    \tptr = args;\n\t\t    \tfor (i = 1; i < MAX_ARGS; i++) {\n\t\t    \t\t// skip blanks\n\t\t    \t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t    \t\t\tptr++;\n\t\t    \t\tfullargv[i] = ptr;\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t\t{EUID_ROOT();\n\t\t\t\tFILE *fp = fopen(\"/firelog\", \"a\");\n\t\t\t\tif (fp) {\n\t\t\t\t\tfprintf(fp, \"i %d ptr #%s#\\n\", i, fullargv[i]);\n\t\t\t\t\tfclose(fp);\n\t\t\t\t}\n\t\t\t\tEUID_USER();}\n#endif\n\n\t\t    \t\tif (*ptr != '\\0') {\n\t\t    \t\t\t// go to the end of the word\n\t\t\t    \t\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0')\n\t\t\t    \t\t\tptr++;\n\t\t    \t\t\t*ptr ='\\0';\n\t\t    \t\t\tfullargv[i] = strdup(fullargv[i]);\n\t\t    \t\t\tif (fullargv[i] == NULL)\n\t\t    \t\t\t\terrExit(\"strdup\");\n\t\t    \t\t\tptr++;\n\t\t    \t\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t    \t\t\t\tptr++;\n\t\t    \t\t\tif (*ptr != '\\0')\n\t\t\t    \t\t\tcontinue;\n\t\t    \t\t}\n\t    \t\t\tfullargv[i] = strdup(fullargv[i]);\n\t\t\t\tfclose(fp);\n\t\t    \t\treturn i + 1;\n\t\t\t}\n\t\t\tfprintf(stderr, \"Error: too many program arguments in users.conf line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfclose(fp);\n\n\treturn 0;\n}",
    "includes": [
      "#include <fnmatch.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAX_READ 4096\t// maximum line length"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: too many program arguments in users.conf line %d\\n\"",
            "lineno"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "fullargv[i]"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "fullargv[i]"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_USER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "42-47",
          "snippet": "static inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"i %d ptr #%s#\\n\"",
            "i",
            "fullargv[i]"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/firelog\"",
            "\"a\""
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "fopen64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "320-327",
          "snippet": "FILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_fopen64_t orig_fopen64 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_fopen64_t orig_fopen64 = NULL;\n\nFILE *fopen64(const char *pathname, const char *mode) {\n\tif (!orig_fopen64)\n\t\torig_fopen64 = (orig_fopen_t)dlsym(RTLD_NEXT, \"fopen64\");\n\n\tFILE *rv = orig_fopen64(pathname, mode);\n\tprintf(\"%u:%s:fopen64 %s:%p\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "EUID_ROOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/include/euid_common.h",
          "lines": "36-40",
          "snippet": "static inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdio.h>\n\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnmatch",
          "args": [
            "usr",
            "user",
            "0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "args",
            "'\\n'"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: users.conf line %d\\n\"",
            "lineno"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "usr",
            "':'"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAX_READ",
            "fp"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/login.users\"",
            "SYSCONFDIR"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "user"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fnmatch.h>\n#include \"firejail.h\"\n\n#define MAX_READ 4096\t// maximum line length\n\nint restricted_shell(const char *user) {\n\tEUID_ASSERT();\n\tassert(user);\n\n\t// open profile file:\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/login.users\", SYSCONFDIR) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(fname, \"r\");\n\tfree(fname);\n\tif (fp == NULL)\n\t\treturn 0;\n\n\tint lineno = 0;\n\tchar buf[MAX_READ];\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\tlineno++;\n\n\t\t// remove empty spaces at the beginning of the line\n\t\tchar *ptr = buf;\n\t\twhile (*ptr == ' ' || *ptr == '\\t') {\n\t\t\tptr++;\n\t\t}\n\t\tif (*ptr == '\\n' || *ptr == '#')\n\t\t\tcontinue;\n\n\t\t//\n\t\t// parse line\n\t\t//\n\n\t\t// extract users\n\t\tchar *usr = ptr;\n\t\tchar *args = strchr(usr, ':');\n\t\tif (args == NULL) {\n\t\t\tfprintf(stderr, \"Error: users.conf line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\n\t\t*args = '\\0';\n\t\targs++;\n\t\tptr = strchr(args, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// extract firejail command line arguments\n\t\tchar *ptr2 = args;\n\t\tint found = 0;\n\t\twhile (*ptr2 != '\\0') {\n\t\t\tif (*ptr2 != ' ' && *ptr2 != '\\t') {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr2++;\n\t\t}\n\t\t// if nothing follows, continue\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\t// user name globbing\n\t\tif (fnmatch(usr, user, 0) == 0) {\n\t\t    \t// process program arguments\n\n\t\t    \tfullargv[0] = \"firejail\";\n\t\t    \tint i;\n\t\t    \tptr = args;\n\t\t    \tfor (i = 1; i < MAX_ARGS; i++) {\n\t\t    \t\t// skip blanks\n\t\t    \t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t    \t\t\tptr++;\n\t\t    \t\tfullargv[i] = ptr;\n#ifdef DEBUG_RESTRICTED_SHELL\n\t\t\t\t{EUID_ROOT();\n\t\t\t\tFILE *fp = fopen(\"/firelog\", \"a\");\n\t\t\t\tif (fp) {\n\t\t\t\t\tfprintf(fp, \"i %d ptr #%s#\\n\", i, fullargv[i]);\n\t\t\t\t\tfclose(fp);\n\t\t\t\t}\n\t\t\t\tEUID_USER();}\n#endif\n\n\t\t    \t\tif (*ptr != '\\0') {\n\t\t    \t\t\t// go to the end of the word\n\t\t\t    \t\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0')\n\t\t\t    \t\t\tptr++;\n\t\t    \t\t\t*ptr ='\\0';\n\t\t    \t\t\tfullargv[i] = strdup(fullargv[i]);\n\t\t    \t\t\tif (fullargv[i] == NULL)\n\t\t    \t\t\t\terrExit(\"strdup\");\n\t\t    \t\t\tptr++;\n\t\t    \t\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t    \t\t\t\tptr++;\n\t\t    \t\t\tif (*ptr != '\\0')\n\t\t\t    \t\t\tcontinue;\n\t\t    \t\t}\n\t    \t\t\tfullargv[i] = strdup(fullargv[i]);\n\t\t\t\tfclose(fp);\n\t\t    \t\treturn i + 1;\n\t\t\t}\n\t\t\tfprintf(stderr, \"Error: too many program arguments in users.conf line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfclose(fp);\n\n\treturn 0;\n}"
  }
]