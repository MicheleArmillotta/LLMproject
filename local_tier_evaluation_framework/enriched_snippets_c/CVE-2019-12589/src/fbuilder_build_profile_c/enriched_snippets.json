[
  {
    "function_name": "build_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fbuilder/build_profile.c",
    "lines": "42-188",
    "snippet": "void build_profile(int argc, char **argv, int index, FILE *fp) {\n\t// next index is the application name\n\tif (index >= argc) {\n\t\tfprintf(stderr, \"Error: application name missing\\n\");\n\t\texit(1);\n\t}\n\n\tchar trace_output[] = \"/tmp/firejail-trace.XXXXXX\";\n\tchar strace_output[] = \"/tmp/firejail-strace.XXXXXX\";\n\n\tint tfile = mkstemp(trace_output);\n\tint stfile = mkstemp(strace_output);\n\tif(tfile == -1 || stfile == -1)\n\t\terrExit(\"mkstemp\");\n\n\t// close the files, firejail/strace will overwrite them!\n\tclose(tfile);\n\tclose(stfile);\n\n\n\tchar *output;\n\tchar *stroutput;\n\tif(asprintf(&output,\"--output=%s\",trace_output) == -1)\n\t\terrExit(\"asprintf\");\n\tif(asprintf(&stroutput,\"-o %s\",strace_output) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *cmdlist[] = {\n\t  \"/usr/bin/firejail\",\n\t  \"--quiet\",\n\t  output,\n\t  \"--noprofile\",\n\t  \"--caps.drop=all\",\n\t  \"--nonewprivs\",\n\t  \"--trace\",\n\t  \"--shell=none\",\n\t  \"/usr/bin/strace\", // also used as a marker in build_profile()\n\t  \"-c\",\n\t  \"-f\",\n\t  stroutput,\n\t};\n\n\t// detect strace\n\tint have_strace = 0;\n\tif (access(\"/usr/bin/strace\", X_OK) == 0)\n\t\thave_strace = 1;\n\n\t// calculate command length\n\tunsigned len = (int) sizeof(cmdlist) / sizeof(char*) + argc - index + 1;\n\tif (arg_debug)\n\t\tprintf(\"command len %d + %d + 1\\n\", (int) (sizeof(cmdlist) / sizeof(char*)), argc - index);\n\tchar *cmd[len];\n\tcmd[0] = cmdlist[0];\t// explicit assignment to clean scan-build error\n\n\t// build command\n\tunsigned i = 0;\n\tfor (i = 0; i < (int) sizeof(cmdlist) / sizeof(char*); i++) {\n\t\t// skip strace if not installed\n\t\tif (have_strace == 0 && strcmp(cmdlist[i], \"/usr/bin/strace\") == 0)\n\t\t\tbreak;\n\t\tcmd[i] = cmdlist[i];\n\t}\n\n\tint i2 = index;\n\tfor (; i < (len - 1); i++, i2++)\n\t\tcmd[i] = argv[i2];\n\tassert(i < len);\n\tcmd[i] = NULL;\n\n\tif (arg_debug) {\n\t\tfor (i = 0; i < len; i++)\n\t\t\tprintf(\"\\t%s\\n\", cmd[i]);\n\t}\n\n\t// fork and execute\n\tpid_t child = fork();\n\tif (child == -1)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tassert(cmd[0]);\n\t\tint rv = execvp(cmd[0], cmd);\n\t\t(void) rv;\n\t\terrExit(\"execv\");\n\t}\n\n\t// wait for all processes to finish\n\tint status;\n\tif (waitpid(child, &status, 0) != child)\n\t\terrExit(\"waitpid\");\n\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\tprintf(\"\\n\\n\\n\");\n\t\tfprintf(fp, \"############################################\\n\");\n\t\tfprintf(fp, \"# %s profile\\n\", argv[index]);\n\t\tfprintf(fp, \"############################################\\n\");\n\t\tfprintf(fp, \"# Persistent global definitions\\n\");\n\t\tfprintf(fp, \"# include /etc/firejail/globals.local\\n\");\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### basic blacklisting\\n\");\n\t\tfprintf(fp, \"include /etc/firejail/disable-common.inc\\n\");\n\t\tfprintf(fp, \"# include /etc/firejail/disable-devel.inc\\n\");\n\t\tfprintf(fp, \"include /etc/firejail/disable-passwdmgr.inc\\n\");\n\t\tfprintf(fp, \"# include /etc/firejail/disable-programs.inc\\n\");\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### home directory whitelisting\\n\");\n\t\tbuild_home(trace_output, fp);\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### filesystem\\n\");\n\t\tbuild_tmp(trace_output, fp);\n\t\tbuild_dev(trace_output, fp);\n\t\tbuild_etc(trace_output, fp);\n\t\tbuild_var(trace_output, fp);\n\t\tbuild_bin(trace_output, fp);\n\t\tbuild_share(trace_output, fp);\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### security filters\\n\");\n\t\tfprintf(fp, \"caps.drop all\\n\");\n\t\tfprintf(fp, \"nonewprivs\\n\");\n\t\tfprintf(fp, \"seccomp\\n\");\n\t\tif (have_strace)\n\t\t\tbuild_seccomp(strace_output, fp);\n\t\telse {\n\t\t\tfprintf(fp, \"# If you install strace on your system, Firejail will also create a\\n\");\n\t\t\tfprintf(fp, \"# whitelisted seccomp filter.\\n\");\n\t\t}\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### network\\n\");\n\t\tbuild_protocol(trace_output, fp);\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### environment\\n\");\n\t\tfprintf(fp, \"shell none\\n\");\n\n\t\tunlink(trace_output);\n\t\tunlink(strace_output);\n\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot run the sandbox\\n\");\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"fbuilder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot run the sandbox\\n\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "strace_output"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "359-366",
          "snippet": "int unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_unlink_t orig_unlink = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_unlink_t orig_unlink = NULL;\n\nint unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"shell none\\n\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"### environment\\n\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_protocol",
          "args": [
            "trace_output",
            "fp"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "build_protocol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fbuilder/build_seccomp.c",
          "lines": "145-191",
          "snippet": "void build_protocol(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\t// run fname\n\tprocess_protocol(fname);\n\n\t// run all the rest\n\tstruct stat s;\n\tint i;\n\tfor (i = 1; i <= 5; i++) {\n\t\tchar *newname;\n\t\tif (asprintf(&newname, \"%s.%d\", fname, i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(newname, &s) == 0)\n\t\t\tprocess_protocol(newname);\n\t\tfree(newname);\n\t}\n\n\tint net = 0;\n\tif (unix_s || inet || inet6 || netlink || packet) {\n\t\tfprintf(fp, \"protocol \");\n\t\tif (unix_s)\n\t\t\tfprintf(fp, \"unix,\");\n\t\tif (inet) {\n\t\t\tfprintf(fp, \"inet,\");\n\t\t\tnet = 1;\n\t\t}\n\t\tif (inet6) {\n\t\t\tfprintf(fp, \"inet6,\");\n\t\t\tnet = 1;\n\t\t}\n\t\tif (netlink)\n\t\t\tfprintf(fp, \"netlink,\");\n\t\tif (packet) {\n\t\t\tfprintf(fp, \"packet\");\n\t\t\tnet = 1;\n\t\t}\n\t\tfprintf(fp, \"\\n\");\n\t}\n\n\tif (net == 0)\n\t\tfprintf(fp, \"net none\\n\");\n\telse {\n\t\tfprintf(fp, \"# net eth0\\n\");\n\t\tfprintf(fp, \"netfilter\\n\");\n\t}\n}",
          "includes": [
            "#include \"fbuilder.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int unix_s = 0;",
            "int inet = 0;",
            "int inet6 = 0;",
            "int netlink = 0;",
            "int packet = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fbuilder.h\"\n\nint unix_s = 0;\nint inet = 0;\nint inet6 = 0;\nint netlink = 0;\nint packet = 0;\n\nvoid build_protocol(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\t// run fname\n\tprocess_protocol(fname);\n\n\t// run all the rest\n\tstruct stat s;\n\tint i;\n\tfor (i = 1; i <= 5; i++) {\n\t\tchar *newname;\n\t\tif (asprintf(&newname, \"%s.%d\", fname, i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(newname, &s) == 0)\n\t\t\tprocess_protocol(newname);\n\t\tfree(newname);\n\t}\n\n\tint net = 0;\n\tif (unix_s || inet || inet6 || netlink || packet) {\n\t\tfprintf(fp, \"protocol \");\n\t\tif (unix_s)\n\t\t\tfprintf(fp, \"unix,\");\n\t\tif (inet) {\n\t\t\tfprintf(fp, \"inet,\");\n\t\t\tnet = 1;\n\t\t}\n\t\tif (inet6) {\n\t\t\tfprintf(fp, \"inet6,\");\n\t\t\tnet = 1;\n\t\t}\n\t\tif (netlink)\n\t\t\tfprintf(fp, \"netlink,\");\n\t\tif (packet) {\n\t\t\tfprintf(fp, \"packet\");\n\t\t\tnet = 1;\n\t\t}\n\t\tfprintf(fp, \"\\n\");\n\t}\n\n\tif (net == 0)\n\t\tfprintf(fp, \"net none\\n\");\n\telse {\n\t\tfprintf(fp, \"# net eth0\\n\");\n\t\tfprintf(fp, \"netfilter\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"### network\\n\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"# whitelisted seccomp filter.\\n\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"# If you install strace on your system, Firejail will also create a\\n\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_seccomp",
          "args": [
            "strace_output",
            "fp"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "build_seccomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fbuilder/build_seccomp.c",
          "lines": "23-80",
          "snippet": "void build_seccomp(const char *fname, FILE *fp) {\n\tassert(fname);\n\tassert(fp);\n\n\tFILE *fp2 = fopen(fname, \"r\");\n\tif (!fp2) {\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\tchar buf[MAX_BUF];\n\tint line = 1;\n\tint position = 0;\n\tint cnt = 0;\n\twhile (fgets(buf, MAX_BUF, fp2)) {\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// first line:\n\t\t//% time     seconds  usecs/call     calls    errors syscall\n\t\tif (line == 1) {\n\t\t\t// extract syscall position\n\t\t\tptr = strstr(buf, \"syscall\");\n\t\t\tif (*buf != '%' || ptr == NULL) {\n\t\t\t\t// skip this line, it could be garbage from strace\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tposition = (int) (ptr - buf);\n\t\t}\n\t\telse if (line == 2) {\n\t\t\tif (*buf != '-') {\n\t\t\t\tfprintf(stderr, \"Error: invalid strace output\\n%s\\n\", buf);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// get out on the next \"----\" line\n\t\t\tif (*buf == '-')\n\t\t\t\tbreak;\n\n\t\t\tif (line == 3)\n\t\t\t\tfprintf(fp, \"# seccomp.keep %s\", buf + position);\n\t\t\telse\n\t\t\t\tfprintf(fp, \",%s\", buf + position);\n\t\t\tcnt++;\n\t\t}\n\t\tline++;\n\t}\n\tfprintf(fp, \"\\n\");\n\tfprintf(fp, \"# %d syscalls total\\n\", cnt);\n\tfprintf(fp, \"# Probably you will need to add more syscalls to seccomp.keep. Look for\\n\");\n\tfprintf(fp, \"# seccomp errors in /var/log/syslog or /var/log/audit/audit.log while\\n\");\n\tfprintf(fp, \"# running your sandbox.\\n\");\n\n\tfclose(fp2);\n}",
          "includes": [
            "#include \"fbuilder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fbuilder.h\"\n\nvoid build_seccomp(const char *fname, FILE *fp) {\n\tassert(fname);\n\tassert(fp);\n\n\tFILE *fp2 = fopen(fname, \"r\");\n\tif (!fp2) {\n\t\tfprintf(stderr, \"Error: cannot open %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\tchar buf[MAX_BUF];\n\tint line = 1;\n\tint position = 0;\n\tint cnt = 0;\n\twhile (fgets(buf, MAX_BUF, fp2)) {\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\t// first line:\n\t\t//% time     seconds  usecs/call     calls    errors syscall\n\t\tif (line == 1) {\n\t\t\t// extract syscall position\n\t\t\tptr = strstr(buf, \"syscall\");\n\t\t\tif (*buf != '%' || ptr == NULL) {\n\t\t\t\t// skip this line, it could be garbage from strace\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tposition = (int) (ptr - buf);\n\t\t}\n\t\telse if (line == 2) {\n\t\t\tif (*buf != '-') {\n\t\t\t\tfprintf(stderr, \"Error: invalid strace output\\n%s\\n\", buf);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// get out on the next \"----\" line\n\t\t\tif (*buf == '-')\n\t\t\t\tbreak;\n\n\t\t\tif (line == 3)\n\t\t\t\tfprintf(fp, \"# seccomp.keep %s\", buf + position);\n\t\t\telse\n\t\t\t\tfprintf(fp, \",%s\", buf + position);\n\t\t\tcnt++;\n\t\t}\n\t\tline++;\n\t}\n\tfprintf(fp, \"\\n\");\n\tfprintf(fp, \"# %d syscalls total\\n\", cnt);\n\tfprintf(fp, \"# Probably you will need to add more syscalls to seccomp.keep. Look for\\n\");\n\tfprintf(fp, \"# seccomp errors in /var/log/syslog or /var/log/audit/audit.log while\\n\");\n\tfprintf(fp, \"# running your sandbox.\\n\");\n\n\tfclose(fp2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"seccomp\\n\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"nonewprivs\\n\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"caps.drop all\\n\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"### security filters\\n\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_share",
          "args": [
            "trace_output",
            "fp"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "build_share",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fbuilder/build_fs.c",
          "lines": "200-209",
          "snippet": "void build_share(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\tprocess_files(fname, \"/usr/share\", share_callback);\n\n\tif (share_out == NULL)\n\t\tfprintf(fp, \"blacklist /usr/share\\n\");\n\telse\n\t\tfiledb_print(share_out, \"whitelist \", fp);\n}",
          "includes": [
            "#include \"fbuilder.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FileDB *share_out = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fbuilder.h\"\n\nstatic FileDB *share_out = NULL;\n\nvoid build_share(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\tprocess_files(fname, \"/usr/share\", share_callback);\n\n\tif (share_out == NULL)\n\t\tfprintf(fp, \"blacklist /usr/share\\n\");\n\telse\n\t\tfiledb_print(share_out, \"whitelist \", fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_bin",
          "args": [
            "trace_output",
            "fp"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "build_bin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fbuilder/build_bin.c",
          "lines": "98-126",
          "snippet": "void build_bin(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\t// run fname\n\tprocess_bin(fname);\n\n\t// run all the rest\n\tstruct stat s;\n\tint i;\n\tfor (i = 1; i <= 5; i++) {\n\t\tchar *newname;\n\t\tif (asprintf(&newname, \"%s.%d\", fname, i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(newname, &s) == 0)\n\t\t\tprocess_bin(newname);\n\t\tfree(newname);\n\t}\n\n\tif (bin_out) {\n\t\tfprintf(fp, \"private-bin \");\n\t\tFileDB *ptr = bin_out;\n\t\twhile (ptr) {\n\t\t\tfprintf(fp, \"%s,\", ptr->fname);\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfprintf(fp, \"\\n\");\n\t\tfprintf(fp, \"# private-lib\\n\");\n\t}\n}",
          "includes": [
            "#include \"fbuilder.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FileDB *bin_out = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fbuilder.h\"\n\nstatic FileDB *bin_out = NULL;\n\nvoid build_bin(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\t// run fname\n\tprocess_bin(fname);\n\n\t// run all the rest\n\tstruct stat s;\n\tint i;\n\tfor (i = 1; i <= 5; i++) {\n\t\tchar *newname;\n\t\tif (asprintf(&newname, \"%s.%d\", fname, i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(newname, &s) == 0)\n\t\t\tprocess_bin(newname);\n\t\tfree(newname);\n\t}\n\n\tif (bin_out) {\n\t\tfprintf(fp, \"private-bin \");\n\t\tFileDB *ptr = bin_out;\n\t\twhile (ptr) {\n\t\t\tfprintf(fp, \"%s,\", ptr->fname);\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfprintf(fp, \"\\n\");\n\t\tfprintf(fp, \"# private-lib\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_var",
          "args": [
            "trace_output",
            "fp"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "build_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fbuilder/build_fs.c",
          "lines": "163-172",
          "snippet": "void build_var(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\tprocess_files(fname, \"/var\", var_callback);\n\n\tif (var_out == NULL)\n\t\tfprintf(fp, \"blacklist /var\\n\");\n\telse\n\t\tfiledb_print(var_out, \"whitelist \", fp);\n}",
          "includes": [
            "#include \"fbuilder.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FileDB *var_out = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fbuilder.h\"\n\nstatic FileDB *var_out = NULL;\n\nvoid build_var(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\tprocess_files(fname, \"/var\", var_callback);\n\n\tif (var_out == NULL)\n\t\tfprintf(fp, \"blacklist /var\\n\");\n\telse\n\t\tfiledb_print(var_out, \"whitelist \", fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_etc",
          "args": [
            "trace_output",
            "fp"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "build_etc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fbuilder/build_fs.c",
          "lines": "128-144",
          "snippet": "void build_etc(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\tprocess_files(fname, \"/etc\", etc_callback);\n\n\tfprintf(fp, \"private-etc \");\n\tif (etc_out == NULL)\n\t\tfprintf(fp, \"none\\n\");\n\telse {\n\t\tFileDB *ptr = etc_out;\n\t\twhile (ptr) {\n\t\t\tfprintf(fp, \"%s,\", ptr->fname);\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfprintf(fp, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"fbuilder.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FileDB *etc_out = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fbuilder.h\"\n\nstatic FileDB *etc_out = NULL;\n\nvoid build_etc(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\tprocess_files(fname, \"/etc\", etc_callback);\n\n\tfprintf(fp, \"private-etc \");\n\tif (etc_out == NULL)\n\t\tfprintf(fp, \"none\\n\");\n\telse {\n\t\tFileDB *ptr = etc_out;\n\t\twhile (ptr) {\n\t\t\tfprintf(fp, \"%s,\", ptr->fname);\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfprintf(fp, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_dev",
          "args": [
            "trace_output",
            "fp"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "build_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fbuilder/build_fs.c",
          "lines": "297-316",
          "snippet": "void build_dev(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\tprocess_files(fname, \"/dev\", dev_callback);\n\n\tif (dev_out == NULL)\n\t\tfprintf(fp, \"private-dev\\n\");\n\telse {\n\t\tfprintf(fp, \"\\n\");\n\t\tfprintf(fp, \"# private-dev\\n\");\n\t\tfprintf(fp, \"# This is the list of devices accessed (on top of regular private-dev devices:\\n\");\n\t\tfprintf(fp, \"# \");\n\t\tFileDB *ptr = dev_out;\n\t\twhile (ptr) {\n\t\t\tfprintf(fp, \"%s,\", ptr->fname);\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfprintf(fp, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"fbuilder.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FileDB *dev_out = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fbuilder.h\"\n\nstatic FileDB *dev_out = NULL;\n\nvoid build_dev(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\tprocess_files(fname, \"/dev\", dev_callback);\n\n\tif (dev_out == NULL)\n\t\tfprintf(fp, \"private-dev\\n\");\n\telse {\n\t\tfprintf(fp, \"\\n\");\n\t\tfprintf(fp, \"# private-dev\\n\");\n\t\tfprintf(fp, \"# This is the list of devices accessed (on top of regular private-dev devices:\\n\");\n\t\tfprintf(fp, \"# \");\n\t\tFileDB *ptr = dev_out;\n\t\twhile (ptr) {\n\t\t\tfprintf(fp, \"%s,\", ptr->fname);\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tfprintf(fp, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_tmp",
          "args": [
            "trace_output",
            "fp"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "build_tmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fbuilder/build_fs.c",
          "lines": "219-238",
          "snippet": "void build_tmp(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\tprocess_files(fname, \"/tmp\", tmp_callback);\n\n\tif (tmp_out == NULL)\n\t\tfprintf(fp, \"private-tmp\\n\");\n\telse {\n\t\tfprintf(fp, \"\\n\");\n\t\tfprintf(fp, \"# private-tmp\\n\");\n\t\tfprintf(fp, \"# File accessed in /tmp directory:\\n\");\n\t\tfprintf(fp, \"# \");\n\t\tFileDB *ptr = tmp_out;\n\t\twhile (ptr) {\n\t\t\tfprintf(fp, \"%s,\", ptr->fname);\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"fbuilder.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FileDB *tmp_out = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fbuilder.h\"\n\nstatic FileDB *tmp_out = NULL;\n\nvoid build_tmp(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\tprocess_files(fname, \"/tmp\", tmp_callback);\n\n\tif (tmp_out == NULL)\n\t\tfprintf(fp, \"private-tmp\\n\");\n\telse {\n\t\tfprintf(fp, \"\\n\");\n\t\tfprintf(fp, \"# private-tmp\\n\");\n\t\tfprintf(fp, \"# File accessed in /tmp directory:\\n\");\n\t\tfprintf(fp, \"# \");\n\t\tFileDB *ptr = tmp_out;\n\t\twhile (ptr) {\n\t\t\tfprintf(fp, \"%s,\", ptr->fname);\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"### filesystem\\n\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_home",
          "args": [
            "trace_output",
            "fp"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "build_home",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fbuilder/build_home.c",
          "lines": "161-199",
          "snippet": "void build_home(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\t// load whitelist common\n\tload_whitelist_common();\n\n\t// find user home directory\n\tstruct passwd *pw = getpwuid(getuid());\n\tif (!pw)\n\t\terrExit(\"getpwuid\");\n\tchar *home = pw->pw_dir;\n\tif (!home)\n\t\terrExit(\"getpwuid\");\n\tint home_len = strlen(home);\n\n\t// run fname\n\tprocess_home(fname, home, home_len);\n\n\t// run all the rest\n\tstruct stat s;\n\tint i;\n\tfor (i = 1; i <= 5; i++) {\n\t\tchar *newname;\n\t\tif (asprintf(&newname, \"%s.%d\", fname, i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(newname, &s) == 0)\n\t\t\tprocess_home(newname, home, home_len);\n\t\tfree(newname);\n\t}\n\n\t// print the out list if any\n\tif (db_out) {\n\t\tfiledb_print(db_out, \"whitelist ~/\", fp);\n\t\tfprintf(fp, \"include /etc/firejail/whitelist-common.inc\\n\");\n\t}\n\telse\n\t\tfprintf(fp, \"private\\n\");\n\n}",
          "includes": [
            "#include \"fbuilder.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FileDB *db_out = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fbuilder.h\"\n\nstatic FileDB *db_out = NULL;\n\nvoid build_home(const char *fname, FILE *fp) {\n\tassert(fname);\n\n\t// load whitelist common\n\tload_whitelist_common();\n\n\t// find user home directory\n\tstruct passwd *pw = getpwuid(getuid());\n\tif (!pw)\n\t\terrExit(\"getpwuid\");\n\tchar *home = pw->pw_dir;\n\tif (!home)\n\t\terrExit(\"getpwuid\");\n\tint home_len = strlen(home);\n\n\t// run fname\n\tprocess_home(fname, home, home_len);\n\n\t// run all the rest\n\tstruct stat s;\n\tint i;\n\tfor (i = 1; i <= 5; i++) {\n\t\tchar *newname;\n\t\tif (asprintf(&newname, \"%s.%d\", fname, i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(newname, &s) == 0)\n\t\t\tprocess_home(newname, home, home_len);\n\t\tfree(newname);\n\t}\n\n\t// print the out list if any\n\tif (db_out) {\n\t\tfiledb_print(db_out, \"whitelist ~/\", fp);\n\t\tfprintf(fp, \"include /etc/firejail/whitelist-common.inc\\n\");\n\t}\n\telse\n\t\tfprintf(fp, \"private\\n\");\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"### home directory whitelisting\\n\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"# include /etc/firejail/disable-programs.inc\\n\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"include /etc/firejail/disable-passwdmgr.inc\\n\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"# include /etc/firejail/disable-devel.inc\\n\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"include /etc/firejail/disable-common.inc\\n\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"### basic blacklisting\\n\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"# include /etc/firejail/globals.local\\n\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"# Persistent global definitions\\n\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"############################################\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"# %s profile\\n\"",
            "argv[index]"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"############################################\\n\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\\n\\n\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"waitpid\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&status",
            "0"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"execv\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "cmd[0]",
            "cmd"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cmd[0]"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\t%s\\n\"",
            "cmd[i]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "i < len"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmdlist[i]",
            "\"/usr/bin/strace\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"command len %d + %d + 1\\n\"",
            "(int) (sizeof(cmdlist) / sizeof(char*))",
            "argc - index"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "\"/usr/bin/strace\"",
            "X_OK"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/libtrace/libtrace.c",
          "lines": "478-485",
          "snippet": "int access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include <dlfcn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static orig_access_t orig_access = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <dirent.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic orig_access_t orig_access = NULL;\n\nint access(const char *pathname, int mode) {\n\tif (!orig_access)\n\t\torig_access = (orig_access_t)dlsym(RTLD_NEXT, \"access\");\n\n\tint rv = orig_access(pathname, mode);\n\tprintf(\"%u:%s:access %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&stroutput",
            "\"-o %s\"",
            "strace_output"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&output",
            "\"--output=%s\"",
            "trace_output"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "stfile"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkstemp\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "strace_output"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "trace_output"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: application name missing\\n\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"fbuilder.h\"\n\nvoid build_profile(int argc, char **argv, int index, FILE *fp) {\n\t// next index is the application name\n\tif (index >= argc) {\n\t\tfprintf(stderr, \"Error: application name missing\\n\");\n\t\texit(1);\n\t}\n\n\tchar trace_output[] = \"/tmp/firejail-trace.XXXXXX\";\n\tchar strace_output[] = \"/tmp/firejail-strace.XXXXXX\";\n\n\tint tfile = mkstemp(trace_output);\n\tint stfile = mkstemp(strace_output);\n\tif(tfile == -1 || stfile == -1)\n\t\terrExit(\"mkstemp\");\n\n\t// close the files, firejail/strace will overwrite them!\n\tclose(tfile);\n\tclose(stfile);\n\n\n\tchar *output;\n\tchar *stroutput;\n\tif(asprintf(&output,\"--output=%s\",trace_output) == -1)\n\t\terrExit(\"asprintf\");\n\tif(asprintf(&stroutput,\"-o %s\",strace_output) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *cmdlist[] = {\n\t  \"/usr/bin/firejail\",\n\t  \"--quiet\",\n\t  output,\n\t  \"--noprofile\",\n\t  \"--caps.drop=all\",\n\t  \"--nonewprivs\",\n\t  \"--trace\",\n\t  \"--shell=none\",\n\t  \"/usr/bin/strace\", // also used as a marker in build_profile()\n\t  \"-c\",\n\t  \"-f\",\n\t  stroutput,\n\t};\n\n\t// detect strace\n\tint have_strace = 0;\n\tif (access(\"/usr/bin/strace\", X_OK) == 0)\n\t\thave_strace = 1;\n\n\t// calculate command length\n\tunsigned len = (int) sizeof(cmdlist) / sizeof(char*) + argc - index + 1;\n\tif (arg_debug)\n\t\tprintf(\"command len %d + %d + 1\\n\", (int) (sizeof(cmdlist) / sizeof(char*)), argc - index);\n\tchar *cmd[len];\n\tcmd[0] = cmdlist[0];\t// explicit assignment to clean scan-build error\n\n\t// build command\n\tunsigned i = 0;\n\tfor (i = 0; i < (int) sizeof(cmdlist) / sizeof(char*); i++) {\n\t\t// skip strace if not installed\n\t\tif (have_strace == 0 && strcmp(cmdlist[i], \"/usr/bin/strace\") == 0)\n\t\t\tbreak;\n\t\tcmd[i] = cmdlist[i];\n\t}\n\n\tint i2 = index;\n\tfor (; i < (len - 1); i++, i2++)\n\t\tcmd[i] = argv[i2];\n\tassert(i < len);\n\tcmd[i] = NULL;\n\n\tif (arg_debug) {\n\t\tfor (i = 0; i < len; i++)\n\t\t\tprintf(\"\\t%s\\n\", cmd[i]);\n\t}\n\n\t// fork and execute\n\tpid_t child = fork();\n\tif (child == -1)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tassert(cmd[0]);\n\t\tint rv = execvp(cmd[0], cmd);\n\t\t(void) rv;\n\t\terrExit(\"execv\");\n\t}\n\n\t// wait for all processes to finish\n\tint status;\n\tif (waitpid(child, &status, 0) != child)\n\t\terrExit(\"waitpid\");\n\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\tprintf(\"\\n\\n\\n\");\n\t\tfprintf(fp, \"############################################\\n\");\n\t\tfprintf(fp, \"# %s profile\\n\", argv[index]);\n\t\tfprintf(fp, \"############################################\\n\");\n\t\tfprintf(fp, \"# Persistent global definitions\\n\");\n\t\tfprintf(fp, \"# include /etc/firejail/globals.local\\n\");\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### basic blacklisting\\n\");\n\t\tfprintf(fp, \"include /etc/firejail/disable-common.inc\\n\");\n\t\tfprintf(fp, \"# include /etc/firejail/disable-devel.inc\\n\");\n\t\tfprintf(fp, \"include /etc/firejail/disable-passwdmgr.inc\\n\");\n\t\tfprintf(fp, \"# include /etc/firejail/disable-programs.inc\\n\");\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### home directory whitelisting\\n\");\n\t\tbuild_home(trace_output, fp);\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### filesystem\\n\");\n\t\tbuild_tmp(trace_output, fp);\n\t\tbuild_dev(trace_output, fp);\n\t\tbuild_etc(trace_output, fp);\n\t\tbuild_var(trace_output, fp);\n\t\tbuild_bin(trace_output, fp);\n\t\tbuild_share(trace_output, fp);\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### security filters\\n\");\n\t\tfprintf(fp, \"caps.drop all\\n\");\n\t\tfprintf(fp, \"nonewprivs\\n\");\n\t\tfprintf(fp, \"seccomp\\n\");\n\t\tif (have_strace)\n\t\t\tbuild_seccomp(strace_output, fp);\n\t\telse {\n\t\t\tfprintf(fp, \"# If you install strace on your system, Firejail will also create a\\n\");\n\t\t\tfprintf(fp, \"# whitelisted seccomp filter.\\n\");\n\t\t}\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### network\\n\");\n\t\tbuild_protocol(trace_output, fp);\n\t\tfprintf(fp, \"\\n\");\n\n\t\tfprintf(fp, \"### environment\\n\");\n\t\tfprintf(fp, \"shell none\\n\");\n\n\t\tunlink(trace_output);\n\t\tunlink(strace_output);\n\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot run the sandbox\\n\");\n\t\texit(1);\n\t}\n}"
  }
]