[
  {
    "function_name": "net_move_interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/veth.c",
    "lines": "250-284",
    "snippet": "int net_move_interface(const char *dev, unsigned pid) {\n\tstruct iplink_req req;\n\tassert(dev);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find ifindex\n\tint ifindex = if_nametoindex(dev);\n\tif (ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find interface %s\\n\", dev);\n\t\texit(1);\n\t}\n\treq.i.ifi_index = ifindex;\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <linux/veth.h>",
      "#include \"../include/libnetlink.h\"",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rtnl_handle rth = { .fd = -1 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtnl_close",
          "args": [
            "&rth"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtnl_talk",
          "args": [
            "&rth",
            "&req.n",
            "0",
            "0",
            "NULL"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_talk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "309-425",
          "snippet": "int rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,\n\t      unsigned groups, struct nlmsghdr *answer)\n{\n\tint status;\n\tunsigned seq;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov = {\n\t\t.iov_base = (void*) n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[16384];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = peer;\n\tnladdr.nl_groups = groups;\n\n\tn->nlmsg_seq = seq = ++rtnl->seq;\n\n\tif (answer == NULL)\n\t\tn->nlmsg_flags |= NLM_F_ACK;\n\n\tstatus = sendmsg(rtnl->fd, &msg, 0);\n\n\tif (status < 0) {\n\t\tperror(\"Cannot talk to rtnetlink\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf,0,sizeof(buf));\n\n\tiov.iov_base = buf;\n\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l < 0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((pid_t)(nladdr.nl_pid) != peer ||\n\t\t\t    h->nlmsg_pid != rtnl->local.nl_pid ||\n\t\t\t    h->nlmsg_seq != seq) {\n\t\t\t\t/* Don't forget to skip that message. */\n\t\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\tif (l < (int)sizeof(struct nlmsgerr)) {\n\t\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (!err->error) {\n\t\t\t\t\t\tif (answer)\n\t\t\t\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfprintf(stderr, \"RTNETLINK answers: %s\\n\", strerror(-err->error));\n\t\t\t\t\terrno = -err->error;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (answer) {\n\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfprintf(stderr, \"Unexpected reply!!!\\n\");\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,\n\t      unsigned groups, struct nlmsghdr *answer)\n{\n\tint status;\n\tunsigned seq;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov = {\n\t\t.iov_base = (void*) n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[16384];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = peer;\n\tnladdr.nl_groups = groups;\n\n\tn->nlmsg_seq = seq = ++rtnl->seq;\n\n\tif (answer == NULL)\n\t\tn->nlmsg_flags |= NLM_F_ACK;\n\n\tstatus = sendmsg(rtnl->fd, &msg, 0);\n\n\tif (status < 0) {\n\t\tperror(\"Cannot talk to rtnetlink\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf,0,sizeof(buf));\n\n\tiov.iov_base = buf;\n\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l < 0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((pid_t)(nladdr.nl_pid) != peer ||\n\t\t\t    h->nlmsg_pid != rtnl->local.nl_pid ||\n\t\t\t    h->nlmsg_seq != seq) {\n\t\t\t\t/* Don't forget to skip that message. */\n\t\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\tif (l < (int)sizeof(struct nlmsgerr)) {\n\t\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (!err->error) {\n\t\t\t\t\t\tif (answer)\n\t\t\t\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfprintf(stderr, \"RTNETLINK answers: %s\\n\", strerror(-err->error));\n\t\t\t\t\terrno = -err->error;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (answer) {\n\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfprintf(stderr, \"Unexpected reply!!!\\n\");\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_NET_NS_PID",
            "&pid",
            "4"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find interface %s\\n\"",
            "dev"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "dev"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(struct ifinfomsg)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&req",
            "0",
            "sizeof(req)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cannot open netlink\\n\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtnl_open",
          "args": [
            "&rth",
            "0"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "103-106",
          "snippet": "int rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)\n{\n\treturn rtnl_open_byproto(rth, subscriptions, NETLINK_ROUTE);\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)\n{\n\treturn rtnl_open_byproto(rth, subscriptions, NETLINK_ROUTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dev"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"fnet.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_move_interface(const char *dev, unsigned pid) {\n\tstruct iplink_req req;\n\tassert(dev);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find ifindex\n\tint ifindex = if_nametoindex(dev);\n\tif (ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find interface %s\\n\", dev);\n\t\texit(1);\n\t}\n\treq.i.ifi_index = ifindex;\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "net_create_ipvlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/veth.c",
    "lines": "186-246",
    "snippet": "int net_create_ipvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"ipvlan\", strlen(\"ipvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = IPVLAN_MODE_L2;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 2);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n//\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <linux/veth.h>",
      "#include \"../include/libnetlink.h\"",
      "#include \"fnet.h\""
    ],
    "macros_used": [
      "#define IPVLAN_MODE_L2 0"
    ],
    "globals_used": [
      "static struct rtnl_handle rth = { .fd = -1 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtnl_close",
          "args": [
            "&rth"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtnl_talk",
          "args": [
            "&rth",
            "&req.n",
            "0",
            "0",
            "NULL"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_talk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "309-425",
          "snippet": "int rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,\n\t      unsigned groups, struct nlmsghdr *answer)\n{\n\tint status;\n\tunsigned seq;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov = {\n\t\t.iov_base = (void*) n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[16384];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = peer;\n\tnladdr.nl_groups = groups;\n\n\tn->nlmsg_seq = seq = ++rtnl->seq;\n\n\tif (answer == NULL)\n\t\tn->nlmsg_flags |= NLM_F_ACK;\n\n\tstatus = sendmsg(rtnl->fd, &msg, 0);\n\n\tif (status < 0) {\n\t\tperror(\"Cannot talk to rtnetlink\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf,0,sizeof(buf));\n\n\tiov.iov_base = buf;\n\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l < 0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((pid_t)(nladdr.nl_pid) != peer ||\n\t\t\t    h->nlmsg_pid != rtnl->local.nl_pid ||\n\t\t\t    h->nlmsg_seq != seq) {\n\t\t\t\t/* Don't forget to skip that message. */\n\t\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\tif (l < (int)sizeof(struct nlmsgerr)) {\n\t\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (!err->error) {\n\t\t\t\t\t\tif (answer)\n\t\t\t\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfprintf(stderr, \"RTNETLINK answers: %s\\n\", strerror(-err->error));\n\t\t\t\t\terrno = -err->error;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (answer) {\n\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfprintf(stderr, \"Unexpected reply!!!\\n\");\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,\n\t      unsigned groups, struct nlmsghdr *answer)\n{\n\tint status;\n\tunsigned seq;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov = {\n\t\t.iov_base = (void*) n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[16384];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = peer;\n\tnladdr.nl_groups = groups;\n\n\tn->nlmsg_seq = seq = ++rtnl->seq;\n\n\tif (answer == NULL)\n\t\tn->nlmsg_flags |= NLM_F_ACK;\n\n\tstatus = sendmsg(rtnl->fd, &msg, 0);\n\n\tif (status < 0) {\n\t\tperror(\"Cannot talk to rtnetlink\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf,0,sizeof(buf));\n\n\tiov.iov_base = buf;\n\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l < 0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((pid_t)(nladdr.nl_pid) != peer ||\n\t\t\t    h->nlmsg_pid != rtnl->local.nl_pid ||\n\t\t\t    h->nlmsg_seq != seq) {\n\t\t\t\t/* Don't forget to skip that message. */\n\t\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\tif (l < (int)sizeof(struct nlmsgerr)) {\n\t\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (!err->error) {\n\t\t\t\t\t\tif (answer)\n\t\t\t\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfprintf(stderr, \"RTNETLINK answers: %s\\n\", strerror(-err->error));\n\t\t\t\t\terrno = -err->error;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (answer) {\n\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfprintf(stderr, \"Unexpected reply!!!\\n\");\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_INFO_KIND",
            "&macvlan_type",
            "2"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"ipvlan\""
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find network device %s\\n\"",
            "parent"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "parent"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(struct ifinfomsg)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&req",
            "0",
            "sizeof(req)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cannot open netlink\\n\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtnl_open",
          "args": [
            "&rth",
            "0"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "103-106",
          "snippet": "int rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)\n{\n\treturn rtnl_open_byproto(rth, subscriptions, NETLINK_ROUTE);\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)\n{\n\treturn rtnl_open_byproto(rth, subscriptions, NETLINK_ROUTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parent"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dev"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"fnet.h\"\n\n#define IPVLAN_MODE_L2 0\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_create_ipvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"ipvlan\", strlen(\"ipvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = IPVLAN_MODE_L2;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 2);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n//\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "net_create_macvlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/veth.c",
    "lines": "127-184",
    "snippet": "int net_create_macvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"macvlan\", strlen(\"macvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = MACVLAN_MODE_BRIDGE;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 4);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <linux/veth.h>",
      "#include \"../include/libnetlink.h\"",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rtnl_handle rth = { .fd = -1 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtnl_close",
          "args": [
            "&rth"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtnl_talk",
          "args": [
            "&rth",
            "&req.n",
            "0",
            "0",
            "NULL"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_talk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "309-425",
          "snippet": "int rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,\n\t      unsigned groups, struct nlmsghdr *answer)\n{\n\tint status;\n\tunsigned seq;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov = {\n\t\t.iov_base = (void*) n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[16384];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = peer;\n\tnladdr.nl_groups = groups;\n\n\tn->nlmsg_seq = seq = ++rtnl->seq;\n\n\tif (answer == NULL)\n\t\tn->nlmsg_flags |= NLM_F_ACK;\n\n\tstatus = sendmsg(rtnl->fd, &msg, 0);\n\n\tif (status < 0) {\n\t\tperror(\"Cannot talk to rtnetlink\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf,0,sizeof(buf));\n\n\tiov.iov_base = buf;\n\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l < 0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((pid_t)(nladdr.nl_pid) != peer ||\n\t\t\t    h->nlmsg_pid != rtnl->local.nl_pid ||\n\t\t\t    h->nlmsg_seq != seq) {\n\t\t\t\t/* Don't forget to skip that message. */\n\t\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\tif (l < (int)sizeof(struct nlmsgerr)) {\n\t\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (!err->error) {\n\t\t\t\t\t\tif (answer)\n\t\t\t\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfprintf(stderr, \"RTNETLINK answers: %s\\n\", strerror(-err->error));\n\t\t\t\t\terrno = -err->error;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (answer) {\n\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfprintf(stderr, \"Unexpected reply!!!\\n\");\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,\n\t      unsigned groups, struct nlmsghdr *answer)\n{\n\tint status;\n\tunsigned seq;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov = {\n\t\t.iov_base = (void*) n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[16384];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = peer;\n\tnladdr.nl_groups = groups;\n\n\tn->nlmsg_seq = seq = ++rtnl->seq;\n\n\tif (answer == NULL)\n\t\tn->nlmsg_flags |= NLM_F_ACK;\n\n\tstatus = sendmsg(rtnl->fd, &msg, 0);\n\n\tif (status < 0) {\n\t\tperror(\"Cannot talk to rtnetlink\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf,0,sizeof(buf));\n\n\tiov.iov_base = buf;\n\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l < 0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((pid_t)(nladdr.nl_pid) != peer ||\n\t\t\t    h->nlmsg_pid != rtnl->local.nl_pid ||\n\t\t\t    h->nlmsg_seq != seq) {\n\t\t\t\t/* Don't forget to skip that message. */\n\t\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\tif (l < (int)sizeof(struct nlmsgerr)) {\n\t\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (!err->error) {\n\t\t\t\t\t\tif (answer)\n\t\t\t\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfprintf(stderr, \"RTNETLINK answers: %s\\n\", strerror(-err->error));\n\t\t\t\t\terrno = -err->error;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (answer) {\n\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfprintf(stderr, \"Unexpected reply!!!\\n\");\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_INFO_KIND",
            "&macvlan_type",
            "4"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"macvlan\""
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find network device %s\\n\"",
            "parent"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "parent"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(struct ifinfomsg)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&req",
            "0",
            "sizeof(req)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cannot open netlink\\n\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtnl_open",
          "args": [
            "&rth",
            "0"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "103-106",
          "snippet": "int rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)\n{\n\treturn rtnl_open_byproto(rth, subscriptions, NETLINK_ROUTE);\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)\n{\n\treturn rtnl_open_byproto(rth, subscriptions, NETLINK_ROUTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parent"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dev"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"fnet.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_create_macvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"macvlan\", strlen(\"macvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = MACVLAN_MODE_BRIDGE;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 4);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "net_create_veth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/fnet/veth.c",
    "lines": "69-124",
    "snippet": "int net_create_veth(const char *dev, const char *nsdev, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\n\tassert(dev);\n\tassert(nsdev);\n\tassert(pid);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\tif (dev) {\n\t\tlen = strlen(dev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t}\n\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"veth\", strlen(\"veth\"));\n\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\n\tstruct rtattr * peerdata = NLMSG_TAIL(&req.n);\n\taddattr_l (&req.n, sizeof(req), VETH_INFO_PEER, NULL, 0);\n\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\t// place the link in the child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\tif (nsdev) {\n\t\tint len = strlen(nsdev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, nsdev, len);\n\t}\n\tpeerdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)peerdata;\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <linux/veth.h>",
      "#include \"../include/libnetlink.h\"",
      "#include \"fnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rtnl_handle rth = { .fd = -1 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtnl_close",
          "args": [
            "&rth"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "46-52",
          "snippet": "void rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "exit_err_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/main.c",
          "lines": "329-332",
          "snippet": "static void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/firejail_user.h\"",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/firejail_user.h\"\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtnl_talk",
          "args": [
            "&rth",
            "&req.n",
            "0",
            "0",
            "NULL"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_talk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "309-425",
          "snippet": "int rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,\n\t      unsigned groups, struct nlmsghdr *answer)\n{\n\tint status;\n\tunsigned seq;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov = {\n\t\t.iov_base = (void*) n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[16384];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = peer;\n\tnladdr.nl_groups = groups;\n\n\tn->nlmsg_seq = seq = ++rtnl->seq;\n\n\tif (answer == NULL)\n\t\tn->nlmsg_flags |= NLM_F_ACK;\n\n\tstatus = sendmsg(rtnl->fd, &msg, 0);\n\n\tif (status < 0) {\n\t\tperror(\"Cannot talk to rtnetlink\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf,0,sizeof(buf));\n\n\tiov.iov_base = buf;\n\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l < 0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((pid_t)(nladdr.nl_pid) != peer ||\n\t\t\t    h->nlmsg_pid != rtnl->local.nl_pid ||\n\t\t\t    h->nlmsg_seq != seq) {\n\t\t\t\t/* Don't forget to skip that message. */\n\t\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\tif (l < (int)sizeof(struct nlmsgerr)) {\n\t\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (!err->error) {\n\t\t\t\t\t\tif (answer)\n\t\t\t\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfprintf(stderr, \"RTNETLINK answers: %s\\n\", strerror(-err->error));\n\t\t\t\t\terrno = -err->error;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (answer) {\n\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfprintf(stderr, \"Unexpected reply!!!\\n\");\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,\n\t      unsigned groups, struct nlmsghdr *answer)\n{\n\tint status;\n\tunsigned seq;\n\tstruct nlmsghdr *h;\n\tstruct sockaddr_nl nladdr;\n\tstruct iovec iov = {\n\t\t.iov_base = (void*) n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tchar   buf[16384];\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid = peer;\n\tnladdr.nl_groups = groups;\n\n\tn->nlmsg_seq = seq = ++rtnl->seq;\n\n\tif (answer == NULL)\n\t\tn->nlmsg_flags |= NLM_F_ACK;\n\n\tstatus = sendmsg(rtnl->fd, &msg, 0);\n\n\tif (status < 0) {\n\t\tperror(\"Cannot talk to rtnetlink\");\n\t\treturn -1;\n\t}\n\n\tmemset(buf,0,sizeof(buf));\n\n\tiov.iov_base = buf;\n\n\twhile (1) {\n\t\tiov.iov_len = sizeof(buf);\n\t\tstatus = recvmsg(rtnl->fd, &msg, 0);\n\n\t\tif (status < 0) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (msg.msg_namelen != sizeof(nladdr)) {\n\t\t\tfprintf(stderr, \"sender address length == %d\\n\", msg.msg_namelen);\n\t\t\texit(1);\n\t\t}\n\t\tfor (h = (struct nlmsghdr*)buf; status >= (int)sizeof(*h); ) {\n\t\t\tint len = h->nlmsg_len;\n\t\t\tint l = len - sizeof(*h);\n\n\t\t\tif (l < 0 || len>status) {\n\t\t\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\t\t\tfprintf(stderr, \"Truncated message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"!!!malformed message: len=%d\\n\", len);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((pid_t)(nladdr.nl_pid) != peer ||\n\t\t\t    h->nlmsg_pid != rtnl->local.nl_pid ||\n\t\t\t    h->nlmsg_seq != seq) {\n\t\t\t\t/* Don't forget to skip that message. */\n\t\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\t\tstruct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);\n\t\t\t\tif (l < (int)sizeof(struct nlmsgerr)) {\n\t\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (!err->error) {\n\t\t\t\t\t\tif (answer)\n\t\t\t\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tfprintf(stderr, \"RTNETLINK answers: %s\\n\", strerror(-err->error));\n\t\t\t\t\terrno = -err->error;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (answer) {\n\t\t\t\tmemcpy(answer, h, h->nlmsg_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfprintf(stderr, \"Unexpected reply!!!\\n\");\n\n\t\t\tstatus -= NLMSG_ALIGN(len);\n\t\t\th = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));\n\t\t}\n\t\tif (msg.msg_flags & MSG_TRUNC) {\n\t\t\tfprintf(stderr, \"Message truncated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"!!!Remnant of size %d\\n\", status);\n\t\t\texit(1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_IFNAME",
            "nsdev",
            "len"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "rta_addattr_l",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "703-719",
          "snippet": "int rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rta_addattr_l(struct rtattr *rta, int maxlen, int type,\n\t\t  const void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif ((int) (RTA_ALIGN(rta->rta_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr,\"rta_addattr_l: Error! max allowed bound %d exceeded\\n\",maxlen);\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + RTA_ALIGN(len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nsdev"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "= strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/macros.c",
          "lines": "83-91",
          "snippet": "len = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(struct ifinfomsg)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&req",
            "0",
            "sizeof(req)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cannot open netlink\\n\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtnl_open",
          "args": [
            "&rth",
            "0"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "rtnl_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/lib/libnetlink.c",
          "lines": "103-106",
          "snippet": "int rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)\n{\n\treturn rtnl_open_byproto(rth, subscriptions, NETLINK_ROUTE);\n}",
          "includes": [
            "#include \"../include/libnetlink.h\"",
            "#include <sys/uio.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <net/if_arp.h>",
            "#include <fcntl.h>",
            "#include <syslog.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/libnetlink.h\"\n#include <sys/uio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <net/if_arp.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)\n{\n\treturn rtnl_open_byproto(rth, subscriptions, NETLINK_ROUTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pid"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nsdev"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dev"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"fnet.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_create_veth(const char *dev, const char *nsdev, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\n\tassert(dev);\n\tassert(nsdev);\n\tassert(pid);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\tif (dev) {\n\t\tlen = strlen(dev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t}\n\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"veth\", strlen(\"veth\"));\n\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\n\tstruct rtattr * peerdata = NLMSG_TAIL(&req.n);\n\taddattr_l (&req.n, sizeof(req), VETH_INFO_PEER, NULL, 0);\n\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\t// place the link in the child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\tif (nsdev) {\n\t\tint len = strlen(nsdev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, nsdev, len);\n\t}\n\tpeerdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)peerdata;\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\trtnl_close(&rth);\n\n\treturn 0;\n}"
  }
]