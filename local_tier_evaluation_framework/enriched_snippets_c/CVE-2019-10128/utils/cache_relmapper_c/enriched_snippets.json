[
  {
    "function_name": "relmap_redo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "911-950",
    "snippet": "void\nrelmap_redo(XLogReaderState *record)\n{\n\tuint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK;\n\n\t/* Backup blocks are not used in relmap records */\n\tAssert(!XLogRecHasAnyBlockRefs(record));\n\n\tif (info == XLOG_RELMAP_UPDATE)\n\t{\n\t\txl_relmap_update *xlrec = (xl_relmap_update *) XLogRecGetData(record);\n\t\tRelMapFile\tnewmap;\n\t\tchar\t   *dbpath;\n\n\t\tif (xlrec->nbytes != sizeof(RelMapFile))\n\t\t\telog(PANIC, \"relmap_redo: wrong size %u in relmap update record\",\n\t\t\t\t xlrec->nbytes);\n\t\tmemcpy(&newmap, xlrec->data, sizeof(newmap));\n\n\t\t/* We need to construct the pathname for this database */\n\t\tdbpath = GetDatabasePath(xlrec->dbid, xlrec->tsid);\n\n\t\t/*\n\t\t * Write out the new map and send sinval, but of course don't write a\n\t\t * new WAL entry.  There's no surrounding transaction to tell to\n\t\t * preserve files, either.\n\t\t *\n\t\t * There shouldn't be anyone else updating relmaps during WAL replay,\n\t\t * so we don't bother to take the RelationMappingLock.  We would need\n\t\t * to do so if load_relmap_file needed to interlock against writers.\n\t\t */\n\t\twrite_relmap_file((xlrec->dbid == InvalidOid), &newmap,\n\t\t\t\t\t\t  false, true, false,\n\t\t\t\t\t\t  xlrec->dbid, xlrec->tsid, dbpath);\n\n\t\tpfree(dbpath);\n\t}\n\telse\n\t\telog(PANIC, \"relmap_redo: unknown op code %u\", info);\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void write_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "PANIC",
            "\"relmap_redo: unknown op code %u\"",
            "info"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "dbpath"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_relmap_file",
          "args": [
            "(xlrec->dbid == InvalidOid)",
            "&newmap",
            "false",
            "true",
            "false",
            "xlrec->dbid",
            "xlrec->tsid",
            "dbpath"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "write_relmap_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "714-856",
          "snippet": "static void\nwrite_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath)\n{\n\tint\t\t\tfd;\n\tRelMapFile *realmap;\n\tchar\t\tmapfilename[MAXPGPATH];\n\n\t/*\n\t * Fill in the overhead fields and update CRC.\n\t */\n\tnewmap->magic = RELMAPPER_FILEMAGIC;\n\tif (newmap->num_mappings < 0 || newmap->num_mappings > MAX_MAPPINGS)\n\t\telog(ERROR, \"attempt to write bogus relation mapping\");\n\n\tINIT_CRC32C(newmap->crc);\n\tCOMP_CRC32C(newmap->crc, (char *) newmap, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(newmap->crc);\n\n\t/*\n\t * Open the target file.  We prefer to do this before entering the\n\t * critical section, so that an open() failure need not force PANIC.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\trealmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t dbpath, RELMAPPER_FILENAME);\n\t\trealmap = &local_map;\n\t}\n\n\tfd = OpenTransientFile(mapfilename, O_WRONLY | O_CREAT | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\tif (write_wal)\n\t{\n\t\txl_relmap_update xlrec;\n\t\tXLogRecPtr\tlsn;\n\n\t\t/* now errors are fatal ... */\n\t\tSTART_CRIT_SECTION();\n\n\t\txlrec.dbid = dbid;\n\t\txlrec.tsid = tsid;\n\t\txlrec.nbytes = sizeof(RelMapFile);\n\n\t\tXLogBeginInsert();\n\t\tXLogRegisterData((char *) (&xlrec), MinSizeOfRelmapUpdate);\n\t\tXLogRegisterData((char *) newmap, sizeof(RelMapFile));\n\n\t\tlsn = XLogInsert(RM_RELMAP_ID, XLOG_RELMAP_UPDATE);\n\n\t\t/* As always, WAL must hit the disk before the data update does */\n\t\tXLogFlush(lsn);\n\t}\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_WRITE);\n\tif (write(fd, newmap, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t{\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\t}\n\tpgstat_report_wait_end();\n\n\t/*\n\t * We choose to fsync the data to disk before considering the task done.\n\t * It would be possible to relax this if it turns out to be a performance\n\t * issue, but it would complicate checkpointing --- see notes for\n\t * CheckPointRelationMap.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t\tereport(data_sync_elevel(ERROR),\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not fsync relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tif (CloseTransientFile(fd))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Now that the file is safely on disk, send sinval message to let other\n\t * backends know to re-read it.  We must do this inside the critical\n\t * section: if for some reason we fail to send the message, we have to\n\t * force a database-wide PANIC.  Otherwise other backends might continue\n\t * execution with stale mapping information, which would be catastrophic\n\t * as soon as others began to use the now-committed data.\n\t */\n\tif (send_sinval)\n\t\tCacheInvalidateRelmap(dbid);\n\n\t/*\n\t * Make sure that the files listed in the map are not deleted if the outer\n\t * transaction aborts.  This had better be within the critical section\n\t * too: it's not likely to fail, but if it did, we'd arrive at transaction\n\t * abort with the files still vulnerable.  PANICing will leave things in a\n\t * good state on-disk.\n\t *\n\t * Note: we're cheating a little bit here by assuming that mapped files\n\t * are either in pg_global or the database's default tablespace.\n\t */\n\tif (preserve_files)\n\t{\n\t\tint32\t\ti;\n\n\t\tfor (i = 0; i < newmap->num_mappings; i++)\n\t\t{\n\t\t\tRelFileNode rnode;\n\n\t\t\trnode.spcNode = tsid;\n\t\t\trnode.dbNode = dbid;\n\t\t\trnode.relNode = newmap->mappings[i].mapfilenode;\n\t\t\tRelationPreserveStorage(rnode, false);\n\t\t}\n\t}\n\n\t/* Success, update permanent copy */\n\tmemcpy(realmap, newmap, sizeof(RelMapFile));\n\n\t/* Critical section done */\n\tif (write_wal)\n\t\tEND_CRIT_SECTION();\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */",
            "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */",
            "#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\""
          ],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static void load_relmap_file(bool shared);",
            "static void write_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\nstatic void write_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath);\n\nstatic void\nwrite_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath)\n{\n\tint\t\t\tfd;\n\tRelMapFile *realmap;\n\tchar\t\tmapfilename[MAXPGPATH];\n\n\t/*\n\t * Fill in the overhead fields and update CRC.\n\t */\n\tnewmap->magic = RELMAPPER_FILEMAGIC;\n\tif (newmap->num_mappings < 0 || newmap->num_mappings > MAX_MAPPINGS)\n\t\telog(ERROR, \"attempt to write bogus relation mapping\");\n\n\tINIT_CRC32C(newmap->crc);\n\tCOMP_CRC32C(newmap->crc, (char *) newmap, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(newmap->crc);\n\n\t/*\n\t * Open the target file.  We prefer to do this before entering the\n\t * critical section, so that an open() failure need not force PANIC.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\trealmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t dbpath, RELMAPPER_FILENAME);\n\t\trealmap = &local_map;\n\t}\n\n\tfd = OpenTransientFile(mapfilename, O_WRONLY | O_CREAT | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\tif (write_wal)\n\t{\n\t\txl_relmap_update xlrec;\n\t\tXLogRecPtr\tlsn;\n\n\t\t/* now errors are fatal ... */\n\t\tSTART_CRIT_SECTION();\n\n\t\txlrec.dbid = dbid;\n\t\txlrec.tsid = tsid;\n\t\txlrec.nbytes = sizeof(RelMapFile);\n\n\t\tXLogBeginInsert();\n\t\tXLogRegisterData((char *) (&xlrec), MinSizeOfRelmapUpdate);\n\t\tXLogRegisterData((char *) newmap, sizeof(RelMapFile));\n\n\t\tlsn = XLogInsert(RM_RELMAP_ID, XLOG_RELMAP_UPDATE);\n\n\t\t/* As always, WAL must hit the disk before the data update does */\n\t\tXLogFlush(lsn);\n\t}\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_WRITE);\n\tif (write(fd, newmap, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t{\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\t}\n\tpgstat_report_wait_end();\n\n\t/*\n\t * We choose to fsync the data to disk before considering the task done.\n\t * It would be possible to relax this if it turns out to be a performance\n\t * issue, but it would complicate checkpointing --- see notes for\n\t * CheckPointRelationMap.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t\tereport(data_sync_elevel(ERROR),\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not fsync relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tif (CloseTransientFile(fd))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Now that the file is safely on disk, send sinval message to let other\n\t * backends know to re-read it.  We must do this inside the critical\n\t * section: if for some reason we fail to send the message, we have to\n\t * force a database-wide PANIC.  Otherwise other backends might continue\n\t * execution with stale mapping information, which would be catastrophic\n\t * as soon as others began to use the now-committed data.\n\t */\n\tif (send_sinval)\n\t\tCacheInvalidateRelmap(dbid);\n\n\t/*\n\t * Make sure that the files listed in the map are not deleted if the outer\n\t * transaction aborts.  This had better be within the critical section\n\t * too: it's not likely to fail, but if it did, we'd arrive at transaction\n\t * abort with the files still vulnerable.  PANICing will leave things in a\n\t * good state on-disk.\n\t *\n\t * Note: we're cheating a little bit here by assuming that mapped files\n\t * are either in pg_global or the database's default tablespace.\n\t */\n\tif (preserve_files)\n\t{\n\t\tint32\t\ti;\n\n\t\tfor (i = 0; i < newmap->num_mappings; i++)\n\t\t{\n\t\t\tRelFileNode rnode;\n\n\t\t\trnode.spcNode = tsid;\n\t\t\trnode.dbNode = dbid;\n\t\t\trnode.relNode = newmap->mappings[i].mapfilenode;\n\t\t\tRelationPreserveStorage(rnode, false);\n\t\t}\n\t}\n\n\t/* Success, update permanent copy */\n\tmemcpy(realmap, newmap, sizeof(RelMapFile));\n\n\t/* Critical section done */\n\tif (write_wal)\n\t\tEND_CRIT_SECTION();\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabasePath",
          "args": [
            "xlrec->dbid",
            "xlrec->tsid"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&newmap",
            "xlrec->data",
            "sizeof(newmap)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLogRecGetData",
          "args": [
            "record"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!XLogRecHasAnyBlockRefs(record)"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLogRecHasAnyBlockRefs",
          "args": [
            "record"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLogRecGetInfo",
          "args": [
            "record"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void write_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath);\n\nvoid\nrelmap_redo(XLogReaderState *record)\n{\n\tuint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK;\n\n\t/* Backup blocks are not used in relmap records */\n\tAssert(!XLogRecHasAnyBlockRefs(record));\n\n\tif (info == XLOG_RELMAP_UPDATE)\n\t{\n\t\txl_relmap_update *xlrec = (xl_relmap_update *) XLogRecGetData(record);\n\t\tRelMapFile\tnewmap;\n\t\tchar\t   *dbpath;\n\n\t\tif (xlrec->nbytes != sizeof(RelMapFile))\n\t\t\telog(PANIC, \"relmap_redo: wrong size %u in relmap update record\",\n\t\t\t\t xlrec->nbytes);\n\t\tmemcpy(&newmap, xlrec->data, sizeof(newmap));\n\n\t\t/* We need to construct the pathname for this database */\n\t\tdbpath = GetDatabasePath(xlrec->dbid, xlrec->tsid);\n\n\t\t/*\n\t\t * Write out the new map and send sinval, but of course don't write a\n\t\t * new WAL entry.  There's no surrounding transaction to tell to\n\t\t * preserve files, either.\n\t\t *\n\t\t * There shouldn't be anyone else updating relmaps during WAL replay,\n\t\t * so we don't bother to take the RelationMappingLock.  We would need\n\t\t * to do so if load_relmap_file needed to interlock against writers.\n\t\t */\n\t\twrite_relmap_file((xlrec->dbid == InvalidOid), &newmap,\n\t\t\t\t\t\t  false, true, false,\n\t\t\t\t\t\t  xlrec->dbid, xlrec->tsid, dbpath);\n\n\t\tpfree(dbpath);\n\t}\n\telse\n\t\telog(PANIC, \"relmap_redo: unknown op code %u\", info);\n}"
  },
  {
    "function_name": "perform_relmap_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "863-906",
    "snippet": "static void\nperform_relmap_update(bool shared, const RelMapFile *updates)\n{\n\tRelMapFile\tnewmap;\n\n\t/*\n\t * Anyone updating a relation's mapping info should take exclusive lock on\n\t * that rel and hold it until commit.  This ensures that there will not be\n\t * concurrent updates on the same mapping value; but there could easily be\n\t * concurrent updates on different values in the same file. We cover that\n\t * by acquiring the RelationMappingLock, re-reading the target file to\n\t * ensure it's up to date, applying the updates, and writing the data\n\t * before releasing RelationMappingLock.\n\t *\n\t * There is only one RelationMappingLock.  In principle we could try to\n\t * have one per mapping file, but it seems unlikely to be worth the\n\t * trouble.\n\t */\n\tLWLockAcquire(RelationMappingLock, LW_EXCLUSIVE);\n\n\t/* Be certain we see any other updates just made */\n\tload_relmap_file(shared);\n\n\t/* Prepare updated data in a local variable */\n\tif (shared)\n\t\tmemcpy(&newmap, &shared_map, sizeof(RelMapFile));\n\telse\n\t\tmemcpy(&newmap, &local_map, sizeof(RelMapFile));\n\n\t/*\n\t * Apply the updates to newmap.  No new mappings should appear, unless\n\t * somebody is adding indexes to system catalogs.\n\t */\n\tmerge_map_updates(&newmap, updates, allowSystemTableMods);\n\n\t/* Write out the updated map and do other necessary tasks */\n\twrite_relmap_file(shared, &newmap, true, true, true,\n\t\t\t\t\t  (shared ? InvalidOid : MyDatabaseId),\n\t\t\t\t\t  (shared ? GLOBALTABLESPACE_OID : MyDatabaseTableSpace),\n\t\t\t\t\t  DatabasePath);\n\n\t/* Now we can release the lock */\n\tLWLockRelease(RelationMappingLock);\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RelMapFile shared_map;",
      "static RelMapFile local_map;",
      "static void load_relmap_file(bool shared);",
      "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "RelationMappingLock"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_relmap_file",
          "args": [
            "shared",
            "&newmap",
            "true",
            "true",
            "true",
            "(shared ? InvalidOid : MyDatabaseId)",
            "(shared ? GLOBALTABLESPACE_OID : MyDatabaseTableSpace)",
            "DatabasePath"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "write_relmap_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "714-856",
          "snippet": "static void\nwrite_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath)\n{\n\tint\t\t\tfd;\n\tRelMapFile *realmap;\n\tchar\t\tmapfilename[MAXPGPATH];\n\n\t/*\n\t * Fill in the overhead fields and update CRC.\n\t */\n\tnewmap->magic = RELMAPPER_FILEMAGIC;\n\tif (newmap->num_mappings < 0 || newmap->num_mappings > MAX_MAPPINGS)\n\t\telog(ERROR, \"attempt to write bogus relation mapping\");\n\n\tINIT_CRC32C(newmap->crc);\n\tCOMP_CRC32C(newmap->crc, (char *) newmap, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(newmap->crc);\n\n\t/*\n\t * Open the target file.  We prefer to do this before entering the\n\t * critical section, so that an open() failure need not force PANIC.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\trealmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t dbpath, RELMAPPER_FILENAME);\n\t\trealmap = &local_map;\n\t}\n\n\tfd = OpenTransientFile(mapfilename, O_WRONLY | O_CREAT | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\tif (write_wal)\n\t{\n\t\txl_relmap_update xlrec;\n\t\tXLogRecPtr\tlsn;\n\n\t\t/* now errors are fatal ... */\n\t\tSTART_CRIT_SECTION();\n\n\t\txlrec.dbid = dbid;\n\t\txlrec.tsid = tsid;\n\t\txlrec.nbytes = sizeof(RelMapFile);\n\n\t\tXLogBeginInsert();\n\t\tXLogRegisterData((char *) (&xlrec), MinSizeOfRelmapUpdate);\n\t\tXLogRegisterData((char *) newmap, sizeof(RelMapFile));\n\n\t\tlsn = XLogInsert(RM_RELMAP_ID, XLOG_RELMAP_UPDATE);\n\n\t\t/* As always, WAL must hit the disk before the data update does */\n\t\tXLogFlush(lsn);\n\t}\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_WRITE);\n\tif (write(fd, newmap, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t{\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\t}\n\tpgstat_report_wait_end();\n\n\t/*\n\t * We choose to fsync the data to disk before considering the task done.\n\t * It would be possible to relax this if it turns out to be a performance\n\t * issue, but it would complicate checkpointing --- see notes for\n\t * CheckPointRelationMap.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t\tereport(data_sync_elevel(ERROR),\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not fsync relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tif (CloseTransientFile(fd))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Now that the file is safely on disk, send sinval message to let other\n\t * backends know to re-read it.  We must do this inside the critical\n\t * section: if for some reason we fail to send the message, we have to\n\t * force a database-wide PANIC.  Otherwise other backends might continue\n\t * execution with stale mapping information, which would be catastrophic\n\t * as soon as others began to use the now-committed data.\n\t */\n\tif (send_sinval)\n\t\tCacheInvalidateRelmap(dbid);\n\n\t/*\n\t * Make sure that the files listed in the map are not deleted if the outer\n\t * transaction aborts.  This had better be within the critical section\n\t * too: it's not likely to fail, but if it did, we'd arrive at transaction\n\t * abort with the files still vulnerable.  PANICing will leave things in a\n\t * good state on-disk.\n\t *\n\t * Note: we're cheating a little bit here by assuming that mapped files\n\t * are either in pg_global or the database's default tablespace.\n\t */\n\tif (preserve_files)\n\t{\n\t\tint32\t\ti;\n\n\t\tfor (i = 0; i < newmap->num_mappings; i++)\n\t\t{\n\t\t\tRelFileNode rnode;\n\n\t\t\trnode.spcNode = tsid;\n\t\t\trnode.dbNode = dbid;\n\t\t\trnode.relNode = newmap->mappings[i].mapfilenode;\n\t\t\tRelationPreserveStorage(rnode, false);\n\t\t}\n\t}\n\n\t/* Success, update permanent copy */\n\tmemcpy(realmap, newmap, sizeof(RelMapFile));\n\n\t/* Critical section done */\n\tif (write_wal)\n\t\tEND_CRIT_SECTION();\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */",
            "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */",
            "#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\""
          ],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static void load_relmap_file(bool shared);",
            "static void write_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\nstatic void write_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath);\n\nstatic void\nwrite_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath)\n{\n\tint\t\t\tfd;\n\tRelMapFile *realmap;\n\tchar\t\tmapfilename[MAXPGPATH];\n\n\t/*\n\t * Fill in the overhead fields and update CRC.\n\t */\n\tnewmap->magic = RELMAPPER_FILEMAGIC;\n\tif (newmap->num_mappings < 0 || newmap->num_mappings > MAX_MAPPINGS)\n\t\telog(ERROR, \"attempt to write bogus relation mapping\");\n\n\tINIT_CRC32C(newmap->crc);\n\tCOMP_CRC32C(newmap->crc, (char *) newmap, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(newmap->crc);\n\n\t/*\n\t * Open the target file.  We prefer to do this before entering the\n\t * critical section, so that an open() failure need not force PANIC.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\trealmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t dbpath, RELMAPPER_FILENAME);\n\t\trealmap = &local_map;\n\t}\n\n\tfd = OpenTransientFile(mapfilename, O_WRONLY | O_CREAT | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\tif (write_wal)\n\t{\n\t\txl_relmap_update xlrec;\n\t\tXLogRecPtr\tlsn;\n\n\t\t/* now errors are fatal ... */\n\t\tSTART_CRIT_SECTION();\n\n\t\txlrec.dbid = dbid;\n\t\txlrec.tsid = tsid;\n\t\txlrec.nbytes = sizeof(RelMapFile);\n\n\t\tXLogBeginInsert();\n\t\tXLogRegisterData((char *) (&xlrec), MinSizeOfRelmapUpdate);\n\t\tXLogRegisterData((char *) newmap, sizeof(RelMapFile));\n\n\t\tlsn = XLogInsert(RM_RELMAP_ID, XLOG_RELMAP_UPDATE);\n\n\t\t/* As always, WAL must hit the disk before the data update does */\n\t\tXLogFlush(lsn);\n\t}\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_WRITE);\n\tif (write(fd, newmap, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t{\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\t}\n\tpgstat_report_wait_end();\n\n\t/*\n\t * We choose to fsync the data to disk before considering the task done.\n\t * It would be possible to relax this if it turns out to be a performance\n\t * issue, but it would complicate checkpointing --- see notes for\n\t * CheckPointRelationMap.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t\tereport(data_sync_elevel(ERROR),\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not fsync relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tif (CloseTransientFile(fd))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Now that the file is safely on disk, send sinval message to let other\n\t * backends know to re-read it.  We must do this inside the critical\n\t * section: if for some reason we fail to send the message, we have to\n\t * force a database-wide PANIC.  Otherwise other backends might continue\n\t * execution with stale mapping information, which would be catastrophic\n\t * as soon as others began to use the now-committed data.\n\t */\n\tif (send_sinval)\n\t\tCacheInvalidateRelmap(dbid);\n\n\t/*\n\t * Make sure that the files listed in the map are not deleted if the outer\n\t * transaction aborts.  This had better be within the critical section\n\t * too: it's not likely to fail, but if it did, we'd arrive at transaction\n\t * abort with the files still vulnerable.  PANICing will leave things in a\n\t * good state on-disk.\n\t *\n\t * Note: we're cheating a little bit here by assuming that mapped files\n\t * are either in pg_global or the database's default tablespace.\n\t */\n\tif (preserve_files)\n\t{\n\t\tint32\t\ti;\n\n\t\tfor (i = 0; i < newmap->num_mappings; i++)\n\t\t{\n\t\t\tRelFileNode rnode;\n\n\t\t\trnode.spcNode = tsid;\n\t\t\trnode.dbNode = dbid;\n\t\t\trnode.relNode = newmap->mappings[i].mapfilenode;\n\t\t\tRelationPreserveStorage(rnode, false);\n\t\t}\n\t}\n\n\t/* Success, update permanent copy */\n\tmemcpy(realmap, newmap, sizeof(RelMapFile));\n\n\t/* Critical section done */\n\tif (write_wal)\n\t\tEND_CRIT_SECTION();\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_map_updates",
          "args": [
            "&newmap",
            "updates",
            "allowSystemTableMods"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "merge_map_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "338-350",
          "snippet": "static void\nmerge_map_updates(RelMapFile *map, const RelMapFile *updates, bool add_okay)\n{\n\tint32\t\ti;\n\n\tfor (i = 0; i < updates->num_mappings; i++)\n\t{\n\t\tapply_map_update(map,\n\t\t\t\t\t\t updates->mappings[i].mapoid,\n\t\t\t\t\t\t updates->mappings[i].mapfilenode,\n\t\t\t\t\t\t add_okay);\n\t}\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);",
            "static void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);",
            "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);\nstatic void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nstatic void\nmerge_map_updates(RelMapFile *map, const RelMapFile *updates, bool add_okay)\n{\n\tint32\t\ti;\n\n\tfor (i = 0; i < updates->num_mappings; i++)\n\t{\n\t\tapply_map_update(map,\n\t\t\t\t\t\t updates->mappings[i].mapoid,\n\t\t\t\t\t\t updates->mappings[i].mapfilenode,\n\t\t\t\t\t\t add_okay);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&newmap",
            "&local_map",
            "sizeof(RelMapFile)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&newmap",
            "&shared_map",
            "sizeof(RelMapFile)"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_relmap_file",
          "args": [
            "shared"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "load_relmap_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "629-692",
          "snippet": "static void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */",
            "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */",
            "#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\""
          ],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static void load_relmap_file(bool shared);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\n\nstatic void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "RelationMappingLock",
            "LW_EXCLUSIVE"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nstatic void\nperform_relmap_update(bool shared, const RelMapFile *updates)\n{\n\tRelMapFile\tnewmap;\n\n\t/*\n\t * Anyone updating a relation's mapping info should take exclusive lock on\n\t * that rel and hold it until commit.  This ensures that there will not be\n\t * concurrent updates on the same mapping value; but there could easily be\n\t * concurrent updates on different values in the same file. We cover that\n\t * by acquiring the RelationMappingLock, re-reading the target file to\n\t * ensure it's up to date, applying the updates, and writing the data\n\t * before releasing RelationMappingLock.\n\t *\n\t * There is only one RelationMappingLock.  In principle we could try to\n\t * have one per mapping file, but it seems unlikely to be worth the\n\t * trouble.\n\t */\n\tLWLockAcquire(RelationMappingLock, LW_EXCLUSIVE);\n\n\t/* Be certain we see any other updates just made */\n\tload_relmap_file(shared);\n\n\t/* Prepare updated data in a local variable */\n\tif (shared)\n\t\tmemcpy(&newmap, &shared_map, sizeof(RelMapFile));\n\telse\n\t\tmemcpy(&newmap, &local_map, sizeof(RelMapFile));\n\n\t/*\n\t * Apply the updates to newmap.  No new mappings should appear, unless\n\t * somebody is adding indexes to system catalogs.\n\t */\n\tmerge_map_updates(&newmap, updates, allowSystemTableMods);\n\n\t/* Write out the updated map and do other necessary tasks */\n\twrite_relmap_file(shared, &newmap, true, true, true,\n\t\t\t\t\t  (shared ? InvalidOid : MyDatabaseId),\n\t\t\t\t\t  (shared ? GLOBALTABLESPACE_OID : MyDatabaseTableSpace),\n\t\t\t\t\t  DatabasePath);\n\n\t/* Now we can release the lock */\n\tLWLockRelease(RelationMappingLock);\n}"
  },
  {
    "function_name": "write_relmap_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "714-856",
    "snippet": "static void\nwrite_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath)\n{\n\tint\t\t\tfd;\n\tRelMapFile *realmap;\n\tchar\t\tmapfilename[MAXPGPATH];\n\n\t/*\n\t * Fill in the overhead fields and update CRC.\n\t */\n\tnewmap->magic = RELMAPPER_FILEMAGIC;\n\tif (newmap->num_mappings < 0 || newmap->num_mappings > MAX_MAPPINGS)\n\t\telog(ERROR, \"attempt to write bogus relation mapping\");\n\n\tINIT_CRC32C(newmap->crc);\n\tCOMP_CRC32C(newmap->crc, (char *) newmap, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(newmap->crc);\n\n\t/*\n\t * Open the target file.  We prefer to do this before entering the\n\t * critical section, so that an open() failure need not force PANIC.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\trealmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t dbpath, RELMAPPER_FILENAME);\n\t\trealmap = &local_map;\n\t}\n\n\tfd = OpenTransientFile(mapfilename, O_WRONLY | O_CREAT | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\tif (write_wal)\n\t{\n\t\txl_relmap_update xlrec;\n\t\tXLogRecPtr\tlsn;\n\n\t\t/* now errors are fatal ... */\n\t\tSTART_CRIT_SECTION();\n\n\t\txlrec.dbid = dbid;\n\t\txlrec.tsid = tsid;\n\t\txlrec.nbytes = sizeof(RelMapFile);\n\n\t\tXLogBeginInsert();\n\t\tXLogRegisterData((char *) (&xlrec), MinSizeOfRelmapUpdate);\n\t\tXLogRegisterData((char *) newmap, sizeof(RelMapFile));\n\n\t\tlsn = XLogInsert(RM_RELMAP_ID, XLOG_RELMAP_UPDATE);\n\n\t\t/* As always, WAL must hit the disk before the data update does */\n\t\tXLogFlush(lsn);\n\t}\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_WRITE);\n\tif (write(fd, newmap, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t{\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\t}\n\tpgstat_report_wait_end();\n\n\t/*\n\t * We choose to fsync the data to disk before considering the task done.\n\t * It would be possible to relax this if it turns out to be a performance\n\t * issue, but it would complicate checkpointing --- see notes for\n\t * CheckPointRelationMap.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t\tereport(data_sync_elevel(ERROR),\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not fsync relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tif (CloseTransientFile(fd))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Now that the file is safely on disk, send sinval message to let other\n\t * backends know to re-read it.  We must do this inside the critical\n\t * section: if for some reason we fail to send the message, we have to\n\t * force a database-wide PANIC.  Otherwise other backends might continue\n\t * execution with stale mapping information, which would be catastrophic\n\t * as soon as others began to use the now-committed data.\n\t */\n\tif (send_sinval)\n\t\tCacheInvalidateRelmap(dbid);\n\n\t/*\n\t * Make sure that the files listed in the map are not deleted if the outer\n\t * transaction aborts.  This had better be within the critical section\n\t * too: it's not likely to fail, but if it did, we'd arrive at transaction\n\t * abort with the files still vulnerable.  PANICing will leave things in a\n\t * good state on-disk.\n\t *\n\t * Note: we're cheating a little bit here by assuming that mapped files\n\t * are either in pg_global or the database's default tablespace.\n\t */\n\tif (preserve_files)\n\t{\n\t\tint32\t\ti;\n\n\t\tfor (i = 0; i < newmap->num_mappings; i++)\n\t\t{\n\t\t\tRelFileNode rnode;\n\n\t\t\trnode.spcNode = tsid;\n\t\t\trnode.dbNode = dbid;\n\t\t\trnode.relNode = newmap->mappings[i].mapfilenode;\n\t\t\tRelationPreserveStorage(rnode, false);\n\t\t}\n\t}\n\n\t/* Success, update permanent copy */\n\tmemcpy(realmap, newmap, sizeof(RelMapFile));\n\n\t/* Critical section done */\n\tif (write_wal)\n\t\tEND_CRIT_SECTION();\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */",
      "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */",
      "#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\""
    ],
    "globals_used": [
      "static RelMapFile shared_map;",
      "static RelMapFile local_map;",
      "static void load_relmap_file(bool shared);",
      "static void write_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "END_CRIT_SECTION",
          "args": [],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "realmap",
            "newmap",
            "sizeof(RelMapFile)"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationPreserveStorage",
          "args": [
            "rnode",
            "false"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CacheInvalidateRelmap",
          "args": [
            "dbid"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "CacheInvalidateRelmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1398-1409",
          "snippet": "void\nCacheInvalidateRelmap(Oid databaseId)\n{\n\tSharedInvalidationMessage msg;\n\n\tmsg.rm.id = SHAREDINVALRELMAP_ID;\n\tmsg.rm.dbId = databaseId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tSendSharedInvalidMessages(&msg, 1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateRelmap(Oid databaseId)\n{\n\tSharedInvalidationMessage msg;\n\n\tmsg.rm.id = SHAREDINVALRELMAP_ID;\n\tmsg.rm.dbId = databaseId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tSendSharedInvalidMessages(&msg, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename))"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not close relation mapping file \\\"%s\\\": %m\"",
            "mapfilename"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "CloseTransientFile",
          "args": [
            "fd"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_end",
          "args": [],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "data_sync_elevel(ERROR)",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not fsync relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename))"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_sync_elevel",
          "args": [
            "ERROR"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_fsync",
          "args": [
            "fd"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_start",
          "args": [
            "WAIT_EVENT_RELATION_MAP_SYNC"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_end",
          "args": [],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename))"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "newmap",
            "sizeof(RelMapFile)"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "write_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5991-5998",
          "snippet": "static void\nwrite_item(const void *data, Size len, FILE *fp)\n{\n\tif (fwrite(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\telog(FATAL, \"could not write init file\");\n\tif (fwrite(data, 1, len, fp) != len)\n\t\telog(FATAL, \"could not write init file\");\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void write_item(const void *data, Size len, FILE *fp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void write_item(const void *data, Size len, FILE *fp);\n\nstatic void\nwrite_item(const void *data, Size len, FILE *fp)\n{\n\tif (fwrite(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\telog(FATAL, \"could not write init file\");\n\tif (fwrite(data, 1, len, fp) != len)\n\t\telog(FATAL, \"could not write init file\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_start",
          "args": [
            "WAIT_EVENT_RELATION_MAP_WRITE"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLogFlush",
          "args": [
            "lsn"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLogInsert",
          "args": [
            "RM_RELMAP_ID",
            "XLOG_RELMAP_UPDATE"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLogRegisterData",
          "args": [
            "(char *) newmap",
            "sizeof(RelMapFile)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLogRegisterData",
          "args": [
            "(char *) (&xlrec)",
            "MinSizeOfRelmapUpdate"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLogBeginInsert",
          "args": [],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "START_CRIT_SECTION",
          "args": [],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename))"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpenTransientFile",
          "args": [
            "mapfilename",
            "O_WRONLY | O_CREAT | PG_BINARY"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "mapfilename",
            "sizeof(mapfilename)",
            "\"%s/%s\"",
            "dbpath",
            "RELMAPPER_FILENAME"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "mapfilename",
            "sizeof(mapfilename)",
            "\"global/%s\"",
            "RELMAPPER_FILENAME"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIN_CRC32C",
          "args": [
            "newmap->crc"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMP_CRC32C",
          "args": [
            "newmap->crc",
            "(char *) newmap",
            "offsetof(RelMapFile, crc)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_CRC32C",
          "args": [
            "newmap->crc"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"attempt to write bogus relation mapping\""
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\nstatic void write_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath);\n\nstatic void\nwrite_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath)\n{\n\tint\t\t\tfd;\n\tRelMapFile *realmap;\n\tchar\t\tmapfilename[MAXPGPATH];\n\n\t/*\n\t * Fill in the overhead fields and update CRC.\n\t */\n\tnewmap->magic = RELMAPPER_FILEMAGIC;\n\tif (newmap->num_mappings < 0 || newmap->num_mappings > MAX_MAPPINGS)\n\t\telog(ERROR, \"attempt to write bogus relation mapping\");\n\n\tINIT_CRC32C(newmap->crc);\n\tCOMP_CRC32C(newmap->crc, (char *) newmap, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(newmap->crc);\n\n\t/*\n\t * Open the target file.  We prefer to do this before entering the\n\t * critical section, so that an open() failure need not force PANIC.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\trealmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t dbpath, RELMAPPER_FILENAME);\n\t\trealmap = &local_map;\n\t}\n\n\tfd = OpenTransientFile(mapfilename, O_WRONLY | O_CREAT | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\tif (write_wal)\n\t{\n\t\txl_relmap_update xlrec;\n\t\tXLogRecPtr\tlsn;\n\n\t\t/* now errors are fatal ... */\n\t\tSTART_CRIT_SECTION();\n\n\t\txlrec.dbid = dbid;\n\t\txlrec.tsid = tsid;\n\t\txlrec.nbytes = sizeof(RelMapFile);\n\n\t\tXLogBeginInsert();\n\t\tXLogRegisterData((char *) (&xlrec), MinSizeOfRelmapUpdate);\n\t\tXLogRegisterData((char *) newmap, sizeof(RelMapFile));\n\n\t\tlsn = XLogInsert(RM_RELMAP_ID, XLOG_RELMAP_UPDATE);\n\n\t\t/* As always, WAL must hit the disk before the data update does */\n\t\tXLogFlush(lsn);\n\t}\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_WRITE);\n\tif (write(fd, newmap, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t{\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\t}\n\tpgstat_report_wait_end();\n\n\t/*\n\t * We choose to fsync the data to disk before considering the task done.\n\t * It would be possible to relax this if it turns out to be a performance\n\t * issue, but it would complicate checkpointing --- see notes for\n\t * CheckPointRelationMap.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t\tereport(data_sync_elevel(ERROR),\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not fsync relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tif (CloseTransientFile(fd))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Now that the file is safely on disk, send sinval message to let other\n\t * backends know to re-read it.  We must do this inside the critical\n\t * section: if for some reason we fail to send the message, we have to\n\t * force a database-wide PANIC.  Otherwise other backends might continue\n\t * execution with stale mapping information, which would be catastrophic\n\t * as soon as others began to use the now-committed data.\n\t */\n\tif (send_sinval)\n\t\tCacheInvalidateRelmap(dbid);\n\n\t/*\n\t * Make sure that the files listed in the map are not deleted if the outer\n\t * transaction aborts.  This had better be within the critical section\n\t * too: it's not likely to fail, but if it did, we'd arrive at transaction\n\t * abort with the files still vulnerable.  PANICing will leave things in a\n\t * good state on-disk.\n\t *\n\t * Note: we're cheating a little bit here by assuming that mapped files\n\t * are either in pg_global or the database's default tablespace.\n\t */\n\tif (preserve_files)\n\t{\n\t\tint32\t\ti;\n\n\t\tfor (i = 0; i < newmap->num_mappings; i++)\n\t\t{\n\t\t\tRelFileNode rnode;\n\n\t\t\trnode.spcNode = tsid;\n\t\t\trnode.dbNode = dbid;\n\t\t\trnode.relNode = newmap->mappings[i].mapfilenode;\n\t\t\tRelationPreserveStorage(rnode, false);\n\t\t}\n\t}\n\n\t/* Success, update permanent copy */\n\tmemcpy(realmap, newmap, sizeof(RelMapFile));\n\n\t/* Critical section done */\n\tif (write_wal)\n\t\tEND_CRIT_SECTION();\n}"
  },
  {
    "function_name": "load_relmap_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "629-692",
    "snippet": "static void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */",
      "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */",
      "#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\""
    ],
    "globals_used": [
      "static RelMapFile shared_map;",
      "static RelMapFile local_map;",
      "static void load_relmap_file(bool shared);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename))"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"relation mapping file \\\"%s\\\" contains incorrect checksum\"",
            "mapfilename"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "EQ_CRC32C",
          "args": [
            "crc",
            "map->crc"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIN_CRC32C",
          "args": [
            "crc"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMP_CRC32C",
          "args": [
            "crc",
            "(char *) map",
            "offsetof(RelMapFile, crc)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_CRC32C",
          "args": [
            "crc"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename))"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CloseTransientFile",
          "args": [
            "fd"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_end",
          "args": [],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename))"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "map",
            "sizeof(RelMapFile)"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_copy_read_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "1267-1345",
          "snippet": "void\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_start",
          "args": [
            "WAIT_EVENT_RELATION_MAP_READ"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename))"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpenTransientFile",
          "args": [
            "mapfilename",
            "O_RDONLY | PG_BINARY"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "mapfilename",
            "sizeof(mapfilename)",
            "\"%s/%s\"",
            "DatabasePath",
            "RELMAPPER_FILENAME"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "mapfilename",
            "sizeof(mapfilename)",
            "\"global/%s\"",
            "RELMAPPER_FILENAME"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\n\nstatic void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}"
  },
  {
    "function_name": "RelationMapInitializePhase3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "606-619",
    "snippet": "void\nRelationMapInitializePhase3(void)\n{\n\t/*\n\t * In bootstrap mode, the map file isn't there yet, so do nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * Load the local map file, die on error.\n\t */\n\tload_relmap_file(false);\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_relmap_file",
          "args": [
            "false"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "load_relmap_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "629-692",
          "snippet": "static void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */",
            "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */",
            "#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\""
          ],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static void load_relmap_file(bool shared);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\n\nstatic void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nRelationMapInitializePhase3(void)\n{\n\t/*\n\t * In bootstrap mode, the map file isn't there yet, so do nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * Load the local map file, die on error.\n\t */\n\tload_relmap_file(false);\n}"
  },
  {
    "function_name": "RelationMapInitializePhase2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "585-598",
    "snippet": "void\nRelationMapInitializePhase2(void)\n{\n\t/*\n\t * In bootstrap mode, the map file isn't there yet, so do nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * Load the shared map file, die on error.\n\t */\n\tload_relmap_file(true);\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void load_relmap_file(bool shared);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_relmap_file",
          "args": [
            "true"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "load_relmap_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "629-692",
          "snippet": "static void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */",
            "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */",
            "#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\""
          ],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static void load_relmap_file(bool shared);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\n\nstatic void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void load_relmap_file(bool shared);\n\nvoid\nRelationMapInitializePhase2(void)\n{\n\t/*\n\t * In bootstrap mode, the map file isn't there yet, so do nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * Load the shared map file, die on error.\n\t */\n\tload_relmap_file(true);\n}"
  },
  {
    "function_name": "RelationMapInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "565-577",
    "snippet": "void\nRelationMapInitialize(void)\n{\n\t/* The static variables should initialize to zeroes, but let's be sure */\n\tshared_map.magic = 0;\t\t/* mark it not loaded */\n\tlocal_map.magic = 0;\n\tshared_map.num_mappings = 0;\n\tlocal_map.num_mappings = 0;\n\tactive_shared_updates.num_mappings = 0;\n\tactive_local_updates.num_mappings = 0;\n\tpending_shared_updates.num_mappings = 0;\n\tpending_local_updates.num_mappings = 0;\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RelMapFile shared_map;",
      "static RelMapFile local_map;",
      "static RelMapFile active_shared_updates;",
      "static RelMapFile active_local_updates;",
      "static RelMapFile pending_shared_updates;",
      "static RelMapFile pending_local_updates;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic RelMapFile pending_shared_updates;\nstatic RelMapFile pending_local_updates;\n\nvoid\nRelationMapInitialize(void)\n{\n\t/* The static variables should initialize to zeroes, but let's be sure */\n\tshared_map.magic = 0;\t\t/* mark it not loaded */\n\tlocal_map.magic = 0;\n\tshared_map.num_mappings = 0;\n\tlocal_map.num_mappings = 0;\n\tactive_shared_updates.num_mappings = 0;\n\tactive_local_updates.num_mappings = 0;\n\tpending_shared_updates.num_mappings = 0;\n\tpending_local_updates.num_mappings = 0;\n}"
  },
  {
    "function_name": "RelationMapFinishBootstrap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "541-557",
    "snippet": "void\nRelationMapFinishBootstrap(void)\n{\n\tAssert(IsBootstrapProcessingMode());\n\n\t/* Shouldn't be anything \"pending\" ... */\n\tAssert(active_shared_updates.num_mappings == 0);\n\tAssert(active_local_updates.num_mappings == 0);\n\tAssert(pending_shared_updates.num_mappings == 0);\n\tAssert(pending_local_updates.num_mappings == 0);\n\n\t/* Write the files; no WAL or sinval needed */\n\twrite_relmap_file(true, &shared_map, false, false, false,\n\t\t\t\t\t  InvalidOid, GLOBALTABLESPACE_OID, NULL);\n\twrite_relmap_file(false, &local_map, false, false, false,\n\t\t\t\t\t  MyDatabaseId, MyDatabaseTableSpace, DatabasePath);\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RelMapFile shared_map;",
      "static RelMapFile local_map;",
      "static RelMapFile active_shared_updates;",
      "static RelMapFile active_local_updates;",
      "static RelMapFile pending_shared_updates;",
      "static RelMapFile pending_local_updates;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_relmap_file",
          "args": [
            "false",
            "&local_map",
            "false",
            "false",
            "false",
            "MyDatabaseId",
            "MyDatabaseTableSpace",
            "DatabasePath"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "write_relmap_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "714-856",
          "snippet": "static void\nwrite_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath)\n{\n\tint\t\t\tfd;\n\tRelMapFile *realmap;\n\tchar\t\tmapfilename[MAXPGPATH];\n\n\t/*\n\t * Fill in the overhead fields and update CRC.\n\t */\n\tnewmap->magic = RELMAPPER_FILEMAGIC;\n\tif (newmap->num_mappings < 0 || newmap->num_mappings > MAX_MAPPINGS)\n\t\telog(ERROR, \"attempt to write bogus relation mapping\");\n\n\tINIT_CRC32C(newmap->crc);\n\tCOMP_CRC32C(newmap->crc, (char *) newmap, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(newmap->crc);\n\n\t/*\n\t * Open the target file.  We prefer to do this before entering the\n\t * critical section, so that an open() failure need not force PANIC.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\trealmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t dbpath, RELMAPPER_FILENAME);\n\t\trealmap = &local_map;\n\t}\n\n\tfd = OpenTransientFile(mapfilename, O_WRONLY | O_CREAT | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\tif (write_wal)\n\t{\n\t\txl_relmap_update xlrec;\n\t\tXLogRecPtr\tlsn;\n\n\t\t/* now errors are fatal ... */\n\t\tSTART_CRIT_SECTION();\n\n\t\txlrec.dbid = dbid;\n\t\txlrec.tsid = tsid;\n\t\txlrec.nbytes = sizeof(RelMapFile);\n\n\t\tXLogBeginInsert();\n\t\tXLogRegisterData((char *) (&xlrec), MinSizeOfRelmapUpdate);\n\t\tXLogRegisterData((char *) newmap, sizeof(RelMapFile));\n\n\t\tlsn = XLogInsert(RM_RELMAP_ID, XLOG_RELMAP_UPDATE);\n\n\t\t/* As always, WAL must hit the disk before the data update does */\n\t\tXLogFlush(lsn);\n\t}\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_WRITE);\n\tif (write(fd, newmap, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t{\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\t}\n\tpgstat_report_wait_end();\n\n\t/*\n\t * We choose to fsync the data to disk before considering the task done.\n\t * It would be possible to relax this if it turns out to be a performance\n\t * issue, but it would complicate checkpointing --- see notes for\n\t * CheckPointRelationMap.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t\tereport(data_sync_elevel(ERROR),\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not fsync relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tif (CloseTransientFile(fd))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Now that the file is safely on disk, send sinval message to let other\n\t * backends know to re-read it.  We must do this inside the critical\n\t * section: if for some reason we fail to send the message, we have to\n\t * force a database-wide PANIC.  Otherwise other backends might continue\n\t * execution with stale mapping information, which would be catastrophic\n\t * as soon as others began to use the now-committed data.\n\t */\n\tif (send_sinval)\n\t\tCacheInvalidateRelmap(dbid);\n\n\t/*\n\t * Make sure that the files listed in the map are not deleted if the outer\n\t * transaction aborts.  This had better be within the critical section\n\t * too: it's not likely to fail, but if it did, we'd arrive at transaction\n\t * abort with the files still vulnerable.  PANICing will leave things in a\n\t * good state on-disk.\n\t *\n\t * Note: we're cheating a little bit here by assuming that mapped files\n\t * are either in pg_global or the database's default tablespace.\n\t */\n\tif (preserve_files)\n\t{\n\t\tint32\t\ti;\n\n\t\tfor (i = 0; i < newmap->num_mappings; i++)\n\t\t{\n\t\t\tRelFileNode rnode;\n\n\t\t\trnode.spcNode = tsid;\n\t\t\trnode.dbNode = dbid;\n\t\t\trnode.relNode = newmap->mappings[i].mapfilenode;\n\t\t\tRelationPreserveStorage(rnode, false);\n\t\t}\n\t}\n\n\t/* Success, update permanent copy */\n\tmemcpy(realmap, newmap, sizeof(RelMapFile));\n\n\t/* Critical section done */\n\tif (write_wal)\n\t\tEND_CRIT_SECTION();\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */",
            "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */",
            "#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\""
          ],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static void load_relmap_file(bool shared);",
            "static void write_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\nstatic void write_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath);\n\nstatic void\nwrite_relmap_file(bool shared, RelMapFile *newmap,\n\t\t\t\t  bool write_wal, bool send_sinval, bool preserve_files,\n\t\t\t\t  Oid dbid, Oid tsid, const char *dbpath)\n{\n\tint\t\t\tfd;\n\tRelMapFile *realmap;\n\tchar\t\tmapfilename[MAXPGPATH];\n\n\t/*\n\t * Fill in the overhead fields and update CRC.\n\t */\n\tnewmap->magic = RELMAPPER_FILEMAGIC;\n\tif (newmap->num_mappings < 0 || newmap->num_mappings > MAX_MAPPINGS)\n\t\telog(ERROR, \"attempt to write bogus relation mapping\");\n\n\tINIT_CRC32C(newmap->crc);\n\tCOMP_CRC32C(newmap->crc, (char *) newmap, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(newmap->crc);\n\n\t/*\n\t * Open the target file.  We prefer to do this before entering the\n\t * critical section, so that an open() failure need not force PANIC.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\trealmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t dbpath, RELMAPPER_FILENAME);\n\t\trealmap = &local_map;\n\t}\n\n\tfd = OpenTransientFile(mapfilename, O_WRONLY | O_CREAT | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\tif (write_wal)\n\t{\n\t\txl_relmap_update xlrec;\n\t\tXLogRecPtr\tlsn;\n\n\t\t/* now errors are fatal ... */\n\t\tSTART_CRIT_SECTION();\n\n\t\txlrec.dbid = dbid;\n\t\txlrec.tsid = tsid;\n\t\txlrec.nbytes = sizeof(RelMapFile);\n\n\t\tXLogBeginInsert();\n\t\tXLogRegisterData((char *) (&xlrec), MinSizeOfRelmapUpdate);\n\t\tXLogRegisterData((char *) newmap, sizeof(RelMapFile));\n\n\t\tlsn = XLogInsert(RM_RELMAP_ID, XLOG_RELMAP_UPDATE);\n\n\t\t/* As always, WAL must hit the disk before the data update does */\n\t\tXLogFlush(lsn);\n\t}\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_WRITE);\n\tif (write(fd, newmap, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t{\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\t}\n\tpgstat_report_wait_end();\n\n\t/*\n\t * We choose to fsync the data to disk before considering the task done.\n\t * It would be possible to relax this if it turns out to be a performance\n\t * issue, but it would complicate checkpointing --- see notes for\n\t * CheckPointRelationMap.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t\tereport(data_sync_elevel(ERROR),\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not fsync relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tif (CloseTransientFile(fd))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Now that the file is safely on disk, send sinval message to let other\n\t * backends know to re-read it.  We must do this inside the critical\n\t * section: if for some reason we fail to send the message, we have to\n\t * force a database-wide PANIC.  Otherwise other backends might continue\n\t * execution with stale mapping information, which would be catastrophic\n\t * as soon as others began to use the now-committed data.\n\t */\n\tif (send_sinval)\n\t\tCacheInvalidateRelmap(dbid);\n\n\t/*\n\t * Make sure that the files listed in the map are not deleted if the outer\n\t * transaction aborts.  This had better be within the critical section\n\t * too: it's not likely to fail, but if it did, we'd arrive at transaction\n\t * abort with the files still vulnerable.  PANICing will leave things in a\n\t * good state on-disk.\n\t *\n\t * Note: we're cheating a little bit here by assuming that mapped files\n\t * are either in pg_global or the database's default tablespace.\n\t */\n\tif (preserve_files)\n\t{\n\t\tint32\t\ti;\n\n\t\tfor (i = 0; i < newmap->num_mappings; i++)\n\t\t{\n\t\t\tRelFileNode rnode;\n\n\t\t\trnode.spcNode = tsid;\n\t\t\trnode.dbNode = dbid;\n\t\t\trnode.relNode = newmap->mappings[i].mapfilenode;\n\t\t\tRelationPreserveStorage(rnode, false);\n\t\t}\n\t}\n\n\t/* Success, update permanent copy */\n\tmemcpy(realmap, newmap, sizeof(RelMapFile));\n\n\t/* Critical section done */\n\tif (write_wal)\n\t\tEND_CRIT_SECTION();\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "pending_local_updates.num_mappings == 0"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "pending_shared_updates.num_mappings == 0"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "active_local_updates.num_mappings == 0"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "active_shared_updates.num_mappings == 0"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "IsBootstrapProcessingMode()"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic RelMapFile pending_shared_updates;\nstatic RelMapFile pending_local_updates;\n\nvoid\nRelationMapFinishBootstrap(void)\n{\n\tAssert(IsBootstrapProcessingMode());\n\n\t/* Shouldn't be anything \"pending\" ... */\n\tAssert(active_shared_updates.num_mappings == 0);\n\tAssert(active_local_updates.num_mappings == 0);\n\tAssert(pending_shared_updates.num_mappings == 0);\n\tAssert(pending_local_updates.num_mappings == 0);\n\n\t/* Write the files; no WAL or sinval needed */\n\twrite_relmap_file(true, &shared_map, false, false, false,\n\t\t\t\t\t  InvalidOid, GLOBALTABLESPACE_OID, NULL);\n\twrite_relmap_file(false, &local_map, false, false, false,\n\t\t\t\t\t  MyDatabaseId, MyDatabaseTableSpace, DatabasePath);\n}"
  },
  {
    "function_name": "CheckPointRelationMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "527-532",
    "snippet": "void\nCheckPointRelationMap(void)\n{\n\tLWLockAcquire(RelationMappingLock, LW_SHARED);\n\tLWLockRelease(RelationMappingLock);\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "RelationMappingLock"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "RelationMappingLock",
            "LW_SHARED"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nCheckPointRelationMap(void)\n{\n\tLWLockAcquire(RelationMappingLock, LW_SHARED);\n\tLWLockRelease(RelationMappingLock);\n}"
  },
  {
    "function_name": "AtPrepare_RelationMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "504-514",
    "snippet": "void\nAtPrepare_RelationMap(void)\n{\n\tif (active_shared_updates.num_mappings != 0 ||\n\t\tactive_local_updates.num_mappings != 0 ||\n\t\tpending_shared_updates.num_mappings != 0 ||\n\t\tpending_local_updates.num_mappings != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"cannot PREPARE a transaction that modified relation mapping\")));\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RelMapFile active_shared_updates;",
      "static RelMapFile active_local_updates;",
      "static RelMapFile pending_shared_updates;",
      "static RelMapFile pending_local_updates;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"cannot PREPARE a transaction that modified relation mapping\"))"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot PREPARE a transaction that modified relation mapping\""
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic RelMapFile pending_shared_updates;\nstatic RelMapFile pending_local_updates;\n\nvoid\nAtPrepare_RelationMap(void)\n{\n\tif (active_shared_updates.num_mappings != 0 ||\n\t\tactive_local_updates.num_mappings != 0 ||\n\t\tpending_shared_updates.num_mappings != 0 ||\n\t\tpending_local_updates.num_mappings != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"cannot PREPARE a transaction that modified relation mapping\")));\n}"
  },
  {
    "function_name": "AtEOXact_RelationMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "460-495",
    "snippet": "void\nAtEOXact_RelationMap(bool isCommit)\n{\n\tif (isCommit)\n\t{\n\t\t/*\n\t\t * We should not get here with any \"pending\" updates.  (We could\n\t\t * logically choose to treat such as committed, but in the current\n\t\t * code this should never happen.)\n\t\t */\n\t\tAssert(pending_shared_updates.num_mappings == 0);\n\t\tAssert(pending_local_updates.num_mappings == 0);\n\n\t\t/*\n\t\t * Write any active updates to the actual map files, then reset them.\n\t\t */\n\t\tif (active_shared_updates.num_mappings != 0)\n\t\t{\n\t\t\tperform_relmap_update(true, &active_shared_updates);\n\t\t\tactive_shared_updates.num_mappings = 0;\n\t\t}\n\t\tif (active_local_updates.num_mappings != 0)\n\t\t{\n\t\t\tperform_relmap_update(false, &active_local_updates);\n\t\t\tactive_local_updates.num_mappings = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Abort --- drop all local and pending updates */\n\t\tactive_shared_updates.num_mappings = 0;\n\t\tactive_local_updates.num_mappings = 0;\n\t\tpending_shared_updates.num_mappings = 0;\n\t\tpending_local_updates.num_mappings = 0;\n\t}\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RelMapFile active_shared_updates;",
      "static RelMapFile active_local_updates;",
      "static RelMapFile pending_shared_updates;",
      "static RelMapFile pending_local_updates;",
      "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perform_relmap_update",
          "args": [
            "false",
            "&active_local_updates"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "perform_relmap_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "863-906",
          "snippet": "static void\nperform_relmap_update(bool shared, const RelMapFile *updates)\n{\n\tRelMapFile\tnewmap;\n\n\t/*\n\t * Anyone updating a relation's mapping info should take exclusive lock on\n\t * that rel and hold it until commit.  This ensures that there will not be\n\t * concurrent updates on the same mapping value; but there could easily be\n\t * concurrent updates on different values in the same file. We cover that\n\t * by acquiring the RelationMappingLock, re-reading the target file to\n\t * ensure it's up to date, applying the updates, and writing the data\n\t * before releasing RelationMappingLock.\n\t *\n\t * There is only one RelationMappingLock.  In principle we could try to\n\t * have one per mapping file, but it seems unlikely to be worth the\n\t * trouble.\n\t */\n\tLWLockAcquire(RelationMappingLock, LW_EXCLUSIVE);\n\n\t/* Be certain we see any other updates just made */\n\tload_relmap_file(shared);\n\n\t/* Prepare updated data in a local variable */\n\tif (shared)\n\t\tmemcpy(&newmap, &shared_map, sizeof(RelMapFile));\n\telse\n\t\tmemcpy(&newmap, &local_map, sizeof(RelMapFile));\n\n\t/*\n\t * Apply the updates to newmap.  No new mappings should appear, unless\n\t * somebody is adding indexes to system catalogs.\n\t */\n\tmerge_map_updates(&newmap, updates, allowSystemTableMods);\n\n\t/* Write out the updated map and do other necessary tasks */\n\twrite_relmap_file(shared, &newmap, true, true, true,\n\t\t\t\t\t  (shared ? InvalidOid : MyDatabaseId),\n\t\t\t\t\t  (shared ? GLOBALTABLESPACE_OID : MyDatabaseTableSpace),\n\t\t\t\t\t  DatabasePath);\n\n\t/* Now we can release the lock */\n\tLWLockRelease(RelationMappingLock);\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static void load_relmap_file(bool shared);",
            "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nstatic void\nperform_relmap_update(bool shared, const RelMapFile *updates)\n{\n\tRelMapFile\tnewmap;\n\n\t/*\n\t * Anyone updating a relation's mapping info should take exclusive lock on\n\t * that rel and hold it until commit.  This ensures that there will not be\n\t * concurrent updates on the same mapping value; but there could easily be\n\t * concurrent updates on different values in the same file. We cover that\n\t * by acquiring the RelationMappingLock, re-reading the target file to\n\t * ensure it's up to date, applying the updates, and writing the data\n\t * before releasing RelationMappingLock.\n\t *\n\t * There is only one RelationMappingLock.  In principle we could try to\n\t * have one per mapping file, but it seems unlikely to be worth the\n\t * trouble.\n\t */\n\tLWLockAcquire(RelationMappingLock, LW_EXCLUSIVE);\n\n\t/* Be certain we see any other updates just made */\n\tload_relmap_file(shared);\n\n\t/* Prepare updated data in a local variable */\n\tif (shared)\n\t\tmemcpy(&newmap, &shared_map, sizeof(RelMapFile));\n\telse\n\t\tmemcpy(&newmap, &local_map, sizeof(RelMapFile));\n\n\t/*\n\t * Apply the updates to newmap.  No new mappings should appear, unless\n\t * somebody is adding indexes to system catalogs.\n\t */\n\tmerge_map_updates(&newmap, updates, allowSystemTableMods);\n\n\t/* Write out the updated map and do other necessary tasks */\n\twrite_relmap_file(shared, &newmap, true, true, true,\n\t\t\t\t\t  (shared ? InvalidOid : MyDatabaseId),\n\t\t\t\t\t  (shared ? GLOBALTABLESPACE_OID : MyDatabaseTableSpace),\n\t\t\t\t\t  DatabasePath);\n\n\t/* Now we can release the lock */\n\tLWLockRelease(RelationMappingLock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "pending_local_updates.num_mappings == 0"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "pending_shared_updates.num_mappings == 0"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic RelMapFile pending_shared_updates;\nstatic RelMapFile pending_local_updates;\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nvoid\nAtEOXact_RelationMap(bool isCommit)\n{\n\tif (isCommit)\n\t{\n\t\t/*\n\t\t * We should not get here with any \"pending\" updates.  (We could\n\t\t * logically choose to treat such as committed, but in the current\n\t\t * code this should never happen.)\n\t\t */\n\t\tAssert(pending_shared_updates.num_mappings == 0);\n\t\tAssert(pending_local_updates.num_mappings == 0);\n\n\t\t/*\n\t\t * Write any active updates to the actual map files, then reset them.\n\t\t */\n\t\tif (active_shared_updates.num_mappings != 0)\n\t\t{\n\t\t\tperform_relmap_update(true, &active_shared_updates);\n\t\t\tactive_shared_updates.num_mappings = 0;\n\t\t}\n\t\tif (active_local_updates.num_mappings != 0)\n\t\t{\n\t\t\tperform_relmap_update(false, &active_local_updates);\n\t\t\tactive_local_updates.num_mappings = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Abort --- drop all local and pending updates */\n\t\tactive_shared_updates.num_mappings = 0;\n\t\tactive_local_updates.num_mappings = 0;\n\t\tpending_shared_updates.num_mappings = 0;\n\t\tpending_local_updates.num_mappings = 0;\n\t}\n}"
  },
  {
    "function_name": "AtCCI_RelationMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "426-443",
    "snippet": "void\nAtCCI_RelationMap(void)\n{\n\tif (pending_shared_updates.num_mappings != 0)\n\t{\n\t\tmerge_map_updates(&active_shared_updates,\n\t\t\t\t\t\t  &pending_shared_updates,\n\t\t\t\t\t\t  true);\n\t\tpending_shared_updates.num_mappings = 0;\n\t}\n\tif (pending_local_updates.num_mappings != 0)\n\t{\n\t\tmerge_map_updates(&active_local_updates,\n\t\t\t\t\t\t  &pending_local_updates,\n\t\t\t\t\t\t  true);\n\t\tpending_local_updates.num_mappings = 0;\n\t}\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RelMapFile active_shared_updates;",
      "static RelMapFile active_local_updates;",
      "static RelMapFile pending_shared_updates;",
      "static RelMapFile pending_local_updates;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_map_updates",
          "args": [
            "&active_local_updates",
            "&pending_local_updates",
            "true"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "merge_map_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "338-350",
          "snippet": "static void\nmerge_map_updates(RelMapFile *map, const RelMapFile *updates, bool add_okay)\n{\n\tint32\t\ti;\n\n\tfor (i = 0; i < updates->num_mappings; i++)\n\t{\n\t\tapply_map_update(map,\n\t\t\t\t\t\t updates->mappings[i].mapoid,\n\t\t\t\t\t\t updates->mappings[i].mapfilenode,\n\t\t\t\t\t\t add_okay);\n\t}\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);",
            "static void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);",
            "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);\nstatic void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nstatic void\nmerge_map_updates(RelMapFile *map, const RelMapFile *updates, bool add_okay)\n{\n\tint32\t\ti;\n\n\tfor (i = 0; i < updates->num_mappings; i++)\n\t{\n\t\tapply_map_update(map,\n\t\t\t\t\t\t updates->mappings[i].mapoid,\n\t\t\t\t\t\t updates->mappings[i].mapfilenode,\n\t\t\t\t\t\t add_okay);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic RelMapFile pending_shared_updates;\nstatic RelMapFile pending_local_updates;\n\nvoid\nAtCCI_RelationMap(void)\n{\n\tif (pending_shared_updates.num_mappings != 0)\n\t{\n\t\tmerge_map_updates(&active_shared_updates,\n\t\t\t\t\t\t  &pending_shared_updates,\n\t\t\t\t\t\t  true);\n\t\tpending_shared_updates.num_mappings = 0;\n\t}\n\tif (pending_local_updates.num_mappings != 0)\n\t{\n\t\tmerge_map_updates(&active_local_updates,\n\t\t\t\t\t\t  &pending_local_updates,\n\t\t\t\t\t\t  true);\n\t\tpending_local_updates.num_mappings = 0;\n\t}\n}"
  },
  {
    "function_name": "RelationMapInvalidateAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "412-419",
    "snippet": "void\nRelationMapInvalidateAll(void)\n{\n\tif (shared_map.magic == RELMAPPER_FILEMAGIC)\n\t\tload_relmap_file(true);\n\tif (local_map.magic == RELMAPPER_FILEMAGIC)\n\t\tload_relmap_file(false);\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */"
    ],
    "globals_used": [
      "static RelMapFile shared_map;",
      "static RelMapFile local_map;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_relmap_file",
          "args": [
            "false"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "load_relmap_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "629-692",
          "snippet": "static void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */",
            "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */",
            "#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\""
          ],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static void load_relmap_file(bool shared);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\n\nstatic void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\n\nvoid\nRelationMapInvalidateAll(void)\n{\n\tif (shared_map.magic == RELMAPPER_FILEMAGIC)\n\t\tload_relmap_file(true);\n\tif (local_map.magic == RELMAPPER_FILEMAGIC)\n\t\tload_relmap_file(false);\n}"
  },
  {
    "function_name": "RelationMapInvalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "390-403",
    "snippet": "void\nRelationMapInvalidate(bool shared)\n{\n\tif (shared)\n\t{\n\t\tif (shared_map.magic == RELMAPPER_FILEMAGIC)\n\t\t\tload_relmap_file(true);\n\t}\n\telse\n\t{\n\t\tif (local_map.magic == RELMAPPER_FILEMAGIC)\n\t\t\tload_relmap_file(false);\n\t}\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */"
    ],
    "globals_used": [
      "static RelMapFile shared_map;",
      "static RelMapFile local_map;",
      "static void load_relmap_file(bool shared);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_relmap_file",
          "args": [
            "false"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "load_relmap_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "629-692",
          "snippet": "static void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */",
            "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */",
            "#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\""
          ],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static void load_relmap_file(bool shared);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n#define RELMAPPER_FILENAME\t\t\"pg_filenode.map\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\n\nstatic void\nload_relmap_file(bool shared)\n{\n\tRelMapFile *map;\n\tchar\t\tmapfilename[MAXPGPATH];\n\tpg_crc32c\tcrc;\n\tint\t\t\tfd;\n\n\tif (shared)\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"global/%s\",\n\t\t\t\t RELMAPPER_FILENAME);\n\t\tmap = &shared_map;\n\t}\n\telse\n\t{\n\t\tsnprintf(mapfilename, sizeof(mapfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELMAPPER_FILENAME);\n\t\tmap = &local_map;\n\t}\n\n\t/* Read data ... */\n\tfd = OpenTransientFile(mapfilename, O_RDONLY | PG_BINARY);\n\tif (fd < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/*\n\t * Note: we could take RelationMappingLock in shared mode here, but it\n\t * seems unnecessary since our read() should be atomic against any\n\t * concurrent updater's write().  If the file is updated shortly after we\n\t * look, the sinval signaling mechanism will make us re-read it before we\n\t * are able to access any relation that's affected by the change.\n\t */\n\tpgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);\n\tif (read(fd, map, sizeof(RelMapFile)) != sizeof(RelMapFile))\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read relation mapping file \\\"%s\\\": %m\",\n\t\t\t\t\t\tmapfilename)));\n\tpgstat_report_wait_end();\n\n\tCloseTransientFile(fd);\n\n\t/* check for correct magic number, etc */\n\tif (map->magic != RELMAPPER_FILEMAGIC ||\n\t\tmap->num_mappings < 0 ||\n\t\tmap->num_mappings > MAX_MAPPINGS)\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains invalid data\",\n\t\t\t\t\t\tmapfilename)));\n\n\t/* verify the CRC */\n\tINIT_CRC32C(crc);\n\tCOMP_CRC32C(crc, (char *) map, offsetof(RelMapFile, crc));\n\tFIN_CRC32C(crc);\n\n\tif (!EQ_CRC32C(crc, map->crc))\n\t\tereport(FATAL,\n\t\t\t\t(errmsg(\"relation mapping file \\\"%s\\\" contains incorrect checksum\",\n\t\t\t\t\t\tmapfilename)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\n\nvoid\nRelationMapInvalidate(bool shared)\n{\n\tif (shared)\n\t{\n\t\tif (shared_map.magic == RELMAPPER_FILEMAGIC)\n\t\t\tload_relmap_file(true);\n\t}\n\telse\n\t{\n\t\tif (local_map.magic == RELMAPPER_FILEMAGIC)\n\t\t\tload_relmap_file(false);\n\t}\n}"
  },
  {
    "function_name": "RelationMapRemoveMapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "360-378",
    "snippet": "void\nRelationMapRemoveMapping(Oid relationId)\n{\n\tRelMapFile *map = &active_local_updates;\n\tint32\t\ti;\n\n\tfor (i = 0; i < map->num_mappings; i++)\n\t{\n\t\tif (relationId == map->mappings[i].mapoid)\n\t\t{\n\t\t\t/* Found it, collapse it out */\n\t\t\tmap->mappings[i] = map->mappings[map->num_mappings - 1];\n\t\t\tmap->num_mappings--;\n\t\t\treturn;\n\t\t}\n\t}\n\telog(ERROR, \"could not find temporary mapping for relation %u\",\n\t\t relationId);\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RelMapFile active_local_updates;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not find temporary mapping for relation %u\"",
            "relationId"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile active_local_updates;\n\nvoid\nRelationMapRemoveMapping(Oid relationId)\n{\n\tRelMapFile *map = &active_local_updates;\n\tint32\t\ti;\n\n\tfor (i = 0; i < map->num_mappings; i++)\n\t{\n\t\tif (relationId == map->mappings[i].mapoid)\n\t\t{\n\t\t\t/* Found it, collapse it out */\n\t\t\tmap->mappings[i] = map->mappings[map->num_mappings - 1];\n\t\t\tmap->num_mappings--;\n\t\t\treturn;\n\t\t}\n\t}\n\telog(ERROR, \"could not find temporary mapping for relation %u\",\n\t\t relationId);\n}"
  },
  {
    "function_name": "merge_map_updates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "338-350",
    "snippet": "static void\nmerge_map_updates(RelMapFile *map, const RelMapFile *updates, bool add_okay)\n{\n\tint32\t\ti;\n\n\tfor (i = 0; i < updates->num_mappings; i++)\n\t{\n\t\tapply_map_update(map,\n\t\t\t\t\t\t updates->mappings[i].mapoid,\n\t\t\t\t\t\t updates->mappings[i].mapfilenode,\n\t\t\t\t\t\t add_okay);\n\t}\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);",
      "static void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);",
      "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_map_update",
          "args": [
            "map",
            "updates->mappings[i].mapoid",
            "updates->mappings[i].mapfilenode",
            "add_okay"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "apply_map_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "306-330",
          "snippet": "static void\napply_map_update(RelMapFile *map, Oid relationId, Oid fileNode, bool add_okay)\n{\n\tint32\t\ti;\n\n\t/* Replace any existing mapping */\n\tfor (i = 0; i < map->num_mappings; i++)\n\t{\n\t\tif (relationId == map->mappings[i].mapoid)\n\t\t{\n\t\t\tmap->mappings[i].mapfilenode = fileNode;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Nope, need to add a new mapping */\n\tif (!add_okay)\n\t\telog(ERROR, \"attempt to apply a mapping to unmapped relation %u\",\n\t\t\t relationId);\n\tif (map->num_mappings >= MAX_MAPPINGS)\n\t\telog(ERROR, \"ran out of space in relation map\");\n\tmap->mappings[map->num_mappings].mapoid = relationId;\n\tmap->mappings[map->num_mappings].mapfilenode = fileNode;\n\tmap->num_mappings++;\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */"
          ],
          "globals_used": [
            "static void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);",
            "static void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n\nstatic void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);\nstatic void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);\n\nstatic void\napply_map_update(RelMapFile *map, Oid relationId, Oid fileNode, bool add_okay)\n{\n\tint32\t\ti;\n\n\t/* Replace any existing mapping */\n\tfor (i = 0; i < map->num_mappings; i++)\n\t{\n\t\tif (relationId == map->mappings[i].mapoid)\n\t\t{\n\t\t\tmap->mappings[i].mapfilenode = fileNode;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Nope, need to add a new mapping */\n\tif (!add_okay)\n\t\telog(ERROR, \"attempt to apply a mapping to unmapped relation %u\",\n\t\t\t relationId);\n\tif (map->num_mappings >= MAX_MAPPINGS)\n\t\telog(ERROR, \"ran out of space in relation map\");\n\tmap->mappings[map->num_mappings].mapoid = relationId;\n\tmap->mappings[map->num_mappings].mapfilenode = fileNode;\n\tmap->num_mappings++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);\nstatic void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nstatic void\nmerge_map_updates(RelMapFile *map, const RelMapFile *updates, bool add_okay)\n{\n\tint32\t\ti;\n\n\tfor (i = 0; i < updates->num_mappings; i++)\n\t{\n\t\tapply_map_update(map,\n\t\t\t\t\t\t updates->mappings[i].mapoid,\n\t\t\t\t\t\t updates->mappings[i].mapfilenode,\n\t\t\t\t\t\t add_okay);\n\t}\n}"
  },
  {
    "function_name": "apply_map_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "306-330",
    "snippet": "static void\napply_map_update(RelMapFile *map, Oid relationId, Oid fileNode, bool add_okay)\n{\n\tint32\t\ti;\n\n\t/* Replace any existing mapping */\n\tfor (i = 0; i < map->num_mappings; i++)\n\t{\n\t\tif (relationId == map->mappings[i].mapoid)\n\t\t{\n\t\t\tmap->mappings[i].mapfilenode = fileNode;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Nope, need to add a new mapping */\n\tif (!add_okay)\n\t\telog(ERROR, \"attempt to apply a mapping to unmapped relation %u\",\n\t\t\t relationId);\n\tif (map->num_mappings >= MAX_MAPPINGS)\n\t\telog(ERROR, \"ran out of space in relation map\");\n\tmap->mappings[map->num_mappings].mapoid = relationId;\n\tmap->mappings[map->num_mappings].mapfilenode = fileNode;\n\tmap->num_mappings++;\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */"
    ],
    "globals_used": [
      "static void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);",
      "static void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"ran out of space in relation map\""
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n\nstatic void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);\nstatic void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);\n\nstatic void\napply_map_update(RelMapFile *map, Oid relationId, Oid fileNode, bool add_okay)\n{\n\tint32\t\ti;\n\n\t/* Replace any existing mapping */\n\tfor (i = 0; i < map->num_mappings; i++)\n\t{\n\t\tif (relationId == map->mappings[i].mapoid)\n\t\t{\n\t\t\tmap->mappings[i].mapfilenode = fileNode;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Nope, need to add a new mapping */\n\tif (!add_okay)\n\t\telog(ERROR, \"attempt to apply a mapping to unmapped relation %u\",\n\t\t\t relationId);\n\tif (map->num_mappings >= MAX_MAPPINGS)\n\t\telog(ERROR, \"ran out of space in relation map\");\n\tmap->mappings[map->num_mappings].mapoid = relationId;\n\tmap->mappings[map->num_mappings].mapfilenode = fileNode;\n\tmap->num_mappings++;\n}"
  },
  {
    "function_name": "RelationMapUpdateMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "247-295",
    "snippet": "void\nRelationMapUpdateMap(Oid relationId, Oid fileNode, bool shared,\n\t\t\t\t\t bool immediate)\n{\n\tRelMapFile *map;\n\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/*\n\t\t * In bootstrap mode, the mapping gets installed in permanent map.\n\t\t */\n\t\tif (shared)\n\t\t\tmap = &shared_map;\n\t\telse\n\t\t\tmap = &local_map;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't currently support map changes within subtransactions, and\n\t\t * parallel workers must avoid relying on mapping state, since it\n\t\t * isn't propagated from the leader.  This could be done with more\n\t\t * bookkeeping infrastructure, but it doesn't presently seem worth it.\n\t\t */\n\t\tif (GetCurrentTransactionNestLevel() > 1)\n\t\t\telog(ERROR, \"cannot change relation mapping within subtransaction\");\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR, \"cannot change relation mapping in parallel mode\");\n\n\t\tif (immediate)\n\t\t{\n\t\t\t/* Make it active, but only locally */\n\t\t\tif (shared)\n\t\t\t\tmap = &active_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &active_local_updates;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Make it pending */\n\t\t\tif (shared)\n\t\t\t\tmap = &pending_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &pending_local_updates;\n\t\t}\n\t}\n\tapply_map_update(map, relationId, fileNode, true);\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RelMapFile shared_map;",
      "static RelMapFile local_map;",
      "static RelMapFile active_shared_updates;",
      "static RelMapFile active_local_updates;",
      "static RelMapFile pending_shared_updates;",
      "static RelMapFile pending_local_updates;",
      "static void load_relmap_file(bool shared);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_map_update",
          "args": [
            "map",
            "relationId",
            "fileNode",
            "true"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "apply_map_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "306-330",
          "snippet": "static void\napply_map_update(RelMapFile *map, Oid relationId, Oid fileNode, bool add_okay)\n{\n\tint32\t\ti;\n\n\t/* Replace any existing mapping */\n\tfor (i = 0; i < map->num_mappings; i++)\n\t{\n\t\tif (relationId == map->mappings[i].mapoid)\n\t\t{\n\t\t\tmap->mappings[i].mapfilenode = fileNode;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Nope, need to add a new mapping */\n\tif (!add_okay)\n\t\telog(ERROR, \"attempt to apply a mapping to unmapped relation %u\",\n\t\t\t relationId);\n\tif (map->num_mappings >= MAX_MAPPINGS)\n\t\telog(ERROR, \"ran out of space in relation map\");\n\tmap->mappings[map->num_mappings].mapoid = relationId;\n\tmap->mappings[map->num_mappings].mapfilenode = fileNode;\n\tmap->num_mappings++;\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */"
          ],
          "globals_used": [
            "static void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);",
            "static void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define MAX_MAPPINGS\t\t\t62\t/* 62 * 8 + 16 = 512 */\n\nstatic void apply_map_update(RelMapFile *map, Oid relationId, Oid fileNode,\n\t\t\t\t bool add_okay);\nstatic void merge_map_updates(RelMapFile *map, const RelMapFile *updates,\n\t\t\t\t  bool add_okay);\n\nstatic void\napply_map_update(RelMapFile *map, Oid relationId, Oid fileNode, bool add_okay)\n{\n\tint32\t\ti;\n\n\t/* Replace any existing mapping */\n\tfor (i = 0; i < map->num_mappings; i++)\n\t{\n\t\tif (relationId == map->mappings[i].mapoid)\n\t\t{\n\t\t\tmap->mappings[i].mapfilenode = fileNode;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Nope, need to add a new mapping */\n\tif (!add_okay)\n\t\telog(ERROR, \"attempt to apply a mapping to unmapped relation %u\",\n\t\t\t relationId);\n\tif (map->num_mappings >= MAX_MAPPINGS)\n\t\telog(ERROR, \"ran out of space in relation map\");\n\tmap->mappings[map->num_mappings].mapoid = relationId;\n\tmap->mappings[map->num_mappings].mapfilenode = fileNode;\n\tmap->num_mappings++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot change relation mapping in parallel mode\""
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsInParallelMode",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionNestLevel",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic RelMapFile pending_shared_updates;\nstatic RelMapFile pending_local_updates;\nstatic void load_relmap_file(bool shared);\n\nvoid\nRelationMapUpdateMap(Oid relationId, Oid fileNode, bool shared,\n\t\t\t\t\t bool immediate)\n{\n\tRelMapFile *map;\n\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/*\n\t\t * In bootstrap mode, the mapping gets installed in permanent map.\n\t\t */\n\t\tif (shared)\n\t\t\tmap = &shared_map;\n\t\telse\n\t\t\tmap = &local_map;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't currently support map changes within subtransactions, and\n\t\t * parallel workers must avoid relying on mapping state, since it\n\t\t * isn't propagated from the leader.  This could be done with more\n\t\t * bookkeeping infrastructure, but it doesn't presently seem worth it.\n\t\t */\n\t\tif (GetCurrentTransactionNestLevel() > 1)\n\t\t\telog(ERROR, \"cannot change relation mapping within subtransaction\");\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR, \"cannot change relation mapping in parallel mode\");\n\n\t\tif (immediate)\n\t\t{\n\t\t\t/* Make it active, but only locally */\n\t\t\tif (shared)\n\t\t\t\tmap = &active_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &active_local_updates;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Make it pending */\n\t\t\tif (shared)\n\t\t\t\tmap = &pending_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &pending_local_updates;\n\t\t}\n\t}\n\tapply_map_update(map, relationId, fileNode, true);\n}"
  },
  {
    "function_name": "RelationMapFilenodeToOid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "198-237",
    "snippet": "Oid\nRelationMapFilenodeToOid(Oid filenode, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RelMapFile shared_map;",
      "static RelMapFile local_map;",
      "static RelMapFile active_shared_updates;",
      "static RelMapFile active_local_updates;",
      "static void load_relmap_file(bool shared);",
      "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic void load_relmap_file(bool shared);\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nOid\nRelationMapFilenodeToOid(Oid filenode, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}"
  },
  {
    "function_name": "RelationMapOidToFilenode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
    "lines": "145-184",
    "snippet": "Oid\nRelationMapOidToFilenode(Oid relationId, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/inval.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/fd.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xloginsert.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RelMapFile shared_map;",
      "static RelMapFile local_map;",
      "static RelMapFile active_shared_updates;",
      "static RelMapFile active_local_updates;",
      "static void load_relmap_file(bool shared);",
      "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic void load_relmap_file(bool shared);\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nOid\nRelationMapOidToFilenode(Oid relationId, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}"
  }
]