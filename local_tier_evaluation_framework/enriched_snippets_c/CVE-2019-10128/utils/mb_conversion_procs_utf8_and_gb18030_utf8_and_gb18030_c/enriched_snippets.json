[
  {
    "function_name": "utf8_to_gb18030",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/utf8_and_gb18030/utf8_and_gb18030.c",
    "lines": "208-224",
    "snippet": "Datum\nutf8_to_gb18030(PG_FUNCTION_ARGS)\n{\n\tunsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2);\n\tunsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3);\n\tint\t\t\tlen = PG_GETARG_INT32(4);\n\n\tCHECK_ENCODING_CONVERSION_ARGS(PG_UTF8, PG_GB18030);\n\n\tUtfToLocal(src, len, dest,\n\t\t\t   &gb18030_from_unicode_tree,\n\t\t\t   NULL, 0,\n\t\t\t   conv_utf8_to_18030,\n\t\t\t   PG_GB18030);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"../../Unicode/utf8_to_gb18030.map\"",
      "#include \"../../Unicode/gb18030_to_utf8.map\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"fmgr.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UtfToLocal",
          "args": [
            "src",
            "len",
            "dest",
            "&gb18030_from_unicode_tree",
            "NULL",
            "0",
            "conv_utf8_to_18030",
            "PG_GB18030"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "UtfToLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
          "lines": "473-641",
          "snippet": "void\nUtfToLocal(const unsigned char *utf, int len,\n\t\t   unsigned char *iso,\n\t\t   const pg_mb_radix_tree *map,\n\t\t   const pg_utf_to_local_combined *cmap, int cmapsize,\n\t\t   utf_local_conversion_func conv_func,\n\t\t   int encoding)\n{\n\tuint32\t\tiutf;\n\tint\t\t\tl;\n\tconst pg_utf_to_local_combined *cp;\n\n\tif (!PG_VALID_ENCODING(encoding))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding number: %d\", encoding)));\n\n\tfor (; len > 0; len -= l)\n\t{\n\t\tunsigned char b1 = 0;\n\t\tunsigned char b2 = 0;\n\t\tunsigned char b3 = 0;\n\t\tunsigned char b4 = 0;\n\n\t\t/* \"break\" cases all represent errors */\n\t\tif (*utf == '\\0')\n\t\t\tbreak;\n\n\t\tl = pg_utf_mblen(utf);\n\t\tif (len < l)\n\t\t\tbreak;\n\n\t\tif (!pg_utf8_islegal(utf, l))\n\t\t\tbreak;\n\n\t\tif (l == 1)\n\t\t{\n\t\t\t/* ASCII case is easy, assume it's one-to-one conversion */\n\t\t\t*iso++ = *utf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* collect coded char of length l */\n\t\tif (l == 2)\n\t\t{\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse if (l == 3)\n\t\t{\n\t\t\tb2 = *utf++;\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse if (l == 4)\n\t\t{\n\t\t\tb1 = *utf++;\n\t\t\tb2 = *utf++;\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\tiutf = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t\tiutf = (b1 << 24 | b2 << 16 | b3 << 8 | b4);\n\n\t\t/* First, try with combined map if possible */\n\t\tif (cmap && len > l)\n\t\t{\n\t\t\tconst unsigned char *utf_save = utf;\n\t\t\tint\t\t\tlen_save = len;\n\t\t\tint\t\t\tl_save = l;\n\n\t\t\t/* collect next character, same as above */\n\t\t\tlen -= l;\n\n\t\t\tl = pg_utf_mblen(utf);\n\t\t\tif (len < l)\n\t\t\t\tbreak;\n\n\t\t\tif (!pg_utf8_islegal(utf, l))\n\t\t\t\tbreak;\n\n\t\t\t/* We assume ASCII character cannot be in combined map */\n\t\t\tif (l > 1)\n\t\t\t{\n\t\t\t\tuint32\t\tiutf2;\n\t\t\t\tuint32\t\tcutf[2];\n\n\t\t\t\tif (l == 2)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse if (l == 3)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 16;\n\t\t\t\t\tiutf2 |= *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse if (l == 4)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 24;\n\t\t\t\t\tiutf2 |= *utf++ << 16;\n\t\t\t\t\tiutf2 |= *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\t\t\tiutf2 = 0;\t/* keep compiler quiet */\n\t\t\t\t}\n\n\t\t\t\tcutf[0] = iutf;\n\t\t\t\tcutf[1] = iutf2;\n\n\t\t\t\tcp = bsearch(cutf, cmap, cmapsize,\n\t\t\t\t\t\t\t sizeof(pg_utf_to_local_combined), compare3);\n\n\t\t\t\tif (cp)\n\t\t\t\t{\n\t\t\t\t\tiso = store_coded_char(iso, cp->code);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* fail, so back up to reprocess second character next time */\n\t\t\tutf = utf_save;\n\t\t\tlen = len_save;\n\t\t\tl = l_save;\n\t\t}\n\n\t\t/* Now check ordinary map */\n\t\tif (map)\n\t\t{\n\t\t\tuint32\t\tconverted = pg_mb_radix_conv(map, l, b1, b2, b3, b4);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tiso = store_coded_char(iso, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* if there's a conversion function, try that */\n\t\tif (conv_func)\n\t\t{\n\t\t\tuint32\t\tconverted = (*conv_func) (iutf);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tiso = store_coded_char(iso, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* failed to translate this character */\n\t\treport_untranslatable_char(PG_UTF8, encoding,\n\t\t\t\t\t\t\t\t   (const char *) (utf - l), len);\n\t}\n\n\t/* if we broke out of loop early, must be invalid input */\n\tif (len > 0)\n\t\treport_invalid_encoding(PG_UTF8, (const char *) utf, len);\n\n\t*iso = '\\0';\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nUtfToLocal(const unsigned char *utf, int len,\n\t\t   unsigned char *iso,\n\t\t   const pg_mb_radix_tree *map,\n\t\t   const pg_utf_to_local_combined *cmap, int cmapsize,\n\t\t   utf_local_conversion_func conv_func,\n\t\t   int encoding)\n{\n\tuint32\t\tiutf;\n\tint\t\t\tl;\n\tconst pg_utf_to_local_combined *cp;\n\n\tif (!PG_VALID_ENCODING(encoding))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding number: %d\", encoding)));\n\n\tfor (; len > 0; len -= l)\n\t{\n\t\tunsigned char b1 = 0;\n\t\tunsigned char b2 = 0;\n\t\tunsigned char b3 = 0;\n\t\tunsigned char b4 = 0;\n\n\t\t/* \"break\" cases all represent errors */\n\t\tif (*utf == '\\0')\n\t\t\tbreak;\n\n\t\tl = pg_utf_mblen(utf);\n\t\tif (len < l)\n\t\t\tbreak;\n\n\t\tif (!pg_utf8_islegal(utf, l))\n\t\t\tbreak;\n\n\t\tif (l == 1)\n\t\t{\n\t\t\t/* ASCII case is easy, assume it's one-to-one conversion */\n\t\t\t*iso++ = *utf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* collect coded char of length l */\n\t\tif (l == 2)\n\t\t{\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse if (l == 3)\n\t\t{\n\t\t\tb2 = *utf++;\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse if (l == 4)\n\t\t{\n\t\t\tb1 = *utf++;\n\t\t\tb2 = *utf++;\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\tiutf = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t\tiutf = (b1 << 24 | b2 << 16 | b3 << 8 | b4);\n\n\t\t/* First, try with combined map if possible */\n\t\tif (cmap && len > l)\n\t\t{\n\t\t\tconst unsigned char *utf_save = utf;\n\t\t\tint\t\t\tlen_save = len;\n\t\t\tint\t\t\tl_save = l;\n\n\t\t\t/* collect next character, same as above */\n\t\t\tlen -= l;\n\n\t\t\tl = pg_utf_mblen(utf);\n\t\t\tif (len < l)\n\t\t\t\tbreak;\n\n\t\t\tif (!pg_utf8_islegal(utf, l))\n\t\t\t\tbreak;\n\n\t\t\t/* We assume ASCII character cannot be in combined map */\n\t\t\tif (l > 1)\n\t\t\t{\n\t\t\t\tuint32\t\tiutf2;\n\t\t\t\tuint32\t\tcutf[2];\n\n\t\t\t\tif (l == 2)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse if (l == 3)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 16;\n\t\t\t\t\tiutf2 |= *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse if (l == 4)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 24;\n\t\t\t\t\tiutf2 |= *utf++ << 16;\n\t\t\t\t\tiutf2 |= *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\t\t\tiutf2 = 0;\t/* keep compiler quiet */\n\t\t\t\t}\n\n\t\t\t\tcutf[0] = iutf;\n\t\t\t\tcutf[1] = iutf2;\n\n\t\t\t\tcp = bsearch(cutf, cmap, cmapsize,\n\t\t\t\t\t\t\t sizeof(pg_utf_to_local_combined), compare3);\n\n\t\t\t\tif (cp)\n\t\t\t\t{\n\t\t\t\t\tiso = store_coded_char(iso, cp->code);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* fail, so back up to reprocess second character next time */\n\t\t\tutf = utf_save;\n\t\t\tlen = len_save;\n\t\t\tl = l_save;\n\t\t}\n\n\t\t/* Now check ordinary map */\n\t\tif (map)\n\t\t{\n\t\t\tuint32\t\tconverted = pg_mb_radix_conv(map, l, b1, b2, b3, b4);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tiso = store_coded_char(iso, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* if there's a conversion function, try that */\n\t\tif (conv_func)\n\t\t{\n\t\t\tuint32\t\tconverted = (*conv_func) (iutf);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tiso = store_coded_char(iso, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* failed to translate this character */\n\t\treport_untranslatable_char(PG_UTF8, encoding,\n\t\t\t\t\t\t\t\t   (const char *) (utf - l), len);\n\t}\n\n\t/* if we broke out of loop early, must be invalid input */\n\tif (len > 0)\n\t\treport_invalid_encoding(PG_UTF8, (const char *) utf, len);\n\n\t*iso = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ENCODING_CONVERSION_ARGS",
          "args": [
            "PG_UTF8",
            "PG_GB18030"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "4"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "3"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "2"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../Unicode/utf8_to_gb18030.map\"\n#include \"../../Unicode/gb18030_to_utf8.map\"\n#include \"mb/pg_wchar.h\"\n#include \"fmgr.h\"\n#include \"postgres.h\"\n\nDatum\nutf8_to_gb18030(PG_FUNCTION_ARGS)\n{\n\tunsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2);\n\tunsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3);\n\tint\t\t\tlen = PG_GETARG_INT32(4);\n\n\tCHECK_ENCODING_CONVERSION_ARGS(PG_UTF8, PG_GB18030);\n\n\tUtfToLocal(src, len, dest,\n\t\t\t   &gb18030_from_unicode_tree,\n\t\t\t   NULL, 0,\n\t\t\t   conv_utf8_to_18030,\n\t\t\t   PG_GB18030);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "gb18030_to_utf8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/utf8_and_gb18030/utf8_and_gb18030.c",
    "lines": "190-206",
    "snippet": "Datum\ngb18030_to_utf8(PG_FUNCTION_ARGS)\n{\n\tunsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2);\n\tunsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3);\n\tint\t\t\tlen = PG_GETARG_INT32(4);\n\n\tCHECK_ENCODING_CONVERSION_ARGS(PG_GB18030, PG_UTF8);\n\n\tLocalToUtf(src, len, dest,\n\t\t\t   &gb18030_to_unicode_tree,\n\t\t\t   NULL, 0,\n\t\t\t   conv_18030_to_utf8,\n\t\t\t   PG_GB18030);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"../../Unicode/utf8_to_gb18030.map\"",
      "#include \"../../Unicode/gb18030_to_utf8.map\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"fmgr.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LocalToUtf",
          "args": [
            "src",
            "len",
            "dest",
            "&gb18030_to_unicode_tree",
            "NULL",
            "0",
            "conv_18030_to_utf8",
            "PG_GB18030"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "LocalToUtf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
          "lines": "665-780",
          "snippet": "void\nLocalToUtf(const unsigned char *iso, int len,\n\t\t   unsigned char *utf,\n\t\t   const pg_mb_radix_tree *map,\n\t\t   const pg_local_to_utf_combined *cmap, int cmapsize,\n\t\t   utf_local_conversion_func conv_func,\n\t\t   int encoding)\n{\n\tuint32\t\tiiso;\n\tint\t\t\tl;\n\tconst pg_local_to_utf_combined *cp;\n\n\tif (!PG_VALID_ENCODING(encoding))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding number: %d\", encoding)));\n\n\tfor (; len > 0; len -= l)\n\t{\n\t\tunsigned char b1 = 0;\n\t\tunsigned char b2 = 0;\n\t\tunsigned char b3 = 0;\n\t\tunsigned char b4 = 0;\n\n\t\t/* \"break\" cases all represent errors */\n\t\tif (*iso == '\\0')\n\t\t\tbreak;\n\n\t\tif (!IS_HIGHBIT_SET(*iso))\n\t\t{\n\t\t\t/* ASCII case is easy, assume it's one-to-one conversion */\n\t\t\t*utf++ = *iso++;\n\t\t\tl = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tl = pg_encoding_verifymb(encoding, (const char *) iso, len);\n\t\tif (l < 0)\n\t\t\tbreak;\n\n\t\t/* collect coded char of length l */\n\t\tif (l == 1)\n\t\t\tb4 = *iso++;\n\t\telse if (l == 2)\n\t\t{\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse if (l == 3)\n\t\t{\n\t\t\tb2 = *iso++;\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse if (l == 4)\n\t\t{\n\t\t\tb1 = *iso++;\n\t\t\tb2 = *iso++;\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\tiiso = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t\tiiso = (b1 << 24 | b2 << 16 | b3 << 8 | b4);\n\n\t\tif (map)\n\t\t{\n\t\t\tuint32\t\tconverted = pg_mb_radix_conv(map, l, b1, b2, b3, b4);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tutf = store_coded_char(utf, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* If there's a combined character map, try that */\n\t\t\tif (cmap)\n\t\t\t{\n\t\t\t\tcp = bsearch(&iiso, cmap, cmapsize,\n\t\t\t\t\t\t\t sizeof(pg_local_to_utf_combined), compare4);\n\n\t\t\t\tif (cp)\n\t\t\t\t{\n\t\t\t\t\tutf = store_coded_char(utf, cp->utf1);\n\t\t\t\t\tutf = store_coded_char(utf, cp->utf2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* if there's a conversion function, try that */\n\t\tif (conv_func)\n\t\t{\n\t\t\tuint32\t\tconverted = (*conv_func) (iiso);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tutf = store_coded_char(utf, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* failed to translate this character */\n\t\treport_untranslatable_char(encoding, PG_UTF8,\n\t\t\t\t\t\t\t\t   (const char *) (iso - l), len);\n\t}\n\n\t/* if we broke out of loop early, must be invalid input */\n\tif (len > 0)\n\t\treport_invalid_encoding(encoding, (const char *) iso, len);\n\n\t*utf = '\\0';\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nLocalToUtf(const unsigned char *iso, int len,\n\t\t   unsigned char *utf,\n\t\t   const pg_mb_radix_tree *map,\n\t\t   const pg_local_to_utf_combined *cmap, int cmapsize,\n\t\t   utf_local_conversion_func conv_func,\n\t\t   int encoding)\n{\n\tuint32\t\tiiso;\n\tint\t\t\tl;\n\tconst pg_local_to_utf_combined *cp;\n\n\tif (!PG_VALID_ENCODING(encoding))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding number: %d\", encoding)));\n\n\tfor (; len > 0; len -= l)\n\t{\n\t\tunsigned char b1 = 0;\n\t\tunsigned char b2 = 0;\n\t\tunsigned char b3 = 0;\n\t\tunsigned char b4 = 0;\n\n\t\t/* \"break\" cases all represent errors */\n\t\tif (*iso == '\\0')\n\t\t\tbreak;\n\n\t\tif (!IS_HIGHBIT_SET(*iso))\n\t\t{\n\t\t\t/* ASCII case is easy, assume it's one-to-one conversion */\n\t\t\t*utf++ = *iso++;\n\t\t\tl = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tl = pg_encoding_verifymb(encoding, (const char *) iso, len);\n\t\tif (l < 0)\n\t\t\tbreak;\n\n\t\t/* collect coded char of length l */\n\t\tif (l == 1)\n\t\t\tb4 = *iso++;\n\t\telse if (l == 2)\n\t\t{\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse if (l == 3)\n\t\t{\n\t\t\tb2 = *iso++;\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse if (l == 4)\n\t\t{\n\t\t\tb1 = *iso++;\n\t\t\tb2 = *iso++;\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\tiiso = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t\tiiso = (b1 << 24 | b2 << 16 | b3 << 8 | b4);\n\n\t\tif (map)\n\t\t{\n\t\t\tuint32\t\tconverted = pg_mb_radix_conv(map, l, b1, b2, b3, b4);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tutf = store_coded_char(utf, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* If there's a combined character map, try that */\n\t\t\tif (cmap)\n\t\t\t{\n\t\t\t\tcp = bsearch(&iiso, cmap, cmapsize,\n\t\t\t\t\t\t\t sizeof(pg_local_to_utf_combined), compare4);\n\n\t\t\t\tif (cp)\n\t\t\t\t{\n\t\t\t\t\tutf = store_coded_char(utf, cp->utf1);\n\t\t\t\t\tutf = store_coded_char(utf, cp->utf2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* if there's a conversion function, try that */\n\t\tif (conv_func)\n\t\t{\n\t\t\tuint32\t\tconverted = (*conv_func) (iiso);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tutf = store_coded_char(utf, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* failed to translate this character */\n\t\treport_untranslatable_char(encoding, PG_UTF8,\n\t\t\t\t\t\t\t\t   (const char *) (iso - l), len);\n\t}\n\n\t/* if we broke out of loop early, must be invalid input */\n\tif (len > 0)\n\t\treport_invalid_encoding(encoding, (const char *) iso, len);\n\n\t*utf = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ENCODING_CONVERSION_ARGS",
          "args": [
            "PG_GB18030",
            "PG_UTF8"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "4"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "3"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "2"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../Unicode/utf8_to_gb18030.map\"\n#include \"../../Unicode/gb18030_to_utf8.map\"\n#include \"mb/pg_wchar.h\"\n#include \"fmgr.h\"\n#include \"postgres.h\"\n\nDatum\ngb18030_to_utf8(PG_FUNCTION_ARGS)\n{\n\tunsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2);\n\tunsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3);\n\tint\t\t\tlen = PG_GETARG_INT32(4);\n\n\tCHECK_ENCODING_CONVERSION_ARGS(PG_GB18030, PG_UTF8);\n\n\tLocalToUtf(src, len, dest,\n\t\t\t   &gb18030_to_unicode_tree,\n\t\t\t   NULL, 0,\n\t\t\t   conv_18030_to_utf8,\n\t\t\t   PG_GB18030);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "conv_utf8_to_18030",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/utf8_and_gb18030/utf8_and_gb18030.c",
    "lines": "154-178",
    "snippet": "static uint32\nconv_utf8_to_18030(uint32 code)\n{\n\tuint32\t\tucs = utf8word_to_unicode(code);\n\n#define convutf8(minunicode, maxunicode, mincode) \\\n\tif (ucs >= minunicode && ucs <= maxunicode) \\\n\t\treturn gb_unlinear(ucs - minunicode + gb_linear(mincode))\n\n\tconvutf8(0x0452, 0x200F, 0x8130D330);\n\tconvutf8(0x2643, 0x2E80, 0x8137A839);\n\tconvutf8(0x361B, 0x3917, 0x8230A633);\n\tconvutf8(0x3CE1, 0x4055, 0x8231D438);\n\tconvutf8(0x4160, 0x4336, 0x8232C937);\n\tconvutf8(0x44D7, 0x464B, 0x8233A339);\n\tconvutf8(0x478E, 0x4946, 0x8233E838);\n\tconvutf8(0x49B8, 0x4C76, 0x8234A131);\n\tconvutf8(0x9FA6, 0xD7FF, 0x82358F33);\n\tconvutf8(0xE865, 0xF92B, 0x8336D030);\n\tconvutf8(0xFA2A, 0xFE2F, 0x84309C38);\n\tconvutf8(0xFFE6, 0xFFFF, 0x8431A234);\n\tconvutf8(0x10000, 0x10FFFF, 0x90308130);\n\t/* No mapping exists */\n\treturn 0;\n}",
    "includes": [
      "#include \"../../Unicode/utf8_to_gb18030.map\"",
      "#include \"../../Unicode/gb18030_to_utf8.map\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"fmgr.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0x10000",
            "0x10FFFF",
            "0x90308130"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0xFFE6",
            "0xFFFF",
            "0x8431A234"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0xFA2A",
            "0xFE2F",
            "0x84309C38"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0xE865",
            "0xF92B",
            "0x8336D030"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0x9FA6",
            "0xD7FF",
            "0x82358F33"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0x49B8",
            "0x4C76",
            "0x8234A131"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0x478E",
            "0x4946",
            "0x8233E838"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0x44D7",
            "0x464B",
            "0x8233A339"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0x4160",
            "0x4336",
            "0x8232C937"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0x3CE1",
            "0x4055",
            "0x8231D438"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0x361B",
            "0x3917",
            "0x8230A633"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0x2643",
            "0x2E80",
            "0x8137A839"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convutf8",
          "args": [
            "0x0452",
            "0x200F",
            "0x8130D330"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utf8word_to_unicode",
          "args": [
            "code"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "utf8word_to_unicode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/utf8_and_gb18030/utf8_and_gb18030.c",
          "lines": "90-119",
          "snippet": "static inline uint32\nutf8word_to_unicode(uint32 c)\n{\n\tuint32\t\tucs;\n\n\tif (c <= 0x7F)\n\t{\n\t\tucs = c;\n\t}\n\telse if (c <= 0xFFFF)\n\t{\n\t\tucs = ((c >> 8) & 0x1F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\telse if (c <= 0xFFFFFF)\n\t{\n\t\tucs = ((c >> 16) & 0x0F) << 12;\n\t\tucs |= ((c >> 8) & 0x3F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\telse\n\t{\n\t\tucs = ((c >> 24) & 0x07) << 18;\n\t\tucs |= ((c >> 16) & 0x3F) << 12;\n\t\tucs |= ((c >> 8) & 0x3F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\n\treturn ucs;\n}",
          "includes": [
            "#include \"../../Unicode/utf8_to_gb18030.map\"",
            "#include \"../../Unicode/gb18030_to_utf8.map\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"fmgr.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../Unicode/utf8_to_gb18030.map\"\n#include \"../../Unicode/gb18030_to_utf8.map\"\n#include \"mb/pg_wchar.h\"\n#include \"fmgr.h\"\n#include \"postgres.h\"\n\nstatic inline uint32\nutf8word_to_unicode(uint32 c)\n{\n\tuint32\t\tucs;\n\n\tif (c <= 0x7F)\n\t{\n\t\tucs = c;\n\t}\n\telse if (c <= 0xFFFF)\n\t{\n\t\tucs = ((c >> 8) & 0x1F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\telse if (c <= 0xFFFFFF)\n\t{\n\t\tucs = ((c >> 16) & 0x0F) << 12;\n\t\tucs |= ((c >> 8) & 0x3F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\telse\n\t{\n\t\tucs = ((c >> 24) & 0x07) << 18;\n\t\tucs |= ((c >> 16) & 0x3F) << 12;\n\t\tucs |= ((c >> 8) & 0x3F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\n\treturn ucs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../Unicode/utf8_to_gb18030.map\"\n#include \"../../Unicode/gb18030_to_utf8.map\"\n#include \"mb/pg_wchar.h\"\n#include \"fmgr.h\"\n#include \"postgres.h\"\n\nstatic uint32\nconv_utf8_to_18030(uint32 code)\n{\n\tuint32\t\tucs = utf8word_to_unicode(code);\n\n#define convutf8(minunicode, maxunicode, mincode) \\\n\tif (ucs >= minunicode && ucs <= maxunicode) \\\n\t\treturn gb_unlinear(ucs - minunicode + gb_linear(mincode))\n\n\tconvutf8(0x0452, 0x200F, 0x8130D330);\n\tconvutf8(0x2643, 0x2E80, 0x8137A839);\n\tconvutf8(0x361B, 0x3917, 0x8230A633);\n\tconvutf8(0x3CE1, 0x4055, 0x8231D438);\n\tconvutf8(0x4160, 0x4336, 0x8232C937);\n\tconvutf8(0x44D7, 0x464B, 0x8233A339);\n\tconvutf8(0x478E, 0x4946, 0x8233E838);\n\tconvutf8(0x49B8, 0x4C76, 0x8234A131);\n\tconvutf8(0x9FA6, 0xD7FF, 0x82358F33);\n\tconvutf8(0xE865, 0xF92B, 0x8336D030);\n\tconvutf8(0xFA2A, 0xFE2F, 0x84309C38);\n\tconvutf8(0xFFE6, 0xFFFF, 0x8431A234);\n\tconvutf8(0x10000, 0x10FFFF, 0x90308130);\n\t/* No mapping exists */\n\treturn 0;\n}"
  },
  {
    "function_name": "conv_18030_to_utf8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/utf8_and_gb18030/utf8_and_gb18030.c",
    "lines": "127-149",
    "snippet": "static uint32\nconv_18030_to_utf8(uint32 code)\n{\n#define conv18030(minunicode, mincode, maxcode) \\\n\tif (code >= mincode && code <= maxcode) \\\n\t\treturn unicode_to_utf8word(gb_linear(code) - gb_linear(mincode) + minunicode)\n\n\tconv18030(0x0452, 0x8130D330, 0x8136A531);\n\tconv18030(0x2643, 0x8137A839, 0x8138FD38);\n\tconv18030(0x361B, 0x8230A633, 0x8230F237);\n\tconv18030(0x3CE1, 0x8231D438, 0x8232AF32);\n\tconv18030(0x4160, 0x8232C937, 0x8232F837);\n\tconv18030(0x44D7, 0x8233A339, 0x8233C931);\n\tconv18030(0x478E, 0x8233E838, 0x82349638);\n\tconv18030(0x49B8, 0x8234A131, 0x8234E733);\n\tconv18030(0x9FA6, 0x82358F33, 0x8336C738);\n\tconv18030(0xE865, 0x8336D030, 0x84308534);\n\tconv18030(0xFA2A, 0x84309C38, 0x84318537);\n\tconv18030(0xFFE6, 0x8431A234, 0x8431A439);\n\tconv18030(0x10000, 0x90308130, 0xE3329A35);\n\t/* No mapping exists */\n\treturn 0;\n}",
    "includes": [
      "#include \"../../Unicode/utf8_to_gb18030.map\"",
      "#include \"../../Unicode/gb18030_to_utf8.map\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"fmgr.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0x10000",
            "0x90308130",
            "0xE3329A35"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0xFFE6",
            "0x8431A234",
            "0x8431A439"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0xFA2A",
            "0x84309C38",
            "0x84318537"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0xE865",
            "0x8336D030",
            "0x84308534"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0x9FA6",
            "0x82358F33",
            "0x8336C738"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0x49B8",
            "0x8234A131",
            "0x8234E733"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0x478E",
            "0x8233E838",
            "0x82349638"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0x44D7",
            "0x8233A339",
            "0x8233C931"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0x4160",
            "0x8232C937",
            "0x8232F837"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0x3CE1",
            "0x8231D438",
            "0x8232AF32"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0x361B",
            "0x8230A633",
            "0x8230F237"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0x2643",
            "0x8137A839",
            "0x8138FD38"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conv18030",
          "args": [
            "0x0452",
            "0x8130D330",
            "0x8136A531"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../Unicode/utf8_to_gb18030.map\"\n#include \"../../Unicode/gb18030_to_utf8.map\"\n#include \"mb/pg_wchar.h\"\n#include \"fmgr.h\"\n#include \"postgres.h\"\n\nstatic uint32\nconv_18030_to_utf8(uint32 code)\n{\n#define conv18030(minunicode, mincode, maxcode) \\\n\tif (code >= mincode && code <= maxcode) \\\n\t\treturn unicode_to_utf8word(gb_linear(code) - gb_linear(mincode) + minunicode)\n\n\tconv18030(0x0452, 0x8130D330, 0x8136A531);\n\tconv18030(0x2643, 0x8137A839, 0x8138FD38);\n\tconv18030(0x361B, 0x8230A633, 0x8230F237);\n\tconv18030(0x3CE1, 0x8231D438, 0x8232AF32);\n\tconv18030(0x4160, 0x8232C937, 0x8232F837);\n\tconv18030(0x44D7, 0x8233A339, 0x8233C931);\n\tconv18030(0x478E, 0x8233E838, 0x82349638);\n\tconv18030(0x49B8, 0x8234A131, 0x8234E733);\n\tconv18030(0x9FA6, 0x82358F33, 0x8336C738);\n\tconv18030(0xE865, 0x8336D030, 0x84308534);\n\tconv18030(0xFA2A, 0x84309C38, 0x84318537);\n\tconv18030(0xFFE6, 0x8431A234, 0x8431A439);\n\tconv18030(0x10000, 0x90308130, 0xE3329A35);\n\t/* No mapping exists */\n\treturn 0;\n}"
  },
  {
    "function_name": "utf8word_to_unicode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/utf8_and_gb18030/utf8_and_gb18030.c",
    "lines": "90-119",
    "snippet": "static inline uint32\nutf8word_to_unicode(uint32 c)\n{\n\tuint32\t\tucs;\n\n\tif (c <= 0x7F)\n\t{\n\t\tucs = c;\n\t}\n\telse if (c <= 0xFFFF)\n\t{\n\t\tucs = ((c >> 8) & 0x1F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\telse if (c <= 0xFFFFFF)\n\t{\n\t\tucs = ((c >> 16) & 0x0F) << 12;\n\t\tucs |= ((c >> 8) & 0x3F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\telse\n\t{\n\t\tucs = ((c >> 24) & 0x07) << 18;\n\t\tucs |= ((c >> 16) & 0x3F) << 12;\n\t\tucs |= ((c >> 8) & 0x3F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\n\treturn ucs;\n}",
    "includes": [
      "#include \"../../Unicode/utf8_to_gb18030.map\"",
      "#include \"../../Unicode/gb18030_to_utf8.map\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"fmgr.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../../Unicode/utf8_to_gb18030.map\"\n#include \"../../Unicode/gb18030_to_utf8.map\"\n#include \"mb/pg_wchar.h\"\n#include \"fmgr.h\"\n#include \"postgres.h\"\n\nstatic inline uint32\nutf8word_to_unicode(uint32 c)\n{\n\tuint32\t\tucs;\n\n\tif (c <= 0x7F)\n\t{\n\t\tucs = c;\n\t}\n\telse if (c <= 0xFFFF)\n\t{\n\t\tucs = ((c >> 8) & 0x1F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\telse if (c <= 0xFFFFFF)\n\t{\n\t\tucs = ((c >> 16) & 0x0F) << 12;\n\t\tucs |= ((c >> 8) & 0x3F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\telse\n\t{\n\t\tucs = ((c >> 24) & 0x07) << 18;\n\t\tucs |= ((c >> 16) & 0x3F) << 12;\n\t\tucs |= ((c >> 8) & 0x3F) << 6;\n\t\tucs |= c & 0x3F;\n\t}\n\n\treturn ucs;\n}"
  },
  {
    "function_name": "unicode_to_utf8word",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/utf8_and_gb18030/utf8_and_gb18030.c",
    "lines": "59-88",
    "snippet": "static inline uint32\nunicode_to_utf8word(uint32 c)\n{\n\tuint32\t\tword;\n\n\tif (c <= 0x7F)\n\t{\n\t\tword = c;\n\t}\n\telse if (c <= 0x7FF)\n\t{\n\t\tword = (0xC0 | ((c >> 6) & 0x1F)) << 8;\n\t\tword |= 0x80 | (c & 0x3F);\n\t}\n\telse if (c <= 0xFFFF)\n\t{\n\t\tword = (0xE0 | ((c >> 12) & 0x0F)) << 16;\n\t\tword |= (0x80 | ((c >> 6) & 0x3F)) << 8;\n\t\tword |= 0x80 | (c & 0x3F);\n\t}\n\telse\n\t{\n\t\tword = (0xF0 | ((c >> 18) & 0x07)) << 24;\n\t\tword |= (0x80 | ((c >> 12) & 0x3F)) << 16;\n\t\tword |= (0x80 | ((c >> 6) & 0x3F)) << 8;\n\t\tword |= 0x80 | (c & 0x3F);\n\t}\n\n\treturn word;\n}",
    "includes": [
      "#include \"../../Unicode/utf8_to_gb18030.map\"",
      "#include \"../../Unicode/gb18030_to_utf8.map\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"fmgr.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../../Unicode/utf8_to_gb18030.map\"\n#include \"../../Unicode/gb18030_to_utf8.map\"\n#include \"mb/pg_wchar.h\"\n#include \"fmgr.h\"\n#include \"postgres.h\"\n\nstatic inline uint32\nunicode_to_utf8word(uint32 c)\n{\n\tuint32\t\tword;\n\n\tif (c <= 0x7F)\n\t{\n\t\tword = c;\n\t}\n\telse if (c <= 0x7FF)\n\t{\n\t\tword = (0xC0 | ((c >> 6) & 0x1F)) << 8;\n\t\tword |= 0x80 | (c & 0x3F);\n\t}\n\telse if (c <= 0xFFFF)\n\t{\n\t\tword = (0xE0 | ((c >> 12) & 0x0F)) << 16;\n\t\tword |= (0x80 | ((c >> 6) & 0x3F)) << 8;\n\t\tword |= 0x80 | (c & 0x3F);\n\t}\n\telse\n\t{\n\t\tword = (0xF0 | ((c >> 18) & 0x07)) << 24;\n\t\tword |= (0x80 | ((c >> 12) & 0x3F)) << 16;\n\t\tword |= (0x80 | ((c >> 6) & 0x3F)) << 8;\n\t\tword |= 0x80 | (c & 0x3F);\n\t}\n\n\treturn word;\n}"
  },
  {
    "function_name": "gb_unlinear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/utf8_and_gb18030/utf8_and_gb18030.c",
    "lines": "43-52",
    "snippet": "static inline uint32\ngb_unlinear(uint32 lin)\n{\n\tuint32\t\tr0 = 0x81 + lin / 12600;\n\tuint32\t\tr1 = 0x30 + (lin / 1260) % 10;\n\tuint32\t\tr2 = 0x81 + (lin / 10) % 126;\n\tuint32\t\tr3 = 0x30 + lin % 10;\n\n\treturn (r0 << 24) | (r1 << 16) | (r2 << 8) | r3;\n}",
    "includes": [
      "#include \"../../Unicode/utf8_to_gb18030.map\"",
      "#include \"../../Unicode/gb18030_to_utf8.map\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"fmgr.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../../Unicode/utf8_to_gb18030.map\"\n#include \"../../Unicode/gb18030_to_utf8.map\"\n#include \"mb/pg_wchar.h\"\n#include \"fmgr.h\"\n#include \"postgres.h\"\n\nstatic inline uint32\ngb_unlinear(uint32 lin)\n{\n\tuint32\t\tr0 = 0x81 + lin / 12600;\n\tuint32\t\tr1 = 0x30 + (lin / 1260) % 10;\n\tuint32\t\tr2 = 0x81 + (lin / 10) % 126;\n\tuint32\t\tr3 = 0x30 + lin % 10;\n\n\treturn (r0 << 24) | (r1 << 16) | (r2 << 8) | r3;\n}"
  },
  {
    "function_name": "gb_linear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/utf8_and_gb18030/utf8_and_gb18030.c",
    "lines": "31-41",
    "snippet": "static inline uint32\ngb_linear(uint32 gb)\n{\n\tuint32\t\tb0 = (gb & 0xff000000) >> 24;\n\tuint32\t\tb1 = (gb & 0x00ff0000) >> 16;\n\tuint32\t\tb2 = (gb & 0x0000ff00) >> 8;\n\tuint32\t\tb3 = (gb & 0x000000ff);\n\n\treturn b0 * 12600 + b1 * 1260 + b2 * 10 + b3 -\n\t\t(0x81 * 12600 + 0x30 * 1260 + 0x81 * 10 + 0x30);\n}",
    "includes": [
      "#include \"../../Unicode/utf8_to_gb18030.map\"",
      "#include \"../../Unicode/gb18030_to_utf8.map\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"fmgr.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../../Unicode/utf8_to_gb18030.map\"\n#include \"../../Unicode/gb18030_to_utf8.map\"\n#include \"mb/pg_wchar.h\"\n#include \"fmgr.h\"\n#include \"postgres.h\"\n\nstatic inline uint32\ngb_linear(uint32 gb)\n{\n\tuint32\t\tb0 = (gb & 0xff000000) >> 24;\n\tuint32\t\tb1 = (gb & 0x00ff0000) >> 16;\n\tuint32\t\tb2 = (gb & 0x0000ff00) >> 8;\n\tuint32\t\tb3 = (gb & 0x000000ff);\n\n\treturn b0 * 12600 + b1 * 1260 + b2 * 10 + b3 -\n\t\t(0x81 * 12600 + 0x30 * 1260 + 0x81 * 10 + 0x30);\n}"
  }
]