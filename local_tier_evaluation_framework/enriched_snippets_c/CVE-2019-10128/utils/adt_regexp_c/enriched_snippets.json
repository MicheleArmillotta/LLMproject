[
  {
    "function_name": "regexp_fixed_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "1379-1437",
    "snippet": "char *\nregexp_fixed_prefix(text *text_re, bool case_insensitive, Oid collation,\n\t\t\t\t\tbool *exact)\n{\n\tchar\t   *result;\n\tregex_t    *re;\n\tint\t\t\tcflags;\n\tint\t\t\tre_result;\n\tpg_wchar   *str;\n\tsize_t\t\tslen;\n\tsize_t\t\tmaxlen;\n\tchar\t\terrMsg[100];\n\n\t*exact = false;\t\t\t\t/* default result */\n\n\t/* Compile RE */\n\tcflags = REG_ADVANCED;\n\tif (case_insensitive)\n\t\tcflags |= REG_ICASE;\n\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\t/* Examine it to see if there's a fixed prefix */\n\tre_result = pg_regprefix(re, &str, &slen);\n\n\tswitch (re_result)\n\t{\n\t\tcase REG_NOMATCH:\n\t\t\treturn NULL;\n\n\t\tcase REG_PREFIX:\n\t\t\t/* continue with wchar conversion */\n\t\t\tbreak;\n\n\t\tcase REG_EXACT:\n\t\t\t*exact = true;\n\t\t\t/* continue with wchar conversion */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* re failed??? */\n\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\tpg_regerror(re_result, re, errMsg, sizeof(errMsg));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t\t\tbreak;\n\t}\n\n\t/* Convert pg_wchar result back to database encoding */\n\tmaxlen = pg_database_encoding_max_length() * slen + 1;\n\tresult = (char *) palloc(maxlen);\n\tslen = pg_wchar2mb_with_len(str, result, slen);\n\tAssert(slen < maxlen);\n\n\tfree(str);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "slen < maxlen"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_wchar2mb_with_len",
          "args": [
            "str",
            "result",
            "slen"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "pg_wchar2mb_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "744-748",
          "snippet": "int\npg_wchar2mb_with_len(const pg_wchar *from, char *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len(from, (unsigned char *) to, len);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_wchar2mb_with_len(const pg_wchar *from, char *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len(from, (unsigned char *) to, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "maxlen"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg))"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"regular expression failed: %s\"",
            "errMsg"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_REGULAR_EXPRESSION"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_regerror",
          "args": [
            "re_result",
            "re",
            "errMsg",
            "sizeof(errMsg)"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_regprefix",
          "args": [
            "re",
            "&str",
            "&slen"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RE_compile_and_cache",
          "args": [
            "text_re",
            "cflags",
            "collation"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "136-249",
          "snippet": "static regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CACHED_RES\t32"
          ],
          "globals_used": [
            "static int\tnum_res = 0;",
            "static cached_re_str re_array[MAX_CACHED_RES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MAX_CACHED_RES\t32\n\nstatic int\tnum_res = 0;\nstatic cached_re_str re_array[MAX_CACHED_RES];\n\nstatic regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nchar *\nregexp_fixed_prefix(text *text_re, bool case_insensitive, Oid collation,\n\t\t\t\t\tbool *exact)\n{\n\tchar\t   *result;\n\tregex_t    *re;\n\tint\t\t\tcflags;\n\tint\t\t\tre_result;\n\tpg_wchar   *str;\n\tsize_t\t\tslen;\n\tsize_t\t\tmaxlen;\n\tchar\t\terrMsg[100];\n\n\t*exact = false;\t\t\t\t/* default result */\n\n\t/* Compile RE */\n\tcflags = REG_ADVANCED;\n\tif (case_insensitive)\n\t\tcflags |= REG_ICASE;\n\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\t/* Examine it to see if there's a fixed prefix */\n\tre_result = pg_regprefix(re, &str, &slen);\n\n\tswitch (re_result)\n\t{\n\t\tcase REG_NOMATCH:\n\t\t\treturn NULL;\n\n\t\tcase REG_PREFIX:\n\t\t\t/* continue with wchar conversion */\n\t\t\tbreak;\n\n\t\tcase REG_EXACT:\n\t\t\t*exact = true;\n\t\t\t/* continue with wchar conversion */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* re failed??? */\n\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\tpg_regerror(re_result, re, errMsg, sizeof(errMsg));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t\t\tbreak;\n\t}\n\n\t/* Convert pg_wchar result back to database encoding */\n\tmaxlen = pg_database_encoding_max_length() * slen + 1;\n\tresult = (char *) palloc(maxlen);\n\tslen = pg_wchar2mb_with_len(str, result, slen);\n\tAssert(slen < maxlen);\n\n\tfree(str);\n\n\treturn result;\n}"
  },
  {
    "function_name": "build_regexp_split_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "1333-1371",
    "snippet": "static Datum\nbuild_regexp_split_result(regexp_matches_ctx *splitctx)\n{\n\tchar\t   *buf = splitctx->conv_buf;\n\tint\t\t\tstartpos;\n\tint\t\t\tendpos;\n\n\tif (splitctx->next_match > 0)\n\t\tstartpos = splitctx->match_locs[splitctx->next_match * 2 - 1];\n\telse\n\t\tstartpos = 0;\n\tif (startpos < 0)\n\t\telog(ERROR, \"invalid match ending position\");\n\n\tif (buf)\n\t{\n\t\tint\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = splitctx->conv_bufsiz;\n\t\tint\t\tlen;\n\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\tlen = pg_wchar2mb_with_len(splitctx->wide_str + startpos,\n\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t   endpos-startpos);\n\t\tAssert(len < bufsiz);\n\t\treturn PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t}\n\telse\n\t{\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\treturn DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t   PointerGetDatum(splitctx->orig_str),\n\t\t\t\t\t\t\t\t   Int32GetDatum(startpos + 1),\n\t\t\t\t\t\t\t\t   Int32GetDatum(endpos - startpos));\n\t}\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum build_regexp_split_result(regexp_matches_ctx *splitctx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall3",
          "args": [
            "text_substr",
            "PointerGetDatum(splitctx->orig_str)",
            "Int32GetDatum(startpos + 1)",
            "Int32GetDatum(endpos - startpos)"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "endpos - startpos"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "startpos + 1"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "splitctx->orig_str"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid match starting position\""
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "cstring_to_text_with_len(buf, len)"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "buf",
            "len"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "len < bufsiz"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_wchar2mb_with_len",
          "args": [
            "splitctx->wide_str + startpos",
            "buf",
            "endpos-startpos"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "pg_wchar2mb_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "744-748",
          "snippet": "int\npg_wchar2mb_with_len(const pg_wchar *from, char *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len(from, (unsigned char *) to, len);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_wchar2mb_with_len(const pg_wchar *from, char *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len(from, (unsigned char *) to, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum build_regexp_split_result(regexp_matches_ctx *splitctx);\n\nstatic Datum\nbuild_regexp_split_result(regexp_matches_ctx *splitctx)\n{\n\tchar\t   *buf = splitctx->conv_buf;\n\tint\t\t\tstartpos;\n\tint\t\t\tendpos;\n\n\tif (splitctx->next_match > 0)\n\t\tstartpos = splitctx->match_locs[splitctx->next_match * 2 - 1];\n\telse\n\t\tstartpos = 0;\n\tif (startpos < 0)\n\t\telog(ERROR, \"invalid match ending position\");\n\n\tif (buf)\n\t{\n\t\tint\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = splitctx->conv_bufsiz;\n\t\tint\t\tlen;\n\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\tlen = pg_wchar2mb_with_len(splitctx->wide_str + startpos,\n\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t   endpos-startpos);\n\t\tAssert(len < bufsiz);\n\t\treturn PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t}\n\telse\n\t{\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\treturn DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t   PointerGetDatum(splitctx->orig_str),\n\t\t\t\t\t\t\t\t   Int32GetDatum(startpos + 1),\n\t\t\t\t\t\t\t\t   Int32GetDatum(endpos - startpos));\n\t}\n}"
  },
  {
    "function_name": "regexp_split_to_array_no_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "1321-1325",
    "snippet": "Datum\nregexp_split_to_array_no_flags(PG_FUNCTION_ARGS)\n{\n\treturn regexp_split_to_array(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "regexp_split_to_array",
          "args": [
            "fcinfo"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "regexp_split_to_array_no_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "1321-1325",
          "snippet": "Datum\nregexp_split_to_array_no_flags(PG_FUNCTION_ARGS)\n{\n\treturn regexp_split_to_array(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\nregexp_split_to_array_no_flags(PG_FUNCTION_ARGS)\n{\n\treturn regexp_split_to_array(fcinfo);\n}"
  },
  {
    "function_name": "regexp_split_to_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "1284-1318",
    "snippet": "Datum\nregexp_split_to_array(PG_FUNCTION_ARGS)\n{\n\tArrayBuildState *astate = NULL;\n\tpg_re_flags re_flags;\n\tregexp_matches_ctx *splitctx;\n\n\t/* Determine options */\n\tparse_re_flags(&re_flags, PG_GETARG_TEXT_PP_IF_EXISTS(2));\n\t/* User mustn't specify 'g' */\n\tif (re_flags.glob)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"regexp_split_to_array does not support the global option\")));\n\t/* But we find all the matches anyway */\n\tre_flags.glob = true;\n\n\tsplitctx = setup_regexp_matches(PG_GETARG_TEXT_PP(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_TEXT_PP(1),\n\t\t\t\t\t\t\t\t\t&re_flags,\n\t\t\t\t\t\t\t\t\tPG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\tfalse, true, true);\n\n\twhile (splitctx->next_match <= splitctx->nmatches)\n\t{\n\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t  build_regexp_split_result(splitctx),\n\t\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\t\tsplitctx->next_match++;\n\t}\n\n\tPG_RETURN_ARRAYTYPE_P(makeArrayResult(astate, CurrentMemoryContext));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum build_regexp_split_result(regexp_matches_ctx *splitctx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "makeArrayResult(astate, CurrentMemoryContext)"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeArrayResult",
          "args": [
            "astate",
            "CurrentMemoryContext"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "makeArrayResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5117-5132",
          "snippet": "Datum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "accumArrayResult",
          "args": [
            "astate",
            "build_regexp_split_result(splitctx)",
            "false",
            "TEXTOID",
            "CurrentMemoryContext"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "accumArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5524-5543",
          "snippet": "ArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_regexp_split_result",
          "args": [
            "splitctx"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "build_regexp_split_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "1333-1371",
          "snippet": "static Datum\nbuild_regexp_split_result(regexp_matches_ctx *splitctx)\n{\n\tchar\t   *buf = splitctx->conv_buf;\n\tint\t\t\tstartpos;\n\tint\t\t\tendpos;\n\n\tif (splitctx->next_match > 0)\n\t\tstartpos = splitctx->match_locs[splitctx->next_match * 2 - 1];\n\telse\n\t\tstartpos = 0;\n\tif (startpos < 0)\n\t\telog(ERROR, \"invalid match ending position\");\n\n\tif (buf)\n\t{\n\t\tint\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = splitctx->conv_bufsiz;\n\t\tint\t\tlen;\n\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\tlen = pg_wchar2mb_with_len(splitctx->wide_str + startpos,\n\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t   endpos-startpos);\n\t\tAssert(len < bufsiz);\n\t\treturn PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t}\n\telse\n\t{\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\treturn DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t   PointerGetDatum(splitctx->orig_str),\n\t\t\t\t\t\t\t\t   Int32GetDatum(startpos + 1),\n\t\t\t\t\t\t\t\t   Int32GetDatum(endpos - startpos));\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum build_regexp_split_result(regexp_matches_ctx *splitctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum build_regexp_split_result(regexp_matches_ctx *splitctx);\n\nstatic Datum\nbuild_regexp_split_result(regexp_matches_ctx *splitctx)\n{\n\tchar\t   *buf = splitctx->conv_buf;\n\tint\t\t\tstartpos;\n\tint\t\t\tendpos;\n\n\tif (splitctx->next_match > 0)\n\t\tstartpos = splitctx->match_locs[splitctx->next_match * 2 - 1];\n\telse\n\t\tstartpos = 0;\n\tif (startpos < 0)\n\t\telog(ERROR, \"invalid match ending position\");\n\n\tif (buf)\n\t{\n\t\tint\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = splitctx->conv_bufsiz;\n\t\tint\t\tlen;\n\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\tlen = pg_wchar2mb_with_len(splitctx->wide_str + startpos,\n\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t   endpos-startpos);\n\t\tAssert(len < bufsiz);\n\t\treturn PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t}\n\telse\n\t{\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\treturn DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t   PointerGetDatum(splitctx->orig_str),\n\t\t\t\t\t\t\t\t   Int32GetDatum(startpos + 1),\n\t\t\t\t\t\t\t\t   Int32GetDatum(endpos - startpos));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_regexp_matches",
          "args": [
            "PG_GETARG_TEXT_PP(0)",
            "PG_GETARG_TEXT_PP(1)",
            "&re_flags",
            "PG_GET_COLLATION()",
            "false",
            "true",
            "true"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "setup_regexp_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "967-1161",
          "snippet": "static regexp_matches_ctx *\nsetup_regexp_matches(text *orig_str, text *pattern, pg_re_flags *re_flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched)\n{\n\tregexp_matches_ctx *matchctx = palloc0(sizeof(regexp_matches_ctx));\n\tint\t\t\teml = pg_database_encoding_max_length();\n\tint\t\t\torig_len;\n\tpg_wchar   *wide_str;\n\tint\t\t\twide_len;\n\tregex_t    *cpattern;\n\tregmatch_t *pmatch;\n\tint\t\t\tpmatch_len;\n\tint\t\t\tarray_len;\n\tint\t\t\tarray_idx;\n\tint\t\t\tprev_match_end;\n\tint\t\t\tprev_valid_match_end;\n\tint\t\t\tstart_search;\n\tint\t\t\tmaxlen = 0;\t\t/* largest fetch length in characters */\n\n\t/* save original string --- we'll extract result substrings from it */\n\tmatchctx->orig_str = orig_str;\n\n\t/* convert string to pg_wchar form for matching */\n\torig_len = VARSIZE_ANY_EXHDR(orig_str);\n\twide_str = (pg_wchar *) palloc(sizeof(pg_wchar) * (orig_len + 1));\n\twide_len = pg_mb2wchar_with_len(VARDATA_ANY(orig_str), wide_str, orig_len);\n\n\t/* set up the compiled pattern */\n\tcpattern = RE_compile_and_cache(pattern, re_flags->cflags, collation);\n\n\t/* do we want to remember subpatterns? */\n\tif (use_subpatterns && cpattern->re_nsub > 0)\n\t{\n\t\tmatchctx->npatterns = cpattern->re_nsub;\n\t\tpmatch_len = cpattern->re_nsub + 1;\n\t}\n\telse\n\t{\n\t\tuse_subpatterns = false;\n\t\tmatchctx->npatterns = 1;\n\t\tpmatch_len = 1;\n\t}\n\n\t/* temporary output space for RE package */\n\tpmatch = palloc(sizeof(regmatch_t) * pmatch_len);\n\n\t/*\n\t * the real output space (grown dynamically if needed)\n\t *\n\t * use values 2^n-1, not 2^n, so that we hit the limit at 2^28-1 rather\n\t * than at 2^27\n\t */\n\tarray_len = re_flags->glob ? 255 : 31;\n\tmatchctx->match_locs = (int *) palloc(sizeof(int) * array_len);\n\tarray_idx = 0;\n\n\t/* search for the pattern, perhaps repeatedly */\n\tprev_match_end = 0;\n\tprev_valid_match_end = 0;\n\tstart_search = 0;\n\twhile (RE_wchar_execute(cpattern, wide_str, wide_len, start_search,\n\t\t\t\t\t\t\tpmatch_len, pmatch))\n\t{\n\t\t/*\n\t\t * If requested, ignore degenerate matches, which are zero-length\n\t\t * matches occurring at the start or end of a string or just after a\n\t\t * previous match.\n\t\t */\n\t\tif (!ignore_degenerate ||\n\t\t\t(pmatch[0].rm_so < wide_len &&\n\t\t\t pmatch[0].rm_eo > prev_match_end))\n\t\t{\n\t\t\t/* enlarge output space if needed */\n\t\t\twhile (array_idx + matchctx->npatterns * 2 + 1 > array_len)\n\t\t\t{\n\t\t\t\tarray_len += array_len + 1;\t\t/* 2^n-1 => 2^(n+1)-1 */\n\t\t\t\tif (array_len > MaxAllocSize/sizeof(int))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"too many regular expression matches\")));\n\t\t\t\tmatchctx->match_locs = (int *) repalloc(matchctx->match_locs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int) * array_len);\n\t\t\t}\n\n\t\t\t/* save this match's locations */\n\t\t\tif (use_subpatterns)\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tfor (i = 1; i <= matchctx->npatterns; i++)\n\t\t\t\t{\n\t\t\t\t\tint\t\tso = pmatch[i].rm_so;\n\t\t\t\t\tint\t\teo = pmatch[i].rm_eo;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\tso = pmatch[0].rm_so;\n\t\t\t\tint\t\teo = pmatch[0].rm_eo;\n\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t}\n\t\t\tmatchctx->nmatches++;\n\n\t\t\t/*\n\t\t\t * check length of unmatched portion between end of previous valid\n\t\t\t * (nondegenerate, or degenerate but not ignored) match and start\n\t\t\t * of current one\n\t\t\t */\n\t\t\tif (fetching_unmatched &&\n\t\t\t\tpmatch[0].rm_so >= 0 &&\n\t\t\t\t(pmatch[0].rm_so - prev_valid_match_end) > maxlen)\n\t\t\t\tmaxlen = (pmatch[0].rm_so - prev_valid_match_end);\n\t\t\tprev_valid_match_end = pmatch[0].rm_eo;\n\t\t}\n\t\tprev_match_end = pmatch[0].rm_eo;\n\n\t\t/* if not glob, stop after one match */\n\t\tif (!re_flags->glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tstart_search = prev_match_end;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tstart_search++;\n\t\tif (start_search > wide_len)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check length of unmatched portion between end of last match and end of\n\t * input string\n\t */\n\tif (fetching_unmatched &&\n\t\t(wide_len - prev_valid_match_end) > maxlen)\n\t\tmaxlen = (wide_len - prev_valid_match_end);\n\n\t/*\n\t * Keep a note of the end position of the string for the benefit of\n\t * splitting code.\n\t */\n\tmatchctx->match_locs[array_idx] = wide_len;\n\n\tif (eml > 1)\n\t{\n\t\tint64\t\tmaxsiz = eml * (int64) maxlen;\n\t\tint\t\t\tconv_bufsiz;\n\n\t\t/*\n\t\t * Make the conversion buffer large enough for any substring of\n\t\t * interest.\n\t\t *\n\t\t * Worst case: assume we need the maximum size (maxlen*eml), but take\n\t\t * advantage of the fact that the original string length in bytes is an\n\t\t * upper bound on the byte length of any fetched substring (and we know\n\t\t * that len+1 is safe to allocate because the varlena header is longer\n\t\t * than 1 byte).\n\t\t */\n\t\tif (maxsiz > orig_len)\n\t\t\tconv_bufsiz = orig_len + 1;\n\t\telse\n\t\t\tconv_bufsiz = maxsiz + 1;\t/* safe since maxsiz < 2^30 */\n\n\t\tmatchctx->conv_buf = palloc(conv_bufsiz);\n\t\tmatchctx->conv_bufsiz = conv_bufsiz;\n\t\tmatchctx->wide_str = wide_str;\n\t}\n\telse\n\t{\n\t\t/* No need to keep the wide string if we're in a single-byte charset. */\n\t\tpfree(wide_str);\n\t\tmatchctx->wide_str = NULL;\n\t\tmatchctx->conv_buf = NULL;\n\t\tmatchctx->conv_bufsiz = 0;\n\t}\n\n\t/* Clean up temp storage */\n\tpfree(pmatch);\n\n\treturn matchctx;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static regexp_matches_ctx *setup_regexp_matches(text *orig_str, text *pattern,\n\t\t\t\t\t pg_re_flags *flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched);",
            "static ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic regexp_matches_ctx *setup_regexp_matches(text *orig_str, text *pattern,\n\t\t\t\t\t pg_re_flags *flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched);\nstatic ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);\n\nstatic regexp_matches_ctx *\nsetup_regexp_matches(text *orig_str, text *pattern, pg_re_flags *re_flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched)\n{\n\tregexp_matches_ctx *matchctx = palloc0(sizeof(regexp_matches_ctx));\n\tint\t\t\teml = pg_database_encoding_max_length();\n\tint\t\t\torig_len;\n\tpg_wchar   *wide_str;\n\tint\t\t\twide_len;\n\tregex_t    *cpattern;\n\tregmatch_t *pmatch;\n\tint\t\t\tpmatch_len;\n\tint\t\t\tarray_len;\n\tint\t\t\tarray_idx;\n\tint\t\t\tprev_match_end;\n\tint\t\t\tprev_valid_match_end;\n\tint\t\t\tstart_search;\n\tint\t\t\tmaxlen = 0;\t\t/* largest fetch length in characters */\n\n\t/* save original string --- we'll extract result substrings from it */\n\tmatchctx->orig_str = orig_str;\n\n\t/* convert string to pg_wchar form for matching */\n\torig_len = VARSIZE_ANY_EXHDR(orig_str);\n\twide_str = (pg_wchar *) palloc(sizeof(pg_wchar) * (orig_len + 1));\n\twide_len = pg_mb2wchar_with_len(VARDATA_ANY(orig_str), wide_str, orig_len);\n\n\t/* set up the compiled pattern */\n\tcpattern = RE_compile_and_cache(pattern, re_flags->cflags, collation);\n\n\t/* do we want to remember subpatterns? */\n\tif (use_subpatterns && cpattern->re_nsub > 0)\n\t{\n\t\tmatchctx->npatterns = cpattern->re_nsub;\n\t\tpmatch_len = cpattern->re_nsub + 1;\n\t}\n\telse\n\t{\n\t\tuse_subpatterns = false;\n\t\tmatchctx->npatterns = 1;\n\t\tpmatch_len = 1;\n\t}\n\n\t/* temporary output space for RE package */\n\tpmatch = palloc(sizeof(regmatch_t) * pmatch_len);\n\n\t/*\n\t * the real output space (grown dynamically if needed)\n\t *\n\t * use values 2^n-1, not 2^n, so that we hit the limit at 2^28-1 rather\n\t * than at 2^27\n\t */\n\tarray_len = re_flags->glob ? 255 : 31;\n\tmatchctx->match_locs = (int *) palloc(sizeof(int) * array_len);\n\tarray_idx = 0;\n\n\t/* search for the pattern, perhaps repeatedly */\n\tprev_match_end = 0;\n\tprev_valid_match_end = 0;\n\tstart_search = 0;\n\twhile (RE_wchar_execute(cpattern, wide_str, wide_len, start_search,\n\t\t\t\t\t\t\tpmatch_len, pmatch))\n\t{\n\t\t/*\n\t\t * If requested, ignore degenerate matches, which are zero-length\n\t\t * matches occurring at the start or end of a string or just after a\n\t\t * previous match.\n\t\t */\n\t\tif (!ignore_degenerate ||\n\t\t\t(pmatch[0].rm_so < wide_len &&\n\t\t\t pmatch[0].rm_eo > prev_match_end))\n\t\t{\n\t\t\t/* enlarge output space if needed */\n\t\t\twhile (array_idx + matchctx->npatterns * 2 + 1 > array_len)\n\t\t\t{\n\t\t\t\tarray_len += array_len + 1;\t\t/* 2^n-1 => 2^(n+1)-1 */\n\t\t\t\tif (array_len > MaxAllocSize/sizeof(int))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"too many regular expression matches\")));\n\t\t\t\tmatchctx->match_locs = (int *) repalloc(matchctx->match_locs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int) * array_len);\n\t\t\t}\n\n\t\t\t/* save this match's locations */\n\t\t\tif (use_subpatterns)\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tfor (i = 1; i <= matchctx->npatterns; i++)\n\t\t\t\t{\n\t\t\t\t\tint\t\tso = pmatch[i].rm_so;\n\t\t\t\t\tint\t\teo = pmatch[i].rm_eo;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\tso = pmatch[0].rm_so;\n\t\t\t\tint\t\teo = pmatch[0].rm_eo;\n\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t}\n\t\t\tmatchctx->nmatches++;\n\n\t\t\t/*\n\t\t\t * check length of unmatched portion between end of previous valid\n\t\t\t * (nondegenerate, or degenerate but not ignored) match and start\n\t\t\t * of current one\n\t\t\t */\n\t\t\tif (fetching_unmatched &&\n\t\t\t\tpmatch[0].rm_so >= 0 &&\n\t\t\t\t(pmatch[0].rm_so - prev_valid_match_end) > maxlen)\n\t\t\t\tmaxlen = (pmatch[0].rm_so - prev_valid_match_end);\n\t\t\tprev_valid_match_end = pmatch[0].rm_eo;\n\t\t}\n\t\tprev_match_end = pmatch[0].rm_eo;\n\n\t\t/* if not glob, stop after one match */\n\t\tif (!re_flags->glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tstart_search = prev_match_end;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tstart_search++;\n\t\tif (start_search > wide_len)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check length of unmatched portion between end of last match and end of\n\t * input string\n\t */\n\tif (fetching_unmatched &&\n\t\t(wide_len - prev_valid_match_end) > maxlen)\n\t\tmaxlen = (wide_len - prev_valid_match_end);\n\n\t/*\n\t * Keep a note of the end position of the string for the benefit of\n\t * splitting code.\n\t */\n\tmatchctx->match_locs[array_idx] = wide_len;\n\n\tif (eml > 1)\n\t{\n\t\tint64\t\tmaxsiz = eml * (int64) maxlen;\n\t\tint\t\t\tconv_bufsiz;\n\n\t\t/*\n\t\t * Make the conversion buffer large enough for any substring of\n\t\t * interest.\n\t\t *\n\t\t * Worst case: assume we need the maximum size (maxlen*eml), but take\n\t\t * advantage of the fact that the original string length in bytes is an\n\t\t * upper bound on the byte length of any fetched substring (and we know\n\t\t * that len+1 is safe to allocate because the varlena header is longer\n\t\t * than 1 byte).\n\t\t */\n\t\tif (maxsiz > orig_len)\n\t\t\tconv_bufsiz = orig_len + 1;\n\t\telse\n\t\t\tconv_bufsiz = maxsiz + 1;\t/* safe since maxsiz < 2^30 */\n\n\t\tmatchctx->conv_buf = palloc(conv_bufsiz);\n\t\tmatchctx->conv_bufsiz = conv_bufsiz;\n\t\tmatchctx->wide_str = wide_str;\n\t}\n\telse\n\t{\n\t\t/* No need to keep the wide string if we're in a single-byte charset. */\n\t\tpfree(wide_str);\n\t\tmatchctx->wide_str = NULL;\n\t\tmatchctx->conv_buf = NULL;\n\t\tmatchctx->conv_bufsiz = 0;\n\t}\n\n\t/* Clean up temp storage */\n\tpfree(pmatch);\n\n\treturn matchctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"regexp_split_to_array does not support the global option\"))"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"regexp_split_to_array does not support the global option\""
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_re_flags",
          "args": [
            "&re_flags",
            "PG_GETARG_TEXT_PP_IF_EXISTS(2)"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "parse_re_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "365-432",
          "snippet": "static void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP_IF_EXISTS",
          "args": [
            "2"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum build_regexp_split_result(regexp_matches_ctx *splitctx);\n\nDatum\nregexp_split_to_array(PG_FUNCTION_ARGS)\n{\n\tArrayBuildState *astate = NULL;\n\tpg_re_flags re_flags;\n\tregexp_matches_ctx *splitctx;\n\n\t/* Determine options */\n\tparse_re_flags(&re_flags, PG_GETARG_TEXT_PP_IF_EXISTS(2));\n\t/* User mustn't specify 'g' */\n\tif (re_flags.glob)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"regexp_split_to_array does not support the global option\")));\n\t/* But we find all the matches anyway */\n\tre_flags.glob = true;\n\n\tsplitctx = setup_regexp_matches(PG_GETARG_TEXT_PP(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_TEXT_PP(1),\n\t\t\t\t\t\t\t\t\t&re_flags,\n\t\t\t\t\t\t\t\t\tPG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\tfalse, true, true);\n\n\twhile (splitctx->next_match <= splitctx->nmatches)\n\t{\n\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t  build_regexp_split_result(splitctx),\n\t\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\t\tsplitctx->next_match++;\n\t}\n\n\tPG_RETURN_ARRAYTYPE_P(makeArrayResult(astate, CurrentMemoryContext));\n}"
  },
  {
    "function_name": "regexp_split_to_table_no_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "1273-1277",
    "snippet": "Datum\nregexp_split_to_table_no_flags(PG_FUNCTION_ARGS)\n{\n\treturn regexp_split_to_table(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "regexp_split_to_table",
          "args": [
            "fcinfo"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "regexp_split_to_table_no_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "1273-1277",
          "snippet": "Datum\nregexp_split_to_table_no_flags(PG_FUNCTION_ARGS)\n{\n\treturn regexp_split_to_table(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\nregexp_split_to_table_no_flags(PG_FUNCTION_ARGS)\n{\n\treturn regexp_split_to_table(fcinfo);\n}"
  },
  {
    "function_name": "regexp_split_to_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "1222-1270",
    "snippet": "Datum\nregexp_split_to_table(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tregexp_matches_ctx *splitctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\ttext\t   *pattern = PG_GETARG_TEXT_PP(1);\n\t\ttext\t   *flags = PG_GETARG_TEXT_PP_IF_EXISTS(2);\n\t\tpg_re_flags re_flags;\n\t\tMemoryContext oldcontext;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* Determine options */\n\t\tparse_re_flags(&re_flags, flags);\n\t\t/* User mustn't specify 'g' */\n\t\tif (re_flags.glob)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"regexp_split_to_table does not support the global option\")));\n\t\t/* But we find all the matches anyway */\n\t\tre_flags.glob = true;\n\n\t\t/* be sure to copy the input string into the multi-call ctx */\n\t\tsplitctx = setup_regexp_matches(PG_GETARG_TEXT_P_COPY(0), pattern,\n\t\t\t\t\t\t\t\t\t\t&re_flags,\n\t\t\t\t\t\t\t\t\t\tPG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\tfalse, true, true);\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tfuncctx->user_fctx = (void *) splitctx;\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tsplitctx = (regexp_matches_ctx *) funcctx->user_fctx;\n\n\tif (splitctx->next_match <= splitctx->nmatches)\n\t{\n\t\tDatum\t\tresult = build_regexp_split_result(splitctx);\n\n\t\tsplitctx->next_match++;\n\t\tSRF_RETURN_NEXT(funcctx, result);\n\t}\n\n\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum build_regexp_split_result(regexp_matches_ctx *splitctx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "result"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_regexp_split_result",
          "args": [
            "splitctx"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "build_regexp_split_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "1333-1371",
          "snippet": "static Datum\nbuild_regexp_split_result(regexp_matches_ctx *splitctx)\n{\n\tchar\t   *buf = splitctx->conv_buf;\n\tint\t\t\tstartpos;\n\tint\t\t\tendpos;\n\n\tif (splitctx->next_match > 0)\n\t\tstartpos = splitctx->match_locs[splitctx->next_match * 2 - 1];\n\telse\n\t\tstartpos = 0;\n\tif (startpos < 0)\n\t\telog(ERROR, \"invalid match ending position\");\n\n\tif (buf)\n\t{\n\t\tint\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = splitctx->conv_bufsiz;\n\t\tint\t\tlen;\n\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\tlen = pg_wchar2mb_with_len(splitctx->wide_str + startpos,\n\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t   endpos-startpos);\n\t\tAssert(len < bufsiz);\n\t\treturn PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t}\n\telse\n\t{\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\treturn DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t   PointerGetDatum(splitctx->orig_str),\n\t\t\t\t\t\t\t\t   Int32GetDatum(startpos + 1),\n\t\t\t\t\t\t\t\t   Int32GetDatum(endpos - startpos));\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum build_regexp_split_result(regexp_matches_ctx *splitctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum build_regexp_split_result(regexp_matches_ctx *splitctx);\n\nstatic Datum\nbuild_regexp_split_result(regexp_matches_ctx *splitctx)\n{\n\tchar\t   *buf = splitctx->conv_buf;\n\tint\t\t\tstartpos;\n\tint\t\t\tendpos;\n\n\tif (splitctx->next_match > 0)\n\t\tstartpos = splitctx->match_locs[splitctx->next_match * 2 - 1];\n\telse\n\t\tstartpos = 0;\n\tif (startpos < 0)\n\t\telog(ERROR, \"invalid match ending position\");\n\n\tif (buf)\n\t{\n\t\tint\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = splitctx->conv_bufsiz;\n\t\tint\t\tlen;\n\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\tlen = pg_wchar2mb_with_len(splitctx->wide_str + startpos,\n\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t   endpos-startpos);\n\t\tAssert(len < bufsiz);\n\t\treturn PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t}\n\telse\n\t{\n\t\tendpos = splitctx->match_locs[splitctx->next_match * 2];\n\t\tif (endpos < startpos)\n\t\t\telog(ERROR, \"invalid match starting position\");\n\t\treturn DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t   PointerGetDatum(splitctx->orig_str),\n\t\t\t\t\t\t\t\t   Int32GetDatum(startpos + 1),\n\t\t\t\t\t\t\t\t   Int32GetDatum(endpos - startpos));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_regexp_matches",
          "args": [
            "PG_GETARG_TEXT_P_COPY(0)",
            "pattern",
            "&re_flags",
            "PG_GET_COLLATION()",
            "false",
            "true",
            "true"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "setup_regexp_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "967-1161",
          "snippet": "static regexp_matches_ctx *\nsetup_regexp_matches(text *orig_str, text *pattern, pg_re_flags *re_flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched)\n{\n\tregexp_matches_ctx *matchctx = palloc0(sizeof(regexp_matches_ctx));\n\tint\t\t\teml = pg_database_encoding_max_length();\n\tint\t\t\torig_len;\n\tpg_wchar   *wide_str;\n\tint\t\t\twide_len;\n\tregex_t    *cpattern;\n\tregmatch_t *pmatch;\n\tint\t\t\tpmatch_len;\n\tint\t\t\tarray_len;\n\tint\t\t\tarray_idx;\n\tint\t\t\tprev_match_end;\n\tint\t\t\tprev_valid_match_end;\n\tint\t\t\tstart_search;\n\tint\t\t\tmaxlen = 0;\t\t/* largest fetch length in characters */\n\n\t/* save original string --- we'll extract result substrings from it */\n\tmatchctx->orig_str = orig_str;\n\n\t/* convert string to pg_wchar form for matching */\n\torig_len = VARSIZE_ANY_EXHDR(orig_str);\n\twide_str = (pg_wchar *) palloc(sizeof(pg_wchar) * (orig_len + 1));\n\twide_len = pg_mb2wchar_with_len(VARDATA_ANY(orig_str), wide_str, orig_len);\n\n\t/* set up the compiled pattern */\n\tcpattern = RE_compile_and_cache(pattern, re_flags->cflags, collation);\n\n\t/* do we want to remember subpatterns? */\n\tif (use_subpatterns && cpattern->re_nsub > 0)\n\t{\n\t\tmatchctx->npatterns = cpattern->re_nsub;\n\t\tpmatch_len = cpattern->re_nsub + 1;\n\t}\n\telse\n\t{\n\t\tuse_subpatterns = false;\n\t\tmatchctx->npatterns = 1;\n\t\tpmatch_len = 1;\n\t}\n\n\t/* temporary output space for RE package */\n\tpmatch = palloc(sizeof(regmatch_t) * pmatch_len);\n\n\t/*\n\t * the real output space (grown dynamically if needed)\n\t *\n\t * use values 2^n-1, not 2^n, so that we hit the limit at 2^28-1 rather\n\t * than at 2^27\n\t */\n\tarray_len = re_flags->glob ? 255 : 31;\n\tmatchctx->match_locs = (int *) palloc(sizeof(int) * array_len);\n\tarray_idx = 0;\n\n\t/* search for the pattern, perhaps repeatedly */\n\tprev_match_end = 0;\n\tprev_valid_match_end = 0;\n\tstart_search = 0;\n\twhile (RE_wchar_execute(cpattern, wide_str, wide_len, start_search,\n\t\t\t\t\t\t\tpmatch_len, pmatch))\n\t{\n\t\t/*\n\t\t * If requested, ignore degenerate matches, which are zero-length\n\t\t * matches occurring at the start or end of a string or just after a\n\t\t * previous match.\n\t\t */\n\t\tif (!ignore_degenerate ||\n\t\t\t(pmatch[0].rm_so < wide_len &&\n\t\t\t pmatch[0].rm_eo > prev_match_end))\n\t\t{\n\t\t\t/* enlarge output space if needed */\n\t\t\twhile (array_idx + matchctx->npatterns * 2 + 1 > array_len)\n\t\t\t{\n\t\t\t\tarray_len += array_len + 1;\t\t/* 2^n-1 => 2^(n+1)-1 */\n\t\t\t\tif (array_len > MaxAllocSize/sizeof(int))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"too many regular expression matches\")));\n\t\t\t\tmatchctx->match_locs = (int *) repalloc(matchctx->match_locs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int) * array_len);\n\t\t\t}\n\n\t\t\t/* save this match's locations */\n\t\t\tif (use_subpatterns)\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tfor (i = 1; i <= matchctx->npatterns; i++)\n\t\t\t\t{\n\t\t\t\t\tint\t\tso = pmatch[i].rm_so;\n\t\t\t\t\tint\t\teo = pmatch[i].rm_eo;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\tso = pmatch[0].rm_so;\n\t\t\t\tint\t\teo = pmatch[0].rm_eo;\n\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t}\n\t\t\tmatchctx->nmatches++;\n\n\t\t\t/*\n\t\t\t * check length of unmatched portion between end of previous valid\n\t\t\t * (nondegenerate, or degenerate but not ignored) match and start\n\t\t\t * of current one\n\t\t\t */\n\t\t\tif (fetching_unmatched &&\n\t\t\t\tpmatch[0].rm_so >= 0 &&\n\t\t\t\t(pmatch[0].rm_so - prev_valid_match_end) > maxlen)\n\t\t\t\tmaxlen = (pmatch[0].rm_so - prev_valid_match_end);\n\t\t\tprev_valid_match_end = pmatch[0].rm_eo;\n\t\t}\n\t\tprev_match_end = pmatch[0].rm_eo;\n\n\t\t/* if not glob, stop after one match */\n\t\tif (!re_flags->glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tstart_search = prev_match_end;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tstart_search++;\n\t\tif (start_search > wide_len)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check length of unmatched portion between end of last match and end of\n\t * input string\n\t */\n\tif (fetching_unmatched &&\n\t\t(wide_len - prev_valid_match_end) > maxlen)\n\t\tmaxlen = (wide_len - prev_valid_match_end);\n\n\t/*\n\t * Keep a note of the end position of the string for the benefit of\n\t * splitting code.\n\t */\n\tmatchctx->match_locs[array_idx] = wide_len;\n\n\tif (eml > 1)\n\t{\n\t\tint64\t\tmaxsiz = eml * (int64) maxlen;\n\t\tint\t\t\tconv_bufsiz;\n\n\t\t/*\n\t\t * Make the conversion buffer large enough for any substring of\n\t\t * interest.\n\t\t *\n\t\t * Worst case: assume we need the maximum size (maxlen*eml), but take\n\t\t * advantage of the fact that the original string length in bytes is an\n\t\t * upper bound on the byte length of any fetched substring (and we know\n\t\t * that len+1 is safe to allocate because the varlena header is longer\n\t\t * than 1 byte).\n\t\t */\n\t\tif (maxsiz > orig_len)\n\t\t\tconv_bufsiz = orig_len + 1;\n\t\telse\n\t\t\tconv_bufsiz = maxsiz + 1;\t/* safe since maxsiz < 2^30 */\n\n\t\tmatchctx->conv_buf = palloc(conv_bufsiz);\n\t\tmatchctx->conv_bufsiz = conv_bufsiz;\n\t\tmatchctx->wide_str = wide_str;\n\t}\n\telse\n\t{\n\t\t/* No need to keep the wide string if we're in a single-byte charset. */\n\t\tpfree(wide_str);\n\t\tmatchctx->wide_str = NULL;\n\t\tmatchctx->conv_buf = NULL;\n\t\tmatchctx->conv_bufsiz = 0;\n\t}\n\n\t/* Clean up temp storage */\n\tpfree(pmatch);\n\n\treturn matchctx;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static regexp_matches_ctx *setup_regexp_matches(text *orig_str, text *pattern,\n\t\t\t\t\t pg_re_flags *flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched);",
            "static ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic regexp_matches_ctx *setup_regexp_matches(text *orig_str, text *pattern,\n\t\t\t\t\t pg_re_flags *flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched);\nstatic ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);\n\nstatic regexp_matches_ctx *\nsetup_regexp_matches(text *orig_str, text *pattern, pg_re_flags *re_flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched)\n{\n\tregexp_matches_ctx *matchctx = palloc0(sizeof(regexp_matches_ctx));\n\tint\t\t\teml = pg_database_encoding_max_length();\n\tint\t\t\torig_len;\n\tpg_wchar   *wide_str;\n\tint\t\t\twide_len;\n\tregex_t    *cpattern;\n\tregmatch_t *pmatch;\n\tint\t\t\tpmatch_len;\n\tint\t\t\tarray_len;\n\tint\t\t\tarray_idx;\n\tint\t\t\tprev_match_end;\n\tint\t\t\tprev_valid_match_end;\n\tint\t\t\tstart_search;\n\tint\t\t\tmaxlen = 0;\t\t/* largest fetch length in characters */\n\n\t/* save original string --- we'll extract result substrings from it */\n\tmatchctx->orig_str = orig_str;\n\n\t/* convert string to pg_wchar form for matching */\n\torig_len = VARSIZE_ANY_EXHDR(orig_str);\n\twide_str = (pg_wchar *) palloc(sizeof(pg_wchar) * (orig_len + 1));\n\twide_len = pg_mb2wchar_with_len(VARDATA_ANY(orig_str), wide_str, orig_len);\n\n\t/* set up the compiled pattern */\n\tcpattern = RE_compile_and_cache(pattern, re_flags->cflags, collation);\n\n\t/* do we want to remember subpatterns? */\n\tif (use_subpatterns && cpattern->re_nsub > 0)\n\t{\n\t\tmatchctx->npatterns = cpattern->re_nsub;\n\t\tpmatch_len = cpattern->re_nsub + 1;\n\t}\n\telse\n\t{\n\t\tuse_subpatterns = false;\n\t\tmatchctx->npatterns = 1;\n\t\tpmatch_len = 1;\n\t}\n\n\t/* temporary output space for RE package */\n\tpmatch = palloc(sizeof(regmatch_t) * pmatch_len);\n\n\t/*\n\t * the real output space (grown dynamically if needed)\n\t *\n\t * use values 2^n-1, not 2^n, so that we hit the limit at 2^28-1 rather\n\t * than at 2^27\n\t */\n\tarray_len = re_flags->glob ? 255 : 31;\n\tmatchctx->match_locs = (int *) palloc(sizeof(int) * array_len);\n\tarray_idx = 0;\n\n\t/* search for the pattern, perhaps repeatedly */\n\tprev_match_end = 0;\n\tprev_valid_match_end = 0;\n\tstart_search = 0;\n\twhile (RE_wchar_execute(cpattern, wide_str, wide_len, start_search,\n\t\t\t\t\t\t\tpmatch_len, pmatch))\n\t{\n\t\t/*\n\t\t * If requested, ignore degenerate matches, which are zero-length\n\t\t * matches occurring at the start or end of a string or just after a\n\t\t * previous match.\n\t\t */\n\t\tif (!ignore_degenerate ||\n\t\t\t(pmatch[0].rm_so < wide_len &&\n\t\t\t pmatch[0].rm_eo > prev_match_end))\n\t\t{\n\t\t\t/* enlarge output space if needed */\n\t\t\twhile (array_idx + matchctx->npatterns * 2 + 1 > array_len)\n\t\t\t{\n\t\t\t\tarray_len += array_len + 1;\t\t/* 2^n-1 => 2^(n+1)-1 */\n\t\t\t\tif (array_len > MaxAllocSize/sizeof(int))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"too many regular expression matches\")));\n\t\t\t\tmatchctx->match_locs = (int *) repalloc(matchctx->match_locs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int) * array_len);\n\t\t\t}\n\n\t\t\t/* save this match's locations */\n\t\t\tif (use_subpatterns)\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tfor (i = 1; i <= matchctx->npatterns; i++)\n\t\t\t\t{\n\t\t\t\t\tint\t\tso = pmatch[i].rm_so;\n\t\t\t\t\tint\t\teo = pmatch[i].rm_eo;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\tso = pmatch[0].rm_so;\n\t\t\t\tint\t\teo = pmatch[0].rm_eo;\n\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t}\n\t\t\tmatchctx->nmatches++;\n\n\t\t\t/*\n\t\t\t * check length of unmatched portion between end of previous valid\n\t\t\t * (nondegenerate, or degenerate but not ignored) match and start\n\t\t\t * of current one\n\t\t\t */\n\t\t\tif (fetching_unmatched &&\n\t\t\t\tpmatch[0].rm_so >= 0 &&\n\t\t\t\t(pmatch[0].rm_so - prev_valid_match_end) > maxlen)\n\t\t\t\tmaxlen = (pmatch[0].rm_so - prev_valid_match_end);\n\t\t\tprev_valid_match_end = pmatch[0].rm_eo;\n\t\t}\n\t\tprev_match_end = pmatch[0].rm_eo;\n\n\t\t/* if not glob, stop after one match */\n\t\tif (!re_flags->glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tstart_search = prev_match_end;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tstart_search++;\n\t\tif (start_search > wide_len)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check length of unmatched portion between end of last match and end of\n\t * input string\n\t */\n\tif (fetching_unmatched &&\n\t\t(wide_len - prev_valid_match_end) > maxlen)\n\t\tmaxlen = (wide_len - prev_valid_match_end);\n\n\t/*\n\t * Keep a note of the end position of the string for the benefit of\n\t * splitting code.\n\t */\n\tmatchctx->match_locs[array_idx] = wide_len;\n\n\tif (eml > 1)\n\t{\n\t\tint64\t\tmaxsiz = eml * (int64) maxlen;\n\t\tint\t\t\tconv_bufsiz;\n\n\t\t/*\n\t\t * Make the conversion buffer large enough for any substring of\n\t\t * interest.\n\t\t *\n\t\t * Worst case: assume we need the maximum size (maxlen*eml), but take\n\t\t * advantage of the fact that the original string length in bytes is an\n\t\t * upper bound on the byte length of any fetched substring (and we know\n\t\t * that len+1 is safe to allocate because the varlena header is longer\n\t\t * than 1 byte).\n\t\t */\n\t\tif (maxsiz > orig_len)\n\t\t\tconv_bufsiz = orig_len + 1;\n\t\telse\n\t\t\tconv_bufsiz = maxsiz + 1;\t/* safe since maxsiz < 2^30 */\n\n\t\tmatchctx->conv_buf = palloc(conv_bufsiz);\n\t\tmatchctx->conv_bufsiz = conv_bufsiz;\n\t\tmatchctx->wide_str = wide_str;\n\t}\n\telse\n\t{\n\t\t/* No need to keep the wide string if we're in a single-byte charset. */\n\t\tpfree(wide_str);\n\t\tmatchctx->wide_str = NULL;\n\t\tmatchctx->conv_buf = NULL;\n\t\tmatchctx->conv_bufsiz = 0;\n\t}\n\n\t/* Clean up temp storage */\n\tpfree(pmatch);\n\n\treturn matchctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_P_COPY",
          "args": [
            "0"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"regexp_split_to_table does not support the global option\"))"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"regexp_split_to_table does not support the global option\""
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_re_flags",
          "args": [
            "&re_flags",
            "flags"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "parse_re_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "365-432",
          "snippet": "static void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP_IF_EXISTS",
          "args": [
            "2"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum build_regexp_split_result(regexp_matches_ctx *splitctx);\n\nDatum\nregexp_split_to_table(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tregexp_matches_ctx *splitctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\ttext\t   *pattern = PG_GETARG_TEXT_PP(1);\n\t\ttext\t   *flags = PG_GETARG_TEXT_PP_IF_EXISTS(2);\n\t\tpg_re_flags re_flags;\n\t\tMemoryContext oldcontext;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* Determine options */\n\t\tparse_re_flags(&re_flags, flags);\n\t\t/* User mustn't specify 'g' */\n\t\tif (re_flags.glob)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"regexp_split_to_table does not support the global option\")));\n\t\t/* But we find all the matches anyway */\n\t\tre_flags.glob = true;\n\n\t\t/* be sure to copy the input string into the multi-call ctx */\n\t\tsplitctx = setup_regexp_matches(PG_GETARG_TEXT_P_COPY(0), pattern,\n\t\t\t\t\t\t\t\t\t\t&re_flags,\n\t\t\t\t\t\t\t\t\t\tPG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\tfalse, true, true);\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tfuncctx->user_fctx = (void *) splitctx;\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tsplitctx = (regexp_matches_ctx *) funcctx->user_fctx;\n\n\tif (splitctx->next_match <= splitctx->nmatches)\n\t{\n\t\tDatum\t\tresult = build_regexp_split_result(splitctx);\n\n\t\tsplitctx->next_match++;\n\t\tSRF_RETURN_NEXT(funcctx, result);\n\t}\n\n\tSRF_RETURN_DONE(funcctx);\n}"
  },
  {
    "function_name": "build_regexp_match_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "1166-1215",
    "snippet": "static ArrayType *\nbuild_regexp_match_result(regexp_matches_ctx *matchctx)\n{\n\tchar\t   *buf = matchctx->conv_buf;\n\tint\t\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = matchctx->conv_bufsiz;\n\tDatum\t   *elems = matchctx->elems;\n\tbool\t   *nulls = matchctx->nulls;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\tint\t\t\tloc;\n\tint\t\t\ti;\n\n\t/* Extract matching substrings from the original string */\n\tloc = matchctx->next_match * matchctx->npatterns * 2;\n\tfor (i = 0; i < matchctx->npatterns; i++)\n\t{\n\t\tint\t\t\tso = matchctx->match_locs[loc++];\n\t\tint\t\t\teo = matchctx->match_locs[loc++];\n\n\t\tif (so < 0 || eo < 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse if (buf)\n\t\t{\n\t\t\tint\t\tlen = pg_wchar2mb_with_len(matchctx->wide_str + so,\n\t\t\t\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t\t\t\t   eo - so);\n\t\t\tAssert(len < bufsiz);\n\t\t\telems[i] = PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t\t\tnulls[i] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(matchctx->orig_str),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(so + 1),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(eo - so));\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/* And form an array */\n\tdims[0] = matchctx->npatterns;\n\tlbs[0] = 1;\n\t/* XXX: this hardcodes assumptions about the text type */\n\treturn construct_md_array(elems, nulls, 1, dims, lbs,\n\t\t\t\t\t\t\t  TEXTOID, -1, false, 'i');\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "construct_md_array",
          "args": [
            "elems",
            "nulls",
            "1",
            "dims",
            "lbs",
            "TEXTOID",
            "-1",
            "false",
            "'i'"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "construct_md_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3325-3404",
          "snippet": "ArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall3",
          "args": [
            "text_substr",
            "PointerGetDatum(matchctx->orig_str)",
            "Int32GetDatum(so + 1)",
            "Int32GetDatum(eo - so)"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "eo - so"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "so + 1"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "matchctx->orig_str"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "cstring_to_text_with_len(buf, len)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "buf",
            "len"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "len < bufsiz"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_wchar2mb_with_len",
          "args": [
            "matchctx->wide_str + so",
            "buf",
            "eo - so"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "pg_wchar2mb_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "744-748",
          "snippet": "int\npg_wchar2mb_with_len(const pg_wchar *from, char *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len(from, (unsigned char *) to, len);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_wchar2mb_with_len(const pg_wchar *from, char *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len(from, (unsigned char *) to, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);\n\nstatic ArrayType *\nbuild_regexp_match_result(regexp_matches_ctx *matchctx)\n{\n\tchar\t   *buf = matchctx->conv_buf;\n\tint\t\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = matchctx->conv_bufsiz;\n\tDatum\t   *elems = matchctx->elems;\n\tbool\t   *nulls = matchctx->nulls;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\tint\t\t\tloc;\n\tint\t\t\ti;\n\n\t/* Extract matching substrings from the original string */\n\tloc = matchctx->next_match * matchctx->npatterns * 2;\n\tfor (i = 0; i < matchctx->npatterns; i++)\n\t{\n\t\tint\t\t\tso = matchctx->match_locs[loc++];\n\t\tint\t\t\teo = matchctx->match_locs[loc++];\n\n\t\tif (so < 0 || eo < 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse if (buf)\n\t\t{\n\t\t\tint\t\tlen = pg_wchar2mb_with_len(matchctx->wide_str + so,\n\t\t\t\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t\t\t\t   eo - so);\n\t\t\tAssert(len < bufsiz);\n\t\t\telems[i] = PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t\t\tnulls[i] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(matchctx->orig_str),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(so + 1),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(eo - so));\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/* And form an array */\n\tdims[0] = matchctx->npatterns;\n\tlbs[0] = 1;\n\t/* XXX: this hardcodes assumptions about the text type */\n\treturn construct_md_array(elems, nulls, 1, dims, lbs,\n\t\t\t\t\t\t\t  TEXTOID, -1, false, 'i');\n}"
  },
  {
    "function_name": "setup_regexp_matches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "967-1161",
    "snippet": "static regexp_matches_ctx *\nsetup_regexp_matches(text *orig_str, text *pattern, pg_re_flags *re_flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched)\n{\n\tregexp_matches_ctx *matchctx = palloc0(sizeof(regexp_matches_ctx));\n\tint\t\t\teml = pg_database_encoding_max_length();\n\tint\t\t\torig_len;\n\tpg_wchar   *wide_str;\n\tint\t\t\twide_len;\n\tregex_t    *cpattern;\n\tregmatch_t *pmatch;\n\tint\t\t\tpmatch_len;\n\tint\t\t\tarray_len;\n\tint\t\t\tarray_idx;\n\tint\t\t\tprev_match_end;\n\tint\t\t\tprev_valid_match_end;\n\tint\t\t\tstart_search;\n\tint\t\t\tmaxlen = 0;\t\t/* largest fetch length in characters */\n\n\t/* save original string --- we'll extract result substrings from it */\n\tmatchctx->orig_str = orig_str;\n\n\t/* convert string to pg_wchar form for matching */\n\torig_len = VARSIZE_ANY_EXHDR(orig_str);\n\twide_str = (pg_wchar *) palloc(sizeof(pg_wchar) * (orig_len + 1));\n\twide_len = pg_mb2wchar_with_len(VARDATA_ANY(orig_str), wide_str, orig_len);\n\n\t/* set up the compiled pattern */\n\tcpattern = RE_compile_and_cache(pattern, re_flags->cflags, collation);\n\n\t/* do we want to remember subpatterns? */\n\tif (use_subpatterns && cpattern->re_nsub > 0)\n\t{\n\t\tmatchctx->npatterns = cpattern->re_nsub;\n\t\tpmatch_len = cpattern->re_nsub + 1;\n\t}\n\telse\n\t{\n\t\tuse_subpatterns = false;\n\t\tmatchctx->npatterns = 1;\n\t\tpmatch_len = 1;\n\t}\n\n\t/* temporary output space for RE package */\n\tpmatch = palloc(sizeof(regmatch_t) * pmatch_len);\n\n\t/*\n\t * the real output space (grown dynamically if needed)\n\t *\n\t * use values 2^n-1, not 2^n, so that we hit the limit at 2^28-1 rather\n\t * than at 2^27\n\t */\n\tarray_len = re_flags->glob ? 255 : 31;\n\tmatchctx->match_locs = (int *) palloc(sizeof(int) * array_len);\n\tarray_idx = 0;\n\n\t/* search for the pattern, perhaps repeatedly */\n\tprev_match_end = 0;\n\tprev_valid_match_end = 0;\n\tstart_search = 0;\n\twhile (RE_wchar_execute(cpattern, wide_str, wide_len, start_search,\n\t\t\t\t\t\t\tpmatch_len, pmatch))\n\t{\n\t\t/*\n\t\t * If requested, ignore degenerate matches, which are zero-length\n\t\t * matches occurring at the start or end of a string or just after a\n\t\t * previous match.\n\t\t */\n\t\tif (!ignore_degenerate ||\n\t\t\t(pmatch[0].rm_so < wide_len &&\n\t\t\t pmatch[0].rm_eo > prev_match_end))\n\t\t{\n\t\t\t/* enlarge output space if needed */\n\t\t\twhile (array_idx + matchctx->npatterns * 2 + 1 > array_len)\n\t\t\t{\n\t\t\t\tarray_len += array_len + 1;\t\t/* 2^n-1 => 2^(n+1)-1 */\n\t\t\t\tif (array_len > MaxAllocSize/sizeof(int))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"too many regular expression matches\")));\n\t\t\t\tmatchctx->match_locs = (int *) repalloc(matchctx->match_locs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int) * array_len);\n\t\t\t}\n\n\t\t\t/* save this match's locations */\n\t\t\tif (use_subpatterns)\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tfor (i = 1; i <= matchctx->npatterns; i++)\n\t\t\t\t{\n\t\t\t\t\tint\t\tso = pmatch[i].rm_so;\n\t\t\t\t\tint\t\teo = pmatch[i].rm_eo;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\tso = pmatch[0].rm_so;\n\t\t\t\tint\t\teo = pmatch[0].rm_eo;\n\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t}\n\t\t\tmatchctx->nmatches++;\n\n\t\t\t/*\n\t\t\t * check length of unmatched portion between end of previous valid\n\t\t\t * (nondegenerate, or degenerate but not ignored) match and start\n\t\t\t * of current one\n\t\t\t */\n\t\t\tif (fetching_unmatched &&\n\t\t\t\tpmatch[0].rm_so >= 0 &&\n\t\t\t\t(pmatch[0].rm_so - prev_valid_match_end) > maxlen)\n\t\t\t\tmaxlen = (pmatch[0].rm_so - prev_valid_match_end);\n\t\t\tprev_valid_match_end = pmatch[0].rm_eo;\n\t\t}\n\t\tprev_match_end = pmatch[0].rm_eo;\n\n\t\t/* if not glob, stop after one match */\n\t\tif (!re_flags->glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tstart_search = prev_match_end;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tstart_search++;\n\t\tif (start_search > wide_len)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check length of unmatched portion between end of last match and end of\n\t * input string\n\t */\n\tif (fetching_unmatched &&\n\t\t(wide_len - prev_valid_match_end) > maxlen)\n\t\tmaxlen = (wide_len - prev_valid_match_end);\n\n\t/*\n\t * Keep a note of the end position of the string for the benefit of\n\t * splitting code.\n\t */\n\tmatchctx->match_locs[array_idx] = wide_len;\n\n\tif (eml > 1)\n\t{\n\t\tint64\t\tmaxsiz = eml * (int64) maxlen;\n\t\tint\t\t\tconv_bufsiz;\n\n\t\t/*\n\t\t * Make the conversion buffer large enough for any substring of\n\t\t * interest.\n\t\t *\n\t\t * Worst case: assume we need the maximum size (maxlen*eml), but take\n\t\t * advantage of the fact that the original string length in bytes is an\n\t\t * upper bound on the byte length of any fetched substring (and we know\n\t\t * that len+1 is safe to allocate because the varlena header is longer\n\t\t * than 1 byte).\n\t\t */\n\t\tif (maxsiz > orig_len)\n\t\t\tconv_bufsiz = orig_len + 1;\n\t\telse\n\t\t\tconv_bufsiz = maxsiz + 1;\t/* safe since maxsiz < 2^30 */\n\n\t\tmatchctx->conv_buf = palloc(conv_bufsiz);\n\t\tmatchctx->conv_bufsiz = conv_bufsiz;\n\t\tmatchctx->wide_str = wide_str;\n\t}\n\telse\n\t{\n\t\t/* No need to keep the wide string if we're in a single-byte charset. */\n\t\tpfree(wide_str);\n\t\tmatchctx->wide_str = NULL;\n\t\tmatchctx->conv_buf = NULL;\n\t\tmatchctx->conv_bufsiz = 0;\n\t}\n\n\t/* Clean up temp storage */\n\tpfree(pmatch);\n\n\treturn matchctx;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static regexp_matches_ctx *setup_regexp_matches(text *orig_str, text *pattern,\n\t\t\t\t\t pg_re_flags *flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched);",
      "static ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "pmatch"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "conv_bufsiz"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "matchctx->match_locs",
            "sizeof(int) * array_len"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"too many regular expression matches\"))"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"too many regular expression matches\""
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RE_wchar_execute",
          "args": [
            "cpattern",
            "wide_str",
            "wide_len",
            "start_search",
            "pmatch_len",
            "pmatch"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "RE_wchar_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "265-293",
          "snippet": "static bool\nRE_wchar_execute(regex_t *re, pg_wchar *data, int data_len,\n\t\t\t\t int start_search, int nmatch, regmatch_t *pmatch)\n{\n\tint\t\t\tregexec_result;\n\tchar\t\terrMsg[100];\n\n\t/* Perform RE match and return result */\n\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\tstart_search,\n\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\tnmatch,\n\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t0);\n\n\tif (regexec_result != REG_OKAY && regexec_result != REG_NOMATCH)\n\t{\n\t\t/* re failed??? */\n\t\tCHECK_FOR_INTERRUPTS();\n\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t}\n\n\treturn (regexec_result == REG_OKAY);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_wchar_execute(regex_t *re, pg_wchar *data, int data_len,\n\t\t\t\t int start_search, int nmatch, regmatch_t *pmatch)\n{\n\tint\t\t\tregexec_result;\n\tchar\t\terrMsg[100];\n\n\t/* Perform RE match and return result */\n\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\tstart_search,\n\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\tnmatch,\n\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t0);\n\n\tif (regexec_result != REG_OKAY && regexec_result != REG_NOMATCH)\n\t{\n\t\t/* re failed??? */\n\t\tCHECK_FOR_INTERRUPTS();\n\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t}\n\n\treturn (regexec_result == REG_OKAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RE_compile_and_cache",
          "args": [
            "pattern",
            "re_flags->cflags",
            "collation"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "136-249",
          "snippet": "static regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CACHED_RES\t32"
          ],
          "globals_used": [
            "static int\tnum_res = 0;",
            "static cached_re_str re_array[MAX_CACHED_RES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MAX_CACHED_RES\t32\n\nstatic int\tnum_res = 0;\nstatic cached_re_str re_array[MAX_CACHED_RES];\n\nstatic regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mb2wchar_with_len",
          "args": [
            "VARDATA_ANY(orig_str)",
            "wide_str",
            "orig_len"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mb2wchar_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "722-726",
          "snippet": "int\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "orig_str"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "orig_str"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(regexp_matches_ctx)"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic regexp_matches_ctx *setup_regexp_matches(text *orig_str, text *pattern,\n\t\t\t\t\t pg_re_flags *flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched);\nstatic ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);\n\nstatic regexp_matches_ctx *\nsetup_regexp_matches(text *orig_str, text *pattern, pg_re_flags *re_flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched)\n{\n\tregexp_matches_ctx *matchctx = palloc0(sizeof(regexp_matches_ctx));\n\tint\t\t\teml = pg_database_encoding_max_length();\n\tint\t\t\torig_len;\n\tpg_wchar   *wide_str;\n\tint\t\t\twide_len;\n\tregex_t    *cpattern;\n\tregmatch_t *pmatch;\n\tint\t\t\tpmatch_len;\n\tint\t\t\tarray_len;\n\tint\t\t\tarray_idx;\n\tint\t\t\tprev_match_end;\n\tint\t\t\tprev_valid_match_end;\n\tint\t\t\tstart_search;\n\tint\t\t\tmaxlen = 0;\t\t/* largest fetch length in characters */\n\n\t/* save original string --- we'll extract result substrings from it */\n\tmatchctx->orig_str = orig_str;\n\n\t/* convert string to pg_wchar form for matching */\n\torig_len = VARSIZE_ANY_EXHDR(orig_str);\n\twide_str = (pg_wchar *) palloc(sizeof(pg_wchar) * (orig_len + 1));\n\twide_len = pg_mb2wchar_with_len(VARDATA_ANY(orig_str), wide_str, orig_len);\n\n\t/* set up the compiled pattern */\n\tcpattern = RE_compile_and_cache(pattern, re_flags->cflags, collation);\n\n\t/* do we want to remember subpatterns? */\n\tif (use_subpatterns && cpattern->re_nsub > 0)\n\t{\n\t\tmatchctx->npatterns = cpattern->re_nsub;\n\t\tpmatch_len = cpattern->re_nsub + 1;\n\t}\n\telse\n\t{\n\t\tuse_subpatterns = false;\n\t\tmatchctx->npatterns = 1;\n\t\tpmatch_len = 1;\n\t}\n\n\t/* temporary output space for RE package */\n\tpmatch = palloc(sizeof(regmatch_t) * pmatch_len);\n\n\t/*\n\t * the real output space (grown dynamically if needed)\n\t *\n\t * use values 2^n-1, not 2^n, so that we hit the limit at 2^28-1 rather\n\t * than at 2^27\n\t */\n\tarray_len = re_flags->glob ? 255 : 31;\n\tmatchctx->match_locs = (int *) palloc(sizeof(int) * array_len);\n\tarray_idx = 0;\n\n\t/* search for the pattern, perhaps repeatedly */\n\tprev_match_end = 0;\n\tprev_valid_match_end = 0;\n\tstart_search = 0;\n\twhile (RE_wchar_execute(cpattern, wide_str, wide_len, start_search,\n\t\t\t\t\t\t\tpmatch_len, pmatch))\n\t{\n\t\t/*\n\t\t * If requested, ignore degenerate matches, which are zero-length\n\t\t * matches occurring at the start or end of a string or just after a\n\t\t * previous match.\n\t\t */\n\t\tif (!ignore_degenerate ||\n\t\t\t(pmatch[0].rm_so < wide_len &&\n\t\t\t pmatch[0].rm_eo > prev_match_end))\n\t\t{\n\t\t\t/* enlarge output space if needed */\n\t\t\twhile (array_idx + matchctx->npatterns * 2 + 1 > array_len)\n\t\t\t{\n\t\t\t\tarray_len += array_len + 1;\t\t/* 2^n-1 => 2^(n+1)-1 */\n\t\t\t\tif (array_len > MaxAllocSize/sizeof(int))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"too many regular expression matches\")));\n\t\t\t\tmatchctx->match_locs = (int *) repalloc(matchctx->match_locs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int) * array_len);\n\t\t\t}\n\n\t\t\t/* save this match's locations */\n\t\t\tif (use_subpatterns)\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tfor (i = 1; i <= matchctx->npatterns; i++)\n\t\t\t\t{\n\t\t\t\t\tint\t\tso = pmatch[i].rm_so;\n\t\t\t\t\tint\t\teo = pmatch[i].rm_eo;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\tso = pmatch[0].rm_so;\n\t\t\t\tint\t\teo = pmatch[0].rm_eo;\n\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t}\n\t\t\tmatchctx->nmatches++;\n\n\t\t\t/*\n\t\t\t * check length of unmatched portion between end of previous valid\n\t\t\t * (nondegenerate, or degenerate but not ignored) match and start\n\t\t\t * of current one\n\t\t\t */\n\t\t\tif (fetching_unmatched &&\n\t\t\t\tpmatch[0].rm_so >= 0 &&\n\t\t\t\t(pmatch[0].rm_so - prev_valid_match_end) > maxlen)\n\t\t\t\tmaxlen = (pmatch[0].rm_so - prev_valid_match_end);\n\t\t\tprev_valid_match_end = pmatch[0].rm_eo;\n\t\t}\n\t\tprev_match_end = pmatch[0].rm_eo;\n\n\t\t/* if not glob, stop after one match */\n\t\tif (!re_flags->glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tstart_search = prev_match_end;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tstart_search++;\n\t\tif (start_search > wide_len)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check length of unmatched portion between end of last match and end of\n\t * input string\n\t */\n\tif (fetching_unmatched &&\n\t\t(wide_len - prev_valid_match_end) > maxlen)\n\t\tmaxlen = (wide_len - prev_valid_match_end);\n\n\t/*\n\t * Keep a note of the end position of the string for the benefit of\n\t * splitting code.\n\t */\n\tmatchctx->match_locs[array_idx] = wide_len;\n\n\tif (eml > 1)\n\t{\n\t\tint64\t\tmaxsiz = eml * (int64) maxlen;\n\t\tint\t\t\tconv_bufsiz;\n\n\t\t/*\n\t\t * Make the conversion buffer large enough for any substring of\n\t\t * interest.\n\t\t *\n\t\t * Worst case: assume we need the maximum size (maxlen*eml), but take\n\t\t * advantage of the fact that the original string length in bytes is an\n\t\t * upper bound on the byte length of any fetched substring (and we know\n\t\t * that len+1 is safe to allocate because the varlena header is longer\n\t\t * than 1 byte).\n\t\t */\n\t\tif (maxsiz > orig_len)\n\t\t\tconv_bufsiz = orig_len + 1;\n\t\telse\n\t\t\tconv_bufsiz = maxsiz + 1;\t/* safe since maxsiz < 2^30 */\n\n\t\tmatchctx->conv_buf = palloc(conv_bufsiz);\n\t\tmatchctx->conv_bufsiz = conv_bufsiz;\n\t\tmatchctx->wide_str = wide_str;\n\t}\n\telse\n\t{\n\t\t/* No need to keep the wide string if we're in a single-byte charset. */\n\t\tpfree(wide_str);\n\t\tmatchctx->wide_str = NULL;\n\t\tmatchctx->conv_buf = NULL;\n\t\tmatchctx->conv_bufsiz = 0;\n\t}\n\n\t/* Clean up temp storage */\n\tpfree(pmatch);\n\n\treturn matchctx;\n}"
  },
  {
    "function_name": "regexp_matches_no_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "944-948",
    "snippet": "Datum\nregexp_matches_no_flags(PG_FUNCTION_ARGS)\n{\n\treturn regexp_matches(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "regexp_matches",
          "args": [
            "fcinfo"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "regexp_matches_no_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "944-948",
          "snippet": "Datum\nregexp_matches_no_flags(PG_FUNCTION_ARGS)\n{\n\treturn regexp_matches(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\nregexp_matches_no_flags(PG_FUNCTION_ARGS)\n{\n\treturn regexp_matches(fcinfo);\n}"
  },
  {
    "function_name": "regexp_matches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "895-941",
    "snippet": "Datum\nregexp_matches(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tregexp_matches_ctx *matchctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\ttext\t   *pattern = PG_GETARG_TEXT_PP(1);\n\t\ttext\t   *flags = PG_GETARG_TEXT_PP_IF_EXISTS(2);\n\t\tpg_re_flags re_flags;\n\t\tMemoryContext oldcontext;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* Determine options */\n\t\tparse_re_flags(&re_flags, flags);\n\n\t\t/* be sure to copy the input string into the multi-call ctx */\n\t\tmatchctx = setup_regexp_matches(PG_GETARG_TEXT_P_COPY(0), pattern,\n\t\t\t\t\t\t\t\t\t\t&re_flags,\n\t\t\t\t\t\t\t\t\t\tPG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\ttrue, false, false);\n\n\t\t/* Pre-create workspace that build_regexp_match_result needs */\n\t\tmatchctx->elems = (Datum *) palloc(sizeof(Datum) * matchctx->npatterns);\n\t\tmatchctx->nulls = (bool *) palloc(sizeof(bool) * matchctx->npatterns);\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tfuncctx->user_fctx = (void *) matchctx;\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tmatchctx = (regexp_matches_ctx *) funcctx->user_fctx;\n\n\tif (matchctx->next_match < matchctx->nmatches)\n\t{\n\t\tArrayType  *result_ary;\n\n\t\tresult_ary = build_regexp_match_result(matchctx);\n\t\tmatchctx->next_match++;\n\t\tSRF_RETURN_NEXT(funcctx, PointerGetDatum(result_ary));\n\t}\n\n\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "PointerGetDatum(result_ary)"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "result_ary"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_regexp_match_result",
          "args": [
            "matchctx"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "build_regexp_match_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "1166-1215",
          "snippet": "static ArrayType *\nbuild_regexp_match_result(regexp_matches_ctx *matchctx)\n{\n\tchar\t   *buf = matchctx->conv_buf;\n\tint\t\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = matchctx->conv_bufsiz;\n\tDatum\t   *elems = matchctx->elems;\n\tbool\t   *nulls = matchctx->nulls;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\tint\t\t\tloc;\n\tint\t\t\ti;\n\n\t/* Extract matching substrings from the original string */\n\tloc = matchctx->next_match * matchctx->npatterns * 2;\n\tfor (i = 0; i < matchctx->npatterns; i++)\n\t{\n\t\tint\t\t\tso = matchctx->match_locs[loc++];\n\t\tint\t\t\teo = matchctx->match_locs[loc++];\n\n\t\tif (so < 0 || eo < 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse if (buf)\n\t\t{\n\t\t\tint\t\tlen = pg_wchar2mb_with_len(matchctx->wide_str + so,\n\t\t\t\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t\t\t\t   eo - so);\n\t\t\tAssert(len < bufsiz);\n\t\t\telems[i] = PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t\t\tnulls[i] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(matchctx->orig_str),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(so + 1),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(eo - so));\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/* And form an array */\n\tdims[0] = matchctx->npatterns;\n\tlbs[0] = 1;\n\t/* XXX: this hardcodes assumptions about the text type */\n\treturn construct_md_array(elems, nulls, 1, dims, lbs,\n\t\t\t\t\t\t\t  TEXTOID, -1, false, 'i');\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);\n\nstatic ArrayType *\nbuild_regexp_match_result(regexp_matches_ctx *matchctx)\n{\n\tchar\t   *buf = matchctx->conv_buf;\n\tint\t\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = matchctx->conv_bufsiz;\n\tDatum\t   *elems = matchctx->elems;\n\tbool\t   *nulls = matchctx->nulls;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\tint\t\t\tloc;\n\tint\t\t\ti;\n\n\t/* Extract matching substrings from the original string */\n\tloc = matchctx->next_match * matchctx->npatterns * 2;\n\tfor (i = 0; i < matchctx->npatterns; i++)\n\t{\n\t\tint\t\t\tso = matchctx->match_locs[loc++];\n\t\tint\t\t\teo = matchctx->match_locs[loc++];\n\n\t\tif (so < 0 || eo < 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse if (buf)\n\t\t{\n\t\t\tint\t\tlen = pg_wchar2mb_with_len(matchctx->wide_str + so,\n\t\t\t\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t\t\t\t   eo - so);\n\t\t\tAssert(len < bufsiz);\n\t\t\telems[i] = PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t\t\tnulls[i] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(matchctx->orig_str),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(so + 1),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(eo - so));\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/* And form an array */\n\tdims[0] = matchctx->npatterns;\n\tlbs[0] = 1;\n\t/* XXX: this hardcodes assumptions about the text type */\n\treturn construct_md_array(elems, nulls, 1, dims, lbs,\n\t\t\t\t\t\t\t  TEXTOID, -1, false, 'i');\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(bool) * matchctx->npatterns"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_regexp_matches",
          "args": [
            "PG_GETARG_TEXT_P_COPY(0)",
            "pattern",
            "&re_flags",
            "PG_GET_COLLATION()",
            "true",
            "false",
            "false"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "setup_regexp_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "967-1161",
          "snippet": "static regexp_matches_ctx *\nsetup_regexp_matches(text *orig_str, text *pattern, pg_re_flags *re_flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched)\n{\n\tregexp_matches_ctx *matchctx = palloc0(sizeof(regexp_matches_ctx));\n\tint\t\t\teml = pg_database_encoding_max_length();\n\tint\t\t\torig_len;\n\tpg_wchar   *wide_str;\n\tint\t\t\twide_len;\n\tregex_t    *cpattern;\n\tregmatch_t *pmatch;\n\tint\t\t\tpmatch_len;\n\tint\t\t\tarray_len;\n\tint\t\t\tarray_idx;\n\tint\t\t\tprev_match_end;\n\tint\t\t\tprev_valid_match_end;\n\tint\t\t\tstart_search;\n\tint\t\t\tmaxlen = 0;\t\t/* largest fetch length in characters */\n\n\t/* save original string --- we'll extract result substrings from it */\n\tmatchctx->orig_str = orig_str;\n\n\t/* convert string to pg_wchar form for matching */\n\torig_len = VARSIZE_ANY_EXHDR(orig_str);\n\twide_str = (pg_wchar *) palloc(sizeof(pg_wchar) * (orig_len + 1));\n\twide_len = pg_mb2wchar_with_len(VARDATA_ANY(orig_str), wide_str, orig_len);\n\n\t/* set up the compiled pattern */\n\tcpattern = RE_compile_and_cache(pattern, re_flags->cflags, collation);\n\n\t/* do we want to remember subpatterns? */\n\tif (use_subpatterns && cpattern->re_nsub > 0)\n\t{\n\t\tmatchctx->npatterns = cpattern->re_nsub;\n\t\tpmatch_len = cpattern->re_nsub + 1;\n\t}\n\telse\n\t{\n\t\tuse_subpatterns = false;\n\t\tmatchctx->npatterns = 1;\n\t\tpmatch_len = 1;\n\t}\n\n\t/* temporary output space for RE package */\n\tpmatch = palloc(sizeof(regmatch_t) * pmatch_len);\n\n\t/*\n\t * the real output space (grown dynamically if needed)\n\t *\n\t * use values 2^n-1, not 2^n, so that we hit the limit at 2^28-1 rather\n\t * than at 2^27\n\t */\n\tarray_len = re_flags->glob ? 255 : 31;\n\tmatchctx->match_locs = (int *) palloc(sizeof(int) * array_len);\n\tarray_idx = 0;\n\n\t/* search for the pattern, perhaps repeatedly */\n\tprev_match_end = 0;\n\tprev_valid_match_end = 0;\n\tstart_search = 0;\n\twhile (RE_wchar_execute(cpattern, wide_str, wide_len, start_search,\n\t\t\t\t\t\t\tpmatch_len, pmatch))\n\t{\n\t\t/*\n\t\t * If requested, ignore degenerate matches, which are zero-length\n\t\t * matches occurring at the start or end of a string or just after a\n\t\t * previous match.\n\t\t */\n\t\tif (!ignore_degenerate ||\n\t\t\t(pmatch[0].rm_so < wide_len &&\n\t\t\t pmatch[0].rm_eo > prev_match_end))\n\t\t{\n\t\t\t/* enlarge output space if needed */\n\t\t\twhile (array_idx + matchctx->npatterns * 2 + 1 > array_len)\n\t\t\t{\n\t\t\t\tarray_len += array_len + 1;\t\t/* 2^n-1 => 2^(n+1)-1 */\n\t\t\t\tif (array_len > MaxAllocSize/sizeof(int))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"too many regular expression matches\")));\n\t\t\t\tmatchctx->match_locs = (int *) repalloc(matchctx->match_locs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int) * array_len);\n\t\t\t}\n\n\t\t\t/* save this match's locations */\n\t\t\tif (use_subpatterns)\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tfor (i = 1; i <= matchctx->npatterns; i++)\n\t\t\t\t{\n\t\t\t\t\tint\t\tso = pmatch[i].rm_so;\n\t\t\t\t\tint\t\teo = pmatch[i].rm_eo;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\tso = pmatch[0].rm_so;\n\t\t\t\tint\t\teo = pmatch[0].rm_eo;\n\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t}\n\t\t\tmatchctx->nmatches++;\n\n\t\t\t/*\n\t\t\t * check length of unmatched portion between end of previous valid\n\t\t\t * (nondegenerate, or degenerate but not ignored) match and start\n\t\t\t * of current one\n\t\t\t */\n\t\t\tif (fetching_unmatched &&\n\t\t\t\tpmatch[0].rm_so >= 0 &&\n\t\t\t\t(pmatch[0].rm_so - prev_valid_match_end) > maxlen)\n\t\t\t\tmaxlen = (pmatch[0].rm_so - prev_valid_match_end);\n\t\t\tprev_valid_match_end = pmatch[0].rm_eo;\n\t\t}\n\t\tprev_match_end = pmatch[0].rm_eo;\n\n\t\t/* if not glob, stop after one match */\n\t\tif (!re_flags->glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tstart_search = prev_match_end;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tstart_search++;\n\t\tif (start_search > wide_len)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check length of unmatched portion between end of last match and end of\n\t * input string\n\t */\n\tif (fetching_unmatched &&\n\t\t(wide_len - prev_valid_match_end) > maxlen)\n\t\tmaxlen = (wide_len - prev_valid_match_end);\n\n\t/*\n\t * Keep a note of the end position of the string for the benefit of\n\t * splitting code.\n\t */\n\tmatchctx->match_locs[array_idx] = wide_len;\n\n\tif (eml > 1)\n\t{\n\t\tint64\t\tmaxsiz = eml * (int64) maxlen;\n\t\tint\t\t\tconv_bufsiz;\n\n\t\t/*\n\t\t * Make the conversion buffer large enough for any substring of\n\t\t * interest.\n\t\t *\n\t\t * Worst case: assume we need the maximum size (maxlen*eml), but take\n\t\t * advantage of the fact that the original string length in bytes is an\n\t\t * upper bound on the byte length of any fetched substring (and we know\n\t\t * that len+1 is safe to allocate because the varlena header is longer\n\t\t * than 1 byte).\n\t\t */\n\t\tif (maxsiz > orig_len)\n\t\t\tconv_bufsiz = orig_len + 1;\n\t\telse\n\t\t\tconv_bufsiz = maxsiz + 1;\t/* safe since maxsiz < 2^30 */\n\n\t\tmatchctx->conv_buf = palloc(conv_bufsiz);\n\t\tmatchctx->conv_bufsiz = conv_bufsiz;\n\t\tmatchctx->wide_str = wide_str;\n\t}\n\telse\n\t{\n\t\t/* No need to keep the wide string if we're in a single-byte charset. */\n\t\tpfree(wide_str);\n\t\tmatchctx->wide_str = NULL;\n\t\tmatchctx->conv_buf = NULL;\n\t\tmatchctx->conv_bufsiz = 0;\n\t}\n\n\t/* Clean up temp storage */\n\tpfree(pmatch);\n\n\treturn matchctx;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static regexp_matches_ctx *setup_regexp_matches(text *orig_str, text *pattern,\n\t\t\t\t\t pg_re_flags *flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched);",
            "static ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic regexp_matches_ctx *setup_regexp_matches(text *orig_str, text *pattern,\n\t\t\t\t\t pg_re_flags *flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched);\nstatic ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);\n\nstatic regexp_matches_ctx *\nsetup_regexp_matches(text *orig_str, text *pattern, pg_re_flags *re_flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched)\n{\n\tregexp_matches_ctx *matchctx = palloc0(sizeof(regexp_matches_ctx));\n\tint\t\t\teml = pg_database_encoding_max_length();\n\tint\t\t\torig_len;\n\tpg_wchar   *wide_str;\n\tint\t\t\twide_len;\n\tregex_t    *cpattern;\n\tregmatch_t *pmatch;\n\tint\t\t\tpmatch_len;\n\tint\t\t\tarray_len;\n\tint\t\t\tarray_idx;\n\tint\t\t\tprev_match_end;\n\tint\t\t\tprev_valid_match_end;\n\tint\t\t\tstart_search;\n\tint\t\t\tmaxlen = 0;\t\t/* largest fetch length in characters */\n\n\t/* save original string --- we'll extract result substrings from it */\n\tmatchctx->orig_str = orig_str;\n\n\t/* convert string to pg_wchar form for matching */\n\torig_len = VARSIZE_ANY_EXHDR(orig_str);\n\twide_str = (pg_wchar *) palloc(sizeof(pg_wchar) * (orig_len + 1));\n\twide_len = pg_mb2wchar_with_len(VARDATA_ANY(orig_str), wide_str, orig_len);\n\n\t/* set up the compiled pattern */\n\tcpattern = RE_compile_and_cache(pattern, re_flags->cflags, collation);\n\n\t/* do we want to remember subpatterns? */\n\tif (use_subpatterns && cpattern->re_nsub > 0)\n\t{\n\t\tmatchctx->npatterns = cpattern->re_nsub;\n\t\tpmatch_len = cpattern->re_nsub + 1;\n\t}\n\telse\n\t{\n\t\tuse_subpatterns = false;\n\t\tmatchctx->npatterns = 1;\n\t\tpmatch_len = 1;\n\t}\n\n\t/* temporary output space for RE package */\n\tpmatch = palloc(sizeof(regmatch_t) * pmatch_len);\n\n\t/*\n\t * the real output space (grown dynamically if needed)\n\t *\n\t * use values 2^n-1, not 2^n, so that we hit the limit at 2^28-1 rather\n\t * than at 2^27\n\t */\n\tarray_len = re_flags->glob ? 255 : 31;\n\tmatchctx->match_locs = (int *) palloc(sizeof(int) * array_len);\n\tarray_idx = 0;\n\n\t/* search for the pattern, perhaps repeatedly */\n\tprev_match_end = 0;\n\tprev_valid_match_end = 0;\n\tstart_search = 0;\n\twhile (RE_wchar_execute(cpattern, wide_str, wide_len, start_search,\n\t\t\t\t\t\t\tpmatch_len, pmatch))\n\t{\n\t\t/*\n\t\t * If requested, ignore degenerate matches, which are zero-length\n\t\t * matches occurring at the start or end of a string or just after a\n\t\t * previous match.\n\t\t */\n\t\tif (!ignore_degenerate ||\n\t\t\t(pmatch[0].rm_so < wide_len &&\n\t\t\t pmatch[0].rm_eo > prev_match_end))\n\t\t{\n\t\t\t/* enlarge output space if needed */\n\t\t\twhile (array_idx + matchctx->npatterns * 2 + 1 > array_len)\n\t\t\t{\n\t\t\t\tarray_len += array_len + 1;\t\t/* 2^n-1 => 2^(n+1)-1 */\n\t\t\t\tif (array_len > MaxAllocSize/sizeof(int))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"too many regular expression matches\")));\n\t\t\t\tmatchctx->match_locs = (int *) repalloc(matchctx->match_locs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int) * array_len);\n\t\t\t}\n\n\t\t\t/* save this match's locations */\n\t\t\tif (use_subpatterns)\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tfor (i = 1; i <= matchctx->npatterns; i++)\n\t\t\t\t{\n\t\t\t\t\tint\t\tso = pmatch[i].rm_so;\n\t\t\t\t\tint\t\teo = pmatch[i].rm_eo;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\tso = pmatch[0].rm_so;\n\t\t\t\tint\t\teo = pmatch[0].rm_eo;\n\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t}\n\t\t\tmatchctx->nmatches++;\n\n\t\t\t/*\n\t\t\t * check length of unmatched portion between end of previous valid\n\t\t\t * (nondegenerate, or degenerate but not ignored) match and start\n\t\t\t * of current one\n\t\t\t */\n\t\t\tif (fetching_unmatched &&\n\t\t\t\tpmatch[0].rm_so >= 0 &&\n\t\t\t\t(pmatch[0].rm_so - prev_valid_match_end) > maxlen)\n\t\t\t\tmaxlen = (pmatch[0].rm_so - prev_valid_match_end);\n\t\t\tprev_valid_match_end = pmatch[0].rm_eo;\n\t\t}\n\t\tprev_match_end = pmatch[0].rm_eo;\n\n\t\t/* if not glob, stop after one match */\n\t\tif (!re_flags->glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tstart_search = prev_match_end;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tstart_search++;\n\t\tif (start_search > wide_len)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check length of unmatched portion between end of last match and end of\n\t * input string\n\t */\n\tif (fetching_unmatched &&\n\t\t(wide_len - prev_valid_match_end) > maxlen)\n\t\tmaxlen = (wide_len - prev_valid_match_end);\n\n\t/*\n\t * Keep a note of the end position of the string for the benefit of\n\t * splitting code.\n\t */\n\tmatchctx->match_locs[array_idx] = wide_len;\n\n\tif (eml > 1)\n\t{\n\t\tint64\t\tmaxsiz = eml * (int64) maxlen;\n\t\tint\t\t\tconv_bufsiz;\n\n\t\t/*\n\t\t * Make the conversion buffer large enough for any substring of\n\t\t * interest.\n\t\t *\n\t\t * Worst case: assume we need the maximum size (maxlen*eml), but take\n\t\t * advantage of the fact that the original string length in bytes is an\n\t\t * upper bound on the byte length of any fetched substring (and we know\n\t\t * that len+1 is safe to allocate because the varlena header is longer\n\t\t * than 1 byte).\n\t\t */\n\t\tif (maxsiz > orig_len)\n\t\t\tconv_bufsiz = orig_len + 1;\n\t\telse\n\t\t\tconv_bufsiz = maxsiz + 1;\t/* safe since maxsiz < 2^30 */\n\n\t\tmatchctx->conv_buf = palloc(conv_bufsiz);\n\t\tmatchctx->conv_bufsiz = conv_bufsiz;\n\t\tmatchctx->wide_str = wide_str;\n\t}\n\telse\n\t{\n\t\t/* No need to keep the wide string if we're in a single-byte charset. */\n\t\tpfree(wide_str);\n\t\tmatchctx->wide_str = NULL;\n\t\tmatchctx->conv_buf = NULL;\n\t\tmatchctx->conv_bufsiz = 0;\n\t}\n\n\t/* Clean up temp storage */\n\tpfree(pmatch);\n\n\treturn matchctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_P_COPY",
          "args": [
            "0"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_re_flags",
          "args": [
            "&re_flags",
            "flags"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "parse_re_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "365-432",
          "snippet": "static void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP_IF_EXISTS",
          "args": [
            "2"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);\n\nDatum\nregexp_matches(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tregexp_matches_ctx *matchctx;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\ttext\t   *pattern = PG_GETARG_TEXT_PP(1);\n\t\ttext\t   *flags = PG_GETARG_TEXT_PP_IF_EXISTS(2);\n\t\tpg_re_flags re_flags;\n\t\tMemoryContext oldcontext;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* Determine options */\n\t\tparse_re_flags(&re_flags, flags);\n\n\t\t/* be sure to copy the input string into the multi-call ctx */\n\t\tmatchctx = setup_regexp_matches(PG_GETARG_TEXT_P_COPY(0), pattern,\n\t\t\t\t\t\t\t\t\t\t&re_flags,\n\t\t\t\t\t\t\t\t\t\tPG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\ttrue, false, false);\n\n\t\t/* Pre-create workspace that build_regexp_match_result needs */\n\t\tmatchctx->elems = (Datum *) palloc(sizeof(Datum) * matchctx->npatterns);\n\t\tmatchctx->nulls = (bool *) palloc(sizeof(bool) * matchctx->npatterns);\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tfuncctx->user_fctx = (void *) matchctx;\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tmatchctx = (regexp_matches_ctx *) funcctx->user_fctx;\n\n\tif (matchctx->next_match < matchctx->nmatches)\n\t{\n\t\tArrayType  *result_ary;\n\n\t\tresult_ary = build_regexp_match_result(matchctx);\n\t\tmatchctx->next_match++;\n\t\tSRF_RETURN_NEXT(funcctx, PointerGetDatum(result_ary));\n\t}\n\n\tSRF_RETURN_DONE(funcctx);\n}"
  },
  {
    "function_name": "regexp_match_no_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "885-889",
    "snippet": "Datum\nregexp_match_no_flags(PG_FUNCTION_ARGS)\n{\n\treturn regexp_match(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "regexp_match",
          "args": [
            "fcinfo"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "build_regexp_match_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "1166-1215",
          "snippet": "static ArrayType *\nbuild_regexp_match_result(regexp_matches_ctx *matchctx)\n{\n\tchar\t   *buf = matchctx->conv_buf;\n\tint\t\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = matchctx->conv_bufsiz;\n\tDatum\t   *elems = matchctx->elems;\n\tbool\t   *nulls = matchctx->nulls;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\tint\t\t\tloc;\n\tint\t\t\ti;\n\n\t/* Extract matching substrings from the original string */\n\tloc = matchctx->next_match * matchctx->npatterns * 2;\n\tfor (i = 0; i < matchctx->npatterns; i++)\n\t{\n\t\tint\t\t\tso = matchctx->match_locs[loc++];\n\t\tint\t\t\teo = matchctx->match_locs[loc++];\n\n\t\tif (so < 0 || eo < 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse if (buf)\n\t\t{\n\t\t\tint\t\tlen = pg_wchar2mb_with_len(matchctx->wide_str + so,\n\t\t\t\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t\t\t\t   eo - so);\n\t\t\tAssert(len < bufsiz);\n\t\t\telems[i] = PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t\t\tnulls[i] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(matchctx->orig_str),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(so + 1),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(eo - so));\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/* And form an array */\n\tdims[0] = matchctx->npatterns;\n\tlbs[0] = 1;\n\t/* XXX: this hardcodes assumptions about the text type */\n\treturn construct_md_array(elems, nulls, 1, dims, lbs,\n\t\t\t\t\t\t\t  TEXTOID, -1, false, 'i');\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);\n\nstatic ArrayType *\nbuild_regexp_match_result(regexp_matches_ctx *matchctx)\n{\n\tchar\t   *buf = matchctx->conv_buf;\n\tint\t\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = matchctx->conv_bufsiz;\n\tDatum\t   *elems = matchctx->elems;\n\tbool\t   *nulls = matchctx->nulls;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\tint\t\t\tloc;\n\tint\t\t\ti;\n\n\t/* Extract matching substrings from the original string */\n\tloc = matchctx->next_match * matchctx->npatterns * 2;\n\tfor (i = 0; i < matchctx->npatterns; i++)\n\t{\n\t\tint\t\t\tso = matchctx->match_locs[loc++];\n\t\tint\t\t\teo = matchctx->match_locs[loc++];\n\n\t\tif (so < 0 || eo < 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse if (buf)\n\t\t{\n\t\t\tint\t\tlen = pg_wchar2mb_with_len(matchctx->wide_str + so,\n\t\t\t\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t\t\t\t   eo - so);\n\t\t\tAssert(len < bufsiz);\n\t\t\telems[i] = PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t\t\tnulls[i] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(matchctx->orig_str),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(so + 1),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(eo - so));\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/* And form an array */\n\tdims[0] = matchctx->npatterns;\n\tlbs[0] = 1;\n\t/* XXX: this hardcodes assumptions about the text type */\n\treturn construct_md_array(elems, nulls, 1, dims, lbs,\n\t\t\t\t\t\t\t  TEXTOID, -1, false, 'i');\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\nregexp_match_no_flags(PG_FUNCTION_ARGS)\n{\n\treturn regexp_match(fcinfo);\n}"
  },
  {
    "function_name": "regexp_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "851-882",
    "snippet": "Datum\nregexp_match(PG_FUNCTION_ARGS)\n{\n\ttext\t   *orig_str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *pattern = PG_GETARG_TEXT_PP(1);\n\ttext\t   *flags = PG_GETARG_TEXT_PP_IF_EXISTS(2);\n\tpg_re_flags re_flags;\n\tregexp_matches_ctx *matchctx;\n\n\t/* Determine options */\n\tparse_re_flags(&re_flags, flags);\n\t/* User mustn't specify 'g' */\n\tif (re_flags.glob)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"regexp_match does not support the global option\"),\n\t\t\t\t errhint(\"Use the regexp_matches function instead.\")));\n\n\tmatchctx = setup_regexp_matches(orig_str, pattern, &re_flags,\n\t\t\t\t\t\t\t\t\tPG_GET_COLLATION(), true, false, false);\n\n\tif (matchctx->nmatches == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(matchctx->nmatches == 1);\n\n\t/* Create workspace that build_regexp_match_result needs */\n\tmatchctx->elems = (Datum *) palloc(sizeof(Datum) * matchctx->npatterns);\n\tmatchctx->nulls = (bool *) palloc(sizeof(bool) * matchctx->npatterns);\n\n\tPG_RETURN_DATUM(PointerGetDatum(build_regexp_match_result(matchctx)));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "PointerGetDatum(build_regexp_match_result(matchctx))"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "build_regexp_match_result(matchctx)"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_regexp_match_result",
          "args": [
            "matchctx"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "build_regexp_match_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "1166-1215",
          "snippet": "static ArrayType *\nbuild_regexp_match_result(regexp_matches_ctx *matchctx)\n{\n\tchar\t   *buf = matchctx->conv_buf;\n\tint\t\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = matchctx->conv_bufsiz;\n\tDatum\t   *elems = matchctx->elems;\n\tbool\t   *nulls = matchctx->nulls;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\tint\t\t\tloc;\n\tint\t\t\ti;\n\n\t/* Extract matching substrings from the original string */\n\tloc = matchctx->next_match * matchctx->npatterns * 2;\n\tfor (i = 0; i < matchctx->npatterns; i++)\n\t{\n\t\tint\t\t\tso = matchctx->match_locs[loc++];\n\t\tint\t\t\teo = matchctx->match_locs[loc++];\n\n\t\tif (so < 0 || eo < 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse if (buf)\n\t\t{\n\t\t\tint\t\tlen = pg_wchar2mb_with_len(matchctx->wide_str + so,\n\t\t\t\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t\t\t\t   eo - so);\n\t\t\tAssert(len < bufsiz);\n\t\t\telems[i] = PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t\t\tnulls[i] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(matchctx->orig_str),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(so + 1),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(eo - so));\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/* And form an array */\n\tdims[0] = matchctx->npatterns;\n\tlbs[0] = 1;\n\t/* XXX: this hardcodes assumptions about the text type */\n\treturn construct_md_array(elems, nulls, 1, dims, lbs,\n\t\t\t\t\t\t\t  TEXTOID, -1, false, 'i');\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);\n\nstatic ArrayType *\nbuild_regexp_match_result(regexp_matches_ctx *matchctx)\n{\n\tchar\t   *buf = matchctx->conv_buf;\n\tint\t\t\tbufsiz PG_USED_FOR_ASSERTS_ONLY = matchctx->conv_bufsiz;\n\tDatum\t   *elems = matchctx->elems;\n\tbool\t   *nulls = matchctx->nulls;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\tint\t\t\tloc;\n\tint\t\t\ti;\n\n\t/* Extract matching substrings from the original string */\n\tloc = matchctx->next_match * matchctx->npatterns * 2;\n\tfor (i = 0; i < matchctx->npatterns; i++)\n\t{\n\t\tint\t\t\tso = matchctx->match_locs[loc++];\n\t\tint\t\t\teo = matchctx->match_locs[loc++];\n\n\t\tif (so < 0 || eo < 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse if (buf)\n\t\t{\n\t\t\tint\t\tlen = pg_wchar2mb_with_len(matchctx->wide_str + so,\n\t\t\t\t\t\t\t\t\t\t\t   buf,\n\t\t\t\t\t\t\t\t\t\t\t   eo - so);\n\t\t\tAssert(len < bufsiz);\n\t\t\telems[i] = PointerGetDatum(cstring_to_text_with_len(buf, len));\n\t\t\tnulls[i] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(matchctx->orig_str),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(so + 1),\n\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(eo - so));\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/* And form an array */\n\tdims[0] = matchctx->npatterns;\n\tlbs[0] = 1;\n\t/* XXX: this hardcodes assumptions about the text type */\n\treturn construct_md_array(elems, nulls, 1, dims, lbs,\n\t\t\t\t\t\t\t  TEXTOID, -1, false, 'i');\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(bool) * matchctx->npatterns"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "matchctx->nmatches == 1"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_regexp_matches",
          "args": [
            "orig_str",
            "pattern",
            "&re_flags",
            "PG_GET_COLLATION()",
            "true",
            "false",
            "false"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "setup_regexp_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "967-1161",
          "snippet": "static regexp_matches_ctx *\nsetup_regexp_matches(text *orig_str, text *pattern, pg_re_flags *re_flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched)\n{\n\tregexp_matches_ctx *matchctx = palloc0(sizeof(regexp_matches_ctx));\n\tint\t\t\teml = pg_database_encoding_max_length();\n\tint\t\t\torig_len;\n\tpg_wchar   *wide_str;\n\tint\t\t\twide_len;\n\tregex_t    *cpattern;\n\tregmatch_t *pmatch;\n\tint\t\t\tpmatch_len;\n\tint\t\t\tarray_len;\n\tint\t\t\tarray_idx;\n\tint\t\t\tprev_match_end;\n\tint\t\t\tprev_valid_match_end;\n\tint\t\t\tstart_search;\n\tint\t\t\tmaxlen = 0;\t\t/* largest fetch length in characters */\n\n\t/* save original string --- we'll extract result substrings from it */\n\tmatchctx->orig_str = orig_str;\n\n\t/* convert string to pg_wchar form for matching */\n\torig_len = VARSIZE_ANY_EXHDR(orig_str);\n\twide_str = (pg_wchar *) palloc(sizeof(pg_wchar) * (orig_len + 1));\n\twide_len = pg_mb2wchar_with_len(VARDATA_ANY(orig_str), wide_str, orig_len);\n\n\t/* set up the compiled pattern */\n\tcpattern = RE_compile_and_cache(pattern, re_flags->cflags, collation);\n\n\t/* do we want to remember subpatterns? */\n\tif (use_subpatterns && cpattern->re_nsub > 0)\n\t{\n\t\tmatchctx->npatterns = cpattern->re_nsub;\n\t\tpmatch_len = cpattern->re_nsub + 1;\n\t}\n\telse\n\t{\n\t\tuse_subpatterns = false;\n\t\tmatchctx->npatterns = 1;\n\t\tpmatch_len = 1;\n\t}\n\n\t/* temporary output space for RE package */\n\tpmatch = palloc(sizeof(regmatch_t) * pmatch_len);\n\n\t/*\n\t * the real output space (grown dynamically if needed)\n\t *\n\t * use values 2^n-1, not 2^n, so that we hit the limit at 2^28-1 rather\n\t * than at 2^27\n\t */\n\tarray_len = re_flags->glob ? 255 : 31;\n\tmatchctx->match_locs = (int *) palloc(sizeof(int) * array_len);\n\tarray_idx = 0;\n\n\t/* search for the pattern, perhaps repeatedly */\n\tprev_match_end = 0;\n\tprev_valid_match_end = 0;\n\tstart_search = 0;\n\twhile (RE_wchar_execute(cpattern, wide_str, wide_len, start_search,\n\t\t\t\t\t\t\tpmatch_len, pmatch))\n\t{\n\t\t/*\n\t\t * If requested, ignore degenerate matches, which are zero-length\n\t\t * matches occurring at the start or end of a string or just after a\n\t\t * previous match.\n\t\t */\n\t\tif (!ignore_degenerate ||\n\t\t\t(pmatch[0].rm_so < wide_len &&\n\t\t\t pmatch[0].rm_eo > prev_match_end))\n\t\t{\n\t\t\t/* enlarge output space if needed */\n\t\t\twhile (array_idx + matchctx->npatterns * 2 + 1 > array_len)\n\t\t\t{\n\t\t\t\tarray_len += array_len + 1;\t\t/* 2^n-1 => 2^(n+1)-1 */\n\t\t\t\tif (array_len > MaxAllocSize/sizeof(int))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"too many regular expression matches\")));\n\t\t\t\tmatchctx->match_locs = (int *) repalloc(matchctx->match_locs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int) * array_len);\n\t\t\t}\n\n\t\t\t/* save this match's locations */\n\t\t\tif (use_subpatterns)\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tfor (i = 1; i <= matchctx->npatterns; i++)\n\t\t\t\t{\n\t\t\t\t\tint\t\tso = pmatch[i].rm_so;\n\t\t\t\t\tint\t\teo = pmatch[i].rm_eo;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\tso = pmatch[0].rm_so;\n\t\t\t\tint\t\teo = pmatch[0].rm_eo;\n\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t}\n\t\t\tmatchctx->nmatches++;\n\n\t\t\t/*\n\t\t\t * check length of unmatched portion between end of previous valid\n\t\t\t * (nondegenerate, or degenerate but not ignored) match and start\n\t\t\t * of current one\n\t\t\t */\n\t\t\tif (fetching_unmatched &&\n\t\t\t\tpmatch[0].rm_so >= 0 &&\n\t\t\t\t(pmatch[0].rm_so - prev_valid_match_end) > maxlen)\n\t\t\t\tmaxlen = (pmatch[0].rm_so - prev_valid_match_end);\n\t\t\tprev_valid_match_end = pmatch[0].rm_eo;\n\t\t}\n\t\tprev_match_end = pmatch[0].rm_eo;\n\n\t\t/* if not glob, stop after one match */\n\t\tif (!re_flags->glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tstart_search = prev_match_end;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tstart_search++;\n\t\tif (start_search > wide_len)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check length of unmatched portion between end of last match and end of\n\t * input string\n\t */\n\tif (fetching_unmatched &&\n\t\t(wide_len - prev_valid_match_end) > maxlen)\n\t\tmaxlen = (wide_len - prev_valid_match_end);\n\n\t/*\n\t * Keep a note of the end position of the string for the benefit of\n\t * splitting code.\n\t */\n\tmatchctx->match_locs[array_idx] = wide_len;\n\n\tif (eml > 1)\n\t{\n\t\tint64\t\tmaxsiz = eml * (int64) maxlen;\n\t\tint\t\t\tconv_bufsiz;\n\n\t\t/*\n\t\t * Make the conversion buffer large enough for any substring of\n\t\t * interest.\n\t\t *\n\t\t * Worst case: assume we need the maximum size (maxlen*eml), but take\n\t\t * advantage of the fact that the original string length in bytes is an\n\t\t * upper bound on the byte length of any fetched substring (and we know\n\t\t * that len+1 is safe to allocate because the varlena header is longer\n\t\t * than 1 byte).\n\t\t */\n\t\tif (maxsiz > orig_len)\n\t\t\tconv_bufsiz = orig_len + 1;\n\t\telse\n\t\t\tconv_bufsiz = maxsiz + 1;\t/* safe since maxsiz < 2^30 */\n\n\t\tmatchctx->conv_buf = palloc(conv_bufsiz);\n\t\tmatchctx->conv_bufsiz = conv_bufsiz;\n\t\tmatchctx->wide_str = wide_str;\n\t}\n\telse\n\t{\n\t\t/* No need to keep the wide string if we're in a single-byte charset. */\n\t\tpfree(wide_str);\n\t\tmatchctx->wide_str = NULL;\n\t\tmatchctx->conv_buf = NULL;\n\t\tmatchctx->conv_bufsiz = 0;\n\t}\n\n\t/* Clean up temp storage */\n\tpfree(pmatch);\n\n\treturn matchctx;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static regexp_matches_ctx *setup_regexp_matches(text *orig_str, text *pattern,\n\t\t\t\t\t pg_re_flags *flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched);",
            "static ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic regexp_matches_ctx *setup_regexp_matches(text *orig_str, text *pattern,\n\t\t\t\t\t pg_re_flags *flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched);\nstatic ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);\n\nstatic regexp_matches_ctx *\nsetup_regexp_matches(text *orig_str, text *pattern, pg_re_flags *re_flags,\n\t\t\t\t\t Oid collation,\n\t\t\t\t\t bool use_subpatterns,\n\t\t\t\t\t bool ignore_degenerate,\n\t\t\t\t\t bool fetching_unmatched)\n{\n\tregexp_matches_ctx *matchctx = palloc0(sizeof(regexp_matches_ctx));\n\tint\t\t\teml = pg_database_encoding_max_length();\n\tint\t\t\torig_len;\n\tpg_wchar   *wide_str;\n\tint\t\t\twide_len;\n\tregex_t    *cpattern;\n\tregmatch_t *pmatch;\n\tint\t\t\tpmatch_len;\n\tint\t\t\tarray_len;\n\tint\t\t\tarray_idx;\n\tint\t\t\tprev_match_end;\n\tint\t\t\tprev_valid_match_end;\n\tint\t\t\tstart_search;\n\tint\t\t\tmaxlen = 0;\t\t/* largest fetch length in characters */\n\n\t/* save original string --- we'll extract result substrings from it */\n\tmatchctx->orig_str = orig_str;\n\n\t/* convert string to pg_wchar form for matching */\n\torig_len = VARSIZE_ANY_EXHDR(orig_str);\n\twide_str = (pg_wchar *) palloc(sizeof(pg_wchar) * (orig_len + 1));\n\twide_len = pg_mb2wchar_with_len(VARDATA_ANY(orig_str), wide_str, orig_len);\n\n\t/* set up the compiled pattern */\n\tcpattern = RE_compile_and_cache(pattern, re_flags->cflags, collation);\n\n\t/* do we want to remember subpatterns? */\n\tif (use_subpatterns && cpattern->re_nsub > 0)\n\t{\n\t\tmatchctx->npatterns = cpattern->re_nsub;\n\t\tpmatch_len = cpattern->re_nsub + 1;\n\t}\n\telse\n\t{\n\t\tuse_subpatterns = false;\n\t\tmatchctx->npatterns = 1;\n\t\tpmatch_len = 1;\n\t}\n\n\t/* temporary output space for RE package */\n\tpmatch = palloc(sizeof(regmatch_t) * pmatch_len);\n\n\t/*\n\t * the real output space (grown dynamically if needed)\n\t *\n\t * use values 2^n-1, not 2^n, so that we hit the limit at 2^28-1 rather\n\t * than at 2^27\n\t */\n\tarray_len = re_flags->glob ? 255 : 31;\n\tmatchctx->match_locs = (int *) palloc(sizeof(int) * array_len);\n\tarray_idx = 0;\n\n\t/* search for the pattern, perhaps repeatedly */\n\tprev_match_end = 0;\n\tprev_valid_match_end = 0;\n\tstart_search = 0;\n\twhile (RE_wchar_execute(cpattern, wide_str, wide_len, start_search,\n\t\t\t\t\t\t\tpmatch_len, pmatch))\n\t{\n\t\t/*\n\t\t * If requested, ignore degenerate matches, which are zero-length\n\t\t * matches occurring at the start or end of a string or just after a\n\t\t * previous match.\n\t\t */\n\t\tif (!ignore_degenerate ||\n\t\t\t(pmatch[0].rm_so < wide_len &&\n\t\t\t pmatch[0].rm_eo > prev_match_end))\n\t\t{\n\t\t\t/* enlarge output space if needed */\n\t\t\twhile (array_idx + matchctx->npatterns * 2 + 1 > array_len)\n\t\t\t{\n\t\t\t\tarray_len += array_len + 1;\t\t/* 2^n-1 => 2^(n+1)-1 */\n\t\t\t\tif (array_len > MaxAllocSize/sizeof(int))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"too many regular expression matches\")));\n\t\t\t\tmatchctx->match_locs = (int *) repalloc(matchctx->match_locs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int) * array_len);\n\t\t\t}\n\n\t\t\t/* save this match's locations */\n\t\t\tif (use_subpatterns)\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tfor (i = 1; i <= matchctx->npatterns; i++)\n\t\t\t\t{\n\t\t\t\t\tint\t\tso = pmatch[i].rm_so;\n\t\t\t\t\tint\t\teo = pmatch[i].rm_eo;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\tso = pmatch[0].rm_so;\n\t\t\t\tint\t\teo = pmatch[0].rm_eo;\n\t\t\t\tmatchctx->match_locs[array_idx++] = so;\n\t\t\t\tmatchctx->match_locs[array_idx++] = eo;\n\t\t\t\tif (so >= 0 && eo >= 0 && (eo - so) > maxlen)\n\t\t\t\t\tmaxlen = (eo - so);\n\t\t\t}\n\t\t\tmatchctx->nmatches++;\n\n\t\t\t/*\n\t\t\t * check length of unmatched portion between end of previous valid\n\t\t\t * (nondegenerate, or degenerate but not ignored) match and start\n\t\t\t * of current one\n\t\t\t */\n\t\t\tif (fetching_unmatched &&\n\t\t\t\tpmatch[0].rm_so >= 0 &&\n\t\t\t\t(pmatch[0].rm_so - prev_valid_match_end) > maxlen)\n\t\t\t\tmaxlen = (pmatch[0].rm_so - prev_valid_match_end);\n\t\t\tprev_valid_match_end = pmatch[0].rm_eo;\n\t\t}\n\t\tprev_match_end = pmatch[0].rm_eo;\n\n\t\t/* if not glob, stop after one match */\n\t\tif (!re_flags->glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tstart_search = prev_match_end;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tstart_search++;\n\t\tif (start_search > wide_len)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check length of unmatched portion between end of last match and end of\n\t * input string\n\t */\n\tif (fetching_unmatched &&\n\t\t(wide_len - prev_valid_match_end) > maxlen)\n\t\tmaxlen = (wide_len - prev_valid_match_end);\n\n\t/*\n\t * Keep a note of the end position of the string for the benefit of\n\t * splitting code.\n\t */\n\tmatchctx->match_locs[array_idx] = wide_len;\n\n\tif (eml > 1)\n\t{\n\t\tint64\t\tmaxsiz = eml * (int64) maxlen;\n\t\tint\t\t\tconv_bufsiz;\n\n\t\t/*\n\t\t * Make the conversion buffer large enough for any substring of\n\t\t * interest.\n\t\t *\n\t\t * Worst case: assume we need the maximum size (maxlen*eml), but take\n\t\t * advantage of the fact that the original string length in bytes is an\n\t\t * upper bound on the byte length of any fetched substring (and we know\n\t\t * that len+1 is safe to allocate because the varlena header is longer\n\t\t * than 1 byte).\n\t\t */\n\t\tif (maxsiz > orig_len)\n\t\t\tconv_bufsiz = orig_len + 1;\n\t\telse\n\t\t\tconv_bufsiz = maxsiz + 1;\t/* safe since maxsiz < 2^30 */\n\n\t\tmatchctx->conv_buf = palloc(conv_bufsiz);\n\t\tmatchctx->conv_bufsiz = conv_bufsiz;\n\t\tmatchctx->wide_str = wide_str;\n\t}\n\telse\n\t{\n\t\t/* No need to keep the wide string if we're in a single-byte charset. */\n\t\tpfree(wide_str);\n\t\tmatchctx->wide_str = NULL;\n\t\tmatchctx->conv_buf = NULL;\n\t\tmatchctx->conv_bufsiz = 0;\n\t}\n\n\t/* Clean up temp storage */\n\tpfree(pmatch);\n\n\treturn matchctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"regexp_match does not support the global option\"),\n\t\t\t\t errhint(\"Use the regexp_matches function instead.\"))"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Use the regexp_matches function instead.\""
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"regexp_match does not support the global option\""
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_re_flags",
          "args": [
            "&re_flags",
            "flags"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "parse_re_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "365-432",
          "snippet": "static void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP_IF_EXISTS",
          "args": [
            "2"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic ArrayType *build_regexp_match_result(regexp_matches_ctx *matchctx);\n\nDatum\nregexp_match(PG_FUNCTION_ARGS)\n{\n\ttext\t   *orig_str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *pattern = PG_GETARG_TEXT_PP(1);\n\ttext\t   *flags = PG_GETARG_TEXT_PP_IF_EXISTS(2);\n\tpg_re_flags re_flags;\n\tregexp_matches_ctx *matchctx;\n\n\t/* Determine options */\n\tparse_re_flags(&re_flags, flags);\n\t/* User mustn't specify 'g' */\n\tif (re_flags.glob)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"regexp_match does not support the global option\"),\n\t\t\t\t errhint(\"Use the regexp_matches function instead.\")));\n\n\tmatchctx = setup_regexp_matches(orig_str, pattern, &re_flags,\n\t\t\t\t\t\t\t\t\tPG_GET_COLLATION(), true, false, false);\n\n\tif (matchctx->nmatches == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(matchctx->nmatches == 1);\n\n\t/* Create workspace that build_regexp_match_result needs */\n\tmatchctx->elems = (Datum *) palloc(sizeof(Datum) * matchctx->npatterns);\n\tmatchctx->nulls = (bool *) palloc(sizeof(bool) * matchctx->npatterns);\n\n\tPG_RETURN_DATUM(PointerGetDatum(build_regexp_match_result(matchctx)));\n}"
  },
  {
    "function_name": "similar_escape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "661-845",
    "snippet": "Datum\nsimilar_escape(PG_FUNCTION_ARGS)\n{\n\ttext\t   *pat_text;\n\ttext\t   *esc_text;\n\ttext\t   *result;\n\tchar\t   *p,\n\t\t\t   *e,\n\t\t\t   *r;\n\tint\t\t\tplen,\n\t\t\t\telen;\n\tbool\t\tafterescape = false;\n\tbool\t\tincharclass = false;\n\tint\t\t\tnquotes = 0;\n\n\t/* This function is not strict, so must test explicitly */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\tpat_text = PG_GETARG_TEXT_PP(0);\n\tp = VARDATA_ANY(pat_text);\n\tplen = VARSIZE_ANY_EXHDR(pat_text);\n\tif (PG_ARGISNULL(1))\n\t{\n\t\t/* No ESCAPE clause provided; default to backslash as escape */\n\t\te = \"\\\\\";\n\t\telen = 1;\n\t}\n\telse\n\t{\n\t\tesc_text = PG_GETARG_TEXT_PP(1);\n\t\te = VARDATA_ANY(esc_text);\n\t\telen = VARSIZE_ANY_EXHDR(esc_text);\n\t\tif (elen == 0)\n\t\t\te = NULL;\t\t\t/* no escape character */\n\t\telse\n\t\t{\n\t\t\tint\t\t\tescape_mblen = pg_mbstrlen_with_len(e, elen);\n\n\t\t\tif (escape_mblen > 1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t\t errmsg(\"invalid escape string\"),\n\t\t\t\t\t\t errhint(\"Escape string must be empty or one character.\")));\n\t\t}\n\t}\n\n\t/*----------\n\t * We surround the transformed input string with\n\t *\t\t\t^(?: ... )$\n\t * which requires some explanation.  We need \"^\" and \"$\" to force\n\t * the pattern to match the entire input string as per SQL99 spec.\n\t * The \"(?:\" and \")\" are a non-capturing set of parens; we have to have\n\t * parens in case the string contains \"|\", else the \"^\" and \"$\" will\n\t * be bound into the first and last alternatives which is not what we\n\t * want, and the parens must be non capturing because we don't want them\n\t * to count when selecting output for SUBSTRING.\n\t *----------\n\t */\n\n\t/*\n\t * We need room for the prefix/postfix plus as many as 3 output bytes per\n\t * input byte; since the input is at most 1GB this can't overflow\n\t */\n\tresult = (text *) palloc(VARHDRSZ + 6 + 3 * plen);\n\tr = VARDATA(result);\n\n\t*r++ = '^';\n\t*r++ = '(';\n\t*r++ = '?';\n\t*r++ = ':';\n\n\twhile (plen > 0)\n\t{\n\t\tchar\t\tpchar = *p;\n\n\t\t/*\n\t\t * If both the escape character and the current character from the\n\t\t * pattern are multi-byte, we need to take the slow path.\n\t\t *\n\t\t * But if one of them is single-byte, we can process the pattern one\n\t\t * byte at a time, ignoring multi-byte characters.  (This works\n\t\t * because all server-encodings have the property that a valid\n\t\t * multi-byte character representation cannot contain the\n\t\t * representation of a valid single-byte character.)\n\t\t */\n\n\t\tif (elen > 1)\n\t\t{\n\t\t\tint\t\t\tmblen = pg_mblen(p);\n\n\t\t\tif (mblen > 1)\n\t\t\t{\n\t\t\t\t/* slow, multi-byte path */\n\t\t\t\tif (afterescape)\n\t\t\t\t{\n\t\t\t\t\t*r++ = '\\\\';\n\t\t\t\t\tmemcpy(r, p, mblen);\n\t\t\t\t\tr += mblen;\n\t\t\t\t\tafterescape = false;\n\t\t\t\t}\n\t\t\t\telse if (e && elen == mblen && memcmp(e, p, mblen) == 0)\n\t\t\t\t{\n\t\t\t\t\t/* SQL99 escape character; do not send to output */\n\t\t\t\t\tafterescape = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We know it's a multi-byte character, so we don't need\n\t\t\t\t\t * to do all the comparisons to single-byte characters\n\t\t\t\t\t * that we do below.\n\t\t\t\t\t */\n\t\t\t\t\tmemcpy(r, p, mblen);\n\t\t\t\t\tr += mblen;\n\t\t\t\t}\n\n\t\t\t\tp += mblen;\n\t\t\t\tplen -= mblen;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* fast path */\n\t\tif (afterescape)\n\t\t{\n\t\t\tif (pchar == '\"' && !incharclass)\t/* for SUBSTRING patterns */\n\t\t\t\t*r++ = ((nquotes++ % 2) == 0) ? '(' : ')';\n\t\t\telse\n\t\t\t{\n\t\t\t\t*r++ = '\\\\';\n\t\t\t\t*r++ = pchar;\n\t\t\t}\n\t\t\tafterescape = false;\n\t\t}\n\t\telse if (e && pchar == *e)\n\t\t{\n\t\t\t/* SQL99 escape character; do not send to output */\n\t\t\tafterescape = true;\n\t\t}\n\t\telse if (incharclass)\n\t\t{\n\t\t\tif (pchar == '\\\\')\n\t\t\t\t*r++ = '\\\\';\n\t\t\t*r++ = pchar;\n\t\t\tif (pchar == ']')\n\t\t\t\tincharclass = false;\n\t\t}\n\t\telse if (pchar == '[')\n\t\t{\n\t\t\t*r++ = pchar;\n\t\t\tincharclass = true;\n\t\t}\n\t\telse if (pchar == '%')\n\t\t{\n\t\t\t*r++ = '.';\n\t\t\t*r++ = '*';\n\t\t}\n\t\telse if (pchar == '_')\n\t\t\t*r++ = '.';\n\t\telse if (pchar == '(')\n\t\t{\n\t\t\t/* convert to non-capturing parenthesis */\n\t\t\t*r++ = '(';\n\t\t\t*r++ = '?';\n\t\t\t*r++ = ':';\n\t\t}\n\t\telse if (pchar == '\\\\' || pchar == '.' ||\n\t\t\t\t pchar == '^' || pchar == '$')\n\t\t{\n\t\t\t*r++ = '\\\\';\n\t\t\t*r++ = pchar;\n\t\t}\n\t\telse\n\t\t\t*r++ = pchar;\n\t\tp++, plen--;\n\t}\n\n\t*r++ = ')';\n\t*r++ = '$';\n\n\tSET_VARSIZE(result, r - ((char *) result));\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "r - ((char *) result)"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r",
            "p",
            "mblen"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "e",
            "p",
            "mblen"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r",
            "p",
            "mblen"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "p"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARHDRSZ + 6 + 3 * plen"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t\t errmsg(\"invalid escape string\"),\n\t\t\t\t\t\t errhint(\"Escape string must be empty or one character.\"))"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Escape string must be empty or one character.\""
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid escape string\""
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_ESCAPE_SEQUENCE"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen_with_len",
          "args": [
            "e",
            "elen"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "793-811",
          "snippet": "int\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "esc_text"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "esc_text"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "pat_text"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "pat_text"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\nsimilar_escape(PG_FUNCTION_ARGS)\n{\n\ttext\t   *pat_text;\n\ttext\t   *esc_text;\n\ttext\t   *result;\n\tchar\t   *p,\n\t\t\t   *e,\n\t\t\t   *r;\n\tint\t\t\tplen,\n\t\t\t\telen;\n\tbool\t\tafterescape = false;\n\tbool\t\tincharclass = false;\n\tint\t\t\tnquotes = 0;\n\n\t/* This function is not strict, so must test explicitly */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\tpat_text = PG_GETARG_TEXT_PP(0);\n\tp = VARDATA_ANY(pat_text);\n\tplen = VARSIZE_ANY_EXHDR(pat_text);\n\tif (PG_ARGISNULL(1))\n\t{\n\t\t/* No ESCAPE clause provided; default to backslash as escape */\n\t\te = \"\\\\\";\n\t\telen = 1;\n\t}\n\telse\n\t{\n\t\tesc_text = PG_GETARG_TEXT_PP(1);\n\t\te = VARDATA_ANY(esc_text);\n\t\telen = VARSIZE_ANY_EXHDR(esc_text);\n\t\tif (elen == 0)\n\t\t\te = NULL;\t\t\t/* no escape character */\n\t\telse\n\t\t{\n\t\t\tint\t\t\tescape_mblen = pg_mbstrlen_with_len(e, elen);\n\n\t\t\tif (escape_mblen > 1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t\t errmsg(\"invalid escape string\"),\n\t\t\t\t\t\t errhint(\"Escape string must be empty or one character.\")));\n\t\t}\n\t}\n\n\t/*----------\n\t * We surround the transformed input string with\n\t *\t\t\t^(?: ... )$\n\t * which requires some explanation.  We need \"^\" and \"$\" to force\n\t * the pattern to match the entire input string as per SQL99 spec.\n\t * The \"(?:\" and \")\" are a non-capturing set of parens; we have to have\n\t * parens in case the string contains \"|\", else the \"^\" and \"$\" will\n\t * be bound into the first and last alternatives which is not what we\n\t * want, and the parens must be non capturing because we don't want them\n\t * to count when selecting output for SUBSTRING.\n\t *----------\n\t */\n\n\t/*\n\t * We need room for the prefix/postfix plus as many as 3 output bytes per\n\t * input byte; since the input is at most 1GB this can't overflow\n\t */\n\tresult = (text *) palloc(VARHDRSZ + 6 + 3 * plen);\n\tr = VARDATA(result);\n\n\t*r++ = '^';\n\t*r++ = '(';\n\t*r++ = '?';\n\t*r++ = ':';\n\n\twhile (plen > 0)\n\t{\n\t\tchar\t\tpchar = *p;\n\n\t\t/*\n\t\t * If both the escape character and the current character from the\n\t\t * pattern are multi-byte, we need to take the slow path.\n\t\t *\n\t\t * But if one of them is single-byte, we can process the pattern one\n\t\t * byte at a time, ignoring multi-byte characters.  (This works\n\t\t * because all server-encodings have the property that a valid\n\t\t * multi-byte character representation cannot contain the\n\t\t * representation of a valid single-byte character.)\n\t\t */\n\n\t\tif (elen > 1)\n\t\t{\n\t\t\tint\t\t\tmblen = pg_mblen(p);\n\n\t\t\tif (mblen > 1)\n\t\t\t{\n\t\t\t\t/* slow, multi-byte path */\n\t\t\t\tif (afterescape)\n\t\t\t\t{\n\t\t\t\t\t*r++ = '\\\\';\n\t\t\t\t\tmemcpy(r, p, mblen);\n\t\t\t\t\tr += mblen;\n\t\t\t\t\tafterescape = false;\n\t\t\t\t}\n\t\t\t\telse if (e && elen == mblen && memcmp(e, p, mblen) == 0)\n\t\t\t\t{\n\t\t\t\t\t/* SQL99 escape character; do not send to output */\n\t\t\t\t\tafterescape = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We know it's a multi-byte character, so we don't need\n\t\t\t\t\t * to do all the comparisons to single-byte characters\n\t\t\t\t\t * that we do below.\n\t\t\t\t\t */\n\t\t\t\t\tmemcpy(r, p, mblen);\n\t\t\t\t\tr += mblen;\n\t\t\t\t}\n\n\t\t\t\tp += mblen;\n\t\t\t\tplen -= mblen;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* fast path */\n\t\tif (afterescape)\n\t\t{\n\t\t\tif (pchar == '\"' && !incharclass)\t/* for SUBSTRING patterns */\n\t\t\t\t*r++ = ((nquotes++ % 2) == 0) ? '(' : ')';\n\t\t\telse\n\t\t\t{\n\t\t\t\t*r++ = '\\\\';\n\t\t\t\t*r++ = pchar;\n\t\t\t}\n\t\t\tafterescape = false;\n\t\t}\n\t\telse if (e && pchar == *e)\n\t\t{\n\t\t\t/* SQL99 escape character; do not send to output */\n\t\t\tafterescape = true;\n\t\t}\n\t\telse if (incharclass)\n\t\t{\n\t\t\tif (pchar == '\\\\')\n\t\t\t\t*r++ = '\\\\';\n\t\t\t*r++ = pchar;\n\t\t\tif (pchar == ']')\n\t\t\t\tincharclass = false;\n\t\t}\n\t\telse if (pchar == '[')\n\t\t{\n\t\t\t*r++ = pchar;\n\t\t\tincharclass = true;\n\t\t}\n\t\telse if (pchar == '%')\n\t\t{\n\t\t\t*r++ = '.';\n\t\t\t*r++ = '*';\n\t\t}\n\t\telse if (pchar == '_')\n\t\t\t*r++ = '.';\n\t\telse if (pchar == '(')\n\t\t{\n\t\t\t/* convert to non-capturing parenthesis */\n\t\t\t*r++ = '(';\n\t\t\t*r++ = '?';\n\t\t\t*r++ = ':';\n\t\t}\n\t\telse if (pchar == '\\\\' || pchar == '.' ||\n\t\t\t\t pchar == '^' || pchar == '$')\n\t\t{\n\t\t\t*r++ = '\\\\';\n\t\t\t*r++ = pchar;\n\t\t}\n\t\telse\n\t\t\t*r++ = pchar;\n\t\tp++, plen--;\n\t}\n\n\t*r++ = ')';\n\t*r++ = '$';\n\n\tSET_VARSIZE(result, r - ((char *) result));\n\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "textregexreplace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "639-654",
    "snippet": "Datum\ntextregexreplace(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\ttext\t   *r = PG_GETARG_TEXT_PP(2);\n\ttext\t   *opt = PG_GETARG_TEXT_PP(3);\n\tregex_t    *re;\n\tpg_re_flags flags;\n\n\tparse_re_flags(&flags, opt);\n\n\tre = RE_compile_and_cache(p, flags.cflags, PG_GET_COLLATION());\n\n\tPG_RETURN_TEXT_P(replace_text_regexp(s, (void *) re, r, flags.glob));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "replace_text_regexp(s, (void *) re, r, flags.glob)"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_text_regexp",
          "args": [
            "s",
            "(void *) re",
            "r",
            "flags.glob"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "replace_text_regexp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4049-4176",
          "snippet": "text *\nreplace_text_regexp(text *src_text, void *regexp,\n\t\t\t\t\ttext *replace_text, bool glob)\n{\n\ttext\t   *ret_text;\n\tregex_t    *re = (regex_t *) regexp;\n\tint\t\t\tsrc_text_len = VARSIZE_ANY_EXHDR(src_text);\n\tStringInfoData buf;\n\tregmatch_t\tpmatch[REGEXP_REPLACE_BACKREF_CNT];\n\tpg_wchar   *data;\n\tsize_t\t\tdata_len;\n\tint\t\t\tsearch_start;\n\tint\t\t\tdata_pos;\n\tchar\t   *start_ptr;\n\tbool\t\thave_escape;\n\n\tinitStringInfo(&buf);\n\n\t/* Convert data string to wide characters. */\n\tdata = (pg_wchar *) palloc((src_text_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(VARDATA_ANY(src_text), data, src_text_len);\n\n\t/* Check whether replace_text has escape char. */\n\thave_escape = check_replace_text_has_escape_char(replace_text);\n\n\t/* start_ptr points to the data_pos'th character of src_text */\n\tstart_ptr = (char *) VARDATA_ANY(src_text);\n\tdata_pos = 0;\n\n\tsearch_start = 0;\n\twhile (search_start <= data_len)\n\t{\n\t\tint\t\t\tregexec_result;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\t\tsearch_start,\n\t\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\t\tREGEXP_REPLACE_BACKREF_CNT,\n\t\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t\t0);\n\n\t\tif (regexec_result == REG_NOMATCH)\n\t\t\tbreak;\n\n\t\tif (regexec_result != REG_OKAY)\n\t\t{\n\t\t\tchar\t\terrMsg[100];\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t\t}\n\n\t\t/*\n\t\t * Copy the text to the left of the match position.  Note we are given\n\t\t * character not byte indexes.\n\t\t */\n\t\tif (pmatch[0].rm_so - data_pos > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tchunk_len = charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\t   pmatch[0].rm_so - data_pos);\n\t\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\n\t\t\t/*\n\t\t\t * Advance start_ptr over that text, to avoid multiple rescans of\n\t\t\t * it if the replace_text contains multiple back-references.\n\t\t\t */\n\t\t\tstart_ptr += chunk_len;\n\t\t\tdata_pos = pmatch[0].rm_so;\n\t\t}\n\n\t\t/*\n\t\t * Copy the replace_text. Process back references when the\n\t\t * replace_text has escape characters.\n\t\t */\n\t\tif (have_escape)\n\t\t\tappendStringInfoRegexpSubstr(&buf, replace_text, pmatch,\n\t\t\t\t\t\t\t\t\t\t start_ptr, data_pos);\n\t\telse\n\t\t\tappendStringInfoText(&buf, replace_text);\n\n\t\t/* Advance start_ptr and data_pos over the matched text. */\n\t\tstart_ptr += charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\tpmatch[0].rm_eo - data_pos);\n\t\tdata_pos = pmatch[0].rm_eo;\n\n\t\t/*\n\t\t * When global option is off, replace the first instance only.\n\t\t */\n\t\tif (!glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tsearch_start = data_pos;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tsearch_start++;\n\t}\n\n\t/*\n\t * Copy the text to the right of the last match.\n\t */\n\tif (data_pos < data_len)\n\t{\n\t\tint\t\t\tchunk_len;\n\n\t\tchunk_len = ((char *) src_text + VARSIZE_ANY(src_text)) - start_ptr;\n\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\t}\n\n\tret_text = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\tpfree(data);\n\n\treturn ret_text;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define REGEXP_REPLACE_BACKREF_CNT\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define REGEXP_REPLACE_BACKREF_CNT\t\t10\n\ntext *\nreplace_text_regexp(text *src_text, void *regexp,\n\t\t\t\t\ttext *replace_text, bool glob)\n{\n\ttext\t   *ret_text;\n\tregex_t    *re = (regex_t *) regexp;\n\tint\t\t\tsrc_text_len = VARSIZE_ANY_EXHDR(src_text);\n\tStringInfoData buf;\n\tregmatch_t\tpmatch[REGEXP_REPLACE_BACKREF_CNT];\n\tpg_wchar   *data;\n\tsize_t\t\tdata_len;\n\tint\t\t\tsearch_start;\n\tint\t\t\tdata_pos;\n\tchar\t   *start_ptr;\n\tbool\t\thave_escape;\n\n\tinitStringInfo(&buf);\n\n\t/* Convert data string to wide characters. */\n\tdata = (pg_wchar *) palloc((src_text_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(VARDATA_ANY(src_text), data, src_text_len);\n\n\t/* Check whether replace_text has escape char. */\n\thave_escape = check_replace_text_has_escape_char(replace_text);\n\n\t/* start_ptr points to the data_pos'th character of src_text */\n\tstart_ptr = (char *) VARDATA_ANY(src_text);\n\tdata_pos = 0;\n\n\tsearch_start = 0;\n\twhile (search_start <= data_len)\n\t{\n\t\tint\t\t\tregexec_result;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\t\tsearch_start,\n\t\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\t\tREGEXP_REPLACE_BACKREF_CNT,\n\t\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t\t0);\n\n\t\tif (regexec_result == REG_NOMATCH)\n\t\t\tbreak;\n\n\t\tif (regexec_result != REG_OKAY)\n\t\t{\n\t\t\tchar\t\terrMsg[100];\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t\t}\n\n\t\t/*\n\t\t * Copy the text to the left of the match position.  Note we are given\n\t\t * character not byte indexes.\n\t\t */\n\t\tif (pmatch[0].rm_so - data_pos > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tchunk_len = charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\t   pmatch[0].rm_so - data_pos);\n\t\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\n\t\t\t/*\n\t\t\t * Advance start_ptr over that text, to avoid multiple rescans of\n\t\t\t * it if the replace_text contains multiple back-references.\n\t\t\t */\n\t\t\tstart_ptr += chunk_len;\n\t\t\tdata_pos = pmatch[0].rm_so;\n\t\t}\n\n\t\t/*\n\t\t * Copy the replace_text. Process back references when the\n\t\t * replace_text has escape characters.\n\t\t */\n\t\tif (have_escape)\n\t\t\tappendStringInfoRegexpSubstr(&buf, replace_text, pmatch,\n\t\t\t\t\t\t\t\t\t\t start_ptr, data_pos);\n\t\telse\n\t\t\tappendStringInfoText(&buf, replace_text);\n\n\t\t/* Advance start_ptr and data_pos over the matched text. */\n\t\tstart_ptr += charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\tpmatch[0].rm_eo - data_pos);\n\t\tdata_pos = pmatch[0].rm_eo;\n\n\t\t/*\n\t\t * When global option is off, replace the first instance only.\n\t\t */\n\t\tif (!glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tsearch_start = data_pos;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tsearch_start++;\n\t}\n\n\t/*\n\t * Copy the text to the right of the last match.\n\t */\n\tif (data_pos < data_len)\n\t{\n\t\tint\t\t\tchunk_len;\n\n\t\tchunk_len = ((char *) src_text + VARSIZE_ANY(src_text)) - start_ptr;\n\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\t}\n\n\tret_text = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\tpfree(data);\n\n\treturn ret_text;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RE_compile_and_cache",
          "args": [
            "p",
            "flags.cflags",
            "PG_GET_COLLATION()"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "136-249",
          "snippet": "static regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CACHED_RES\t32"
          ],
          "globals_used": [
            "static int\tnum_res = 0;",
            "static cached_re_str re_array[MAX_CACHED_RES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MAX_CACHED_RES\t32\n\nstatic int\tnum_res = 0;\nstatic cached_re_str re_array[MAX_CACHED_RES];\n\nstatic regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_re_flags",
          "args": [
            "&flags",
            "opt"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "parse_re_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "365-432",
          "snippet": "static void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\ntextregexreplace(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\ttext\t   *r = PG_GETARG_TEXT_PP(2);\n\ttext\t   *opt = PG_GETARG_TEXT_PP(3);\n\tregex_t    *re;\n\tpg_re_flags flags;\n\n\tparse_re_flags(&flags, opt);\n\n\tre = RE_compile_and_cache(p, flags.cflags, PG_GET_COLLATION());\n\n\tPG_RETURN_TEXT_P(replace_text_regexp(s, (void *) re, r, flags.glob));\n}"
  },
  {
    "function_name": "textregexreplace_noopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "622-633",
    "snippet": "Datum\ntextregexreplace_noopt(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\ttext\t   *r = PG_GETARG_TEXT_PP(2);\n\tregex_t    *re;\n\n\tre = RE_compile_and_cache(p, REG_ADVANCED, PG_GET_COLLATION());\n\n\tPG_RETURN_TEXT_P(replace_text_regexp(s, (void *) re, r, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "replace_text_regexp(s, (void *) re, r, false)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_text_regexp",
          "args": [
            "s",
            "(void *) re",
            "r",
            "false"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "replace_text_regexp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4049-4176",
          "snippet": "text *\nreplace_text_regexp(text *src_text, void *regexp,\n\t\t\t\t\ttext *replace_text, bool glob)\n{\n\ttext\t   *ret_text;\n\tregex_t    *re = (regex_t *) regexp;\n\tint\t\t\tsrc_text_len = VARSIZE_ANY_EXHDR(src_text);\n\tStringInfoData buf;\n\tregmatch_t\tpmatch[REGEXP_REPLACE_BACKREF_CNT];\n\tpg_wchar   *data;\n\tsize_t\t\tdata_len;\n\tint\t\t\tsearch_start;\n\tint\t\t\tdata_pos;\n\tchar\t   *start_ptr;\n\tbool\t\thave_escape;\n\n\tinitStringInfo(&buf);\n\n\t/* Convert data string to wide characters. */\n\tdata = (pg_wchar *) palloc((src_text_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(VARDATA_ANY(src_text), data, src_text_len);\n\n\t/* Check whether replace_text has escape char. */\n\thave_escape = check_replace_text_has_escape_char(replace_text);\n\n\t/* start_ptr points to the data_pos'th character of src_text */\n\tstart_ptr = (char *) VARDATA_ANY(src_text);\n\tdata_pos = 0;\n\n\tsearch_start = 0;\n\twhile (search_start <= data_len)\n\t{\n\t\tint\t\t\tregexec_result;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\t\tsearch_start,\n\t\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\t\tREGEXP_REPLACE_BACKREF_CNT,\n\t\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t\t0);\n\n\t\tif (regexec_result == REG_NOMATCH)\n\t\t\tbreak;\n\n\t\tif (regexec_result != REG_OKAY)\n\t\t{\n\t\t\tchar\t\terrMsg[100];\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t\t}\n\n\t\t/*\n\t\t * Copy the text to the left of the match position.  Note we are given\n\t\t * character not byte indexes.\n\t\t */\n\t\tif (pmatch[0].rm_so - data_pos > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tchunk_len = charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\t   pmatch[0].rm_so - data_pos);\n\t\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\n\t\t\t/*\n\t\t\t * Advance start_ptr over that text, to avoid multiple rescans of\n\t\t\t * it if the replace_text contains multiple back-references.\n\t\t\t */\n\t\t\tstart_ptr += chunk_len;\n\t\t\tdata_pos = pmatch[0].rm_so;\n\t\t}\n\n\t\t/*\n\t\t * Copy the replace_text. Process back references when the\n\t\t * replace_text has escape characters.\n\t\t */\n\t\tif (have_escape)\n\t\t\tappendStringInfoRegexpSubstr(&buf, replace_text, pmatch,\n\t\t\t\t\t\t\t\t\t\t start_ptr, data_pos);\n\t\telse\n\t\t\tappendStringInfoText(&buf, replace_text);\n\n\t\t/* Advance start_ptr and data_pos over the matched text. */\n\t\tstart_ptr += charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\tpmatch[0].rm_eo - data_pos);\n\t\tdata_pos = pmatch[0].rm_eo;\n\n\t\t/*\n\t\t * When global option is off, replace the first instance only.\n\t\t */\n\t\tif (!glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tsearch_start = data_pos;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tsearch_start++;\n\t}\n\n\t/*\n\t * Copy the text to the right of the last match.\n\t */\n\tif (data_pos < data_len)\n\t{\n\t\tint\t\t\tchunk_len;\n\n\t\tchunk_len = ((char *) src_text + VARSIZE_ANY(src_text)) - start_ptr;\n\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\t}\n\n\tret_text = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\tpfree(data);\n\n\treturn ret_text;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define REGEXP_REPLACE_BACKREF_CNT\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define REGEXP_REPLACE_BACKREF_CNT\t\t10\n\ntext *\nreplace_text_regexp(text *src_text, void *regexp,\n\t\t\t\t\ttext *replace_text, bool glob)\n{\n\ttext\t   *ret_text;\n\tregex_t    *re = (regex_t *) regexp;\n\tint\t\t\tsrc_text_len = VARSIZE_ANY_EXHDR(src_text);\n\tStringInfoData buf;\n\tregmatch_t\tpmatch[REGEXP_REPLACE_BACKREF_CNT];\n\tpg_wchar   *data;\n\tsize_t\t\tdata_len;\n\tint\t\t\tsearch_start;\n\tint\t\t\tdata_pos;\n\tchar\t   *start_ptr;\n\tbool\t\thave_escape;\n\n\tinitStringInfo(&buf);\n\n\t/* Convert data string to wide characters. */\n\tdata = (pg_wchar *) palloc((src_text_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(VARDATA_ANY(src_text), data, src_text_len);\n\n\t/* Check whether replace_text has escape char. */\n\thave_escape = check_replace_text_has_escape_char(replace_text);\n\n\t/* start_ptr points to the data_pos'th character of src_text */\n\tstart_ptr = (char *) VARDATA_ANY(src_text);\n\tdata_pos = 0;\n\n\tsearch_start = 0;\n\twhile (search_start <= data_len)\n\t{\n\t\tint\t\t\tregexec_result;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\t\tsearch_start,\n\t\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\t\tREGEXP_REPLACE_BACKREF_CNT,\n\t\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t\t0);\n\n\t\tif (regexec_result == REG_NOMATCH)\n\t\t\tbreak;\n\n\t\tif (regexec_result != REG_OKAY)\n\t\t{\n\t\t\tchar\t\terrMsg[100];\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t\t}\n\n\t\t/*\n\t\t * Copy the text to the left of the match position.  Note we are given\n\t\t * character not byte indexes.\n\t\t */\n\t\tif (pmatch[0].rm_so - data_pos > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tchunk_len = charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\t   pmatch[0].rm_so - data_pos);\n\t\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\n\t\t\t/*\n\t\t\t * Advance start_ptr over that text, to avoid multiple rescans of\n\t\t\t * it if the replace_text contains multiple back-references.\n\t\t\t */\n\t\t\tstart_ptr += chunk_len;\n\t\t\tdata_pos = pmatch[0].rm_so;\n\t\t}\n\n\t\t/*\n\t\t * Copy the replace_text. Process back references when the\n\t\t * replace_text has escape characters.\n\t\t */\n\t\tif (have_escape)\n\t\t\tappendStringInfoRegexpSubstr(&buf, replace_text, pmatch,\n\t\t\t\t\t\t\t\t\t\t start_ptr, data_pos);\n\t\telse\n\t\t\tappendStringInfoText(&buf, replace_text);\n\n\t\t/* Advance start_ptr and data_pos over the matched text. */\n\t\tstart_ptr += charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\tpmatch[0].rm_eo - data_pos);\n\t\tdata_pos = pmatch[0].rm_eo;\n\n\t\t/*\n\t\t * When global option is off, replace the first instance only.\n\t\t */\n\t\tif (!glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tsearch_start = data_pos;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tsearch_start++;\n\t}\n\n\t/*\n\t * Copy the text to the right of the last match.\n\t */\n\tif (data_pos < data_len)\n\t{\n\t\tint\t\t\tchunk_len;\n\n\t\tchunk_len = ((char *) src_text + VARSIZE_ANY(src_text)) - start_ptr;\n\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\t}\n\n\tret_text = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\tpfree(data);\n\n\treturn ret_text;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RE_compile_and_cache",
          "args": [
            "p",
            "REG_ADVANCED",
            "PG_GET_COLLATION()"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "136-249",
          "snippet": "static regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CACHED_RES\t32"
          ],
          "globals_used": [
            "static int\tnum_res = 0;",
            "static cached_re_str re_array[MAX_CACHED_RES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MAX_CACHED_RES\t32\n\nstatic int\tnum_res = 0;\nstatic cached_re_str re_array[MAX_CACHED_RES];\n\nstatic regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\ntextregexreplace_noopt(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\ttext\t   *r = PG_GETARG_TEXT_PP(2);\n\tregex_t    *re;\n\n\tre = RE_compile_and_cache(p, REG_ADVANCED, PG_GET_COLLATION());\n\n\tPG_RETURN_TEXT_P(replace_text_regexp(s, (void *) re, r, false));\n}"
  },
  {
    "function_name": "textregexsubstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "563-613",
    "snippet": "Datum\ntextregexsubstr(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\tregex_t    *re;\n\tregmatch_t\tpmatch[2];\n\tint\t\t\tso,\n\t\t\t\teo;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(p, REG_ADVANCED, PG_GET_COLLATION());\n\n\t/*\n\t * We pass two regmatch_t structs to get info about the overall match and\n\t * the match for the first parenthesized subexpression (if any). If there\n\t * is a parenthesized subexpression, we return what it matched; else\n\t * return what the whole regexp matched.\n\t */\n\tif (!RE_execute(re,\n\t\t\t\t\tVARDATA_ANY(s), VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t2, pmatch))\n\t\tPG_RETURN_NULL();\t\t/* definitely no match */\n\n\tif (re->re_nsub > 0)\n\t{\n\t\t/* has parenthesized subexpressions, use the first one */\n\t\tso = pmatch[1].rm_so;\n\t\teo = pmatch[1].rm_eo;\n\t}\n\telse\n\t{\n\t\t/* no parenthesized subexpression, use whole match */\n\t\tso = pmatch[0].rm_so;\n\t\teo = pmatch[0].rm_eo;\n\t}\n\n\t/*\n\t * It is possible to have a match to the whole pattern but no match for a\n\t * subexpression; for example 'foo(bar)?' is considered to match 'foo' but\n\t * there is no subexpression match.  So this extra test for match failure\n\t * is not redundant.\n\t */\n\tif (so < 0 || eo < 0)\n\t\tPG_RETURN_NULL();\n\n\treturn DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t   PointerGetDatum(s),\n\t\t\t\t\t\t\t   Int32GetDatum(so + 1),\n\t\t\t\t\t\t\t   Int32GetDatum(eo - so));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall3",
          "args": [
            "text_substr",
            "PointerGetDatum(s)",
            "Int32GetDatum(so + 1)",
            "Int32GetDatum(eo - so)"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "eo - so"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "so + 1"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "s"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RE_execute",
          "args": [
            "re",
            "VARDATA_ANY(s)",
            "VARSIZE_ANY_EXHDR(s)",
            "2",
            "pmatch"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "RE_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "308-325",
          "snippet": "static bool\nRE_execute(regex_t *re, char *dat, int dat_len,\n\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tpg_wchar   *data;\n\tint\t\t\tdata_len;\n\tbool\t\tmatch;\n\n\t/* Convert data string to wide characters */\n\tdata = (pg_wchar *) palloc((dat_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(dat, data, dat_len);\n\n\t/* Perform RE match and return result */\n\tmatch = RE_wchar_execute(re, data, data_len, 0, nmatch, pmatch);\n\n\tpfree(data);\n\treturn match;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_execute(regex_t *re, char *dat, int dat_len,\n\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tpg_wchar   *data;\n\tint\t\t\tdata_len;\n\tbool\t\tmatch;\n\n\t/* Convert data string to wide characters */\n\tdata = (pg_wchar *) palloc((dat_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(dat, data, dat_len);\n\n\t/* Perform RE match and return result */\n\tmatch = RE_wchar_execute(re, data, data_len, 0, nmatch, pmatch);\n\n\tpfree(data);\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "s"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "s"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RE_compile_and_cache",
          "args": [
            "p",
            "REG_ADVANCED",
            "PG_GET_COLLATION()"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "136-249",
          "snippet": "static regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CACHED_RES\t32"
          ],
          "globals_used": [
            "static int\tnum_res = 0;",
            "static cached_re_str re_array[MAX_CACHED_RES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MAX_CACHED_RES\t32\n\nstatic int\tnum_res = 0;\nstatic cached_re_str re_array[MAX_CACHED_RES];\n\nstatic regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\ntextregexsubstr(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\tregex_t    *re;\n\tregmatch_t\tpmatch[2];\n\tint\t\t\tso,\n\t\t\t\teo;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(p, REG_ADVANCED, PG_GET_COLLATION());\n\n\t/*\n\t * We pass two regmatch_t structs to get info about the overall match and\n\t * the match for the first parenthesized subexpression (if any). If there\n\t * is a parenthesized subexpression, we return what it matched; else\n\t * return what the whole regexp matched.\n\t */\n\tif (!RE_execute(re,\n\t\t\t\t\tVARDATA_ANY(s), VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t2, pmatch))\n\t\tPG_RETURN_NULL();\t\t/* definitely no match */\n\n\tif (re->re_nsub > 0)\n\t{\n\t\t/* has parenthesized subexpressions, use the first one */\n\t\tso = pmatch[1].rm_so;\n\t\teo = pmatch[1].rm_eo;\n\t}\n\telse\n\t{\n\t\t/* no parenthesized subexpression, use whole match */\n\t\tso = pmatch[0].rm_so;\n\t\teo = pmatch[0].rm_eo;\n\t}\n\n\t/*\n\t * It is possible to have a match to the whole pattern but no match for a\n\t * subexpression; for example 'foo(bar)?' is considered to match 'foo' but\n\t * there is no subexpression match.  So this extra test for match failure\n\t * is not redundant.\n\t */\n\tif (so < 0 || eo < 0)\n\t\tPG_RETURN_NULL();\n\n\treturn DirectFunctionCall3(text_substr,\n\t\t\t\t\t\t\t   PointerGetDatum(s),\n\t\t\t\t\t\t\t   Int32GetDatum(so + 1),\n\t\t\t\t\t\t\t   Int32GetDatum(eo - so));\n}"
  },
  {
    "function_name": "texticregexne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "544-556",
    "snippet": "Datum\ntexticregexne(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RE_compile_and_execute",
          "args": [
            "p",
            "VARDATA_ANY(s)",
            "VARSIZE_ANY_EXHDR(s)",
            "REG_ADVANCED | REG_ICASE",
            "PG_GET_COLLATION()",
            "0",
            "NULL"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "342-353",
          "snippet": "static bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "s"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "s"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\ntexticregexne(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL));\n}"
  },
  {
    "function_name": "texticregexeq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "530-542",
    "snippet": "Datum\ntexticregexeq(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t  VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t  VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RE_compile_and_execute",
          "args": [
            "p",
            "VARDATA_ANY(s)",
            "VARSIZE_ANY_EXHDR(s)",
            "REG_ADVANCED | REG_ICASE",
            "PG_GET_COLLATION()",
            "0",
            "NULL"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "342-353",
          "snippet": "static bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "s"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "s"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\ntexticregexeq(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t  VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL));\n}"
  },
  {
    "function_name": "nameicregexne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "516-528",
    "snippet": "Datum\nnameicregexne(PG_FUNCTION_ARGS)\n{\n\tName\t\tn = PG_GETARG_NAME(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t   strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t   strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RE_compile_and_execute",
          "args": [
            "p",
            "NameStr(*n)",
            "strlen(NameStr(*n))",
            "REG_ADVANCED | REG_ICASE",
            "PG_GET_COLLATION()",
            "0",
            "NULL"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "342-353",
          "snippet": "static bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "NameStr(*n)"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*n"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*n"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\nnameicregexne(PG_FUNCTION_ARGS)\n{\n\tName\t\tn = PG_GETARG_NAME(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t   strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL));\n}"
  },
  {
    "function_name": "nameicregexeq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "502-514",
    "snippet": "Datum\nnameicregexeq(PG_FUNCTION_ARGS)\n{\n\tName\t\tn = PG_GETARG_NAME(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t  strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t  strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RE_compile_and_execute",
          "args": [
            "p",
            "NameStr(*n)",
            "strlen(NameStr(*n))",
            "REG_ADVANCED | REG_ICASE",
            "PG_GET_COLLATION()",
            "0",
            "NULL"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "342-353",
          "snippet": "static bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "NameStr(*n)"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*n"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*n"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\nnameicregexeq(PG_FUNCTION_ARGS)\n{\n\tName\t\tn = PG_GETARG_NAME(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t  strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED | REG_ICASE,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL));\n}"
  },
  {
    "function_name": "textregexne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "481-493",
    "snippet": "Datum\ntextregexne(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL)"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RE_compile_and_execute",
          "args": [
            "p",
            "VARDATA_ANY(s)",
            "VARSIZE_ANY_EXHDR(s)",
            "REG_ADVANCED",
            "PG_GET_COLLATION()",
            "0",
            "NULL"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "342-353",
          "snippet": "static bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "s"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "s"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\ntextregexne(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL));\n}"
  },
  {
    "function_name": "textregexeq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "467-479",
    "snippet": "Datum\ntextregexeq(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t  VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t  VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RE_compile_and_execute",
          "args": [
            "p",
            "VARDATA_ANY(s)",
            "VARSIZE_ANY_EXHDR(s)",
            "REG_ADVANCED",
            "PG_GET_COLLATION()",
            "0",
            "NULL"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "342-353",
          "snippet": "static bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "s"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "s"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\ntextregexeq(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  VARDATA_ANY(s),\n\t\t\t\t\t\t\t\t\t\t  VARSIZE_ANY_EXHDR(s),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL));\n}"
  },
  {
    "function_name": "nameregexne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "453-465",
    "snippet": "Datum\nnameregexne(PG_FUNCTION_ARGS)\n{\n\tName\t\tn = PG_GETARG_NAME(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t   strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t   strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RE_compile_and_execute",
          "args": [
            "p",
            "NameStr(*n)",
            "strlen(NameStr(*n))",
            "REG_ADVANCED",
            "PG_GET_COLLATION()",
            "0",
            "NULL"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "342-353",
          "snippet": "static bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "NameStr(*n)"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*n"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*n"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\nnameregexne(PG_FUNCTION_ARGS)\n{\n\tName\t\tn = PG_GETARG_NAME(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(!RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t   NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t   strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t   REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t   PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t   0, NULL));\n}"
  },
  {
    "function_name": "nameregexeq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "439-451",
    "snippet": "Datum\nnameregexeq(PG_FUNCTION_ARGS)\n{\n\tName\t\tn = PG_GETARG_NAME(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t  strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t  strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RE_compile_and_execute",
          "args": [
            "p",
            "NameStr(*n)",
            "strlen(NameStr(*n))",
            "REG_ADVANCED",
            "PG_GET_COLLATION()",
            "0",
            "NULL"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "342-353",
          "snippet": "static bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "NameStr(*n)"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*n"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*n"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\nnameregexeq(PG_FUNCTION_ARGS)\n{\n\tName\t\tn = PG_GETARG_NAME(0);\n\ttext\t   *p = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_BOOL(RE_compile_and_execute(p,\n\t\t\t\t\t\t\t\t\t\t  NameStr(*n),\n\t\t\t\t\t\t\t\t\t\t  strlen(NameStr(*n)),\n\t\t\t\t\t\t\t\t\t\t  REG_ADVANCED,\n\t\t\t\t\t\t\t\t\t\t  PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t\t\t  0, NULL));\n}"
  },
  {
    "function_name": "parse_re_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "365-432",
    "snippet": "static void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i]))"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid regexp option: \\\"%c\\\"\"",
            "opt_p[i]"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "opts"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "opts"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic void\nparse_re_flags(pg_re_flags *flags, text *opts)\n{\n\t/* regex flavor is always folded into the compile flags */\n\tflags->cflags = REG_ADVANCED;\n\tflags->glob = false;\n\n\tif (opts)\n\t{\n\t\tchar\t   *opt_p = VARDATA_ANY(opts);\n\t\tint\t\t\topt_len = VARSIZE_ANY_EXHDR(opts);\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < opt_len; i++)\n\t\t{\n\t\t\tswitch (opt_p[i])\n\t\t\t{\n\t\t\t\tcase 'g':\n\t\t\t\t\tflags->glob = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\t\t/* BREs (but why???) */\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\t\t/* case sensitive */\n\t\t\t\t\tflags->cflags &= ~REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\t\t/* plain EREs */\n\t\t\t\t\tflags->cflags |= REG_EXTENDED;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_QUOTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'i':\t\t/* case insensitive */\n\t\t\t\t\tflags->cflags |= REG_ICASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\t\t/* Perloid synonym for n */\n\t\t\t\tcase 'n':\t\t/* \\n affects ^ $ . [^ */\n\t\t\t\t\tflags->cflags |= REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\t\t/* ~Perl, \\n affects . [^ */\n\t\t\t\t\tflags->cflags |= REG_NLSTOP;\n\t\t\t\t\tflags->cflags &= ~REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\t\t/* literal string */\n\t\t\t\t\tflags->cflags |= REG_QUOTE;\n\t\t\t\t\tflags->cflags &= ~(REG_ADVANCED | REG_EXTENDED);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\t\t/* single line, \\n ordinary */\n\t\t\t\t\tflags->cflags &= ~REG_NEWLINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\t\t/* tight syntax */\n\t\t\t\t\tflags->cflags &= ~REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\t\t/* weird, \\n affects ^ $ only */\n\t\t\t\t\tflags->cflags &= ~REG_NLSTOP;\n\t\t\t\t\tflags->cflags |= REG_NLANCH;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\t\t/* expanded syntax */\n\t\t\t\t\tflags->cflags |= REG_EXPANDED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid regexp option: \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t\topt_p[i])));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "RE_compile_and_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "342-353",
    "snippet": "static bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RE_execute",
          "args": [
            "re",
            "dat",
            "dat_len",
            "nmatch",
            "pmatch"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "RE_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "308-325",
          "snippet": "static bool\nRE_execute(regex_t *re, char *dat, int dat_len,\n\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tpg_wchar   *data;\n\tint\t\t\tdata_len;\n\tbool\t\tmatch;\n\n\t/* Convert data string to wide characters */\n\tdata = (pg_wchar *) palloc((dat_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(dat, data, dat_len);\n\n\t/* Perform RE match and return result */\n\tmatch = RE_wchar_execute(re, data, data_len, 0, nmatch, pmatch);\n\n\tpfree(data);\n\treturn match;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_execute(regex_t *re, char *dat, int dat_len,\n\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tpg_wchar   *data;\n\tint\t\t\tdata_len;\n\tbool\t\tmatch;\n\n\t/* Convert data string to wide characters */\n\tdata = (pg_wchar *) palloc((dat_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(dat, data, dat_len);\n\n\t/* Perform RE match and return result */\n\tmatch = RE_wchar_execute(re, data, data_len, 0, nmatch, pmatch);\n\n\tpfree(data);\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RE_compile_and_cache",
          "args": [
            "text_re",
            "cflags",
            "collation"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "RE_compile_and_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "136-249",
          "snippet": "static regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CACHED_RES\t32"
          ],
          "globals_used": [
            "static int\tnum_res = 0;",
            "static cached_re_str re_array[MAX_CACHED_RES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MAX_CACHED_RES\t32\n\nstatic int\tnum_res = 0;\nstatic cached_re_str re_array[MAX_CACHED_RES];\n\nstatic regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_compile_and_execute(text *text_re, char *dat, int dat_len,\n\t\t\t\t\t   int cflags, Oid collation,\n\t\t\t\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tregex_t    *re;\n\n\t/* Compile RE */\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\treturn RE_execute(re, dat, dat_len, nmatch, pmatch);\n}"
  },
  {
    "function_name": "RE_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "308-325",
    "snippet": "static bool\nRE_execute(regex_t *re, char *dat, int dat_len,\n\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tpg_wchar   *data;\n\tint\t\t\tdata_len;\n\tbool\t\tmatch;\n\n\t/* Convert data string to wide characters */\n\tdata = (pg_wchar *) palloc((dat_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(dat, data, dat_len);\n\n\t/* Perform RE match and return result */\n\tmatch = RE_wchar_execute(re, data, data_len, 0, nmatch, pmatch);\n\n\tpfree(data);\n\treturn match;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "data"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RE_wchar_execute",
          "args": [
            "re",
            "data",
            "data_len",
            "0",
            "nmatch",
            "pmatch"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "RE_wchar_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "265-293",
          "snippet": "static bool\nRE_wchar_execute(regex_t *re, pg_wchar *data, int data_len,\n\t\t\t\t int start_search, int nmatch, regmatch_t *pmatch)\n{\n\tint\t\t\tregexec_result;\n\tchar\t\terrMsg[100];\n\n\t/* Perform RE match and return result */\n\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\tstart_search,\n\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\tnmatch,\n\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t0);\n\n\tif (regexec_result != REG_OKAY && regexec_result != REG_NOMATCH)\n\t{\n\t\t/* re failed??? */\n\t\tCHECK_FOR_INTERRUPTS();\n\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t}\n\n\treturn (regexec_result == REG_OKAY);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_wchar_execute(regex_t *re, pg_wchar *data, int data_len,\n\t\t\t\t int start_search, int nmatch, regmatch_t *pmatch)\n{\n\tint\t\t\tregexec_result;\n\tchar\t\terrMsg[100];\n\n\t/* Perform RE match and return result */\n\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\tstart_search,\n\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\tnmatch,\n\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t0);\n\n\tif (regexec_result != REG_OKAY && regexec_result != REG_NOMATCH)\n\t{\n\t\t/* re failed??? */\n\t\tCHECK_FOR_INTERRUPTS();\n\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t}\n\n\treturn (regexec_result == REG_OKAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mb2wchar_with_len",
          "args": [
            "dat",
            "data",
            "dat_len"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mb2wchar_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "722-726",
          "snippet": "int\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(dat_len + 1) * sizeof(pg_wchar)"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_execute(regex_t *re, char *dat, int dat_len,\n\t\t   int nmatch, regmatch_t *pmatch)\n{\n\tpg_wchar   *data;\n\tint\t\t\tdata_len;\n\tbool\t\tmatch;\n\n\t/* Convert data string to wide characters */\n\tdata = (pg_wchar *) palloc((dat_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(dat, data, dat_len);\n\n\t/* Perform RE match and return result */\n\tmatch = RE_wchar_execute(re, data, data_len, 0, nmatch, pmatch);\n\n\tpfree(data);\n\treturn match;\n}"
  },
  {
    "function_name": "RE_wchar_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "265-293",
    "snippet": "static bool\nRE_wchar_execute(regex_t *re, pg_wchar *data, int data_len,\n\t\t\t\t int start_search, int nmatch, regmatch_t *pmatch)\n{\n\tint\t\t\tregexec_result;\n\tchar\t\terrMsg[100];\n\n\t/* Perform RE match and return result */\n\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\tstart_search,\n\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\tnmatch,\n\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t0);\n\n\tif (regexec_result != REG_OKAY && regexec_result != REG_NOMATCH)\n\t{\n\t\t/* re failed??? */\n\t\tCHECK_FOR_INTERRUPTS();\n\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t}\n\n\treturn (regexec_result == REG_OKAY);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg))"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"regular expression failed: %s\"",
            "errMsg"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_REGULAR_EXPRESSION"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_regerror",
          "args": [
            "regexec_result",
            "re",
            "errMsg",
            "sizeof(errMsg)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_regexec",
          "args": [
            "re",
            "data",
            "data_len",
            "start_search",
            "NULL",
            "/* no details */nmatch",
            "pmatch",
            "0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic bool\nRE_wchar_execute(regex_t *re, pg_wchar *data, int data_len,\n\t\t\t\t int start_search, int nmatch, regmatch_t *pmatch)\n{\n\tint\t\t\tregexec_result;\n\tchar\t\terrMsg[100];\n\n\t/* Perform RE match and return result */\n\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\tstart_search,\n\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\tnmatch,\n\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t0);\n\n\tif (regexec_result != REG_OKAY && regexec_result != REG_NOMATCH)\n\t{\n\t\t/* re failed??? */\n\t\tCHECK_FOR_INTERRUPTS();\n\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t}\n\n\treturn (regexec_result == REG_OKAY);\n}"
  },
  {
    "function_name": "RE_compile_and_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
    "lines": "136-249",
    "snippet": "static regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"regex/regex.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_CACHED_RES\t32"
    ],
    "globals_used": [
      "static int\tnum_res = 0;",
      "static cached_re_str re_array[MAX_CACHED_RES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&re_array[1]",
            "&re_array[0]",
            "num_res * sizeof(cached_re_str)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "re_array[num_res].cre_pat"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_regfree",
          "args": [
            "&re_array[num_res].cre_re"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "num_res < MAX_CACHED_RES"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "re_temp.cre_pat",
            "text_re_val",
            "text_re_len"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"))"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OUT_OF_MEMORY"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_regfree",
          "args": [
            "&re_temp.cre_re"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "Max(text_re_len, 1)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "text_re_len",
            "1"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg))"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_regerror",
          "args": [
            "regcomp_result",
            "&re_temp.cre_re",
            "errMsg",
            "sizeof(errMsg)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_regcomp",
          "args": [
            "&re_temp.cre_re",
            "pattern",
            "pattern_len",
            "cflags",
            "collation"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mb2wchar_with_len",
          "args": [
            "text_re_val",
            "pattern",
            "text_re_len"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mb2wchar_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "722-726",
          "snippet": "int\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(text_re_len + 1) * sizeof(pg_wchar)"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&re_array[1]",
            "&re_array[0]",
            "i * sizeof(cached_re_str)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "re_array[i].cre_pat",
            "text_re_val",
            "text_re_len"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "text_re"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "text_re"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MAX_CACHED_RES\t32\n\nstatic int\tnum_res = 0;\nstatic cached_re_str re_array[MAX_CACHED_RES];\n\nstatic regex_t *\nRE_compile_and_cache(text *text_re, int cflags, Oid collation)\n{\n\tint\t\t\ttext_re_len = VARSIZE_ANY_EXHDR(text_re);\n\tchar\t   *text_re_val = VARDATA_ANY(text_re);\n\tpg_wchar   *pattern;\n\tint\t\t\tpattern_len;\n\tint\t\t\ti;\n\tint\t\t\tregcomp_result;\n\tcached_re_str re_temp;\n\tchar\t\terrMsg[100];\n\n\t/*\n\t * Look for a match among previously compiled REs.  Since the data\n\t * structure is self-organizing with most-used entries at the front, our\n\t * search strategy can just be to scan from the front.\n\t */\n\tfor (i = 0; i < num_res; i++)\n\t{\n\t\tif (re_array[i].cre_pat_len == text_re_len &&\n\t\t\tre_array[i].cre_flags == cflags &&\n\t\t\tre_array[i].cre_collation == collation &&\n\t\t\tmemcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Found a match; move it to front if not there already.\n\t\t\t */\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tre_temp = re_array[i];\n\t\t\t\tmemmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));\n\t\t\t\tre_array[0] = re_temp;\n\t\t\t}\n\n\t\t\treturn &re_array[0].cre_re;\n\t\t}\n\t}\n\n\t/*\n\t * Couldn't find it, so try to compile the new RE.  To avoid leaking\n\t * resources on failure, we build into the re_temp local.\n\t */\n\n\t/* Convert pattern string to wide characters */\n\tpattern = (pg_wchar *) palloc((text_re_len + 1) * sizeof(pg_wchar));\n\tpattern_len = pg_mb2wchar_with_len(text_re_val,\n\t\t\t\t\t\t\t\t\t   pattern,\n\t\t\t\t\t\t\t\t\t   text_re_len);\n\n\tregcomp_result = pg_regcomp(&re_temp.cre_re,\n\t\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\t\tpattern_len,\n\t\t\t\t\t\t\t\tcflags,\n\t\t\t\t\t\t\t\tcollation);\n\n\tpfree(pattern);\n\n\tif (regcomp_result != REG_OKAY)\n\t{\n\t\t/* re didn't compile (no need for pg_regfree, if so) */\n\n\t\t/*\n\t\t * Here and in other places in this file, do CHECK_FOR_INTERRUPTS\n\t\t * before reporting a regex error.  This is so that if the regex\n\t\t * library aborts and returns REG_CANCEL, we don't print an error\n\t\t * message that implies the regex was invalid.\n\t\t */\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tpg_regerror(regcomp_result, &re_temp.cre_re, errMsg, sizeof(errMsg));\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t errmsg(\"invalid regular expression: %s\", errMsg)));\n\t}\n\n\t/*\n\t * We use malloc/free for the cre_pat field because the storage has to\n\t * persist across transactions, and because we want to get control back on\n\t * out-of-memory.  The Max() is because some malloc implementations return\n\t * NULL for malloc(0).\n\t */\n\tre_temp.cre_pat = malloc(Max(text_re_len, 1));\n\tif (re_temp.cre_pat == NULL)\n\t{\n\t\tpg_regfree(&re_temp.cre_re);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\tmemcpy(re_temp.cre_pat, text_re_val, text_re_len);\n\tre_temp.cre_pat_len = text_re_len;\n\tre_temp.cre_flags = cflags;\n\tre_temp.cre_collation = collation;\n\n\t/*\n\t * Okay, we have a valid new item in re_temp; insert it into the storage\n\t * array.  Discard last entry if needed.\n\t */\n\tif (num_res >= MAX_CACHED_RES)\n\t{\n\t\t--num_res;\n\t\tAssert(num_res < MAX_CACHED_RES);\n\t\tpg_regfree(&re_array[num_res].cre_re);\n\t\tfree(re_array[num_res].cre_pat);\n\t}\n\n\tif (num_res > 0)\n\t\tmemmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));\n\n\tre_array[0] = re_temp;\n\tnum_res++;\n\n\treturn &re_array[0].cre_re;\n}"
  }
]